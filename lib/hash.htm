<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  hash.s7i      Hash map support library                          *)</span>
<span class="comment">(*  Copyright (C) 1989 - 2013, 2022, 2024  Thomas Mertes            *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="comment">(**
 *  Abstract data type, describing hash maps.
 *  A hash map stores key-value pairs. A hash map guarantees that a
 *  key can be mapped quickly to its corresponding value. The keys
 *  of a hash map have the type ''keyType'' and the value have the
 *  type ''baseType''. A hash map is only possible, if ''keyType''
 *  supports the functions ''hashCode'' and ''compare''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">type</span>: <span class="type">hash</span> <span class="type">[</span> <span class="type">(</span><span class="type">in</span> <span class="type">type</span><span class="type">:</span> <span class="type">keyType</span><span class="type">)</span> <span class="type">]</span> <span class="type">(</span><span class="op">in</span> <span class="type">type</span>: baseType) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">type</span>: hashType <span class="keywd">is</span> void;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: keyValueType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    hashType := get_type(getfunc(<span class="type">hash</span> <span class="type">[</span> <span class="type">(</span><span class="type">attr</span> <span class="type">keyType</span><span class="type">)</span> <span class="type">]</span> <span class="type">(</span>attr baseType)));
    <span class="keywd">if</span> hashType = void <span class="keywd">then</span>
      global
      hashType := newtype;
      IN_PARAM_IS_REFERENCE(hashType);
      keyValueType := newtype;
      IN_PARAM_IS_REFERENCE(keyValueType);
      <span class="keywd">const</span> <span class="type">boolean</span>: isHashType (attr hashType)                                <span class="keywd">is</span> TRUE;
      <span class="keywd">const</span> <span class="type">type</span>: <span class="type">hash</span> <span class="type">[</span> <span class="type">(</span><span class="type">attr</span> <span class="type">keyType</span><span class="type">)</span> <span class="type">]</span> <span class="type">(</span>attr baseType)                      <span class="keywd">is</span> hashType;
      <span class="keywd">const</span> <span class="type">type</span>: key_type (attr hashType)                                     <span class="keywd">is</span> keyType;
      <span class="keywd">const</span> <span class="type">type</span>: base_type (attr hashType)                                    <span class="keywd">is</span> baseType;

      <span class="keywd">const</span> <span class="type">reference</span>: (attr hashType) . keyHashCode <span class="keywd">is</span> getfunc(hashCode(<span class="op">in</span> keyType: anElem));
      <span class="keywd">const</span> <span class="type">reference</span>: (attr hashType) . keyCreate   <span class="keywd">is</span> getfunc((<span class="keywd">ref</span> keyType: dest) ::= (<span class="op">in</span> keyType: source));
      <span class="keywd">const</span> <span class="type">reference</span>: (attr hashType) . keyDestroy  <span class="keywd">is</span> getfunc(destroy(<span class="keywd">ref</span> keyType: aValue));
      <span class="keywd">const</span> <span class="type">reference</span>: (attr hashType) . keyCopy     <span class="keywd">is</span> getfunc((<span class="keywd">inout</span> keyType: dest) := (<span class="op">in</span> keyType: source));
      <span class="keywd">const</span> <span class="type">reference</span>: (attr hashType) . keyCompare  <span class="keywd">is</span> getfunc(compare(<span class="op">in</span> keyType: key1, <span class="op">in</span> keyType: key2));
      <span class="keywd">const</span> <span class="type">reference</span>: (attr hashType) . dataCreate  <span class="keywd">is</span> getfunc((<span class="keywd">ref</span> <span class="type">baseType</span>: dest) ::= (<span class="op">in</span> <span class="type">baseType</span>: source));
      <span class="keywd">const</span> <span class="type">reference</span>: (attr hashType) . dataDestroy <span class="keywd">is</span> getfunc(destroy(<span class="keywd">ref</span> <span class="type">baseType</span>: aValue));
      <span class="keywd">const</span> <span class="type">reference</span>: (attr hashType) . dataCopy    <span class="keywd">is</span> getfunc((<span class="keywd">inout</span> <span class="type">baseType</span>: dest) := (<span class="op">in</span> <span class="type">baseType</span>:source));

      <span class="keywd">const</span> <span class="type">proc</span>: CREATE (<span class="keywd">ref</span> <span class="type">hashType</span>: dest, <span class="op">in</span> <span class="type">hashType</span>: source,
                          <span class="op">in</span> <span class="type">reference</span>: keyCreate, <span class="op">in</span> <span class="type">reference</span>: keyDestroy,
                          <span class="op">in</span> <span class="type">reference</span>: dataCreate, <span class="op">in</span> <span class="type">reference</span>: dataDestroy) <span class="keywd">is</span> action <span class="stri">"HSH_CREATE"</span>;
      <span class="keywd">const</span> <span class="type">proc</span>: DESTROY (<span class="keywd">ref</span> <span class="type">hashType</span>: aValue, <span class="op">in</span> <span class="type">reference</span>: keyDestroy,
                           <span class="op">in</span> <span class="type">reference</span>: dataDestroy)                          <span class="keywd">is</span> action <span class="stri">"HSH_DESTR"</span>;
      <span class="keywd">const</span> <span class="type">proc</span>: COPY (<span class="keywd">inout</span> <span class="type">hashType</span>: dest, <span class="op">in</span> <span class="type">hashType</span>: source,
                        <span class="op">in</span> <span class="type">reference</span>: keyCreate, <span class="op">in</span> <span class="type">reference</span>: keyDestroy,
                        <span class="op">in</span> <span class="type">reference</span>: dataCreate, <span class="op">in</span> <span class="type">reference</span>: dataDestroy)   <span class="keywd">is</span> action <span class="stri">"HSH_CPY"</span>;
      <span class="keywd">const</span> <span class="type">proc</span>: FOR_DATA (<span class="keywd">inout</span> <span class="type">baseType</span>: forVar, <span class="op">in</span> <span class="type">hashType</span>: aHashMap,
                            <span class="op">in</span> <span class="type">proc</span>: statements, <span class="op">in</span> <span class="type">reference</span>: dataCopy)       <span class="keywd">is</span> action <span class="stri">"HSH_FOR"</span>;
      <span class="keywd">const</span> <span class="type">proc</span>: FOR_KEY (<span class="keywd">inout</span> keyType: keyVar, <span class="op">in</span> <span class="type">hashType</span>: aHashMap,
                           <span class="op">in</span> <span class="type">proc</span>: statements, <span class="op">in</span> <span class="type">reference</span>: keyCop)          <span class="keywd">is</span> action <span class="stri">"HSH_FOR_KEY"</span>;
      <span class="keywd">const</span> <span class="type">proc</span>: FOR_DATA_KEY (<span class="keywd">inout</span> <span class="type">baseType</span>: forVar, <span class="keywd">inout</span> keyType: keyVar,
                                <span class="op">in</span> <span class="type">hashType</span>: aHashMap, <span class="op">in</span> <span class="type">proc</span>: statements,
                                <span class="op">in</span> <span class="type">reference</span>: dataCopy, <span class="op">in</span> <span class="type">reference</span>: keyCopy) <span class="keywd">is</span> action <span class="stri">"HSH_FOR_DATA_KEY"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">keyType</span>: KEYS (<span class="op">in</span> <span class="type">hashType</span>: aHashMap, <span class="op">in</span> <span class="type">reference</span>: keyCreate,
                                      <span class="op">in</span> <span class="type">reference</span>: keyDestroy)                <span class="keywd">is</span> action <span class="stri">"HSH_KEYS"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">baseType</span>: VALUES (<span class="op">in</span> <span class="type">hashType</span>: aHashMap, <span class="op">in</span> <span class="type">reference</span>: dataCreate,
                                         <span class="op">in</span> <span class="type">reference</span>: dataDestroy)            <span class="keywd">is</span> action <span class="stri">"HSH_VALUES"</span>;

      <span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">ref</span> <span class="type">hashType</span>: dest) ::= (<span class="op">in</span> <span class="type">hashType</span>: source) <span class="keywd">is</span> <span class="keywd">func</span>
        <span class="keywd">begin</span>
          CREATE(dest, source, hashType.keyCreate, hashType.keyDestroy,
              hashType.dataCreate, hashType.dataDestroy);
        <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="keywd">const</span> <span class="type">proc</span>: destroy (<span class="keywd">ref</span> <span class="type">hashType</span>: oldHash) <span class="keywd">is</span> <span class="keywd">func</span>
        <span class="keywd">begin</span>
          DESTROY(oldHash, hashType.keyDestroy, hashType.dataDestroy);
        <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">hashType</span>: dest) := (<span class="op">in</span> <span class="type">hashType</span>: source) <span class="keywd">is</span> <span class="keywd">func</span>
        <span class="keywd">begin</span>
          COPY(dest, source, hashType.keyCreate, hashType.keyDestroy,
              hashType.dataCreate, hashType.dataDestroy);
        <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="comment">(**
       *  Number of elements in the hash map ''aHashMap''.
       *  @return the number of elements in ''aHashMap''.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: length (<span class="op">in</span> <span class="type">hashType</span>: aHashMap)                       <span class="keywd">is</span> action <span class="stri">"HSH_LNG"</span>;

      <span class="keywd">const</span> <span class="type">func</span> <span class="type">baseType</span>: INDEX (<span class="op">in</span> <span class="type">hashType</span>: aHashMap, <span class="op">in</span> keyType: aKey,
                                  <span class="op">in</span> <span class="type">integer</span>: hashCode,
                                  <span class="op">in</span> <span class="type">reference</span>: keyCompare)                    <span class="keywd">is</span> action <span class="stri">"HSH_IDX"</span>;
      <span class="keywd">const</span> <span class="type">varfunc</span> <span class="type">baseType</span>: INDEX (<span class="keywd">inout</span> <span class="type">hashType</span>: aHashMap, <span class="op">in</span> keyType: aKey,
                                     <span class="op">in</span> <span class="type">integer</span>: hashCode,
                                     <span class="op">in</span> <span class="type">reference</span>: keyCompare)                 <span class="keywd">is</span> action <span class="stri">"HSH_IDX"</span>;

      <span class="keywd">const</span> <span class="type">func</span> <span class="type">baseType</span>: INDEX2 (<span class="op">in</span> <span class="type">hashType</span>: aHashMap, <span class="op">in</span> keyType: aKey,
                                   <span class="op">in</span> <span class="type">integer</span>: hashCode, <span class="op">in</span> <span class="type">baseType</span>: defaultValue,
                                   <span class="op">in</span> <span class="type">reference</span>: keyCompare,
                                   <span class="op">in</span> <span class="type">reference</span>: dataCreate)                   <span class="keywd">is</span> action <span class="stri">"HSH_IDX2"</span>;

      <span class="keywd">const</span> <span class="type">func</span> ptr <span class="type">baseType</span>: REFINDEX (<span class="op">in</span> <span class="type">hashType</span>: aHashMap, <span class="op">in</span> keyType: aKey,
                                         <span class="op">in</span> <span class="type">integer</span>: hashCode,
                                         <span class="op">in</span> <span class="type">reference</span>: keyCompare)             <span class="keywd">is</span> action <span class="stri">"HSH_REFIDX"</span>;
      <span class="keywd">const</span> <span class="type">proc</span>: INCL (<span class="keywd">inout</span> <span class="type">hashType</span>: aHashMap, <span class="op">in</span> keyType: aKey,
                        <span class="op">in</span> <span class="type">baseType</span>: anElem, <span class="op">in</span> <span class="type">integer</span>: hashCode,
                        <span class="op">in</span> <span class="type">reference</span>: keyCompare, <span class="op">in</span> <span class="type">reference</span>: keyCreate,
                        <span class="op">in</span> <span class="type">reference</span>: dataCreate, <span class="op">in</span> <span class="type">reference</span>: dataCopy)      <span class="keywd">is</span> action <span class="stri">"HSH_INCL"</span>;
      <span class="keywd">const</span> <span class="type">proc</span>: EXCL (<span class="keywd">inout</span> <span class="type">hashType</span>: aHashMap, <span class="op">in</span> keyType: aKey,
                        <span class="op">in</span> <span class="type">integer</span>: hashCode, <span class="op">in</span> <span class="type">reference</span>: keyCompare,
                        <span class="op">in</span> <span class="type">reference</span>: keyDestroy, <span class="op">in</span> <span class="type">reference</span>: dataDestroy)   <span class="keywd">is</span> action <span class="stri">"HSH_EXCL"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">baseType</span>: UPDATE (<span class="keywd">inout</span> <span class="type">hashType</span>: aHashMap, <span class="op">in</span> keyType: aKey,
                                   <span class="op">in</span> <span class="type">baseType</span>: anElem, <span class="op">in</span> <span class="type">integer</span>: hashCode,
                                   <span class="op">in</span> <span class="type">reference</span>: keyCompare, <span class="op">in</span> <span class="type">reference</span>: keyCreate,
                                   <span class="op">in</span> <span class="type">reference</span>: dataCreate)                   <span class="keywd">is</span> action <span class="stri">"HSH_UPDATE"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: CONTAINS (<span class="op">in</span> <span class="type">hashType</span>: aHashMap, <span class="op">in</span> keyType: aKey,
                                    <span class="op">in</span> <span class="type">integer</span>: hashCode,
                                    <span class="op">in</span> <span class="type">reference</span>: keyCompare)                  <span class="keywd">is</span> action <span class="stri">"HSH_CONTAINS"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">hashType</span>: GEN_HASH (<span class="op">in</span> <span class="type">keyValueType</span>: keyValuePairs,
                                     <span class="op">in</span> <span class="type">reference</span>: keyHashCode,
                                     <span class="op">in</span> <span class="type">reference</span>: keyCompare,
                                     <span class="op">in</span> <span class="type">reference</span>: keyDestroy,
                                     <span class="op">in</span> <span class="type">reference</span>: dataDestroy)                <span class="keywd">is</span> action <span class="stri">"HSH_GEN_HASH"</span>;
<span class="comment">(*
      const func hashType: (attr hashType) conv (in hashType: aHashMap)        is action "HSH_CONV";
      const varfunc hashType: (attr hashType) conv (inout hashType: aHashMap)  is action "TYP_VARCONV";
*)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">hashType</span>: (attr hashType) . _GENERATE_EMPTY_HASH              <span class="keywd">is</span> action <span class="stri">"HSH_EMPTY"</span>;
      <span class="keywd">const</span> <span class="type">hashType</span>: (attr hashType) . EMPTY_HASH                             <span class="keywd">is</span> hashType._GENERATE_EMPTY_HASH;
      <span class="keywd">const</span> <span class="type">hashType</span>: (attr hashType) . value                                  <span class="keywd">is</span> hashType._GENERATE_EMPTY_HASH;

      <span class="comment">(**
       *  Access one value from the hash table ''aHashMap''.
       *  @return the element with the key ''aKey'' from ''aHashMap''.
       *  @exception RANGE_ERROR If ''aHashMap'' does not have an element
       *             with the key ''aKey''.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">baseType</span>: (<span class="op">in</span> <span class="type">hashType</span>: aHashMap) [ (<span class="op">in</span> keyType: aKey) ] <span class="keywd">is</span>
        <span class="keywd">return</span> INDEX(aHashMap, aKey, hashCode(aKey), hashType.keyCompare);

      <span class="keywd">const</span> <span class="type">varfunc</span> <span class="type">baseType</span>: (<span class="keywd">inout</span> <span class="type">hashType</span>: aHashMap) [ (<span class="op">in</span> keyType: aKey) ] <span class="keywd">is</span>
        <span class="keywd">return</span> <span class="keywd">var</span> INDEX(aHashMap, aKey, hashCode(aKey), hashType.keyCompare);

      <span class="comment">(**
       *  Access one value from the hash table ''aHashMap''.
       *  @return the element with the key ''aKey'' from ''aHashMap'' or
       *          ''defaultValue'' if ''aHashMap'' does not have an element
       *          with the key ''aKey''.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">baseType</span>: (<span class="op">in</span> <span class="type">hashType</span>: aHashMap) [ (<span class="op">in</span> keyType: aKey) default (<span class="op">in</span> <span class="type">baseType</span>: defaultValue) ] <span class="keywd">is</span>
        <span class="keywd">return</span> INDEX2(aHashMap, aKey, hashCode(aKey), defaultValue,
                      hashType.keyCompare, hashType.dataCreate);

      <span class="comment">(**
       *  Hash membership test.
       *  Determine if ''aKey'' is a member of the hash map ''aHashMap''.
       *  @return TRUE if ''aKey'' is a member of ''aHashMap'',
       *          FALSE otherwise.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> keyType: aKey) <span class="op">in</span> (<span class="op">in</span> <span class="type">hashType</span>: aHashMap) <span class="keywd">is</span>
        <span class="keywd">return</span> CONTAINS(aHashMap, aKey, hashCode(aKey), hashType.keyCompare);

      <span class="comment">(**
       *  Negated hash membership test.
       *  Determine if ''aKey'' is not a member of the hash map ''aHashMap''.
       *  @return FALSE if ''aKey'' is a member of ''aHashMap'',
       *          TRUE otherwise.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> keyType: aKey) <span class="op">not</span> <span class="op">in</span> (<span class="op">in</span> <span class="type">hashType</span>: aHashMap) <span class="keywd">is</span>
        <span class="keywd">return</span> <span class="op">not</span> CONTAINS(aHashMap, aKey, hashCode(aKey), hashType.keyCompare);

      <span class="comment">(**
       *  Add ''anElem'' with the key ''aKey'' to the hash map ''aHashMap''.
       *  If an element with the key ''aKey'' already exists,
       *  it is overwritten with ''anElem''.
       *   incl(aHash, aKey, aValue);
       *  @exception MEMORY_ERROR If there is not enough memory.
       *)</span>
      <span class="keywd">const</span> <span class="type">proc</span>: incl (<span class="keywd">inout</span> <span class="type">hashType</span>: aHashMap, <span class="op">in</span> keyType: aKey, <span class="op">in</span> <span class="type">baseType</span>: anElem) <span class="keywd">is</span> <span class="keywd">func</span>
        <span class="keywd">begin</span>
          INCL(aHashMap, aKey, anElem, hashCode(aKey), hashType.keyCompare,
              hashType.keyCreate, hashType.dataCreate, hashType.dataCopy);
        <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="comment">(**
       *  Remove the element with the key ''aKey'' from the hash map ''aHashMap''.
       *)</span>
      <span class="keywd">const</span> <span class="type">proc</span>: excl (<span class="keywd">inout</span> <span class="type">hashType</span>: aHashMap, <span class="op">in</span> keyType: aKey) <span class="keywd">is</span> <span class="keywd">func</span>
        <span class="keywd">begin</span>
          EXCL(aHashMap, aKey, hashCode(aKey), hashType.keyCompare,
              hashType.keyDestroy, hashType.dataDestroy);
        <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="comment">(**
       *  Add ''anElem'' with the key ''aKey'' to the hash map ''aHashMap''.
       *  If an element with the key ''aKey'' already exists,
       *  it is overwritten with ''anElem''.
       *   aHash @:= [aKey] aValue;
       *  @exception MEMORY_ERROR If there is not enough memory.
       *)</span>
      <span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">hashType</span>: aHashMap) @:= [ (<span class="op">in</span> keyType: aKey) ] (<span class="op">in</span> <span class="type">baseType</span>: anElem) <span class="keywd">is</span> <span class="keywd">func</span>
        <span class="keywd">begin</span>
          INCL(aHashMap, aKey, anElem, hashCode(aKey), hashType.keyCompare,
              hashType.keyCreate, hashType.dataCreate, hashType.dataCopy);
        <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="keywd">const</span> <span class="type">func</span> <span class="type">baseType</span>: update (<span class="keywd">inout</span> <span class="type">hashType</span>: aHashMap, <span class="op">in</span> keyType: aKey, <span class="op">in</span> <span class="type">baseType</span>: anElem) <span class="keywd">is</span>
        <span class="keywd">return</span> UPDATE(aHashMap, aKey, anElem, hashCode(aKey), hashType.keyCompare,
                      hashType.keyCreate, hashType.dataCreate);

      <span class="comment">(**
       *  Create a key-value pair to be used in a hash literal.
       *  A key-value pair with the key "one" and the value 1 is created with
       *   ["one" : 1]
       *  A key-value pair can only be used inside a hash literal. E.g.:
       *   [] (["one" : 1], ["two" : 2])
       *  This hash literal defines a hash with the keys "one" and "two"
       *  and the corresponding values 1 and 2.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">keyValueType</span>: [ (<span class="op">in</span> keyType: aKey) : (<span class="op">in</span> <span class="type">baseType</span>: aValue) ]  <span class="keywd">is</span> action <span class="stri">"HSH_GEN_KEY_VALUE"</span>;

      <span class="keywd">const</span> <span class="type">func</span> <span class="type">keyValueType</span>: (<span class="op">in</span> <span class="type">keyValueType</span>: element1) ,
                               (<span class="op">in</span> <span class="type">keyValueType</span>: element2)                     <span class="keywd">is</span> action <span class="stri">"HSH_CONCAT_KEY_VALUE"</span>;

      <span class="comment">(**
       *  Declare a hash literal from key-value pairs.
       *  One or many key-value pairs are used to create a hash literal:
       *   [] (["one" : 1], ["two" : 2])
       *  This hash literal defines a hash with the keys "one" and "two"
       *  and the corresponding values 1 and 2.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">hashType</span>: [] (<span class="op">in</span> <span class="type">func</span> <span class="type">keyValueType</span>: keyValuePairs) <span class="keywd">is</span>
        <span class="keywd">return</span> GEN_HASH(keyValuePairs, hashType.keyHashCode, hashType.keyCompare,
                        hashType.keyDestroy, hashType.dataDestroy);

<span class="comment">(*
      const proc: clear (inout hashType: aHashMap) is func
        local
          var baseType: anElem is baseType.value;
        begin
          for anElem range source do
            excl(dest, anElem);
          end for;
        end func;
*)</span>

      <span class="comment">(**
       *  For-loop where ''forVar'' loops over the values of the hash map ''aHashMap''.
       *  The succession of values is unordered and not related to the order
       *  in which the values have been added to the hash map. E.g.:
       *   for aValue range aHash do ...
       *  In many cases it is okay to process the values unordered.
       *  The values can be processed in an ordered way by using ''values'' and ''sort'':
       *   for aValue range sort(values(aHash)) do ...
       *)</span>
      <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">for</span> (<span class="keywd">inout</span> <span class="type">baseType</span>: forVar) <span class="keywd">range</span> (<span class="op">in</span> <span class="type">hashType</span>: aHashMap) <span class="keywd">do</span>
                    (<span class="op">in</span> <span class="type">proc</span>: statements)
                  <span class="keywd">end</span> <span class="keywd">for</span> <span class="keywd">is</span> <span class="keywd">func</span>
        <span class="keywd">begin</span>
          FOR_DATA(forVar, aHashMap, statements, hashType.dataCopy);
        <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="comment">(**
       *  For-loop where ''keyVar'' loops over the keys (indices) of the hash map ''aHashMap''.
       *  The succession of keys (indices) is unordered and not related to
       *  the order in which the keys have been added to the hash map. E.g.:
       *   for aKey range aHash do ...
       *  In many cases it is okay to process the keys (indices) unordered.
       *  The keys can be processed in an ordered way by using ''keys'' and ''sort'':
       *   for aKey range sort(keys(aHash)) do ...
       *)</span>
      <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">for</span> <span class="keywd">key</span> (<span class="keywd">inout</span> keyType: keyVar) <span class="keywd">range</span> (<span class="op">in</span> <span class="type">hashType</span>: aHashMap) <span class="keywd">do</span>
                    (<span class="op">in</span> <span class="type">proc</span>: statements)
                  <span class="keywd">end</span> <span class="keywd">for</span> <span class="keywd">is</span> <span class="keywd">func</span>
        <span class="keywd">begin</span>
          FOR_KEY(keyVar, aHashMap, statements, hashType.keyCopy);
        <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="comment">(**
       *  For-loop where ''forVar'' and ''keyVar'' loop over the hash map ''aHashMap''.
       *  The variable ''forVar'' loops over the values of ''aHashMap''
       *  and ''keyVar'' loops over the keys (indices) of ''aHashMap''.
       *  The succession of keys (indices) and values is unordered and not related
       *  to the order in which they have been added to the hash map. E.g.:
       *   for aValue key aKey range aHash do ...
       *  In many cases it is okay to process the keys (indices) and values unordered.
       *  The keys and values can be processed in an ordered way by using ''keys'' and ''sort'':
       *   for aKey range sort(keys(aHash)) do
       *     value := aHash[aKey];
       *     ...
       *)</span>
      <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">for</span> (<span class="keywd">inout</span> <span class="type">baseType</span>: forVar) <span class="keywd">key</span> (<span class="keywd">inout</span> keyType: keyVar) <span class="keywd">range</span> (<span class="op">in</span> <span class="type">hashType</span>: aHashMap) <span class="keywd">do</span>
                    (<span class="op">in</span> <span class="type">proc</span>: statements)
                  <span class="keywd">end</span> <span class="keywd">for</span> <span class="keywd">is</span> <span class="keywd">func</span>
        <span class="keywd">begin</span>
          FOR_DATA_KEY(forVar, keyVar, aHashMap, statements, hashType.dataCopy, hashType.keyCopy);
        <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="comment">(**
       *  Obtain the keys of the hash map ''aHashMap''.
       *  The returned array of keys is unordered and the succession of
       *  keys is not related to the order in which the keys have been
       *  added to the hash map. A loop over the keys like
       *   for aKey range keys(aHash) do ...
       *  is equal to the following for-each loop
       *   for key aKey range aHash do ...
       *  The keys can be processed in an ordered way by using ''sort'':
       *   for aKey range sort(keys(aHash)) do ...
       *  @return an unordered array with the keys of the hash map.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">keyType</span>: keys (<span class="op">in</span> <span class="type">hashType</span>: aHashMap) <span class="keywd">is</span>
        <span class="keywd">return</span> KEYS(aHashMap, hashType.keyCreate, hashType.keyDestroy);

      <span class="comment">(**
       *  Obtain the values of the hash map ''aHashMap''.
       *  The returned array of values is unordered and the succession of
       *  values is not related to the order in which the values have been
       *  added to the hash map. A loop over the values like
       *   for aValue range values(aHash) do ...
       *  is equal to the following for-each loop
       *   for aValue range aHash do ...
       *  The values can be processed in an ordered way by using ''sort'':
       *   for aValue range sort(values(aHash)) do ...
       *  @return an unordered array with the values of the hash map.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">baseType</span>: values (<span class="op">in</span> <span class="type">hashType</span>: aHashMap) <span class="keywd">is</span>
        <span class="keywd">return</span> VALUES(aHashMap, hashType.dataCreate, hashType.dataDestroy);

      <span class="keywd">if</span> getobj((<span class="op">in</span> <span class="type">baseType</span>: element1) = (<span class="op">in</span> <span class="type">baseType</span>: element2)) &lt;> NIL <span class="keywd">then</span>

        <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">hashType</span>: hash1) = (<span class="op">in</span> <span class="type">hashType</span>: hash2) <span class="keywd">is</span> <span class="keywd">func</span>
          <span class="keywd">result</span>
            <span class="keywd">var</span> <span class="type">boolean</span>: isEqual <span class="keywd">is</span> TRUE;
          <span class="keywd">local</span>
            <span class="keywd">var</span> keyType: aKey <span class="keywd">is</span> keyType.value;
            <span class="keywd">var</span> <span class="type">baseType</span>: aValue <span class="keywd">is</span> baseType.value;
          <span class="keywd">begin</span>
            <span class="keywd">if</span> length(hash1) &lt;> length(hash2) <span class="keywd">then</span>
              isEqual := FALSE;
            <span class="keywd">else</span>
              <span class="keywd">for</span> aValue <span class="keywd">key</span> aKey <span class="keywd">range</span> hash1 <span class="keywd">do</span>
                <span class="keywd">if</span> <span class="op">not</span> (aKey <span class="op">in</span> hash2 <span class="op">and</span> aValue = hash2[aKey]) <span class="keywd">then</span>
                  isEqual := FALSE;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">for</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">func</span>;

        <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">hashType</span>: hash1) &lt;> (<span class="op">in</span> <span class="type">hashType</span>: hash2) <span class="keywd">is</span>
          <span class="keywd">return</span> <span class="op">not</span> hash1 = hash2;
      <span class="keywd">end</span> <span class="keywd">if</span>;

      <span class="keywd">if</span> getfunc(hashCode(<span class="op">in</span> <span class="type">baseType</span>: anElem)) &lt;> NIL <span class="op">and</span>
          getfunc(compare(<span class="op">in</span> <span class="type">baseType</span>: elem1, <span class="op">in</span> <span class="type">baseType</span>: elem2)) &lt;> NIL <span class="keywd">then</span>

        <span class="comment">(**
         *  Create a hash map from ''aHashMap'' where key and value are exchanged.
         *  Since a hash value can correspond to many keys the type returned
         *  is ''hash [baseType] array keyType''.
         *   const type: stringIntegerHash is hash [string] integer;
         *   const type: integerStringHash is hash [integer] array string;
         *   ...
         *   var stringIntegerHash: aHash is [] (["zero" : 0], ["null" : 0], ["one" : 1]);
         *   var integerStringHash: stringsByIntValue is integerStringHash.value;
         *   var integer: number is 0;
         *   var string: stri is "";
         *   ...
         *   stringsByIntValue := flip(aHash);
         *   for number range sort(keys(stringsByIntValue)) do
         *     for stri range stringsByIntValue[number] do
         *       writeln(stri &lt;&amp; ": " &lt;&amp; number);
         *     end for;
         *   end for;
         *)</span>
        <span class="keywd">const</span> <span class="type">func</span> <span class="type">hash</span> <span class="type">[</span><span class="type">baseType</span><span class="type">]</span> <span class="type">array</span> keyType: flip (<span class="op">in</span> <span class="type">hashType</span>: aHashMap) <span class="keywd">is</span> <span class="keywd">func</span>
          <span class="keywd">result</span>
            <span class="keywd">var</span> <span class="type">hash</span> <span class="type">[</span><span class="type">baseType</span><span class="type">]</span> <span class="type">array</span> keyType: inverseHash <span class="keywd">is</span> (<span class="type">hash</span> <span class="type">[</span><span class="type">baseType</span><span class="type">]</span> <span class="type">array</span> keyType).value;
          <span class="keywd">local</span>
            <span class="keywd">var</span> keyType: aKey <span class="keywd">is</span> keyType.value;
            <span class="keywd">var</span> <span class="type">baseType</span>: aValue <span class="keywd">is</span> baseType.value;
          <span class="keywd">begin</span>
            <span class="keywd">for</span> aValue <span class="keywd">key</span> aKey <span class="keywd">range</span> aHashMap <span class="keywd">do</span>
              <span class="keywd">if</span> aValue <span class="op">in</span> inverseHash <span class="keywd">then</span>
                inverseHash[aValue] &amp;:= aKey;
              <span class="keywd">else</span>
                inverseHash @:= [aValue] [] (aKey);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">for</span>;
          <span class="keywd">end</span> <span class="keywd">func</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;

      <span class="keywd">end</span> global;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
