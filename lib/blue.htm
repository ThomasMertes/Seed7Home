<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  dnafight.sd7  Bacterial dna fight programming game              *)</span>
<span class="comment">(*  Copyright (C) 1985  Johannes Gritsch                            *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">const</span> <span class="type">type</span>: iField <span class="keywd">is</span> <span class="type">array</span> <span class="type">[</span>direction] integer; <span class="comment">(* array [HERE..EAST] of integer; *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: dna (BLUE) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">bactColor</span>: SELF <span class="keywd">is</span> BLUE;
    <span class="keywd">const</span> <span class="type">integer</span>: MINSPLITSIZE <span class="keywd">is</span> 7;

    <span class="keywd">var</span> <span class="type">direction</span>: bestDie <span class="keywd">is</span> HERE;
    <span class="keywd">var</span> <span class="type">direction</span>: bestEat <span class="keywd">is</span> HERE;
    <span class="keywd">var</span> <span class="type">direction</span>: bestSplit <span class="keywd">is</span> HERE;
    <span class="keywd">var</span> <span class="type">direction</span>: maxDir <span class="keywd">is</span> HERE;
    <span class="keywd">var</span> <span class="type">iField</span>: eatMass <span class="keywd">is</span> direction <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">iField</span>: splitPrior <span class="keywd">is</span> direction <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">iField</span>: eatPrior <span class="keywd">is</span> direction <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">iField</span>: diePrior <span class="keywd">is</span> direction <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: needed <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: ownSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: splitable <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: enemies <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: splitSize <span class="keywd">is</span> 0;


    <span class="keywd">const</span> <span class="type">proc</span>: findMax (<span class="keywd">inout</span> <span class="type">direction</span>: dmax, <span class="op">in</span> <span class="type">iField</span>: field) <span class="keywd">is</span> <span class="keywd">func</span>
      <span class="keywd">local</span>
        <span class="keywd">var</span> <span class="type">directSet</span>: maxDir <span class="keywd">is</span> directSet.EMPTY_SET;
        <span class="keywd">var</span> <span class="type">direction</span>: fd <span class="keywd">is</span> HERE;
        <span class="keywd">var</span> <span class="type">integer</span>: xmax <span class="keywd">is</span> 0;

      <span class="keywd">begin</span> <span class="comment">(* findMax *)</span>
        maxDir := {HERE};
        xmax := field[HERE];
        <span class="keywd">for</span> fd <span class="keywd">range</span> MAIN_DIRECTIONS <span class="keywd">do</span>
          <span class="keywd">if</span> field[fd] > xmax <span class="keywd">then</span>
            xmax := field[fd];
            maxDir := directSet.EMPTY_SET;
            incl(maxDir, fd);
          <span class="keywd">else</span>
            <span class="keywd">if</span> field[fd] = xmax <span class="keywd">then</span>
              incl(maxDir, fd);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
        dmax := ranDir(maxDir);
      <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* findMax *)</span>


    <span class="keywd">const</span> <span class="type">proc</span>: getMax (<span class="keywd">inout</span> <span class="type">direction</span>: maxDir) <span class="keywd">is</span> <span class="keywd">func</span>
      <span class="keywd">local</span>
        <span class="keywd">var</span> <span class="type">direction</span>: dir <span class="keywd">is</span> HERE;
        <span class="keywd">var</span> <span class="type">directSet</span>: maxDirSet <span class="keywd">is</span> directSet.EMPTY_SET;
        <span class="keywd">var</span> <span class="type">power</span>: gmax <span class="keywd">is</span> 0;

      <span class="keywd">begin</span> <span class="comment">(* getMax *)</span>
        maxDirSet := {NORTH};
        gmax := food(NORTH);
        <span class="keywd">for</span> dir <span class="keywd">range</span> MAIN_DIRECTIONS <span class="keywd">do</span>
          <span class="keywd">if</span> food(dir) > gmax <span class="keywd">then</span>
            gmax := food(dir);
            maxDirSet := directSet.EMPTY_SET;
            incl(maxDirSet, dir);
          <span class="keywd">else</span>
            <span class="keywd">if</span> food(dir) = gmax <span class="keywd">then</span>
              incl(maxDirSet, dir);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
        maxDir := ranDir(maxDirSet);
      <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* getMax *)</span>


    <span class="keywd">const</span> <span class="type">proc</span>: init <span class="keywd">is</span> <span class="keywd">func</span>

      <span class="keywd">local</span>
        <span class="keywd">var</span> <span class="type">iField</span>: next <span class="keywd">is</span> direction <span class="op">times</span> 0;
        <span class="keywd">var</span> <span class="type">iField</span>: next2 <span class="keywd">is</span> direction <span class="op">times</span> 0;
        <span class="keywd">var</span> <span class="type">direction</span>: dir <span class="keywd">is</span> HERE;
        <span class="keywd">var</span> <span class="type">power</span>: fNeeded <span class="keywd">is</span> 0;
        <span class="keywd">var</span> <span class="type">power</span>: konst <span class="keywd">is</span> 0;
        <span class="keywd">var</span> <span class="type">power</span>: ownSize2 <span class="keywd">is</span> 0;
        <span class="keywd">var</span> <span class="type">power</span>: needed2 <span class="keywd">is</span> 0;
        <span class="keywd">var</span> <span class="type">power</span>: splitSub <span class="keywd">is</span> 0;


        <span class="keywd">const</span> <span class="type">proc</span>: getPar (<span class="keywd">inout</span> <span class="type">integer</span>: eatPrior, <span class="keywd">inout</span> <span class="type">integer</span>: splitPrior,
            <span class="keywd">inout</span> <span class="type">integer</span>: next, <span class="keywd">inout</span> <span class="type">integer</span>: next2, <span class="op">in</span> <span class="type">power</span>: fodder) <span class="keywd">is</span> <span class="keywd">func</span>

          <span class="keywd">begin</span> <span class="comment">(* getPar *)</span>
            <span class="keywd">if</span> hunger = 0 <span class="keywd">then</span>
              <span class="keywd">if</span> fodder &lt; needed2 <span class="keywd">then</span>
                next2 := 0;
                splitPrior := 0;
              <span class="keywd">else</span>
                next2 := ownSize2 - needed2 + min(fodder, ownSize2);
                splitPrior := fodder;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> fodder &lt; needed <span class="keywd">then</span>
                next := 0;
                eatPrior := fodder - konst;
              <span class="keywd">else</span>
                next := ownSize - needed + min(fodder, ownSize);
                eatPrior := fodder;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">else</span>
              next2 := ownSize2 - needed2 + min(fodder, ownSize2);
              splitPrior := fodder + 1;
              next := ownSize - needed + min(fodder, ownSize);
              eatPrior := fodder;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* getPar *)</span>


      <span class="keywd">begin</span> <span class="comment">(* init *)</span>
        enemies := FALSE;
        konst := initSize + foodReserve;
        ownSize := strength(HERE);
        splitSize := 2 * food(HERE);
        splitSub := 0;
        needed := max(0, shrinkSize(ownSize));
        ownSize2 := (ownSize + 1) <span class="op">div</span> 2;
        needed2 := max(0, shrinkSize(ownSize2));
        getPar(eatPrior[HERE], splitPrior[HERE], next[HERE], next2[HERE],
            food(HERE));
        ownSize2 := ownSize <span class="op">div</span> 2;
        needed2 := max(0, shrinkSize(ownSize2));
        diePrior[HERE] := food(HERE);
        <span class="keywd">if</span> hunger = 0 <span class="keywd">then</span>
          eatMass[HERE] := 1;
        <span class="keywd">else</span>
          eatMass[HERE] := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;

        <span class="keywd">for</span> dir <span class="keywd">range</span> MAIN_DIRECTIONS <span class="keywd">do</span>

          <span class="keywd">case</span> view(dir) <span class="keywd">of</span>

            <span class="keywd">when</span> {EDGE}:
              eatPrior[dir] := -konst;
              splitPrior[dir] := 0;
              next[dir] := 0;
              next2[dir] := 0;
              splitSub := splitSub + 2;
              diePrior[dir] := -3 * konst;
              eatMass[dir] := 0;

            <span class="keywd">when</span> {CLEAR}:
              getPar(eatPrior[dir], splitPrior[dir],
                  next[dir], next2[dir], food(dir));
              diePrior[dir] := food(dir);
              <span class="keywd">if</span> food(dir) = foodReserve <span class="keywd">then</span>
                splitSize +:= max(5, foodReserve);
              <span class="keywd">else</span>
                splitSize +:= 2 * food(dir);
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> food(dir) > needed <span class="keywd">then</span>
                eatMass[HERE] := ownSize;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              eatMass[dir] := min(ownSize, food(dir));

            <span class="keywd">when</span> {SELF}:
              eatMass[dir] := 0;
              diePrior[dir] := -konst;
              diePrior[HERE] := diePrior[HERE] + 1;
              eatPrior[HERE] := eatPrior[HERE] - 1;
              eatPrior[dir] := - 2 * konst + 1;
              <span class="keywd">if</span> hunger = 0 <span class="op">and</span> strength(dir) &lt; needed <span class="keywd">then</span>
                next[dir] := 0;
              <span class="keywd">else</span>
                <span class="keywd">if</span> strength(dir) &lt;= ownSize <span class="keywd">then</span>
                  next[dir] := ownSize - needed + strength(dir);
                <span class="keywd">else</span>
                  next[dir] := 0;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              splitPrior[dir] := 0;
              next2[dir] := 0;
              splitSize +:= food(dir);

            <span class="keywd">otherwise</span>:
              eatMass[dir] := 0;
              eatMass[HERE] := ownSize;
              diePrior[HERE] := diePrior[HERE] - 2 * strength(dir);
              enemies := TRUE;
              <span class="keywd">if</span> strength(dir) > ownSize <span class="keywd">then</span>
                diePrior[dir] := - 2 * konst;
              <span class="keywd">else</span>
                diePrior[dir] := 2 * konst;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> hunger = 0 <span class="op">and</span> strength(dir) &lt; needed <span class="keywd">then</span>
                eatPrior[dir] := strength(dir) - 1;
                next[dir] := 0;
              <span class="keywd">else</span>
                <span class="keywd">if</span> strength(dir) &lt;= ownSize <span class="keywd">then</span>
                  eatPrior[dir] := strength(dir) + 1;
                  next[dir] := ownSize - needed + strength(dir);
                <span class="keywd">else</span>
                  <span class="keywd">if</span> next[HERE] &lt;= strength(dir) <span class="keywd">then</span>
                    fNeeded := shrinkSize(strength(dir));
                    <span class="keywd">if</span> fNeeded > next[HERE] <span class="keywd">then</span>
                      eatPrior[HERE] := eatPrior[HERE] - 2 * konst;
                    <span class="keywd">end</span> <span class="keywd">if</span>;
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                  eatPrior[dir] := -2 * konst;
                  next[dir] := 0;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              splitPrior[dir] := 0;
              next2[dir] := 0;
              <span class="keywd">if</span> next2[HERE] &lt; strength(dir) <span class="keywd">then</span>
                splitPrior[HERE] := 0;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              splitSize +:= food(dir);
          <span class="keywd">end</span> <span class="keywd">case</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;

        <span class="keywd">for</span> dir <span class="keywd">range</span> DIAGONAL_DIRECTIONS <span class="keywd">do</span>

          <span class="keywd">case</span> view(dir) <span class="keywd">of</span>

            <span class="keywd">when</span> {EDGE}:
              splitSub := splitSub + 1;

            <span class="keywd">when</span> {CLEAR}:
              <span class="keywd">if</span> hunger > 0 <span class="keywd">then</span>
                <span class="keywd">if</span> view(left[dir]) = CLEAR <span class="keywd">then</span>
                  eatPrior[left[dir]] +:= (food(dir) + 1) <span class="op">div</span> 2;
                <span class="keywd">end</span> <span class="keywd">if</span>;
                <span class="keywd">if</span> splitPrior[left[dir]] > 0 <span class="keywd">then</span>
                  splitPrior[left[dir]] +:= (food(dir) + 1) <span class="op">div</span> 2;
                <span class="keywd">end</span> <span class="keywd">if</span>;
                <span class="keywd">if</span> view(right[dir]) = CLEAR <span class="keywd">then</span>
                  eatPrior[right[dir]] +:= (food(dir) + 1) <span class="op">div</span> 2;
                <span class="keywd">end</span> <span class="keywd">if</span>;
                <span class="keywd">if</span> splitPrior[right[dir]] > 0 <span class="keywd">then</span>
                  splitPrior[right[dir]] +:= (food(dir) + 1) <span class="op">div</span> 2
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> food(dir) = foodReserve <span class="keywd">then</span>
                splitSize +:= max(5, foodReserve);
              <span class="keywd">else</span>
                splitSize +:= food(dir);
              <span class="keywd">end</span> <span class="keywd">if</span>;

            <span class="keywd">when</span> {SELF}:
              splitSize +:= (food(dir) + 1) <span class="op">div</span> 2;
              <span class="keywd">if</span> view(left[dir]) <span class="op">in</span> {CLEAR, SELF} <span class="keywd">then</span>
                diePrior[left[dir]] +:= 1 + konst * ord(view(left[dir]) = SELF);
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> view(right[dir]) <span class="op">in</span> {CLEAR, SELF} <span class="keywd">then</span>
                diePrior[right[dir]] +:= 1 + konst * ord(view(right[dir]) = SELF);
              <span class="keywd">end</span> <span class="keywd">if</span>;

            <span class="keywd">otherwise</span>:
              enemies := TRUE;
              <span class="keywd">if</span> strength(dir) >= next2[left[dir]] <span class="keywd">then</span>
                splitPrior[left[dir]] := 0;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> strength(dir) >= next2[right[dir]] <span class="keywd">then</span>
                splitPrior[right[dir]] := 0;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> next[left[dir]] &lt;= strength(dir) <span class="keywd">then</span>
                eatPrior[left[dir]] -:= konst;
              <span class="keywd">else</span>
                <span class="keywd">if</span> hunger > 1 <span class="op">and</span> view(left[dir]) = CLEAR <span class="keywd">then</span>
                  eatPrior[left[dir]] +:= strength(dir) <span class="op">div</span> 2;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> next[right[dir]] &lt;= strength(dir) <span class="keywd">then</span>
                eatPrior[right[dir]] -:= konst;
              <span class="keywd">else</span>
                <span class="keywd">if</span> hunger > 1 <span class="op">and</span> view(right[dir]) = CLEAR <span class="keywd">then</span>
                  eatPrior[right[dir]] +:= strength(dir) <span class="op">div</span> 2;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              splitSize +:= (food(dir) + 1) <span class="op">div</span> 2;
              diePrior[left[dir]] -:= 2 * konst;
              diePrior[right[dir]] -:= 2 * konst;
          <span class="keywd">end</span> <span class="keywd">case</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;

        splitSize := max(MINSPLITSIZE, splitSize <span class="op">div</span> (10 - splitSub));
      <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* init *)</span>


  <span class="keywd">begin</span> <span class="comment">(* dna (BLUE) *)</span>
    init;
    splitable := splitPrior[HERE] > 0;
    splitPrior[HERE] := 0;
    findMax(bestSplit, splitPrior);
    <span class="keywd">if</span> bestSplit &lt;> HERE <span class="op">and</span> splitable <span class="op">and</span> ownSize > splitSize <span class="op">and</span>
        view(bestSplit) = CLEAR <span class="keywd">then</span>
      split(bestSplit, (ownSize + 1) <span class="op">div</span> 2, ownSize <span class="op">div</span> 2);
    <span class="keywd">else</span>
      getMax(maxDir);
      <span class="keywd">if</span> hunger = 0 <span class="op">and</span> food(maxDir) &lt; needed <span class="op">and</span> food(HERE) &lt; needed <span class="keywd">then</span>
        findMax(bestDie, diePrior);
        <span class="keywd">if</span> bestDie = HERE <span class="op">or</span> view(bestDie) = CLEAR <span class="keywd">then</span>
          eat(bestDie, eatMass[bestDie]);
        <span class="keywd">else</span>
          eat(HERE, eatMass[HERE]);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        <span class="keywd">if</span> food(maxDir) &lt; needed <span class="op">and</span> <span class="op">not</span> enemies <span class="keywd">then</span>
          <span class="keywd">if</span> food(HERE) > needed <span class="op">or</span> <span class="op">not</span> splitable <span class="op">or</span> bestSplit = HERE <span class="op">or</span>
              ownSize &lt; 4 <span class="op">or</span> view(bestSplit) &lt;> CLEAR <span class="keywd">then</span>
            eat(HERE, eatMass[HERE]);
          <span class="keywd">else</span>
            split(bestSplit, (ownSize + 1) <span class="op">div</span> 2, ownSize <span class="op">div</span> 2);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          findMax(bestEat, eatPrior);
          <span class="keywd">if</span> view(bestEat) = EDGE <span class="keywd">then</span>
            eat(HERE, eatMass[HERE]);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> bestEat &lt;> HERE <span class="op">and</span> view(bestEat) &lt;> CLEAR <span class="keywd">then</span>
            <span class="keywd">if</span> strength(bestEat) > ownSize <span class="keywd">then</span>
              eat(HERE, eatMass[HERE]);
            <span class="keywd">else</span>
              kill(bestEat);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            eat(bestEat, eatMass[bestEat]);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* dna (BLUE) *)</span>
</pre>
</body>
</html>
