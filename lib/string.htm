<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  string.s7i    String support library                            *)</span>
<span class="comment">(*  Copyright (C) 1989 - 2013  Thomas Mertes                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">ref</span> <span class="type">string</span>: dest) ::= (<span class="op">in</span> <span class="type">string</span>: source)           <span class="keywd">is</span> action <span class="stri">"STR_CREATE"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">string</span>: dest) := (<span class="op">in</span> <span class="type">string</span>: source)          <span class="keywd">is</span> action <span class="stri">"STR_CPY"</span>;


<span class="comment">(**
 *  Default value of ''string'' ("").
 *)</span>
<span class="keywd">const</span> <span class="type">string</span>: (attr string) . value <span class="keywd">is</span> <span class="stri">""</span>;


<span class="comment">(**
 *  String multiplication.
 *  The string ''stri'' is concatenated to itself such that in total
 *  ''factor'' strings are concatenated.
 *   "LA" mult 3     returns "LALALA"
 *   "WORD" mult 0   returns ""
 *  @return the result of the string multiplication.
 *  @exception RANGE_ERROR If the factor is negative.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">string</span>: stri) <span class="op">mult</span> (<span class="op">in</span> <span class="type">integer</span>: factor)   <span class="keywd">is</span> action <span class="stri">"STR_MULT"</span>;


<span class="comment">(**
 *  Pad a ''string'' with spaces at the left side up to a given length.
 *  @return the ''string'' left padded with spaces.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">string</span>: stri) <span class="op">lpad</span> (<span class="op">in</span> <span class="type">integer</span>: length)   <span class="keywd">is</span> action <span class="stri">"STR_LPAD"</span>;


<span class="comment">(**
 *  Pad a ''string'' with zeroes at the left side up to a given length.
 *  @return the ''string'' left padded with zeroes.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">string</span>: stri) <span class="op">lpad0</span> (<span class="op">in</span> <span class="type">integer</span>: length)  <span class="keywd">is</span> action <span class="stri">"STR_LPAD0"</span>;


<span class="comment">(**
 *  Pad a ''string'' with spaces at the right side up to a given length.
 *  @return the ''string'' right padded with spaces.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">string</span>: stri) <span class="op">rpad</span> (<span class="op">in</span> <span class="type">integer</span>: length)   <span class="keywd">is</span> action <span class="stri">"STR_RPAD"</span>;


<span class="comment">(**
 *  Concatenate two strings.
 *  This operator is intended for normal expressions. Its parameters
 *  are not converted to ''string''.
 *  @return the result of the concatenation.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">string</span>: stri1) &amp; (<span class="op">in</span> <span class="type">string</span>: stri2)       <span class="keywd">is</span> action <span class="stri">"STR_CAT"</span>;


<span class="comment">(**
 *  Concatenate two strings.
 *  This operator is intended for write statements. The functions
 *  [[enable_io#enable_io(in_type)|enable_io]] respectively
 *  [[enable_output#enable_output(in_type)|enable_output]] overload
 *  the &lt;&amp; operator for many types. This overloaded operators
 *  optionally convert parameters to ''string''.
 *  @return the result of the concatenation.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">string</span>: stri1) &lt;&amp; (<span class="op">in</span> <span class="type">string</span>: stri2)      <span class="keywd">is</span> action <span class="stri">"STR_CAT"</span>;


<span class="comment">(**
 *  Get a character, identified by an ''index'', from a ''string''.
 *  The first character has the ''index'' 1.
 *   "abcde"[1]  returns 'a'
 *   "abcde"[5]  returns 'e'
 *   "abcde"[0]  raises INDEX_ERROR
 *   "abcde"[6]  raises INDEX_ERROR
 *  @return the character specified with the ''index''.
 *  @exception INDEX_ERROR If the ''index'' is less than 1 or
 *             greater than the length of the ''string''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">char</span>: (<span class="op">in</span> <span class="type">string</span>: stri) [ (<span class="op">in</span> <span class="type">integer</span>: index) ]       <span class="keywd">is</span> action <span class="stri">"STR_IDX"</span>;


<span class="comment">(**
 *  Get a substring beginning at a ''start'' position.
 *  The first character in a ''string'' has the position 1.
 *   "abcde"[3 ..]  returns "cde"
 *   "abcde"[6 ..]  returns ""
 *        ""[1 ..]  returns ""
 *   "abcde"[1 ..]  returns "abcde"
 *   "abcde"[0 ..]  raises INDEX_ERROR
 *  @param stri Source string from which the substring is created.
 *  @param start Start position which must be >= 1.
 *  @return the substring beginning at the ''start'' position.
 *  @exception INDEX_ERROR The ''start'' position is negative or zero.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">string</span>: stri) [ (<span class="op">in</span> <span class="type">integer</span>: start) .. ]  <span class="keywd">is</span> action <span class="stri">"STR_TAIL"</span>;


<span class="comment">(**
 *  Get a substring ending at a ''stop'' position.
 *  The first character in a ''string'' has the position 1.
 *   "abcde"[.. 4]   returns "abcd"
 *   "abcde"[.. 6]   returns "abcde"
 *        ""[.. 5]   returns ""
 *   "abcde"[.. 0]   returns ""
 *   "abcde"[.. -1]  raises INDEX_ERROR
 *  @param stri Source string from which the substring is created.
 *  @param stop Stop position which must be >= 0.
 *  @return the substring ending at the ''stop'' position.
 *  @exception INDEX_ERROR The ''stop'' position is negative.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">string</span>: stri) [ .. (<span class="op">in</span> <span class="type">integer</span>: stop) ]   <span class="keywd">is</span> action <span class="stri">"STR_HEAD"</span>;


<span class="comment">(**
 *  Get a substring from a ''start'' position to a ''stop'' position.
 *  The first character in a ''string'' has the position 1.
 *   "abcde"[2 .. 4]   returns "bcd"
 *   "abcde"[2 .. 7]   returns "bcde"
 *   "abcde"[4 .. 3]   returns ""
 *   "abcde"[4 .. 2]   raises INDEX_ERROR
 *   "abcde"[6 .. 8]   returns ""
 *   "abcde"[1 .. 3]   returns "abc"
 *   "abcde"[0 .. 3]   raises INDEX_ERROR
 *   "abcde"[1 .. 0]   returns ""
 *   "abcde"[1 .. -1]  raises INDEX_ERROR
 *  @param stri Source string from which the substring is created.
 *  @param start Start position which must be >= 1.
 *  @param stop Stop position which must be >= pred(''start'').
 *  @return the substring from position ''start'' to ''stop''.
 *  @exception INDEX_ERROR The ''start'' position is negative or zero, or
 *                         the ''stop'' position is less than pred(''start'').
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">string</span>: stri) [ (<span class="op">in</span> <span class="type">integer</span>: start) ..
                                       (<span class="op">in</span> <span class="type">integer</span>: stop) ]      <span class="keywd">is</span> action <span class="stri">"STR_RANGE"</span>;


<span class="comment">(**
 *  Get a substring from a ''start'' position with a given ''length''.
 *  The first character in a ''string'' has the position 1.
 *   "abcde"[2 len 3]   returns "bcd"
 *   "abcde"[2 len 5]   returns "bcde"
 *   "abcde"[3 len 0]   returns ""
 *   "abcde"[6 len 2]   returns ""
 *   "abcde"[3 len -1]  raises INDEX_ERROR
 *   "abcde"[0 len 2]   raises INDEX_ERROR
 *  @param stri Source string from which the substring is created.
 *  @param start Start position which must be >= 1.
 *  @param length Requested maximum length of the substring.
 *  @return the substring from the ''start'' position with up to ''length'' characters.
 *  @exception INDEX_ERROR The ''start'' position is negative or zero, or
 *                         the ''length'' is negative.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">string</span>: stri) [ (<span class="op">in</span> <span class="type">integer</span>: start) len
                                       (<span class="op">in</span> <span class="type">integer</span>: length) ]    <span class="keywd">is</span> action <span class="stri">"STR_SUBSTR"</span>;


<span class="comment">(**
 *  Get a substring from a ''start'' position with a guaranteed ''length''.
 *  The first character in a string has the position 1.
 *   "abcde"[2 fixLen 3]   returns "bcd"
 *   "abcde"[3 fixLen 0]   returns ""
 *   "abcde"[2 fixLen 5]   raises INDEX_ERROR
 *   "abcde"[6 fixLen 2]   raises INDEX_ERROR
 *   "abcde"[3 fixLen -1]  raises INDEX_ERROR
 *   "abcde"[0 fixLen 2]   raises INDEX_ERROR
 *        ""[1 fixLen 0]   raises INDEX_ERROR
 *  @param stri Source string from which the substring is created.
 *  @param start Start position between 1 and length(''stri'').
 *  @param length Guaranteed length of the substring.
 *  @return the substring from the ''start'' position with ''length'' characters.
 *  @exception INDEX_ERROR The ''length'' is negative, or the ''start'' position
 *                         is outside of the string, or the substring from the
 *                         ''start'' position has less than ''length'' characters.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">string</span>: stri) [ (<span class="op">in</span> <span class="type">integer</span>: start) fixLen
                                       (<span class="op">in</span> <span class="type">integer</span>: length) ]    <span class="keywd">is</span> action <span class="stri">"STR_SUBSTR_FIXLEN"</span>;


<span class="comment">(**
 *  Append the string ''extension'' to ''destination''.
 *  @exception MEMORY_ERROR Not enough memory for the concatenated
 *             string.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">string</span>: destination) &amp;:= (<span class="op">in</span> <span class="type">string</span>: extension)   <span class="keywd">is</span> action <span class="stri">"STR_APPEND"</span>;


<span class="comment">(**
 *  Append the char ''extension'' to ''destination''.
 *  @exception MEMORY_ERROR Not enough memory for the concatenated
 *             string.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">string</span>: destination) &amp;:= (<span class="op">in</span> <span class="type">char</span>: extension)     <span class="keywd">is</span> action <span class="stri">"STR_PUSH"</span>;


<span class="comment">(**
 *  Assign char ''source'' to the ''position'' of the ''destination''.
 *   A @:= [B] C;
 *  is equivalent to
 *   A := A[..pred(B)] &amp; str(C) &amp; A[succ(B)..];
 *  @exception INDEX_ERROR If ''position'' is negative or zero, or
 *             a character beyond ''destination'' would be overwritten
 *             (''position'' > length(''destination'') holds).
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">string</span>: destination) @:= [ (<span class="op">in</span> <span class="type">integer</span>: position) ] (<span class="op">in</span> <span class="type">char</span>: source) <span class="keywd">is</span> action <span class="stri">"STR_ELEMCPY"</span>;


<span class="comment">(**
 *  Assign string ''source'' to the ''position'' of the ''destination''.
 *   A @:= [B] C;
 *  is equivalent to
 *   A := A[..pred(B)] &amp; C &amp; A[B+length(C)..];
 *  @exception INDEX_ERROR If ''position'' is negative or zero, or
 *             if ''destination'' is smaller than ''source'', or
 *             characters beyond ''destination'' would be overwritten
 *             (''position'' + length(''source'') > succ(length(''destination''))
 *             holds).
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">string</span>: destination) @:= [ (<span class="op">in</span> <span class="type">integer</span>: position) ] (<span class="op">in</span> <span class="type">string</span>: source) <span class="keywd">is</span> action <span class="stri">"STR_POSCPY"</span>;


<span class="comment">(**
 *  Check if two strings are equal.
 *  @return TRUE if both strings are equal,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">string</span>: stri1) = (<span class="op">in</span> <span class="type">string</span>: stri2)      <span class="keywd">is</span> action <span class="stri">"STR_EQ"</span>;


<span class="comment">(**
 *  Check if two strings are not equal.
 *  @return FALSE if both strings are equal,
 *          TRUE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">string</span>: stri1) &lt;> (<span class="op">in</span> <span class="type">string</span>: stri2)     <span class="keywd">is</span> action <span class="stri">"STR_NE"</span>;


<span class="comment">(**
 *  Check if stri1 is less than stri2.
 *  @return TRUE if stri1 is less than stri2,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">string</span>: stri1) &lt; (<span class="op">in</span> <span class="type">string</span>: stri2)      <span class="keywd">is</span> action <span class="stri">"STR_LT"</span>;


<span class="comment">(**
 *  Check if stri1 is greater than stri2.
 *  @return TRUE if stri1 is greater than stri2,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">string</span>: stri1) > (<span class="op">in</span> <span class="type">string</span>: stri2)      <span class="keywd">is</span> action <span class="stri">"STR_GT"</span>;


<span class="comment">(**
 *  Check if stri1 is less than or equal to stri2.
 *  @return TRUE if stri1 is less than or equal to stri2,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">string</span>: stri1) &lt;= (<span class="op">in</span> <span class="type">string</span>: stri2)     <span class="keywd">is</span> action <span class="stri">"STR_LE"</span>;


<span class="comment">(**
 *  Check if stri1 is greater than or equal to stri2.
 *  @return TRUE if stri1 is greater than or equal to stri2,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">string</span>: stri1) >= (<span class="op">in</span> <span class="type">string</span>: stri2)     <span class="keywd">is</span> action <span class="stri">"STR_GE"</span>;


<span class="comment">(**
 *  Compare two strings.
 *  @return -1, 0 or 1 if the first argument is considered to be
 *          respectively less than, equal to, or greater than the
 *          second.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: compare (<span class="op">in</span> <span class="type">string</span>: stri1, <span class="op">in</span> <span class="type">string</span>: stri2) <span class="keywd">is</span> action <span class="stri">"STR_CMP"</span>;


<span class="comment">(**
 *  Compute the hash value of a ''string''.
 *  @return the hash value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: hashCode (<span class="op">in</span> <span class="type">string</span>: stri)                   <span class="keywd">is</span> action <span class="stri">"STR_HASHCODE"</span>;


<span class="comment">(**
 *  Determine the length of a ''string''.
 *  @return the length of the ''string''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: length (<span class="op">in</span> <span class="type">string</span>: stri)                     <span class="keywd">is</span> action <span class="stri">"STR_LNG"</span>;


<span class="comment">(**
 *  Determine if a string starts with a ''prefix''.
 *   startsWith("tmp_s7c.c", "tmp_")  returns TRUE
 *   startsWith("example", "E")       returns FALSE
 *  @return TRUE if ''stri'' starts with ''prefix'',
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: startsWith (<span class="op">in</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="type">string</span>: prefix) <span class="keywd">is</span>
  <span class="keywd">return</span> stri[.. length(prefix)] = prefix;


<span class="comment">(**
 *  Determine if a string ends with a ''suffix''.
 *   endsWith("hello.sd7", ".sd7")  returns TRUE
 *   endsWith("A string", "\0;")    returns FALSE
 *  @return TRUE if ''stri'' ends with ''suffix'',
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: endsWith (<span class="op">in</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="type">string</span>: suffix) <span class="keywd">is</span>
  <span class="keywd">return</span> length(stri) >= length(suffix) <span class="op">and</span>
         stri[succ(length(stri) - length(suffix)) ..] = suffix;


<span class="comment">(**
 *  Check if ''stri'' has the ''searched'' characters starting from ''index''.
 *   equalAtIndex("The quick brown fox", "quick", 5)  returns TRUE
 *   equalAtIndex("axis", "xi", 3)                    returns FALSE
 *  @return TRUE if ''stri'' has the ''searched'' characters starting from ''index'',
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: equalAtIndex (<span class="op">in</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="type">string</span>: searched, <span class="op">in</span> <span class="type">integer</span>: index) <span class="keywd">is</span>
  <span class="keywd">return</span> stri[index len length(searched)] = searched;


<span class="comment">(**
 *  Determine leftmost position of string ''searched'' in ''mainStri''.
 *  If the string is found the position of its first character
 *  is the result. The first character in a string has the position 1.
 *  @return the position of ''searched'' or 0 if ''mainStri''
 *          does not contain ''searched''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: pos (<span class="op">in</span> <span class="type">string</span>: mainStri, <span class="op">in</span> <span class="type">string</span>: searched)  <span class="keywd">is</span> action <span class="stri">"STR_POS"</span>;


<span class="comment">(**
 *  Determine leftmost position of char ''searched'' in ''mainStri''.
 *  The first character in a string has the position 1.
 *  @return the position of ''searched'' or 0 if ''mainStri''
 *          does not contain ''searched''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: pos (<span class="op">in</span> <span class="type">string</span>: mainStri, <span class="op">in</span> <span class="type">char</span>: searched)    <span class="keywd">is</span> action <span class="stri">"STR_CHPOS"</span>;


<span class="comment">(**
 *  Search string ''searched'' in ''mainStri'' at or after ''fromIndex''.
 *  The search starts at ''fromIndex'' and proceeds to the right.
 *  If the string is found the position of its first character
 *  is the result. The first character in a string has the position 1.
 *  The pos function is designed to allow loops like:
 *
 *   index := pos(stri, searchedStri);
 *   while index &lt;> 0 do
 *     # Do something with index
 *     index := pos(stri, searchedStri, succ(index));
 *   end while;
 *
 *  @return the position of ''searched'' or 0 if ''mainStri''
 *          does not contain ''searched'' at or after ''fromIndex''.
 *  @exception RANGE_ERROR If ''fromIndex'' &lt;= 0 holds.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: pos (<span class="op">in</span> <span class="type">string</span>: mainStri, <span class="op">in</span> <span class="type">string</span>: searched,
                         <span class="op">in</span> <span class="type">integer</span>: fromIndex)                     <span class="keywd">is</span> action <span class="stri">"STR_IPOS"</span>;


<span class="comment">(**
 *  Search char ''searched'' in ''mainStri'' at or after ''fromIndex''.
 *  The search starts at ''fromIndex'' and proceeds to the right.
 *  The first character in a string has the position 1.
 *  @return the position of ''searched'' or 0 if ''mainStri''
 *          does not contain ''searched'' at or after ''fromIndex''.
 *  @exception RANGE_ERROR If ''fromIndex'' &lt;= 0 holds.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: pos (<span class="op">in</span> <span class="type">string</span>: mainStri, <span class="op">in</span> <span class="type">char</span>: searched,
                         <span class="op">in</span> <span class="type">integer</span>: fromIndex)                     <span class="keywd">is</span> action <span class="stri">"STR_CHIPOS"</span>;


<span class="comment">(**
 *  Determine rightmost position of string ''searched'' in ''mainStri''.
 *  If the string is found the position of its first character
 *  is the result. The first character in a string has the position 1.
 *  @return the position of ''searched'' or 0 if ''mainStri''
 *          does not contain ''searched''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: rpos (<span class="op">in</span> <span class="type">string</span>: mainStri, <span class="op">in</span> <span class="type">string</span>: searched) <span class="keywd">is</span> action <span class="stri">"STR_RPOS"</span>;


<span class="comment">(**
 *  Determine rightmost position of char ''searched'' in ''mainStri''.
 *  The first character in a string has the position 1.
 *  @return the position of ''searched'' or 0 if ''mainStri''
 *          does not contain ''searched''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: rpos (<span class="op">in</span> <span class="type">string</span>: mainStri, <span class="op">in</span> <span class="type">char</span>: searched)   <span class="keywd">is</span> action <span class="stri">"STR_RCHPOS"</span>;


<span class="comment">(**
 *  Search string ''searched'' in ''mainStri'' at or before ''fromIndex''.
 *  The search starts at ''fromIndex'' and proceeds to the left.
 *  The first character in a string has the position 1.
 *  The rpos function is designed to allow loops like:
 *
 *   index := rpos(stri, searchedStri);
 *   while index &lt;> 0 do
 *     # Do something with index
 *     index := rpos(stri, searchedStri, pred(index));
 *   end while;
 *
 *  @return the position of ''searched'' or 0 if ''mainStri''
 *          does not contain ''searched'' at or before ''fromIndex''.
 *  @exception RANGE_ERROR If ''fromIndex'' > length(stri) holds.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: rpos (<span class="op">in</span> <span class="type">string</span>: mainStri, <span class="op">in</span> <span class="type">string</span>: searched,
                          <span class="op">in</span> <span class="type">integer</span>: fromIndex)                    <span class="keywd">is</span> action <span class="stri">"STR_RIPOS"</span>;


<span class="comment">(**
 *  Search char ''searched'' in ''mainStri'' at or before ''fromIndex''.
 *  The search starts at ''fromIndex'' and proceeds to the left.
 *  The first character in a string has the position 1.
 *  @return the position of ''searched'' or 0 if ''mainStri''
 *          does not contain ''searched'' at or before ''fromIndex''.
 *  @exception RANGE_ERROR If ''fromIndex'' > length(stri) holds.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: rpos (<span class="op">in</span> <span class="type">string</span>: mainStri, <span class="op">in</span> <span class="type">char</span>: searched,
                          <span class="op">in</span> <span class="type">integer</span>: fromIndex)                    <span class="keywd">is</span> action <span class="stri">"STR_RCHIPOS"</span>;


<span class="comment">(* const proc: count (in string: mainStri, in string: searched)       is action "STR_CNT"; *)</span>


<span class="comment">(**
 *  Replace occurrences of ''searched'' in ''mainStri'' by ''replacement''.
 *  The function processes ''mainStri'' from left to right and replaces
 *  ''searched'' by ''replacement''. After a ''searched'' has been replaced
 *  the search for the next ''searched'' starts after the ''replacement''.
 *  If a replacement creates new occurrences of ''searched'' they are left
 *  intact.
 *   replace("old gold", "old", "one")        returns "one gone"
 *   replace("it   is very  low", "  ", " ")  returns "it  is very low"
 *   replace("balll", "all", "al")            returns "ball"
 *   replace("faaaaceeees", "aacee", "ace")   returns "faaaceees"
 *  @return the result of the replacement.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: replace (<span class="op">in</span> <span class="type">string</span>: mainStri, <span class="op">in</span> <span class="type">string</span>: searched,
                            <span class="op">in</span> <span class="type">string</span>: replacement)                 <span class="keywd">is</span> action <span class="stri">"STR_REPL"</span>;


<span class="comment">(**
 *  Replace one occurrence of ''searched'' in ''mainStri'' by ''replacement''.
 *  If there is no occurrence of ''searched'' return the unchanged ''mainStri''.
 *  @return the result of the replacement.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: replace1 (<span class="op">in</span> <span class="type">string</span>: mainStri, <span class="op">in</span> <span class="type">string</span>: searched,
    <span class="op">in</span> <span class="type">string</span>: replacement) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: replaced <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    pos := pos(mainStri, searched);
    <span class="keywd">if</span> pos &lt;> 0 <span class="keywd">then</span>
      replaced := mainStri[.. pred(pos)] &amp; replacement &amp; mainStri[pos + length(searched) ..];
    <span class="keywd">else</span>
      replaced := mainStri;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Replace all occurrences of ''searched'' in ''mainStri'' by ''replacement''.
 *  The function processes ''mainStri'' from left to right and replaces
 *  ''searched'' by ''replacement''. If a replacement creates new occurrences
 *  of ''searched'' they are replaced also.  This can be used to replace
 *  multiple occurrences of a character by one occurrence
 *   replaceN("//path///file", "//", "/")      returns "/path/file"
 *   replaceN("it   is very  low", "  ", " ")  returns "it is very low"
 *   replaceN("balll", "all", "al")            returns "bal"
 *   replaceN("faaaaceeees", "aacee", "ace")   returns "faces"
 *  @return the result of the replacement.
 *  @exception MEMORY_ERROR If ''searched'' is a substring of ''replacement''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: replaceN (<span class="op">in</span> <span class="type">string</span>: mainStri, <span class="op">in</span> <span class="type">string</span>: searched,
                             <span class="op">in</span> <span class="type">string</span>: replacement) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: replaced <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(replacement) &lt; length(searched) <span class="keywd">then</span>
      length := length(mainStri);
      replaced := replace(mainStri, searched, replacement);
      <span class="keywd">while</span> length(replaced) &lt;> length <span class="keywd">do</span>
        length := length(replaced);
        replaced := replace(replaced, searched, replacement);
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">elsif</span> length(replacement) > length(searched) <span class="keywd">then</span>
      <span class="keywd">if</span> pos(replacement, searched) &lt;> 0 <span class="keywd">then</span>
        <span class="keywd">if</span> pos(mainStri, searched) &lt;> 0 <span class="keywd">then</span>
          raise MEMORY_ERROR;
        <span class="keywd">else</span>
          replaced := mainStri;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        length := length(mainStri);
        replaced := replace(mainStri, searched, replacement);
        <span class="keywd">while</span> length(replaced) &lt;> length <span class="keywd">do</span>
          length := length(replaced);
          replaced := replace(replaced, searched, replacement);
        <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> searched = replacement <span class="keywd">then</span>
      replaced := mainStri;
    <span class="keywd">else</span>
      replaced := replace(mainStri, searched, replacement);
      <span class="keywd">while</span> pos(replaced, searched) &lt;> 0 <span class="keywd">do</span>
        replaced := replace(replaced, searched, replacement);
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Replace occurrences of ''search1'' followed by ''search2'' with ''replacement''.
 *  Searches ''mainStri'' for ''search1'' followed by ''search2''. The
 *  characters from the beginning of ''search1'' to the end of ''search2''
 *  are replaced by ''replacement''. There can be zero or more characters
 *  between ''search1'' and ''search2''. With ''replace2'' unnested comments
 *  can be removed:
 *   replace2("x := (*ord*) y;", "(*", "*)", "")  returns "x :=  y;"
 *  @return the result of the replacement.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: replace2 (<span class="op">in</span> <span class="type">string</span>: mainStri, <span class="op">in</span> <span class="type">string</span>: search1,
    <span class="op">in</span> <span class="type">string</span>: search2, <span class="op">in</span> <span class="type">string</span>: replacement) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: replaced <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: startPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: endPos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    startPos := pos(mainStri, search1);
    <span class="keywd">while</span> startPos &lt;> 0 <span class="keywd">do</span>
      replaced &amp;:= mainStri[endPos .. pred(startPos)];
      endPos := pos(mainStri, search2, startPos + length(search1));
      <span class="keywd">if</span> endPos &lt;> 0 <span class="keywd">then</span>
        replaced &amp;:= replacement;
        endPos +:= length(search2);
        startPos := pos(mainStri, search1, endPos);
      <span class="keywd">else</span>
        endPos := startPos;
        startPos := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    replaced &amp;:= mainStri[endPos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Convert a string to upper case.
 *  The conversion uses the default Unicode case mapping,
 *  where each character is considered in isolation.
 *  Characters without case mapping are left unchanged.
 *  The mapping is independent from the locale. Individual
 *  character case mappings cannot be reversed, because some
 *  characters have multiple characters that map to them.
 *  @return the string converted to upper case.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: upper (<span class="op">in</span> <span class="type">string</span>: stri)                     <span class="keywd">is</span> action <span class="stri">"STR_UP"</span>;


<span class="comment">(**
 *  Convert a string to lower case.
 *  The conversion uses the default Unicode case mapping,
 *  where each character is considered in isolation.
 *  Characters without case mapping are left unchanged.
 *  The mapping is independent from the locale. Individual
 *  character case mappings cannot be reversed, because some
 *  characters have multiple characters that map to them.
 *  @return the string converted to lower case.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: lower (<span class="op">in</span> <span class="type">string</span>: stri)                     <span class="keywd">is</span> action <span class="stri">"STR_LOW"</span>;


<span class="comment">(**
 *  Number of screen columns occupied by the Unicode string ''stri''.
 *  The width of single characters can be 0,1 or 2 depending on the
 *  width occupied on a terminal. Non-spacing characters and control
 *  characters have width of 0. Kanji and other full width characters
 *  have a width of 2.
 *  @return the sum of the character widths in ''stri''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: width (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="comment">(**
 *  Reverse the characters in a string.
 *   reverse("ABC")  returns "CBA"
 *  @return the reversed string.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: reverse (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="comment">(**
 *  Return string with leading and trailing whitespace omitted.
 *  All characters less than or equal to ' ' (space) count as whitespace.
 *   trim(" /n xyz /r")  returns "xyz"
 *  @return string with leading and trailing whitespace omitted.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: trim (<span class="op">in</span> <span class="type">string</span>: stri)                      <span class="keywd">is</span> action <span class="stri">"STR_TRIM"</span>;


<span class="comment">(**
 *  Return string with leading whitespace omitted.
 *  All characters less than or equal to ' ' (space) count as whitespace.
 *   ltrim(" /n xyz /r")  returns "xyz /r"
 *  @return string with leading whitespace omitted.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: ltrim (<span class="op">in</span> <span class="type">string</span>: stri)                     <span class="keywd">is</span> action <span class="stri">"STR_LTRIM"</span>;


<span class="comment">(**
 *  Return string with trailing whitespace omitted.
 *  All characters less than or equal to ' ' (space) count as whitespace.
 *   rtrim(" /n xyz /r")  returns " /n xyz"
 *  @return string with trailing whitespace omitted.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: rtrim (<span class="op">in</span> <span class="type">string</span>: stri)                     <span class="keywd">is</span> action <span class="stri">"STR_RTRIM"</span>;


<span class="comment">(**
 *  Trim a string such that it can be converted to ''aType''.
 *  Removes leading and trailing whitespace from ''stri''.
 *  This function is overloaded for types where removing leading
 *  or trailing whitespace would change the value.
 *   trimValue(integer, " 1 ")                 returns "1"
 *   integer(trimValue(integer, " 1 "))        returns 1
 *   integer parse trimValue(integer, " 1 ")   returns 1
 *  @return the trimmed string.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: trimValue (<span class="op">in</span> <span class="type">type</span>: aType, <span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span>
  <span class="keywd">return</span> trim(stri);


<span class="comment">(**
 *  Trim a string such that it can be converted to ''string''.
 *  Leaves ''stri'' unchanged, since trimming would change the value.
 *   trimValue(string, " 1 ")                returns " 1 "
 *   string(trimValue(string, " 1 "))        returns " 1 "
 *   string parse trimValue(string, " 1 ")   returns " 1 "
 *  @return the unchanged string.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: trimValue (attr string, <span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span>
  <span class="keywd">return</span> stri;


<span class="comment">(**
 *  Convert to a string.
 *  @return its parameter unchanged.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">string</span>: stri)                       <span class="keywd">is</span> action <span class="stri">"STR_STR"</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: literal (<span class="op">in</span> <span class="type">string</span>: stri)                   <span class="keywd">is</span> action <span class="stri">"STR_LIT"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: c_literal (<span class="op">in</span> <span class="type">string</span>: stri)                 <span class="keywd">is</span> action <span class="stri">"STR_CLIT"</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getint (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: <span class="op">digits</span> <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] >= <span class="stri">'0'</span> <span class="op">and</span> stri[pos] &lt;= <span class="stri">'9'</span> <span class="keywd">do</span>
      incr(pos);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="op">digits</span> := stri[.. pred(pos)];
    stri := stri[pos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: gets (<span class="keywd">inout</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="type">integer</span>: maxLength) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: striRead <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    striRead := stri[.. maxLength];
    stri := stri[succ(length(striRead)) ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Convert to a string.
 *  @return its parameter unchanged.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: string (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span>
  <span class="keywd">return</span> stri;


<span class="comment">(**
 *  Convert to a string.
 *  @return its parameter unchanged.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (attr string) <span class="op">parse</span> (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span>
  <span class="keywd">return</span> stri;


DECLARE_TERNARY(string);
</pre>
</body>
</html>
