<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  progs.s7i     Program handling support library                  *)</span>
<span class="comment">(*  Copyright (C) 1991 - 1994, 2004 - 2015, 2020  Thomas Mertes     *)</span>
<span class="comment">(*                2021, 2024  Thomas Mertes                         *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/category.htm">category.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bstring.htm">bstring.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bigint.htm">bigint.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/float.htm">float.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/external_file.htm">external_file.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/graph.htm">graph.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/poll.htm">poll.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/process.htm">process.s7i</a>"</span>;


<span class="comment">(**
 *  Type to describe a Seed7 program.
 *)</span>
<span class="keywd">const</span> <span class="type">type</span>: program <span class="keywd">is</span> subtype object;


IN_PARAM_IS_REFERENCE(program);

<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">ref</span> <span class="type">program</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">program</span>: source)                <span class="keywd">is</span> action <span class="stri">"PRG_CREATE"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: destroy (<span class="keywd">ref</span> <span class="type">program</span>: aValue)                                <span class="keywd">is</span> action <span class="stri">"PRG_DESTR"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">program</span>: dest) := (<span class="keywd">ref</span> <span class="type">program</span>: source)               <span class="keywd">is</span> action <span class="stri">"PRG_CPY"</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: _GENERATE_EMPTY_PROG                                 <span class="keywd">is</span> action <span class="stri">"PRG_EMPTY"</span>;
<span class="keywd">const</span> <span class="type">program</span>: (attr program) . EMPTY                                    <span class="keywd">is</span> _GENERATE_EMPTY_PROG;


<span class="comment">(**
 *  Default value of ''program'' (program.EMPTY).
 *)</span>
<span class="keywd">const</span> <span class="type">program</span>: (attr program) . value                                    <span class="keywd">is</span> program.EMPTY;


<span class="comment">(**
 *  Check if two ''program'' values are equal.
 *  @return TRUE if both values are equal, FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">program</span>: prog1) = (<span class="op">in</span> <span class="type">program</span>: prog2)            <span class="keywd">is</span> action <span class="stri">"PRG_EQ"</span>;


<span class="comment">(**
 *  Check if two ''program'' values are not equal.
 *  @return FALSE if both values are equal, TRUE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">program</span>: prog1) &lt;> (<span class="op">in</span> <span class="type">program</span>: prog2)           <span class="keywd">is</span> action <span class="stri">"PRG_NE"</span>;


<span class="comment">(**
 *  Returns the name of ''aProgram'' without path and extension.
 *  This function does not follow symbolic links.
 *  It determines, with which name a program was called.
 *  If a symbolic link refers to a program, the name of
 *  the symbolic link is returned.
 *  @return the name of the program.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: name (<span class="op">in</span> <span class="type">program</span>: aProgram)                           <span class="keywd">is</span> action <span class="stri">"PRG_NAME"</span>;


<span class="comment">(**
 *  Return the absolute path of the program ''aProgram''.
 *  This function does follow symbolic links.
 *  @return the absolute path of the program.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: path (<span class="op">in</span> <span class="type">program</span>: aProgram)                           <span class="keywd">is</span> action <span class="stri">"PRG_PATH"</span>;


<span class="keywd">const</span> <span class="type">type</span>: singleParseOption <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">enum</span>
    TRACE_ACTIONS,         <span class="comment"># Trace primitive actions</span>
    TRACE_DO_ACTION_CHECK, <span class="comment"># Do action check</span>
    TRACE_DYNAMIC_CALLS,   <span class="comment"># Trace dynamic calls</span>
    TRACE_EXCEPTIONS,      <span class="comment"># Trace exceptions and handlers</span>
    TRACE_HEAP_SIZE,       <span class="comment"># Trace heap size</span>
    TRACE_MATCH,           <span class="comment"># Trace matching expressions</span>
    TRACE_EXECUTIL,        <span class="comment"># Trace exec utility functions</span>
    WRITE_LIBRARY_NAMES,   <span class="comment"># Write a list of include libraries</span>
    WRITE_LINE_NUMBERS,    <span class="comment"># Write line numbers, while analyzing</span>
    SHOW_IDENT_TABLE,      <span class="comment"># Show the identifier table after the analyzing phase</span>
    SHOW_STATISTICS        <span class="comment"># Show compilation statistics</span>
  <span class="keywd">end</span> <span class="keywd">enum</span>;

<span class="keywd">const</span> <span class="type">type</span>: parseOptions <span class="keywd">is</span> <span class="type">set</span> <span class="type">of</span> <span class="type">singleParseOption</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseFile (<span class="op">in</span> <span class="type">string</span>: fileName, <span class="op">in</span> <span class="type">parseOptions</span>: options,
                               <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: libraryDirs,
                               <span class="op">in</span> <span class="type">clib_file</span>: errorFile)                  <span class="keywd">is</span> action <span class="stri">"PRG_FIL_PARSE"</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseFile (<span class="op">in</span> <span class="type">string</span>: fileName, <span class="op">in</span> <span class="type">parseOptions</span>: options,
                               <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: libraryDirs,
                               <span class="keywd">inout</span> <span class="type">null_file</span>: errorFile) <span class="keywd">is</span>
  <span class="keywd">return</span> parseFile(fileName, options, libraryDirs, CLIB_NULL_FILE);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseFile (<span class="op">in</span> <span class="type">string</span>: fileName, <span class="op">in</span> <span class="type">parseOptions</span>: options,
                               <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: libraryDirs,
                               <span class="keywd">inout</span> <span class="type">external_file</span>: errorFile) <span class="keywd">is</span>
  <span class="keywd">return</span> parseFile(fileName, options, libraryDirs, errorFile.ext_file);


<span class="comment">(**
 *  Parse the file with the given ''fileName'', ''options'', ''libraryDirs'' and ''errorFile''.
 *  @param fileName Name of the file to be parsed.
 *  @param options Pptions to be used for the parsing.
 *  @param libraryDirs List of directories for the include/library files.
 *  @param errorFile File for the error messages.
 *  @return the parsed program, or ''program.EMPTY'' if the file ''fileName''
 *          could not be opened.
 *  @exception RANGE_ERROR ''fileName'' does not use the standard path
 *             representation or ''fileName'' is not representable in
 *             the system path type.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseFile (<span class="op">in</span> <span class="type">string</span>: fileName, <span class="op">in</span> <span class="type">parseOptions</span>: options,
                               <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: libraryDirs,
                               <span class="keywd">inout</span> <span class="type">file</span>: errorFile) <span class="keywd">is</span> DYNAMIC;


<span class="comment">(**
 *  Parse the file with the given ''fileName'', ''options'' and ''libraryDirs''.
 *  @param fileName Name of the file to be parsed.
 *  @param options Pptions to be used for the parsing.
 *  @param libraryDirs List of directories for the include/library files.
 *  @return the parsed program, or ''program.EMPTY'' if the file ''fileName''
 *          could not be opened.
 *  @exception RANGE_ERROR ''fileName'' does not use the standard path
 *             representation or ''fileName'' is not representable in
 *             the system path type.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseFile (<span class="op">in</span> <span class="type">string</span>: fileName, <span class="op">in</span> <span class="type">parseOptions</span>: options,
                               <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: libraryDirs) <span class="keywd">is</span>
  <span class="keywd">return</span> parseFile(fileName, options, libraryDirs, CLIB_NULL_FILE);


<span class="comment">(**
 *  Parse the file with the given ''fileName'' and ''options''.
 *  @param fileName Name of the file to be parsed.
 *  @param options Pptions to be used for the parsing.
 *  @return the parsed program, or ''program.EMPTY'' if the file ''fileName''
 *          could not be opened.
 *  @exception RANGE_ERROR ''fileName'' does not use the standard path
 *             representation or ''fileName'' is not representable in
 *             the system path type.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseFile (<span class="op">in</span> <span class="type">string</span>: fileName, <span class="op">in</span> <span class="type">parseOptions</span>: options) <span class="keywd">is</span>
  <span class="keywd">return</span> parseFile(fileName, options, 0 <span class="op">times</span> <span class="stri">""</span>, CLIB_NULL_FILE);


<span class="comment">(**
 *  Parse the file with the given ''fileName''.
 *  @param fileName Name of the file to be parsed.
 *  @return the parsed program, or ''program.EMPTY'' if the file ''fileName''
 *          could not be opened.
 *  @exception RANGE_ERROR ''fileName'' does not use the standard path
 *             representation or ''fileName'' is not representable in
 *             the system path type.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseFile (<span class="op">in</span> <span class="type">string</span>: fileName) <span class="keywd">is</span>
  <span class="keywd">return</span> parseFile(fileName, parseOptions.value, 0 <span class="op">times</span> <span class="stri">""</span>, CLIB_NULL_FILE);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseStri (<span class="op">in</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="type">parseOptions</span>: options,
                               <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: libraryDirs,
                               <span class="op">in</span> <span class="type">clib_file</span>: errorFile)                  <span class="keywd">is</span> action <span class="stri">"PRG_STR_PARSE"</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseStri (<span class="op">in</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="type">parseOptions</span>: options,
                               <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: libraryDirs,
                               <span class="keywd">inout</span> <span class="type">null_file</span>: errorFile) <span class="keywd">is</span>
  <span class="keywd">return</span> parseStri(stri, options, libraryDirs, CLIB_NULL_FILE);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseStri (<span class="op">in</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="type">parseOptions</span>: options,
                               <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: libraryDirs,
                               <span class="keywd">inout</span> <span class="type">external_file</span>: errorFile) <span class="keywd">is</span>
  <span class="keywd">return</span> parseStri(stri, options, libraryDirs, errorFile.ext_file);


<span class="comment">(**
 *  Parse the given ''string'' with ''options', ''libraryDirs'' and ''errorFile''.
 *  @param stri String to be parsed.
 *  @param options Pptions to be used for the parsing.
 *  @param libraryDirs List of directories for the include/library files.
 *  @param errorFile File for the error messages.
 *  @return the parsed program.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseStri (<span class="op">in</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="type">parseOptions</span>: options,
                               <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: libraryDirs,
                               <span class="keywd">inout</span> <span class="type">file</span>: errorFile) <span class="keywd">is</span> DYNAMIC;


<span class="comment">(**
 *  Parse the given ''string'' with ''options' and ''libraryDirs''.
 *  @param stri String to be parsed.
 *  @param options Pptions to be used for the parsing.
 *  @param libraryDirs List of directories for the include/library files.
 *  @return the parsed program.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseStri (<span class="op">in</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="type">parseOptions</span>: options,
                               <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: libraryDirs) <span class="keywd">is</span>
  <span class="keywd">return</span> parseStri(stri, options, libraryDirs, CLIB_NULL_FILE);


<span class="comment">(**
 *  Parse the given ''string'' with ''options'.
 *  @param stri String to be parsed.
 *  @param options Pptions to be used for the parsing.
 *  @return the parsed program.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseStri (<span class="op">in</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="type">parseOptions</span>: options) <span class="keywd">is</span>
  <span class="keywd">return</span> parseStri(stri, options, 0 <span class="op">times</span> <span class="stri">""</span>, CLIB_NULL_FILE);


<span class="comment">(**
 *  Parse the given ''string''.
 *  @param stri String to be parsed.
 *  @return the parsed program.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseStri (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span>
  <span class="keywd">return</span> parseStri(stri, parseOptions.value, 0 <span class="op">times</span> <span class="stri">""</span>, CLIB_NULL_FILE);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseStri (<span class="op">in</span> <span class="type">bstring</span>: bstri, <span class="op">in</span> <span class="type">parseOptions</span>: options,
                               <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: libraryDirs,
                               <span class="op">in</span> <span class="type">clib_file</span>: errorFile)                  <span class="keywd">is</span> action <span class="stri">"PRG_BSTRI_PARSE"</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseStri (<span class="op">in</span> <span class="type">bstring</span>: bstri, <span class="op">in</span> <span class="type">parseOptions</span>: options,
                               <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: libraryDirs,
                               <span class="keywd">inout</span> <span class="type">null_file</span>: errorFile) <span class="keywd">is</span>
  <span class="keywd">return</span> parseStri(bstri, options, libraryDirs, CLIB_NULL_FILE);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseStri (<span class="op">in</span> <span class="type">bstring</span>: bstri, <span class="op">in</span> <span class="type">parseOptions</span>: options,
                               <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: libraryDirs,
                               <span class="keywd">inout</span> <span class="type">external_file</span>: errorFile) <span class="keywd">is</span>
  <span class="keywd">return</span> parseStri(bstri, options, libraryDirs, errorFile.ext_file);


<span class="comment">(**
 *  Parse the given ''bstring'' with ''options', ''libraryDirs'' and ''errorFile''.
 *  @param bstri BString to be parsed.
 *  @param options Pptions to be used for the parsing.
 *  @param libraryDirs List of directories for the include/library files.
 *  @param errorFile File for the error messages.
 *  @return the parsed program.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseStri (<span class="op">in</span> <span class="type">bstring</span>: bstri, <span class="op">in</span> <span class="type">parseOptions</span>: options,
                               <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: libraryDirs,
                               <span class="keywd">inout</span> <span class="type">file</span>: errorFile) <span class="keywd">is</span> DYNAMIC;


<span class="comment">(**
 *  Parse the given ''bstring'' with ''options' and ''libraryDirs''.
 *  @param bstri BString to be parsed.
 *  @param options Pptions to be used for the parsing.
 *  @param libraryDirs List of directories for the include/library files.
 *  @return the parsed program.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseStri (<span class="op">in</span> <span class="type">bstring</span>: bstri, <span class="op">in</span> <span class="type">parseOptions</span>: options,
                               <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: libraryDirs) <span class="keywd">is</span>
  <span class="keywd">return</span> parseStri(bstri, options, libraryDirs, CLIB_NULL_FILE);


<span class="comment">(**
 *  Parse the given ''bstring'' with ''options'.
 *  @param bstri BString to be parsed.
 *  @param options Pptions to be used for the parsing.
 *  @return the parsed program.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseStri (<span class="op">in</span> <span class="type">bstring</span>: bstri, <span class="op">in</span> <span class="type">parseOptions</span>: options) <span class="keywd">is</span>
  <span class="keywd">return</span> parseStri(bstri, options, 0 <span class="op">times</span> <span class="stri">""</span>, CLIB_NULL_FILE);


<span class="comment">(**
 *  Parse the given ''bstring''.
 *  @param bstri BString to be parsed.
 *  @return the parsed program.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: parseStri (<span class="op">in</span> <span class="type">bstring</span>: bstri) <span class="keywd">is</span>
  <span class="keywd">return</span> parseStri(bstri, parseOptions.value, 0 <span class="op">times</span> <span class="stri">""</span>, CLIB_NULL_FILE);


<span class="comment">(**
 *  Evaluate ''anExpression'' which is part of ''aProgram''.
 *  @return the result of the evaluation.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: evaluate (<span class="op">in</span> <span class="type">program</span>: aProgram,
                                <span class="op">in</span> <span class="type">reference</span>: anExpression)              <span class="keywd">is</span> action <span class="stri">"PRG_EVAL"</span>;


<span class="comment">(**
 *  Execute ''aProgram'' with the given ''parameters'', ''options'' and ''protFileName''.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: execute (<span class="op">in</span> <span class="type">program</span>: aProgram, <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: parameters,
                     <span class="op">in</span> <span class="type">parseOptions</span>: options,
                     <span class="op">in</span> <span class="type">string</span>: protFileName)                            <span class="keywd">is</span> action <span class="stri">"PRG_EXEC"</span>;


<span class="comment">(**
 *  Execute ''aProgram'' with the given ''parameters'' and ''options''.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: execute (<span class="op">in</span> <span class="type">program</span>: aProgram, <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: parameters,
                     <span class="op">in</span> <span class="type">parseOptions</span>: options) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    execute(aProgram, parameters, options, <span class="stri">""</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Execute ''aProgram'' with the given ''parameters''.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: execute (<span class="op">in</span> <span class="type">program</span>: aProgram, <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: parameters) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    execute(aProgram, parameters, parseOptions.value, <span class="stri">""</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Execute ''aProgram'' with an empty parameter list.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: execute (<span class="op">in</span> <span class="type">program</span>: aProgram) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    execute(aProgram, 0 <span class="op">times</span> <span class="stri">""</span>, parseOptions.value, <span class="stri">""</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the value of the system variable ''name'' in ''aProgram''.
 *  @return a reference to the value of the system variable or
 *          NIL if no system variable ''name'' exists.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: sysVar (<span class="op">in</span> <span class="type">program</span>: aProgram, <span class="op">in</span> <span class="type">string</span>: name)     <span class="keywd">is</span> action <span class="stri">"PRG_SYSVAR"</span>;


<span class="comment">(**
 *  Determine the number of errors in ''aProgram''.
 *  @return the number of errors.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: errorCount (<span class="op">in</span> <span class="type">program</span>: aProgram)                    <span class="keywd">is</span> action <span class="stri">"PRG_ERROR_COUNT"</span>;


<span class="keywd">const</span> <span class="type">type</span>: errorType <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">enum</span>
    OUT_OF_HEAP_SPACE,
    EOF_ENCOUNTERED,
    CHAR_ILLEGAL,
    COMMENTOPEN,
    FILENOTFOUND,
    WRONG_PATH_DELIMITER,
    ESSENTIAL_INCLUDE_FAILED,
    ILLEGALPRAGMA,
    WRONGACTION,
    WRONGSYSTEM,
    DOLLAR_VALUE_WRONG,
    DOLLAR_TYPE_WRONG,
    SYSTEM_MAIN_MISSING,
    CARD_DECIMAL_TOO_BIG,
    NEGATIVEEXPONENT,
    DIGITEXPECTED,
    CARD_WITH_EXPONENT_TOO_BIG,
    BASE2TO36ALLOWED,
    EXTDIGITEXPECTED,
    ILLEGALBASEDDIGIT,
    CARD_BASED_TOO_BIG,
    APOSTROPHEXPECTED,
    CHAREXCEEDS,
    WRONG_QUOTATION_REPRESENTATION,
    STRINGESCAPE,
    WRONGNUMERICALESCAPE,
    NUMERICAL_ESCAPE_TOO_BIG,
    BACKSLASHEXPECTED,
    STRINGEXCEEDS,
    NAMEEXPECTED,
    CARD_EXPECTED,
    STRI_EXPECTED,
    IDENT_EXPECTED,
    TYPE_EXPECTED,
    PROC_EXPECTED,
    PARAM_SPECIFIER_EXPECTED,
    PARAM_DECL_OR_SYMBOL_EXPECTED,
    EXCEPTION_EXPECTED,
    EXPR_EXPECTED,
    EXPECTED_SYMBOL,
    PARAM_DECL_FAILED,
    DECL_FAILED,
    OBJTWICEDECLARED,
    PREVIOUS_DECLARATION,
    EXCEPTION_RAISED,
    ILLEGAL_ASSOCIATIVITY,
    ILLEGAL_PRIORITY,
    TWO_PARAMETER_SYNTAX,
    EMPTY_SYNTAX,
    SYNTAX_DECLARED_TWICE,
    DOT_EXPR_EXPECTED,
    REDECLARED_INFIX_PRIORITY,
    REDECLARED_PREFIX_PRIORITY,
    WRONG_EXPR_PARAM_PRIORITY,
    WRONG_PREFIX_PRIORITY,
    DOT_EXPR_ILLEGAL,
    NO_MATCH,
    WRONGACCESSRIGHT,
    LITERAL_TYPE_UNDEFINED,
    KIND_OF_IN_PARAM_UNDEFINED,
    OVERLONG_UTF8_ENCODING,
    UTF16_SURROGATE_CHAR_FOUND,
    CHAR_NOT_UNICODE,
    UTF8_CONTINUATION_BYTE_EXPECTED,
    UNEXPECTED_UTF8_CONTINUATION_BYTE,
    SOLITARY_UTF8_START_BYTE,
    UTF16_BYTE_ORDER_MARK_FOUND
  <span class="keywd">end</span> <span class="keywd">enum</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">errorType</span>: error) <span class="keywd">is</span>
    <span class="keywd">return</span> literal(error);

enable_output(errorType);


<span class="keywd">const</span> <span class="type">type</span>: parseError <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">errorType</span>: error <span class="keywd">is</span> errorType.value;
    <span class="keywd">var</span> <span class="type">string</span>: fileName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: lineNumber <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: columnNumber <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: message <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: errorLine <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: DO_GET_ERROR (<span class="op">in</span> <span class="type">program</span>: aProgram, <span class="op">in</span> <span class="type">integer</span>: errorIndex,
    <span class="keywd">inout</span> <span class="type">integer</span>: errorNumber, <span class="keywd">inout</span> <span class="type">string</span>: fileName,
    <span class="keywd">inout</span> <span class="type">integer</span>: lineNumber, <span class="keywd">inout</span> <span class="type">integer</span>: columnNumber,
    <span class="keywd">inout</span> <span class="type">string</span>: msg, <span class="keywd">inout</span> <span class="type">string</span>: errorLine)                          <span class="keywd">is</span> action <span class="stri">"PRG_GET_ERROR"</span>;


<span class="comment">(**
 *  Get the error specified by ''errorIndex'' from ''aProgram''.
 *  @return the specified error.
 *  @exception RANGE_ERROR If ''errorIndex'' &lt;= 0 holds, or
 *                         no error with ''errorIndex'' exists.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">parseError</span>: getError (<span class="op">in</span> <span class="type">program</span>: aProgram, <span class="op">in</span> <span class="type">integer</span>: errorIndex) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">parseError</span>: error <span class="keywd">is</span> parseError.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: errorNumber <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    DO_GET_ERROR(aProgram, errorIndex, errorNumber,
                 error.fileName, error.lineNumber, error.columnNumber,
                 error.message, error.errorLine);
    error.error := errorType <span class="op">conv</span> errorNumber;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the list of global defined objects in ''aProgram''.
 *  The returned list contains constant and variable objects
 *  in the same order as the definitions of the source program.
 *  Literal objects and local objects are not part of this list.
 *  @return the list of global defined objects.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">ref_list</span>: globalObjects (<span class="op">in</span> <span class="type">program</span>: aProgram)                <span class="keywd">is</span> action <span class="stri">"PRG_GLOBAL_OBJECTS"</span>;


<span class="comment">(**
 *  Determine object with ''name'' from program ''aProgram''.
 *  @return a reference to the object or NIL if no object ''name'' exists.
 *  @exception MEMORY_ERROR If ''name'' cannot be converted to
 *             the internal representation.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: syobject (<span class="op">in</span> <span class="type">program</span>: aProgram, <span class="op">in</span> <span class="type">string</span>: name)   <span class="keywd">is</span> action <span class="stri">"PRG_SYOBJECT"</span>;


<span class="comment">(**
 *  Determine object from program ''aProgram'' which matches ''expression''.
 *  @return object from program.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: match (<span class="op">in</span> <span class="type">program</span>: aProgram, <span class="op">in</span> <span class="type">ref_list</span>: expression) <span class="keywd">is</span> action <span class="stri">"PRG_MATCH"</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: matchExpr (<span class="op">in</span> <span class="type">program</span>: aProgram, <span class="op">in</span> <span class="type">ref_list</span>: expression)  <span class="keywd">is</span> action <span class="stri">"PRG_MATCH_EXPR"</span>;
<span class="comment"># const func program: get (PROGRAM)                                      is action "PRG_PROG";</span>


<span class="comment">(**
 *  Determine if the referenced object is temporary.
 *  @return TRUE if ''aReference'' is temporary, FALSE otherwise.
 *  @exception RANGE_ERROR If ''aReference'' is NIL.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isTemp (<span class="op">in</span> <span class="type">reference</span>: aReference)                    <span class="keywd">is</span> action <span class="stri">"REF_ISTEMP"</span>;


<span class="comment">(**
 *  Determine if the referenced object is variable.
 *  @return TRUE if ''aReference'' is a variable, FALSE otherwise.
 *  @exception RANGE_ERROR If ''aReference'' is NIL.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isVar (<span class="op">in</span> <span class="type">reference</span>: aReference)                     <span class="keywd">is</span> action <span class="stri">"REF_ISVAR"</span>;


<span class="comment">(**
 *  Set var flag of a referenced object.
 *  @exception RANGE_ERROR If ''aReference'' is NIL.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: setVar (<span class="op">in</span> <span class="type">reference</span>: aReference, <span class="op">in</span> <span class="type">boolean</span>: isVariable)    <span class="keywd">is</span> action <span class="stri">"REF_SETVAR"</span>;


<span class="comment">(**
 *  Get the category of a referenced object.
 *  @return the category of the referenced object.
 *  @exception RANGE_ERROR If ''aReference'' is NIL.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> category: category (<span class="op">in</span> <span class="type">reference</span>: aReference)                 <span class="keywd">is</span> action <span class="stri">"REF_CATEGORY"</span>;


<span class="comment">(**
 *  Set the category of ''aReference'' to ''aCategory''.
 *  @exception RANGE_ERROR If ''aReference'' is NIL.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: setCategory (<span class="op">in</span> <span class="type">reference</span>: aReference,
                         <span class="op">in</span> category: aCategory)                         <span class="keywd">is</span> action <span class="stri">"REF_SETCATEGORY"</span>;


<span class="comment">(**
 *  Get the formal parameters of the function referenced by ''funcRef''.
 *  For objects without parameters an empty list is returned.
 *  @return the formal parameters as [[ref_list]].
 *  @exception RANGE_ERROR If ''funcRef'' is NIL.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">ref_list</span>: formalParams (<span class="op">in</span> <span class="type">reference</span>: funcRef)                <span class="keywd">is</span> action <span class="stri">"REF_PARAMS"</span>;


<span class="comment">(**
 *  Set the formal parameters of ''funcRef'' to ''params''.
 *  @exception RANGE_ERROR If ''funcRef'' is NIL.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: setFormalParams (<span class="op">in</span> <span class="type">reference</span>: funcRef, <span class="op">in</span> <span class="type">ref_list</span>: params) <span class="keywd">is</span> action <span class="stri">"REF_SETPARAMS"</span>;


<span class="comment">(**
 *  Gets the result variable of ''funcRef''.
 *  @return a [[reference]] to the result variable.
 *  @exception RANGE_ERROR If ''funcRef'' is NIL or
 *                         category(funcRef) &lt;> BLOCKOBJECT holds.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: resultVar (<span class="op">in</span> <span class="type">reference</span>: funcRef)                  <span class="keywd">is</span> action <span class="stri">"REF_RESULT"</span>;


<span class="comment">(**
 *  Gets the initialization value of the result variable of ''funcRef''.
 *  @return a [[reference]] to the initialization value.
 *  @exception RANGE_ERROR If ''funcRef'' is NIL or
 *                         category(funcRef) &lt;> BLOCKOBJECT holds.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: resultInitValue (<span class="op">in</span> <span class="type">reference</span>: funcRef)            <span class="keywd">is</span> action <span class="stri">"REF_RESINI"</span>;


<span class="comment">(**
 *  Gets the local constants of ''funcRef''.
 *  @return the local constants as [[ref_list]].
 *  @exception RANGE_ERROR If ''funcRef'' is NIL or
 *                         category(funcRef) &lt;> BLOCKOBJECT holds.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">ref_list</span>: localConsts (<span class="op">in</span> <span class="type">reference</span>: funcRef)                 <span class="keywd">is</span> action <span class="stri">"REF_LOCAL_CONSTS"</span>;


<span class="comment">(**
 *  Gets the local variables of ''funcRef''.
 *  @return the local variables as [[ref_list]].
 *  @exception RANGE_ERROR If ''funcRef'' is NIL or
 *                         category(funcRef) &lt;> BLOCKOBJECT holds.
 *  @exception MEMORY_ERROR An out of memory situation occurred.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">ref_list</span>: localVars (<span class="op">in</span> <span class="type">reference</span>: funcRef)                   <span class="keywd">is</span> action <span class="stri">"REF_LOCAL_VARS"</span>;


<span class="comment">(**
 *  Gets the body of the function referenced by ''funcRef''.
 *  @return the body expression of ''funcRef''.
 *  @exception RANGE_ERROR If ''funcRef'' is NIL or
 *                         category(funcRef) &lt;> BLOCKOBJECT holds.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: body (<span class="op">in</span> <span class="type">reference</span>: funcRef)                       <span class="keywd">is</span> action <span class="stri">"REF_BODY"</span>;


<span class="comment">(**
 *  Obtain the minimum index of the array referenced by 'arrayRef'.
 *  @param arrayRef Reference to an array object.
 *  @return the minimum index of the array.
 *  @exception RANGE_ERROR If 'arrayRef' does not refer to an array.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: arrayMinIdx (<span class="op">in</span> <span class="type">reference</span>: arrayRef)                 <span class="keywd">is</span> action <span class="stri">"REF_ARRMINIDX"</span>;


<span class="comment">(**
 *  Obtain the maximum index of the array referenced by 'arrayRef'.
 *  @param arrayRef Reference to an array object.
 *  @return the maximum index of the array.
 *  @exception RANGE_ERROR If 'arrayRef' does not refer to an array.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: arrayMaxIdx (<span class="op">in</span> <span class="type">reference</span>: arrayRef)                 <span class="keywd">is</span> action <span class="stri">"REF_ARRMAXIDX"</span>;


<span class="comment">(**
 *  Obtain the length of the array referenced by 'arrayRef'.
 *  @param arrayRef Reference to an array object.
 *  @return the length of the array.
 *  @exception RANGE_ERROR If 'arrayRef' does not refer to an array.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: arrayLength (<span class="op">in</span> <span class="type">reference</span>: arrayRef) <span class="keywd">is</span>
    <span class="keywd">return</span> succ(arrayMaxIdx(arrayRef) - arrayMinIdx(arrayRef));


<span class="keywd">const</span> <span class="type">func</span> <span class="type">ref_list</span>: arrayToList (<span class="op">in</span> <span class="type">reference</span>: arrayRef)                <span class="keywd">is</span> action <span class="stri">"REF_ARRTOLIST"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">ref_list</span>: structToList (<span class="op">in</span> <span class="type">reference</span>: structRef)              <span class="keywd">is</span> action <span class="stri">"REF_SCTTOLIST"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">ref_list</span>: hashDataToList (<span class="op">in</span> <span class="type">reference</span>: hashRef)              <span class="keywd">is</span> action <span class="stri">"REF_HSHDATATOLIST"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">ref_list</span>: hashKeysToList (<span class="op">in</span> <span class="type">reference</span>: hashRef)              <span class="keywd">is</span> action <span class="stri">"REF_HSHKEYSTOLIST"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: hashLength (<span class="op">in</span> <span class="type">reference</span>: hashRef)                   <span class="keywd">is</span> action <span class="stri">"REF_HSHLENGTH"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: interfaceToStruct (<span class="op">in</span> <span class="type">reference</span>: interfaceRef)     <span class="keywd">is</span> action <span class="stri">"REF_ITFTOSCT"</span>;


<span class="comment">(**
 *  Determine the file name of a referenced object.
 *  @return the file name of the referenced object.
 *  @exception RANGE_ERROR If ''aReference'' is NIL.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: file (<span class="op">in</span> <span class="type">reference</span>: aReference)                     <span class="keywd">is</span> action <span class="stri">"REF_FILE"</span>;


<span class="comment">(**
 *  Determine the absolute file path of a referenced object.
 *  @return the absolute file path of the referenced object.
 *  @exception RANGE_ERROR If ''aReference'' is NIL.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: path (<span class="op">in</span> <span class="type">reference</span>: aReference)                     <span class="keywd">is</span> action <span class="stri">"REF_PATH"</span>;


<span class="comment">(**
 *  Determine the line number of a referenced object.
 *  @return the line number of the referenced object.
 *  @exception RANGE_ERROR If ''aReference'' is NIL.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: line (<span class="op">in</span> <span class="type">reference</span>: aReference)                    <span class="keywd">is</span> action <span class="stri">"REF_LINE"</span>;


<span class="comment">(**
 *  Delivers an unique number for each object
 *  @return a unique object number.
 *  @exception RANGE_ERROR The type has no owning program or number map.
 *  @exception MEMORY_ERROR Not enough memory to maintain the object table.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: objNumber (<span class="op">in</span> <span class="type">reference</span>: aReference)               <span class="keywd">is</span> action <span class="stri">"REF_NUM"</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: alloc (<span class="op">in</span> <span class="type">reference</span>: aReference)                 <span class="keywd">is</span> action <span class="stri">"REF_ALLOC"</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: alloc (<span class="op">in</span> <span class="type">boolean</span>: isVar, <span class="op">in</span> <span class="type">type</span>: aType, <span class="op">in</span> <span class="type">integer</span>: number) <span class="keywd">is</span> action <span class="stri">"REF_ALLOC_INT"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: alloc (<span class="op">in</span> <span class="type">boolean</span>: isVar, <span class="op">in</span> <span class="type">type</span>: aType, <span class="op">in</span> <span class="type">string</span>: stri)    <span class="keywd">is</span> action <span class="stri">"REF_ALLOC_STRI"</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: allocVar (<span class="op">in</span> <span class="type">type</span>: aType, <span class="op">in</span> category: aCategory)      <span class="keywd">is</span> action <span class="stri">"REF_ALLOC_VAR"</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: getValue (<span class="op">in</span> <span class="type">reference</span>: aReference, attr boolean)        <span class="keywd">is</span> action <span class="stri">"BLN_VALUE"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getValue (<span class="op">in</span> <span class="type">reference</span>: aReference, attr integer)        <span class="keywd">is</span> action <span class="stri">"INT_VALUE"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">char</span>: getValue (<span class="op">in</span> <span class="type">reference</span>: aReference, attr char)              <span class="keywd">is</span> action <span class="stri">"CHR_VALUE"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getValue (<span class="op">in</span> <span class="type">reference</span>: aReference, attr string)          <span class="keywd">is</span> action <span class="stri">"STR_VALUE"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bstring</span>: getValue (<span class="op">in</span> <span class="type">reference</span>: aReference, attr bstring)        <span class="keywd">is</span> action <span class="stri">"BST_VALUE"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bitset</span>: getValue (<span class="op">in</span> <span class="type">reference</span>: aReference, attr bitset)          <span class="keywd">is</span> action <span class="stri">"SET_VALUE"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">pollData</span>: getValue (<span class="op">in</span> <span class="type">reference</span>: aReference, attr pollData)      <span class="keywd">is</span> action <span class="stri">"POL_VALUE"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">program</span>: getValue (<span class="op">in</span> <span class="type">reference</span>: aReference, attr program)        <span class="keywd">is</span> action <span class="stri">"PRG_VALUE"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">ACTION</span>: getValue (<span class="op">in</span> <span class="type">reference</span>: aReference, attr ACTION)          <span class="keywd">is</span> action <span class="stri">"ACT_VALUE"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">clib_file</span>: getValue (<span class="op">in</span> <span class="type">reference</span>: aReference, attr clib_file)    <span class="keywd">is</span> action <span class="stri">"FIL_VALUE"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">ref_list</span>: getValue (<span class="op">in</span> <span class="type">reference</span>: aReference, attr ref_list)      <span class="keywd">is</span> action <span class="stri">"RFL_VALUE"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: getValue (<span class="op">in</span> <span class="type">reference</span>: aReference, attr bigInteger)  <span class="keywd">is</span> action <span class="stri">"BIG_VALUE"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: getValue (<span class="op">in</span> <span class="type">reference</span>: aReference, attr float)            <span class="keywd">is</span> action <span class="stri">"FLT_VALUE"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: getValue (<span class="op">in</span> <span class="type">reference</span>: aReference, attr reference)    <span class="keywd">is</span> action <span class="stri">"REF_VALUE"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">PRIMITIVE_WINDOW</span>: getValue (<span class="op">in</span> <span class="type">reference</span>: aReference,
                                       attr PRIMITIVE_WINDOW)                <span class="keywd">is</span> action <span class="stri">"DRW_VALUE"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">pointList</span>: getValue (<span class="op">in</span> <span class="type">reference</span>: aReference, attr pointList)    <span class="keywd">is</span> action <span class="stri">"PLT_VALUE"</span>;
<span class="keywd">const</span> <span class="type">func</span> process: getValue (<span class="op">in</span> <span class="type">reference</span>: aReference, attr process)        <span class="keywd">is</span> action <span class="stri">"PCS_VALUE"</span>;
<span class="comment"># const func type: getValue (in reference: aReference, attr type)            is action "TYP_VALUE";</span>

<span class="keywd">const</span> <span class="type">proc</span>: setValue(<span class="keywd">inout</span> <span class="type">reference</span>: listRef, <span class="op">in</span> <span class="type">ref_list</span>: list)      <span class="keywd">is</span> action <span class="stri">"RFL_SET_VALUE"</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: typeNumber  (<span class="op">in</span> <span class="type">type</span>: aType)                       <span class="keywd">is</span> action <span class="stri">"TYP_NUM"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: typeObject (<span class="op">in</span> <span class="type">type</span>: aType)                      <span class="keywd">is</span> action <span class="stri">"TYP_MATCHOBJ"</span>;
</pre>
</body>
</html>
