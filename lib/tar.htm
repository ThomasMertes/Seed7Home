<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  tar.s7i       Tar archive library                               *)</span>
<span class="comment">(*  Copyright (C) 1994, 2004, 2005, 2010, 2014  Thomas Mertes       *)</span>
<span class="comment">(*                2016 - 2024  Thomas Mertes                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/stdio.htm">stdio.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/time.htm">time.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/filesys.htm">filesys.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/unicode.htm">unicode.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/subfile.htm">subfile.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/iobuffer.htm">iobuffer.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/archive_base.htm">archive_base.s7i</a>"</span>;


<span class="keywd">const</span> <span class="type">string</span>: TAR_MAGIC <span class="keywd">is</span> <span class="stri">"ustar"</span>;
<span class="keywd">const</span> <span class="type">string</span>: TAR_NOMAGIC <span class="keywd">is</span> <span class="stri">""</span>;

<span class="keywd">const</span> <span class="type">integer</span>: TAR_BLOCK_SIZE <span class="keywd">is</span> 512;

<span class="keywd">const</span> <span class="type">char</span>: REGTYPE         <span class="keywd">is</span> <span class="stri">'0'</span>;   <span class="comment"># Regular file (preferred code)</span>
<span class="keywd">const</span> <span class="type">char</span>: AREGTYPE        <span class="keywd">is</span> <span class="stri">'\0;'</span>; <span class="comment"># Regular file (alternate code)</span>
<span class="keywd">const</span> <span class="type">char</span>: LNKTYPE         <span class="keywd">is</span> <span class="stri">'1'</span>;   <span class="comment"># Hard link.</span>
<span class="keywd">const</span> <span class="type">char</span>: SYMTYPE         <span class="keywd">is</span> <span class="stri">'2'</span>;   <span class="comment"># Symbolic link</span>
<span class="keywd">const</span> <span class="type">char</span>: CHRTYPE         <span class="keywd">is</span> <span class="stri">'3'</span>;   <span class="comment"># Character special</span>
<span class="keywd">const</span> <span class="type">char</span>: BLKTYPE         <span class="keywd">is</span> <span class="stri">'4'</span>;   <span class="comment"># Block special</span>
<span class="keywd">const</span> <span class="type">char</span>: DIRTYPE         <span class="keywd">is</span> <span class="stri">'5'</span>;   <span class="comment"># Directory</span>
<span class="keywd">const</span> <span class="type">char</span>: FIFOTYPE        <span class="keywd">is</span> <span class="stri">'6'</span>;   <span class="comment"># Named pipe</span>
<span class="keywd">const</span> <span class="type">char</span>: CONTTYPE        <span class="keywd">is</span> <span class="stri">'7'</span>;   <span class="comment"># Contiguous file</span>
<span class="keywd">const</span> <span class="type">char</span>: LONGNAMETYPE    <span class="keywd">is</span> <span class="stri">'L'</span>;   <span class="comment"># Long (untruncated) filename of the next file.</span>
<span class="keywd">const</span> <span class="type">char</span>: LONGLINKTYPE    <span class="keywd">is</span> <span class="stri">'K'</span>;   <span class="comment"># Long link destination of a previous header.</span>
<span class="keywd">const</span> <span class="type">char</span>: GLOBAL_HEADER   <span class="keywd">is</span> <span class="stri">'g'</span>;   <span class="comment"># Global extended header with meta data</span>
<span class="keywd">const</span> <span class="type">char</span>: EXTENDED_HEADER <span class="keywd">is</span> <span class="stri">'x'</span>;   <span class="comment"># Meta data for the next file in the archive.</span>


<span class="keywd">const</span> <span class="type">type</span>: tarHeader <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">string</span>: name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: mode <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: uid <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: gid <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: fileSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: mtime <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: chksum <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">char</span>: typeflag <span class="keywd">is</span> REGTYPE;
    <span class="keywd">var</span> <span class="type">string</span>: linkname <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: magic <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: version <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: uname <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: gname <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: devmajor <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: devminor <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: prefix <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: chksumOkay <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">string</span>: filePath <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: filePathSuffix <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: linkPath <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: dataStartPos <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showHeader (<span class="keywd">inout</span> <span class="type">file</span>: outFile, <span class="op">in</span> <span class="type">tarHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(outFile, <span class="stri">"name: "</span> &lt;&amp; header.name);
    writeln(outFile, <span class="stri">"mode: "</span> &lt;&amp; header.mode radix 8);
    writeln(outFile, <span class="stri">"uid: "</span> &lt;&amp; header.uid);
    writeln(outFile, <span class="stri">"gid: "</span> &lt;&amp; header.gid);
    writeln(outFile, <span class="stri">"fileSize: "</span> &lt;&amp; header.fileSize);
    writeln(outFile, <span class="stri">"mtime: "</span> &lt;&amp; header.mtime);
    writeln(outFile, <span class="stri">"chksum: "</span> &lt;&amp; header.chksum);
    writeln(outFile, <span class="stri">"typeflag: "</span> &lt;&amp; literal(header.typeflag));
    writeln(outFile, <span class="stri">"linkname: "</span> &lt;&amp; header.linkname);
    writeln(outFile, <span class="stri">"magic: "</span> &lt;&amp; literal(header.magic));
    writeln(outFile, <span class="stri">"version: "</span> &lt;&amp; literal(header.version));
    writeln(outFile, <span class="stri">"uname: "</span> &lt;&amp; header.uname);
    writeln(outFile, <span class="stri">"gname: "</span> &lt;&amp; header.gname);
    writeln(outFile, <span class="stri">"devmajor: "</span> &lt;&amp; header.devmajor);
    writeln(outFile, <span class="stri">"devminor: "</span> &lt;&amp; header.devminor);
    writeln(outFile, <span class="stri">"prefix: "</span> &lt;&amp; header.prefix);
    writeln(outFile, <span class="stri">"chksumOkay: "</span> &lt;&amp; header.chksumOkay);
    writeln(outFile, <span class="stri">"filePath: "</span> &lt;&amp; header.filePath);
    writeln(outFile, <span class="stri">"filePathSuffix: "</span> &lt;&amp; header.filePathSuffix);
    writeln(outFile, <span class="stri">"linkPath: "</span> &lt;&amp; header.linkPath);
    writeln(outFile, <span class="stri">"dataStartPos: "</span> &lt;&amp; header.dataStartPos);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: gets0 (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: data <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: zeroBytePos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    zeroBytePos := pos(stri, <span class="stri">"\0;"</span>);
    <span class="keywd">if</span> zeroBytePos &lt;> 0 <span class="keywd">then</span>
      data := stri[ .. pred(zeroBytePos)];
    <span class="keywd">else</span>
      data := stri;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: gets0Spc (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: data <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: zeroBytePos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: spacePos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    zeroBytePos := pos(stri, <span class="stri">"\0;"</span>);
    <span class="keywd">if</span> zeroBytePos &lt;> 0 <span class="keywd">then</span>
      data := stri[ .. pred(zeroBytePos)];
    <span class="keywd">else</span>
      data := stri;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    spacePos := pos(data, <span class="stri">" "</span>);
    <span class="keywd">if</span> spacePos &lt;> 0 <span class="keywd">then</span>
      data := data[ .. pred(spacePos)];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getOct (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: start <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> start &lt;= length(stri) <span class="op">and</span> stri[start] = <span class="stri">' '</span> <span class="keywd">do</span>
      incr(start);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    pos := start;
    <span class="keywd">while</span> pos &lt;= length(stri) <span class="op">and</span> stri[pos] >= <span class="stri">'0'</span> <span class="op">and</span> stri[pos] &lt;= <span class="stri">'7'</span> <span class="keywd">do</span>
      incr(pos);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> pos > start <span class="keywd">then</span>
      number := integer(stri[start .. pred(pos)], 8);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getMetaData (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">integer</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: metaData <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: subPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    subPos := pos;
    <span class="keywd">while</span> subPos &lt;= length(stri) <span class="op">and</span> stri[subPos] >= <span class="stri">'0'</span> <span class="op">and</span> stri[subPos] &lt;= <span class="stri">'9'</span> <span class="keywd">do</span>
      incr(subPos);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> subPos > 1 <span class="op">and</span> stri[subPos] = <span class="stri">' '</span> <span class="keywd">then</span>
      length := integer(stri[pos .. pred(subPos)]);
      metaData := stri[succ(subPos) .. pos + length - 2];
      pos +:= length;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: puts0 (<span class="keywd">inout</span> <span class="type">string</span>: out_stri, <span class="op">in</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="type">integer</span>: length) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    out_stri &amp;:= stri[ .. length];
    <span class="keywd">if</span> length(stri) &lt; length <span class="keywd">then</span>
      out_stri &amp;:= <span class="stri">"\0;"</span> <span class="op">mult</span> length - length(stri);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: putSpc (<span class="keywd">inout</span> <span class="type">string</span>: out_stri, <span class="op">in</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="type">integer</span>: length) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    out_stri &amp;:= stri[ .. length] <span class="op">rpad</span> length;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: putOct (<span class="keywd">inout</span> <span class="type">string</span>: out_stri, <span class="op">in</span> <span class="type">integer</span>: number, <span class="op">in</span> <span class="type">integer</span>: length) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    out_stri &amp;:= number radix 8 <span class="op">lpad0</span> pred(length) &lt;&amp; <span class="stri">"\0;"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: tarChksum (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: checkSum <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> ch <span class="keywd">range</span> stri <span class="keywd">do</span>
      checkSum +:= ord(ch);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    checkSum := checkSum <span class="op">mod</span> 2 ** 16;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">tarHeader</span>: tarHeader (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">begin</span>
    header.name :=        gets0(stri[  1 fixLen 100]);
    header.mode :=       getOct(stri[101 fixLen   8]);
    header.uid :=        getOct(stri[109 fixLen   8]);
    header.gid :=        getOct(stri[117 fixLen   8]);
    header.fileSize :=   getOct(stri[125 fixLen  12]);
    header.mtime :=      getOct(stri[137 fixLen  12]);
    header.chksum :=     getOct(stri[149 fixLen   8]);
    header.typeflag :=          stri[157];     <span class="comment">(* 1*)</span>
    header.linkname :=    gets0(stri[158 fixLen 100]);
    header.magic :=    gets0Spc(stri[258 fixLen   6]);
    header.version :=           stri[264 fixLen   2];
    header.uname :=       gets0(stri[266 fixLen  32]);
    header.gname :=       gets0(stri[298 fixLen  32]);
    header.devmajor :=   getOct(stri[330 fixLen   8]);
    header.devminor :=   getOct(stri[338 fixLen   8]);
    header.prefix :=      gets0(stri[346 fixLen 155]);
    <span class="comment"># Unused                                     12</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">tarHeader</span>: readHeadBlock (<span class="keywd">inout</span> <span class="type">file</span>: inFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := gets(inFile, TAR_BLOCK_SIZE);
    <span class="keywd">if</span> length(stri) = TAR_BLOCK_SIZE <span class="keywd">then</span>
      header := tarHeader(stri);
      <span class="comment"># The checksum is computed with an empty chksum field:</span>
      header.chksumOkay :=
          tarChksum(stri[ .. 148] &amp; (<span class="stri">""</span> <span class="op">lpad</span> 8) &amp; stri[157 .. ]) = header.chksum;
      <span class="comment"># showHeader(STD_OUT, header);</span>
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readHead (<span class="keywd">inout</span> <span class="type">file</span>: inFile, <span class="keywd">inout</span> <span class="type">tarHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: filePath8 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: linkPath8 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: extendedHeaderData <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">string</span>: metaData <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    header := readHeadBlock(inFile);
    <span class="comment"># showHeader(STD_OUT, header);</span>
    <span class="keywd">while</span> header.magic = TAR_MAGIC <span class="op">and</span>
        (((header.typeflag = LONGNAMETYPE <span class="op">or</span> header.typeflag = LONGLINKTYPE) <span class="op">and</span>
           header.name = <span class="stri">"././@LongLink"</span>) <span class="op">or</span>
         header.typeflag = EXTENDED_HEADER <span class="op">or</span> header.typeflag = GLOBAL_HEADER) <span class="keywd">do</span>
      <span class="keywd">if</span> header.typeflag = LONGNAMETYPE <span class="keywd">then</span>
        filePath8 := gets(inFile, header.fileSize);
      <span class="keywd">elsif</span> header.typeflag = LONGLINKTYPE <span class="keywd">then</span>
        linkPath8 := gets(inFile, header.fileSize);
      <span class="keywd">elsif</span> header.typeflag = EXTENDED_HEADER <span class="keywd">then</span>
        extendedHeaderData := gets(inFile, header.fileSize);
        pos := 1;
        <span class="keywd">while</span> pos &lt;= length(extendedHeaderData) <span class="keywd">do</span>
          metaData := getMetaData(extendedHeaderData, pos);
          <span class="comment"># writeln("metaData: " &lt;&amp; metaData);</span>
          <span class="keywd">if</span> startsWith(metaData, <span class="stri">"path="</span>) <span class="keywd">then</span>
            filePath8 := metaData[6 ..];
          <span class="keywd">elsif</span> startsWith(metaData, <span class="stri">"linkpath="</span>) <span class="keywd">then</span>
            linkPath8 := metaData[10 ..];
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">else</span> <span class="comment"># header.typeflag = GLOBAL_HEADER</span>
        ignore(gets(inFile, header.fileSize));
      <span class="keywd">end</span> <span class="keywd">if</span>;
      seek(inFile, tell(inFile) + pred(TAR_BLOCK_SIZE) -
           pred(header.fileSize) <span class="op">mod</span> TAR_BLOCK_SIZE);
      header := readHeadBlock(inFile);
      <span class="comment"># showHeader(STD_OUT, header);</span>
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> filePath8 = <span class="stri">""</span> <span class="keywd">then</span>
      <span class="keywd">if</span> header.prefix &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        filePath8 := header.prefix &amp; <span class="stri">"/"</span> &amp; header.name;
      <span class="keywd">else</span>
        filePath8 := header.name;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">block</span>
      header.filePath := fromUtf8(filePath8);
    exception
      catch RANGE_ERROR:
        header.filePath := filePath8;
    <span class="keywd">end</span> <span class="keywd">block</span>;
    <span class="keywd">if</span> linkPath8 = <span class="stri">""</span> <span class="keywd">then</span>
      linkPath8 := header.linkname;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">block</span>
      header.linkPath := fromUtf8(linkPath8);
    exception
      catch RANGE_ERROR:
        header.linkPath := linkPath8;
    <span class="keywd">end</span> <span class="keywd">block</span>;
    <span class="keywd">if</span> endsWith(header.filePath, <span class="stri">"/"</span>) <span class="op">and</span> header.filePath &lt;> <span class="stri">"/"</span> <span class="keywd">then</span>
      header.filePath := header.filePath[.. pred(length(header.filePath))];
      header.filePathSuffix := <span class="stri">"/"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> endsWith(header.linkPath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      header.linkPath := header.linkPath[.. pred(length(header.linkPath))];
    <span class="keywd">end</span> <span class="keywd">if</span>;
    header.dataStartPos := tell(inFile);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">tarHeader</span>: readMinimumOfHeadBlock (<span class="keywd">inout</span> <span class="type">file</span>: inFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := gets(inFile, TAR_BLOCK_SIZE);
    <span class="keywd">if</span> length(stri) = TAR_BLOCK_SIZE <span class="keywd">then</span>
      header.name :=         gets0(stri[  1 fixLen 100]);
      header.fileSize :=    getOct(stri[125 fixLen  12]);
      header.typeflag :=           stri[157];     <span class="comment">(* 1*)</span>
      header.magic :=     gets0Spc(stri[258 fixLen   6]);
      header.prefix :=       gets0(stri[346 fixLen 155]);
      <span class="comment"># writeln("header.name: " &lt;&amp; header.name);</span>
      <span class="comment"># showHeader(STD_OUT, header);</span>
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readMinimumOfHead (<span class="keywd">inout</span> <span class="type">file</span>: inFile, <span class="keywd">inout</span> <span class="type">tarHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: filePath8 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: extendedHeaderData <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">string</span>: metaData <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    header := readMinimumOfHeadBlock(inFile);
    <span class="comment"># showHeader(STD_OUT, header);</span>
    <span class="keywd">while</span> header.magic = TAR_MAGIC <span class="op">and</span>
        (((header.typeflag = LONGNAMETYPE <span class="op">or</span> header.typeflag = LONGLINKTYPE) <span class="op">and</span>
           header.name = <span class="stri">"././@LongLink"</span>) <span class="op">or</span>
         header.typeflag = EXTENDED_HEADER <span class="op">or</span> header.typeflag = GLOBAL_HEADER) <span class="keywd">do</span>
      <span class="keywd">if</span> header.typeflag = LONGNAMETYPE <span class="keywd">then</span>
        filePath8 := gets(inFile, header.fileSize);
        seek(inFile, tell(inFile) + pred(TAR_BLOCK_SIZE) - pred(header.fileSize) <span class="op">mod</span> TAR_BLOCK_SIZE);
      <span class="keywd">elsif</span> header.typeflag = EXTENDED_HEADER <span class="keywd">then</span>
        extendedHeaderData := gets(inFile, header.fileSize);
        pos := 1;
        <span class="keywd">while</span> pos &lt;= length(extendedHeaderData) <span class="keywd">do</span>
          metaData := getMetaData(extendedHeaderData, pos);
          <span class="comment"># writeln("metaData: " &lt;&amp; metaData);</span>
          <span class="keywd">if</span> startsWith(metaData, <span class="stri">"path="</span>) <span class="keywd">then</span>
            filePath8 := metaData[6 ..];
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">while</span>;
        seek(inFile, tell(inFile) + pred(TAR_BLOCK_SIZE) - pred(header.fileSize) <span class="op">mod</span> TAR_BLOCK_SIZE);
      <span class="keywd">else</span>  <span class="comment"># header.typeflag = LONGLINKTYPE or</span>
            <span class="comment"># header.typeflag = GLOBAL_HEADER</span>
        seek(inFile, succ(succ((tell(inFile) + header.fileSize - 2) <span class="op">mdiv</span>
                     TAR_BLOCK_SIZE) * TAR_BLOCK_SIZE));
      <span class="keywd">end</span> <span class="keywd">if</span>;
      header := readMinimumOfHeadBlock(inFile);
      <span class="comment"># showHeader(STD_OUT, header);</span>
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> filePath8 = <span class="stri">""</span> <span class="keywd">then</span>
      <span class="keywd">if</span> header.prefix &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        filePath8 := header.prefix &amp; <span class="stri">"/"</span> &amp; header.name;
      <span class="keywd">else</span>
        filePath8 := header.name;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">block</span>
      header.filePath := fromUtf8(filePath8);
    exception
      catch RANGE_ERROR:
        header.filePath := filePath8;
    <span class="keywd">end</span> <span class="keywd">block</span>;
    <span class="keywd">if</span> endsWith(header.filePath, <span class="stri">"/"</span>) <span class="op">and</span> header.filePath &lt;> <span class="stri">"/"</span> <span class="keywd">then</span>
      header.filePath := header.filePath[.. pred(length(header.filePath))];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">tarHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: chksum <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    puts0  (stri, header.name,               100);
    putOct (stri, header.mode,                 8);
    putOct (stri, header.uid,                  8);
    putOct (stri, header.gid,                  8);
    putOct (stri, header.fileSize,            12);
    putOct (stri, header.mtime,               12);
    putSpc (stri, <span class="stri">""</span>,                          8);
    stri &amp;:=      header.typeflag;          <span class="comment">(* 1*)</span>
    puts0  (stri, header.linkname,           100);
    puts0  (stri, header.magic,                6);
    putSpc (stri, header.version,              2);
    puts0  (stri, header.uname,               32);
    puts0  (stri, header.gname,               32);
    putOct (stri, header.devmajor,             8);
    putOct (stri, header.devminor,             8);
    puts0  (stri, header.prefix,             155);
    puts0  (stri, <span class="stri">""</span>,                         12);
    <span class="comment"># The checksum is computed with an empty chksum field:</span>
    putOct (chksum, tarChksum(stri), 8);
    <span class="comment"># The computed checksum is inserted:</span>
    stri := stri[ .. 148] &amp; chksum &amp; stri[157 .. ];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: writeHead (<span class="keywd">inout</span> <span class="type">file</span>: outFile, <span class="op">in</span> <span class="keywd">var</span> <span class="type">tarHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: filePath8 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: linkPath8 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">tarHeader</span>: longNameHead <span class="keywd">is</span> tarHeader.value;
    <span class="keywd">var</span> <span class="type">integer</span>: startPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: slashPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    filePath8 := toUtf8(header.filePath);
    <span class="keywd">if</span> filePath8 &amp; header.filePathSuffix &lt;> header.prefix &amp; <span class="stri">"/"</span> &amp; header.name <span class="keywd">then</span>
      <span class="keywd">if</span> length(filePath8) + length(header.filePathSuffix) > 100 <span class="keywd">then</span>
        <span class="keywd">if</span> length(filePath8) + length(header.filePathSuffix) &lt;= 256 <span class="keywd">then</span>
          startPos := max(2, length(filePath8) + length(header.filePathSuffix) - 100);
          slashPos := pos(filePath8, <span class="stri">"/"</span>, startPos);
          <span class="keywd">if</span> slashPos &lt;> 0 <span class="keywd">then</span>
            <span class="keywd">if</span> slashPos &lt;= 156 <span class="keywd">then</span>  <span class="comment"># Maximum prefix length is 155.</span>
              header.name := filePath8[succ(slashPos) ..] &amp; header.filePathSuffix;
              header.prefix := filePath8[.. pred(slashPos)];
            <span class="keywd">else</span>
              slashPos := 0;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> slashPos = 0 <span class="keywd">then</span>
          longNameHead.name     := <span class="stri">"././@LongLink"</span>;
          longNameHead.mode     := 0;
          longNameHead.uid      := 0;
          longNameHead.gid      := 0;
          longNameHead.fileSize := length(filePath8) + length(header.filePathSuffix);
          longNameHead.mtime    := 0;
          longNameHead.typeflag := LONGNAMETYPE;
          longNameHead.linkname := <span class="stri">""</span>;
          longNameHead.magic    := TAR_MAGIC;
          longNameHead.version  := <span class="stri">"  "</span>;
          longNameHead.uname    := <span class="stri">"root"</span>;
          longNameHead.gname    := <span class="stri">"root"</span>;
          longNameHead.devmajor := 0;
          longNameHead.devminor := 0;
          longNameHead.prefix   := <span class="stri">""</span>;
          write(outFile, str(longNameHead));
          write(outFile, filePath8);
          write(outFile, header.filePathSuffix);
          write(outFile, <span class="stri">"\0;"</span> <span class="op">mult</span> pred(TAR_BLOCK_SIZE) - pred(longNameHead.fileSize) <span class="op">mod</span> TAR_BLOCK_SIZE);
          header.name := (filePath8 &amp; header.filePathSuffix)[.. 100];
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        header.name := filePath8 &amp; header.filePathSuffix;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    linkPath8 := toUtf8(header.linkPath);
    <span class="keywd">if</span> length(filePath8) > 100 <span class="keywd">then</span>
      longNameHead.name     := <span class="stri">"././@LongLink"</span>;
      longNameHead.mode     := 0;
      longNameHead.uid      := 0;
      longNameHead.gid      := 0;
      longNameHead.fileSize := length(linkPath8);
      longNameHead.mtime    := 0;
      longNameHead.typeflag := LONGLINKTYPE;
      longNameHead.linkname := <span class="stri">""</span>;
      longNameHead.magic    := TAR_MAGIC;
      longNameHead.version  := <span class="stri">"  "</span>;
      longNameHead.uname    := <span class="stri">"root"</span>;
      longNameHead.gname    := <span class="stri">"root"</span>;
      longNameHead.devmajor := 0;
      longNameHead.devminor := 0;
      longNameHead.prefix   := <span class="stri">""</span>;
      write(outFile, str(longNameHead));
      write(outFile, linkPath8);
      write(outFile, <span class="stri">"\0;"</span> <span class="op">mult</span> pred(TAR_BLOCK_SIZE) - pred(longNameHead.fileSize) <span class="op">mod</span> TAR_BLOCK_SIZE);
    <span class="keywd">else</span>
      header.linkname := linkPath8;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    write(outFile, str(header));
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: tarCatalogType <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">string</span><span class="type">]</span> <span class="type">tarHeader</span>;


<span class="comment">(**
 *  [[filesys#fileSys|FileSys]] implementation type to access a TAR archive.
 *  File paths in a TAR archive can be absolute (they start with a slash)
 *  or relative (they do not start with a slash). The tar file system does
 *  not support the concept of a current working directory. The functions
 *  chdir and getcwd are not supported by the tar file system. Absolute
 *  and relative paths in a TAR archive can be accessed directly.
 *  Since "/" is just a normal path in a TAR archive the root path of a
 *  tar file system is "". Possible usages of tar file system functions are:
 *    getMTime(aTarFile, "src/drivers")   # Relative path in the archive.
 *    fileType(aTarFile, "/usr/include")  # Absolute path in the archive.
 *    fileSize(aTarFile, "/image")        # Absolute path in the archive.
 *    readDir(aTarFile, "")               # Return e.g.: "src" and "/"
 *    readDir(aTarFile, "/")              # Return e.g.: "usr" and "image"
 *)</span>
<span class="keywd">const</span> <span class="type">type</span>: tarArchive <span class="keywd">is</span> <span class="keywd">sub</span> emptyFileSys <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">file</span>: tarFile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> archiveRegisterType: register <span class="keywd">is</span> archiveRegisterType.value;
    <span class="keywd">var</span> <span class="type">tarCatalogType</span>: catalog <span class="keywd">is</span> tarCatalogType.value;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="comment">(**
 *  Open a TAR archive with the given tarFile.
 *  @param tarFile File that contains a TAR archive.
 *  @return a file system that accesses the TAR archive, or
 *          fileSys.value if it could not be opened.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">fileSys</span>: openTar (<span class="keywd">inout</span> <span class="type">file</span>: tarFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fileSys</span>: newFileSys <span class="keywd">is</span> fileSys.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
    <span class="keywd">var</span> <span class="type">integer</span>: headPos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">tarArchive</span>: tar <span class="keywd">is</span> tarArchive.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(tarFile) = 0 <span class="keywd">then</span>
      tar.tarFile := tarFile;
      newFileSys := toInterface(tar);
    <span class="keywd">else</span>
      seek(tarFile, headPos);
      readHead(tarFile, header);
      <span class="keywd">if</span> header.chksumOkay <span class="op">and</span> header.filePath &lt;> <span class="stri">""</span> <span class="op">and</span>
          (header.magic = TAR_MAGIC <span class="op">or</span> header.magic = TAR_NOMAGIC) <span class="keywd">then</span>
        tar.tarFile := tarFile;
        <span class="keywd">repeat</span>
          <span class="comment"># writeln(header.filePath &lt;&amp; " " &lt;&amp; headPos);</span>
          tar.register @:= [header.filePath] headPos;
          <span class="keywd">if</span> header.fileSize = 0 <span class="keywd">then</span>
            headPos := tell(tarFile);
          <span class="keywd">else</span>
            headPos := tell(tarFile) +
                succ(pred(header.fileSize) <span class="op">mdiv</span> TAR_BLOCK_SIZE) * TAR_BLOCK_SIZE;
            seek(tarFile, headPos);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          readMinimumOfHead(tarFile, header);
        <span class="keywd">until</span> header.filePath = <span class="stri">""</span> <span class="op">or</span>
              (header.magic &lt;> TAR_MAGIC <span class="op">and</span> header.magic &lt;> TAR_NOMAGIC);
        newFileSys := toInterface(tar);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Open a TAR archive with the given tarFileName.
 *  @param tarFileName Name of the TAR archive to be opened.
 *  @return a file system that accesses the TAR archive, or
 *          fileSys.value if it could not be opened.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">fileSys</span>: openTar (<span class="op">in</span> <span class="type">string</span>: tarFileName) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fileSys</span>: tar <span class="keywd">is</span> fileSys.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">file</span>: tarFile <span class="keywd">is</span> STD_NULL;
  <span class="keywd">begin</span>
    tarFile := open(tarFileName, <span class="stri">"r"</span>);
    tar := openTar(tarFile);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Close a TAR archive. The TAR file below stays open.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: close (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="comment"># close(tar.tarFile);</span>
    tar.tarFile := STD_NULL;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">tarHeader</span>: addToCatalog (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">begin</span>
    seek(tar.tarFile, tar.register[filePath]);
    readHead(tar.tarFile, header);
    tar.catalog @:= [filePath] header;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: implicitDir (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: dirPath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: implicitDir <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: filePath <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> dirPath &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      <span class="keywd">for</span> <span class="keywd">key</span> filePath <span class="keywd">range</span> tar.register <span class="keywd">do</span>
        <span class="keywd">if</span> startsWith(filePath, dirPath) <span class="op">and</span>
            length(filePath) > length(dirPath) <span class="op">and</span>
            (filePath[succ(length(dirPath))] = <span class="stri">'/'</span> <span class="op">or</span> dirPath = <span class="stri">"/"</span>) <span class="keywd">then</span>
          implicitDir := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">tarHeader</span>: addImplicitDir (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar,
    <span class="op">in</span> <span class="type">string</span>: dirPath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">begin</span>
    header.filePath := dirPath;
    <span class="keywd">if</span> dirPath &lt;> <span class="stri">"/"</span> <span class="keywd">then</span>
      header.filePathSuffix := <span class="stri">"/"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    header.typeflag := DIRTYPE;
    header.dataStartPos := -1;
    tar.catalog @:= [dirPath] header;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: followSymlink (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: filePath,
    <span class="keywd">inout</span> <span class="type">tarHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: missingPath <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: symlinkCount <span class="keywd">is</span> MAX_SYMLINKS;
    <span class="keywd">var</span> <span class="type">boolean</span>: isSymlink <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("followSymlink: " &lt;&amp; filePath);</span>
    <span class="keywd">repeat</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> tar.catalog <span class="keywd">then</span>
        header := tar.catalog[filePath];
      <span class="keywd">elsif</span> filePath <span class="op">in</span> tar.register <span class="keywd">then</span>
        header := addToCatalog(tar, filePath);
      <span class="keywd">elsif</span> implicitDir(tar, filePath) <span class="keywd">then</span>
        header := addImplicitDir(tar, filePath);
      <span class="keywd">else</span>
        <span class="comment"># The file does not exist.</span>
        missingPath := filePath;
        isSymlink := FALSE;
        <span class="comment"># writeln("missing: " &lt;&amp; missingPath);</span>
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> missingPath = <span class="stri">""</span> <span class="keywd">then</span>
        <span class="keywd">if</span> header.typeflag = SYMTYPE <span class="keywd">then</span>
          decr(symlinkCount);
          filePath := symlinkDestination(filePath, header.linkPath);
          <span class="keywd">if</span> startsWith(filePath, <span class="stri">"/"</span>) <span class="op">and</span>
              filePath <span class="op">not</span> <span class="op">in</span> tar.catalog <span class="op">and</span> filePath <span class="op">not</span> <span class="op">in</span> tar.register <span class="keywd">then</span>
            filePath := filePath[2 ..];
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          isSymlink := FALSE;
          <span class="comment"># writeln("found: " &lt;&amp; header.filePath);</span>
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> <span class="op">not</span> isSymlink <span class="op">or</span> symlinkCount &lt; 0;
    <span class="keywd">if</span> isSymlink <span class="keywd">then</span>
      <span class="comment"># Too many symbolic links.</span>
      raise FILE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">tarHeader</span>: followSymlink (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: missingPath <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    missingPath := followSymlink(tar, filePath, header);
    <span class="keywd">if</span> missingPath &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      <span class="comment"># The file does not exist.</span>
      raise FILE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the file names in a directory inside a TAR archive.
 *  Note that the function returns only the file names.
 *  Additional information must be obtained with other calls.
 *  @param tar Open TAR archive.
 *  @param dirPath Path of a directory in the TAR archive.
 *  @return an array with the file names.
 *  @exception RANGE_ERROR ''dirPath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''dirPath'' is not present in the TAR archive.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: readDir (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: dirPath) <span class="keywd">is</span>
  <span class="keywd">return</span> readDir(tar.register, dirPath);


<span class="comment">(**
 *  Determine the file paths in a TAR archive.
 *  Note that the function returns only the file paths.
 *  Additional information must be obtained with other calls.
 *  @param tar Open TAR archive.
 *  @return an array with the file paths.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: readDir (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, RECURSIVE) <span class="keywd">is</span>
  <span class="keywd">return</span> sort(keys(tar.register));


<span class="comment">(**
 *  Determine the type of a file in a TAR archive.
 *  The function follows symbolic links. If the chain of
 *  symbolic links is too long the function returns ''FILE_SYMLINK''.
 *  A return value of ''FILE_ABSENT'' does not imply that a file
 *  with this name can be created, since missing directories and
 *  invalid file names cause also ''FILE_ABSENT''.
 *  @return the type of the file.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">fileType</span>: fileType (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fileType</span>: aFileType <span class="keywd">is</span> FILE_UNKNOWN;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
    <span class="keywd">var</span> <span class="type">integer</span>: symlinkCount <span class="keywd">is</span> MAX_SYMLINKS;
    <span class="keywd">var</span> <span class="type">boolean</span>: isSymlink <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("fileType: " &lt;&amp; filePath);</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath = <span class="stri">""</span> <span class="keywd">then</span>
      aFileType := FILE_DIR;
    <span class="keywd">else</span>
      <span class="keywd">repeat</span>
        isSymlink := FALSE;
        <span class="keywd">if</span> filePath <span class="op">in</span> tar.catalog <span class="keywd">then</span>
          header := tar.catalog[filePath];
        <span class="keywd">elsif</span> filePath <span class="op">in</span> tar.register <span class="keywd">then</span>
          header := addToCatalog(tar, filePath);
        <span class="keywd">elsif</span> implicitDir(tar, filePath) <span class="keywd">then</span>
          header := addImplicitDir(tar, filePath);
        <span class="keywd">else</span>
          aFileType := FILE_ABSENT;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> aFileType = FILE_UNKNOWN <span class="keywd">then</span>
          <span class="keywd">case</span> header.typeflag <span class="keywd">of</span>
            <span class="keywd">when</span> {REGTYPE}:  aFileType := FILE_REGULAR;
            <span class="keywd">when</span> {AREGTYPE}: aFileType := FILE_REGULAR;
            <span class="keywd">when</span> {CHRTYPE}:  aFileType := FILE_CHAR;
            <span class="keywd">when</span> {BLKTYPE}:  aFileType := FILE_BLOCK;
            <span class="keywd">when</span> {DIRTYPE}:  aFileType := FILE_DIR;
            <span class="keywd">when</span> {FIFOTYPE}: aFileType := FILE_FIFO;
            <span class="keywd">when</span> {CONTTYPE}: aFileType := FILE_UNKNOWN;
            <span class="keywd">when</span> {SYMTYPE}:
              isSymlink := TRUE;
              decr(symlinkCount);
              filePath := symlinkDestination(filePath, header.linkPath);
              <span class="keywd">if</span> startsWith(filePath, <span class="stri">"/"</span>) <span class="op">and</span>
                  filePath <span class="op">not</span> <span class="op">in</span> tar.catalog <span class="op">and</span> filePath <span class="op">not</span> <span class="op">in</span> tar.register <span class="keywd">then</span>
                filePath := filePath[2 ..];
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">otherwise</span>:       aFileType := FILE_UNKNOWN;
          <span class="keywd">end</span> <span class="keywd">case</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> <span class="op">not</span> isSymlink <span class="op">or</span> symlinkCount &lt; 0;
      <span class="keywd">if</span> isSymlink <span class="keywd">then</span>
        aFileType := FILE_SYMLINK;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the type of a file in a TAR archive.
 *  The function does not follow symbolic links. Therefore it may
 *  return ''FILE_SYMLINK''. A return value of ''FILE_ABSENT'' does
 *  not imply that a file with this name can be created, since missing
 *  directories and invalid file names cause also ''FILE_ABSENT''.
 *  @return the type of the file.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">fileType</span>: fileTypeSL (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fileType</span>: aFileType <span class="keywd">is</span> FILE_UNKNOWN;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: typeflag <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("fileTypeSL: " &lt;&amp; filePath);</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath = <span class="stri">""</span> <span class="keywd">then</span>
      aFileType := FILE_DIR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> tar.catalog <span class="keywd">then</span>
        typeflag := tar.catalog[filePath].typeflag;
      <span class="keywd">elsif</span> filePath <span class="op">in</span> tar.register <span class="keywd">then</span>
        typeflag := addToCatalog(tar, filePath).typeflag;
      <span class="keywd">elsif</span> implicitDir(tar, filePath) <span class="keywd">then</span>
        typeflag := addImplicitDir(tar, filePath).typeflag;
      <span class="keywd">else</span>
        aFileType := FILE_ABSENT;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> aFileType = FILE_UNKNOWN <span class="keywd">then</span>
        <span class="keywd">case</span> typeflag <span class="keywd">of</span>
          <span class="keywd">when</span> {REGTYPE}:  aFileType := FILE_REGULAR;
          <span class="keywd">when</span> {AREGTYPE}: aFileType := FILE_REGULAR;
          <span class="keywd">when</span> {SYMTYPE}:  aFileType := FILE_SYMLINK;
          <span class="keywd">when</span> {CHRTYPE}:  aFileType := FILE_CHAR;
          <span class="keywd">when</span> {BLKTYPE}:  aFileType := FILE_BLOCK;
          <span class="keywd">when</span> {DIRTYPE}:  aFileType := FILE_DIR;
          <span class="keywd">when</span> {FIFOTYPE}: aFileType := FILE_FIFO;
          <span class="keywd">when</span> {CONTTYPE}: aFileType := FILE_UNKNOWN;
          <span class="keywd">otherwise</span>:       aFileType := FILE_UNKNOWN;
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the file mode (permissions) of a file in a TAR archive.
 *  The function follows symbolic links.
 *  @return the file mode.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the TAR archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">fileMode</span>: getFileMode (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fileMode</span>: mode <span class="keywd">is</span> fileMode.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      mode := fileMode(followSymlink(tar, filePath).mode <span class="op">mod</span> 8#1000);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Change the file mode (permissions) of a file in a TAR archive.
 *  The function follows symbolic links.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the TAR archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: setFileMode (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">fileMode</span>: mode) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      header := followSymlink(tar, filePath);
      <span class="keywd">if</span> header.filePath <span class="op">in</span> tar.register <span class="keywd">then</span>
        header.mode := (header.mode >> 9 &lt;&lt; 9) + integer(mode);
        tar.catalog @:= [header.filePath] header;
        seek(tar.tarFile, tar.register[header.filePath]);
        writeHead(tar.tarFile, tar.catalog[header.filePath]);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the size of a file in a TAR archive.
 *  The file size is measured in bytes.
 *  For directories a size of 0 is returned.
 *  The function follows symbolic links.
 *  @return the size of the file.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the TAR archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: fileSize (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: size <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      size := followSymlink(tar, filePath).fileSize;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the modification time of a file in a TAR archive.
 *  The function follows symbolic links.
 *  @return the modification time of the file.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the TAR archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: getMTime (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: modificationTime <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      modificationTime := timestamp1970ToTime(
          followSymlink(tar, filePath).mtime);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Set the modification time of a file in a TAR archive.
 *  The function follows symbolic links.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception RANGE_ERROR ''modificationTime'' is invalid or cannot be
 *             converted to the system file time.
 *  @exception FILE_ERROR ''filePath'' is not present in the TAR archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: setMTime (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">time</span>: modificationTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: mtime <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">begin</span>
    mtime := timestamp1970(modificationTime);
    <span class="keywd">if</span> mtime &lt; 0 <span class="op">or</span> mtime >= 2 ** 31 <span class="op">or</span>
        (filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>)) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      header := followSymlink(tar, filePath);
      <span class="keywd">if</span> header.filePath <span class="op">in</span> tar.register <span class="keywd">then</span>
        header.mtime := mtime;
        tar.catalog @:= [header.filePath] header;
        seek(tar.tarFile, tar.register[header.filePath]);
        writeHead(tar.tarFile, tar.catalog[header.filePath]);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the name of the owner (UID) of a file in a TAR archive.
 *  The function follows symbolic links.
 *  @return the name of the file owner.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the TAR archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getOwner (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: owner <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      header := followSymlink(tar, filePath);
      <span class="keywd">if</span> header.uname &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        owner := header.uname;
      <span class="keywd">else</span>
        owner := str(header.uid);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Set the owner of a file in a TAR archive.
 *  The function follows symbolic links.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the TAR archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: setOwner (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">string</span>: owner) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      header := followSymlink(tar, filePath);
      <span class="keywd">if</span> header.filePath <span class="op">in</span> tar.register <span class="keywd">then</span>
        <span class="keywd">if</span> isDigitString(owner) <span class="keywd">then</span>
          header.uid := integer(owner);
          header.uname := <span class="stri">""</span>;
        <span class="keywd">else</span>
          header.uid := 0;
          header.uname := owner;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        tar.catalog @:= [header.filePath] header;
        seek(tar.tarFile, tar.register[header.filePath]);
        writeHead(tar.tarFile, tar.catalog[header.filePath]);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the name of the group (GID) of a file in a TAR archive.
 *  The function follows symbolic links.
 *  @return the name of the file group.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the TAR archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getGroup (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: group <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      header := followSymlink(tar, filePath);
      <span class="keywd">if</span> header.gname &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        group := header.gname;
      <span class="keywd">else</span>
        group := str(header.gid);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Set the group of a file in a TAR archive.
 *  The function follows symbolic links.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the TAR archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: setGroup (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">string</span>: group) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      header := followSymlink(tar, filePath);
      <span class="keywd">if</span> header.filePath <span class="op">in</span> tar.register <span class="keywd">then</span>
        <span class="keywd">if</span> isDigitString(group) <span class="keywd">then</span>
          header.gid := integer(group);
          header.gname := <span class="stri">""</span>;
        <span class="keywd">else</span>
          header.gid := 0;
          header.gname := group;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        tar.catalog @:= [header.filePath] header;
        seek(tar.tarFile, tar.register[header.filePath]);
        writeHead(tar.tarFile, tar.catalog[header.filePath]);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the file mode (permissions) of a symbolic link in a TAR archive.
 *  The function only works for symbolic links and does not follow the
 *  symbolic link.
 *  @return the file mode.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR The file described with ''filePath'' is not
 *             present in the TAR archive, or it is not a symbolic link.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">fileMode</span>: getFileMode (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath, SYMLINK) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fileMode</span>: mode <span class="keywd">is</span> fileMode.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("getFileMode: " &lt;&amp; filePath);</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath = <span class="stri">""</span> <span class="keywd">then</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> tar.catalog <span class="keywd">then</span>
        header := tar.catalog[filePath];
      <span class="keywd">elsif</span> filePath <span class="op">in</span> tar.register <span class="keywd">then</span>
        header := addToCatalog(tar, filePath);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> header.typeflag = SYMTYPE <span class="keywd">then</span>
        mode := fileMode(header.mode <span class="op">mod</span> 8#1000);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the modification time of a symbolic link in a TAR archive.
 *  The function only works for symbolic links and does not follow the
 *  symbolic link.
 *  @return the modification time of the symbolic link.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR The file described with ''filePath'' is not
 *             present in the TAR archive, or it is not a symbolic link.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: getMTime (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath, SYMLINK) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: modificationTime <span class="keywd">is</span> time.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("getMTime: " &lt;&amp; filePath);</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath = <span class="stri">""</span> <span class="keywd">then</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> tar.catalog <span class="keywd">then</span>
        header := tar.catalog[filePath];
      <span class="keywd">elsif</span> filePath <span class="op">in</span> tar.register <span class="keywd">then</span>
        header := addToCatalog(tar, filePath);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> header.typeflag = SYMTYPE <span class="keywd">then</span>
        modificationTime := timestamp1970ToTime(header.mtime);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Set the modification time of a symbolic link in a TAR archive.
 *  The function only works for symbolic links and does not follow the
 *  symbolic link.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception RANGE_ERROR ''modificationTime'' is invalid or it cannot be
 *             converted to the system file time.
 *  @exception FILE_ERROR The file described with ''filePath'' is not
 *             present in the TAR archive, or it is not a symbolic link.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: setMTime (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">time</span>: modificationTime, SYMLINK) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: mtime <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">begin</span>
    mtime := timestamp1970(modificationTime);
    <span class="keywd">if</span> mtime &lt; 0 <span class="op">or</span> mtime >= 2 ** 31 <span class="op">or</span>
        (filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>)) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath = <span class="stri">""</span> <span class="keywd">then</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> tar.catalog <span class="keywd">then</span>
        header := tar.catalog[filePath];
      <span class="keywd">elsif</span> filePath <span class="op">in</span> tar.register <span class="keywd">then</span>
        header := addToCatalog(tar, filePath);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> header.typeflag = SYMTYPE <span class="keywd">then</span>
        header.mtime := mtime;
        tar.catalog @:= [header.filePath] header;
        seek(tar.tarFile, tar.register[header.filePath]);
        writeHead(tar.tarFile, tar.catalog[header.filePath]);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the name of the owner (UID) of a symbolic link in a TAR archive.
 *  The function only works for symbolic links and does not follow the
 *  symbolic link.
 *  @return the name of the file owner.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR The file described with ''filePath'' is not
 *             present in the TAR archive, or it is not a symbolic link.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getOwner (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath, SYMLINK) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: owner <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("getOwner: " &lt;&amp; filePath);</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath = <span class="stri">""</span> <span class="keywd">then</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> tar.catalog <span class="keywd">then</span>
        header := tar.catalog[filePath];
      <span class="keywd">elsif</span> filePath <span class="op">in</span> tar.register <span class="keywd">then</span>
        header := addToCatalog(tar, filePath);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> header.typeflag = SYMTYPE <span class="keywd">then</span>
        <span class="keywd">if</span> header.uname &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          owner := header.uname;
        <span class="keywd">else</span>
          owner := str(header.uid);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Set the owner of a symbolic link in a TAR archive.
 *  The function only works for symbolic links and does not follow the
 *  symbolic link.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR The file described with ''filePath'' is not
 *             present in the TAR archive, or it is not a symbolic link.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: setOwner (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">string</span>: owner, SYMLINK) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath = <span class="stri">""</span> <span class="keywd">then</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> tar.catalog <span class="keywd">then</span>
        header := tar.catalog[filePath];
      <span class="keywd">elsif</span> filePath <span class="op">in</span> tar.register <span class="keywd">then</span>
        header := addToCatalog(tar, filePath);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> header.typeflag = SYMTYPE <span class="keywd">then</span>
        <span class="keywd">if</span> isDigitString(owner) <span class="keywd">then</span>
          header.uid := integer(owner);
          header.uname := <span class="stri">""</span>;
        <span class="keywd">else</span>
          header.uid := 0;
          header.uname := owner;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        tar.catalog @:= [header.filePath] header;
        seek(tar.tarFile, tar.register[header.filePath]);
        writeHead(tar.tarFile, tar.catalog[header.filePath]);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the name of the group (GID) of a symbolic link in a TAR archive.
 *  The function only works for symbolic links and does not follow the
 *  symbolic link.
 *  @return the name of the file group.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR The file described with ''filePath'' is not
 *             present in the TAR archive, or it is not a symbolic link.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getGroup (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath, SYMLINK) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: group <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("getGroup: " &lt;&amp; filePath);</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath = <span class="stri">""</span> <span class="keywd">then</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> tar.catalog <span class="keywd">then</span>
        header := tar.catalog[filePath];
      <span class="keywd">elsif</span> filePath <span class="op">in</span> tar.register <span class="keywd">then</span>
        header := addToCatalog(tar, filePath);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> header.typeflag = SYMTYPE <span class="keywd">then</span>
        <span class="keywd">if</span> header.gname &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          group := header.gname;
        <span class="keywd">else</span>
          group := str(header.gid);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Set the group of a symbolic link in a TAR archive.
 *  The function only works for symbolic links and does not follow the
 *  symbolic link.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR The file described with ''filePath'' is not
 *             present in the TAR archive, or it is not a symbolic link.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: setGroup (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">string</span>: group, SYMLINK) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath = <span class="stri">""</span> <span class="keywd">then</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> tar.catalog <span class="keywd">then</span>
        header := tar.catalog[filePath];
      <span class="keywd">elsif</span> filePath <span class="op">in</span> tar.register <span class="keywd">then</span>
        header := addToCatalog(tar, filePath);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> header.typeflag = SYMTYPE <span class="keywd">then</span>
        <span class="keywd">if</span> isDigitString(group) <span class="keywd">then</span>
          header.uid := integer(group);
          header.gname := <span class="stri">""</span>;
        <span class="keywd">else</span>
          header.uid := 0;
          header.gname := group;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        tar.catalog @:= [header.filePath] header;
        seek(tar.tarFile, tar.register[header.filePath]);
        writeHead(tar.tarFile, tar.catalog[header.filePath]);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads the destination of a symbolic link in a TAR archive.
 *  @return The destination referred by the symbolic link.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the TAR archive,
 *             or is not a symbolic link.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: readLink (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: linkPath <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath <span class="op">in</span> tar.catalog <span class="keywd">then</span>
      header := tar.catalog[filePath];
    <span class="keywd">elsif</span> filePath <span class="op">in</span> tar.register <span class="keywd">then</span>
      header := addToCatalog(tar, filePath);
    <span class="keywd">else</span>
      raise FILE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> header.typeflag = SYMTYPE <span class="keywd">then</span>
      linkPath := header.linkPath;
    <span class="keywd">else</span>
      raise FILE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Create a symbolic link in a TAR archive.
 *  The symbolic link ''symlinkPath'' will refer to ''targetPath'' afterwards.
 *  @param targetPath String to be contained in the symbolic link.
 *  @param symlinkPath Name of the symbolic link to be created.
 *  @exception RANGE_ERROR ''targetPath'' or ''symlinkPath'' does not use the
 *             standard path representation.
 *  @exception FILE_ERROR A system function returns an error.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: symlink (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: targetPath,
    <span class="op">in</span> <span class="type">string</span>: symlinkPath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
    <span class="keywd">var</span> <span class="type">string</span>: targetPath8 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: symlinkPath8 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("symlink: " &lt;&amp; targetPath &lt;&amp; " " &lt;&amp; symlinkPath);</span>
    <span class="keywd">if</span> symlinkPath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(symlinkPath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> symlinkPath = <span class="stri">""</span> <span class="op">or</span> symlinkPath <span class="op">in</span> tar.catalog <span class="op">or</span>
        symlinkPath <span class="op">in</span> tar.register <span class="op">or</span> implicitDir(tar, symlinkPath) <span class="keywd">then</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      header.name     := symlinkPath[.. 100];
      header.mode     := 8#777;
      header.uid      := 100;
      header.gid      := 100;
      header.fileSize := 0;
      header.mtime    := timestamp1970(time(NOW));
      header.typeflag := SYMTYPE;
      header.magic    := TAR_MAGIC;
      header.version  := <span class="stri">"  "</span>;
      header.filePath := symlinkPath;
      header.linkPath := targetPath;
      length := length(tar.tarFile);
      <span class="keywd">if</span> seekable(tar.tarFile) <span class="keywd">then</span>
        seek(tar.tarFile, succ(length));
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="comment"># Add zero bytes such that the next header starts at a multiple of the block size:</span>
      write(tar.tarFile, <span class="stri">"\0;"</span> <span class="op">mult</span> pred(TAR_BLOCK_SIZE) -
            pred(length) <span class="op">mod</span> TAR_BLOCK_SIZE);
      tar.register @:= [symlinkPath] tell(tar.tarFile);
      writeHead(tar.tarFile, header);
      header.dataStartPos := tell(tar.tarFile);
      tar.catalog @:= [symlinkPath] header;
      flush(tar.tarFile);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(*
const proc: moveSingleFile (inout tarArchive: tar, in string: sourcePath,
    in string: destPath) is func
  local
    var tarHeader: header is tarHeader.value;
    var integer: headerPos is 0;
  begin
    if sourcePath &lt;> "/" and endsWith(sourcePath, "/") or
        destPath &lt;> "/" and endsWith(destPath, "/") then
      raise RANGE_ERROR;
    elsif sourcePath &lt;> destPath then
      if destPath in tar.register then
        raise FILE_ERROR;
      elsif sourcePath in tar.catalog then
        header := tar.catalog[sourcePath];
        header.filePath := destPath;
        excl(tar.catalog, sourcePath);
        tar.catalog @:= [destPath] header;
        headerPos := tar.register[sourcePath];
        excl(tar.register, sourcePath;
        tar.register @:= [destPath] headerPos;
        seek(tar.tarFile, headerPos);
        writeHead(tar.tarFile, header);
      elsif sourcePath in tar.register then
        header := addToCatalog(tar, sourcePath);
        header.mtime := mtime;
        tar.catalog @:= [sourcePath] header;
      else
        raise FILE_ERROR;
      end if;
      seek(tar.tarFile, tar.register[sourcePath]);
      writeHead(tar.tarFile, tar.catalog[sourcePath]);
    end if;
  end func;


(* *
 *  Move and rename a file or directory tree in a TAR archive.
 *  @exception RANGE_ERROR ''sourcePath'' or ''destPath'' does not use
 *             the standard path representation.
 *  @exception FILE_ERROR Source file does not exist or destination file
 *             already exists.
 *)
const proc: moveFile (inout tarArchive: tar, in string: sourcePath,
    in string: destPath) is func
  local
    var tarHeader: header is tarHeader.value;
    var integer: headerPos is 0;
  begin
    if sourcePath &lt;> "/" and endsWith(sourcePath, "/") or
        destPath &lt;> "/" and endsWith(destPath, "/") then
      raise RANGE_ERROR;
    elsif sourcePath &lt;> destPath then
      if destPath in tar.register then
        raise FILE_ERROR;
      elsif sourcePath in tar.catalog then
        header := tar.catalog[sourcePath];
        header.filePath := destPath;
        excl(tar.catalog, sourcePath);
        tar.catalog @:= [destPath] header;
        headerPos := tar.register[sourcePath];
        excl(tar.register, sourcePath;
        tar.register @:= [destPath] headerPos;
        seek(tar.tarFile, headerPos);
        writeHead(tar.tarFile, header);
      elsif sourcePath in tar.register then
        header := addToCatalog(tar, sourcePath);
        header.mtime := mtime;
        tar.catalog @:= [sourcePath] header;
      else
        raise FILE_ERROR;
      end if;
      seek(tar.tarFile, tar.register[sourcePath]);
      writeHead(tar.tarFile, tar.catalog[sourcePath]);
    end if;
  end func;
*)</span>


<span class="comment">(**
 *  Get the contents of a file in a TAR archive.
 *  The function follows symbolic links.
 *  @return the specified file as string.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the TAR archive,
 *             or is not a regular file, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getFile (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: content <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      header := followSymlink(tar, filePath);
      <span class="keywd">if</span> header.typeflag = REGTYPE <span class="op">or</span> header.typeflag = AREGTYPE <span class="keywd">then</span>
        seek(tar.tarFile, header.dataStartPos);
        content := gets(tar.tarFile, header.fileSize);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Write ''data'' to a TAR archive with the given ''filePath''.
 *  If the file exists already, it is overwritten.
 *  The function follows symbolic links.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR The file exists, but it is not a regular file.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: putFile (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">string</span>: data) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
    <span class="keywd">var</span> <span class="type">string</span>: missingPath <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: appendFile <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath = <span class="stri">""</span> <span class="op">or</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      missingPath := followSymlink(tar, filePath, header);
      <span class="keywd">if</span> missingPath = <span class="stri">""</span> <span class="keywd">then</span>
        <span class="comment"># The file does exist.</span>
        filePath := header.filePath;
        <span class="keywd">if</span> header.typeflag &lt;> REGTYPE <span class="op">and</span> header.typeflag &lt;> AREGTYPE <span class="keywd">then</span>
          raise FILE_ERROR;
        <span class="keywd">else</span>
          <span class="keywd">if</span> succ(pred(header.fileSize) <span class="op">mdiv</span> TAR_BLOCK_SIZE) * TAR_BLOCK_SIZE =
              succ(pred(length(data)) <span class="op">mdiv</span> TAR_BLOCK_SIZE) * TAR_BLOCK_SIZE <span class="keywd">then</span>
            <span class="comment"># The number of blocks used of the old file and the new file are identical.</span>
            <span class="comment"># The file data is rewritten in place.</span>
            header.fileSize := length(data);
            tar.catalog @:= [filePath] header;
            seek(tar.tarFile, header.dataStartPos - TAR_BLOCK_SIZE);
            <span class="comment"># Write just the main header. Extended headers are left unchanged.</span>
            write(tar.tarFile, str(header));
            write(tar.tarFile, data);
            write(tar.tarFile, <span class="stri">"\0;"</span> <span class="op">mult</span> pred(TAR_BLOCK_SIZE) -
                  pred(header.fileSize) <span class="op">mod</span> TAR_BLOCK_SIZE);
            appendFile := FALSE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        filePath := missingPath;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> appendFile <span class="keywd">then</span>
        length := length(tar.tarFile);
        <span class="keywd">if</span> seekable(tar.tarFile) <span class="keywd">then</span>
          seek(tar.tarFile, succ(length));
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="comment"># Add zero bytes such that the next header starts at a multiple of the block size:</span>
        write(tar.tarFile, <span class="stri">"\0;"</span> <span class="op">mult</span> pred(TAR_BLOCK_SIZE) -
              pred(length) <span class="op">mod</span> TAR_BLOCK_SIZE);
        tar.register @:= [filePath] tell(tar.tarFile);
        <span class="keywd">if</span> missingPath &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          header.name     := filePath[.. 100];
          header.mode     := 8#664;
          header.uid      := 100;
          header.gid      := 100;
          header.mtime    := timestamp1970(time(NOW));
          header.typeflag := REGTYPE;
          header.magic    := TAR_MAGIC;
          header.version  := <span class="stri">"  "</span>;
          header.filePath := filePath;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        header.fileSize := length(data);
        writeHead(tar.tarFile, header);
        header.dataStartPos := tell(tar.tarFile);
        tar.catalog @:= [filePath] header;
        write(tar.tarFile, data);
        write(tar.tarFile, <span class="stri">"\0;"</span> <span class="op">mult</span> pred(TAR_BLOCK_SIZE) -
              pred(header.fileSize) <span class="op">mod</span> TAR_BLOCK_SIZE);
        flush(tar.tarFile);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Creates a new directory in a TAR archive.
 *  The function does not follow symbolic links.
 *  @exception RANGE_ERROR ''dirPath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR A system function returns an error.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: mkdir (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
    <span class="keywd">var</span> <span class="type">boolean</span>: fileExists <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">integer</span>: dataStartPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath = <span class="stri">""</span> <span class="op">or</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath <span class="op">in</span> tar.catalog <span class="keywd">then</span>
      dataStartPos := tar.catalog[filePath].dataStartPos;
    <span class="keywd">elsif</span> filePath <span class="op">in</span> tar.register <span class="keywd">then</span>
      dataStartPos := addToCatalog(tar, filePath).dataStartPos;
    <span class="keywd">elsif</span> implicitDir(tar, filePath) <span class="keywd">then</span>
      dataStartPos := addImplicitDir(tar, filePath).dataStartPos;
    <span class="keywd">else</span>
      fileExists := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> fileExists <span class="op">and</span> dataStartPos &lt;> -1 <span class="keywd">then</span>
      <span class="comment"># The file exists and it is not an implicit directory.</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      length := length(tar.tarFile);
      seek(tar.tarFile, succ(length));
      <span class="comment"># Add zero bytes such that the next header starts at a multiple of the block size:</span>
      write(tar.tarFile, <span class="stri">"\0;"</span> <span class="op">mult</span> pred(TAR_BLOCK_SIZE) - pred(length) <span class="op">mod</span> TAR_BLOCK_SIZE);
      tar.register @:= [filePath] tell(tar.tarFile);
      header.name     := (filePath &amp; <span class="stri">"/"</span>) [.. 100];
      header.mode     := 8#775;
      header.uid      := 100;
      header.gid      := 100;
      header.fileSize := 0;
      header.mtime    := timestamp1970(time(NOW));
      header.typeflag := DIRTYPE;
      header.magic    := TAR_MAGIC;
      header.version  := <span class="stri">"  "</span>;
      header.filePath := filePath;
      header.filePathSuffix := <span class="stri">"/"</span>;
      writeHead(tar.tarFile, header);
      header.dataStartPos := tell(tar.tarFile);
      tar.catalog @:= [filePath] header;
      flush(tar.tarFile);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  For-loop which loops recursively over the paths in a TAR archive.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">for</span> (<span class="keywd">inout</span> <span class="type">string</span>: filePath) <span class="keywd">range</span> (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar) <span class="keywd">do</span>
              (<span class="op">in</span> <span class="type">proc</span>: statements)
            <span class="keywd">end</span> <span class="keywd">for</span> <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">for</span> <span class="keywd">key</span> filePath <span class="keywd">range</span> tar.register <span class="keywd">do</span>
      statements;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">file</span>: openFileInTar (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">string</span>: mode) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">file</span>: newFile <span class="keywd">is</span> STD_NULL;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tarHeader</span>: header <span class="keywd">is</span> tarHeader.value;
    <span class="keywd">var</span> <span class="type">string</span>: missingPath <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> mode = <span class="stri">"r"</span> <span class="keywd">then</span>
      <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
        raise RANGE_ERROR;
      <span class="keywd">else</span>
        missingPath := followSymlink(tar, filePath, header);
        <span class="keywd">if</span> missingPath = <span class="stri">""</span> <span class="op">and</span> (header.typeflag = REGTYPE <span class="op">or</span>
                                 header.typeflag = AREGTYPE) <span class="keywd">then</span>
          newFile := openSubFile(tar.tarFile, header.dataStartPos,
                                 header.fileSize);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Open a file with ''filePath'' and ''mode'' in in a TAR archive.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">file</span>: open (<span class="keywd">inout</span> <span class="type">tarArchive</span>: tar, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">string</span>: mode) <span class="keywd">is</span>
  <span class="keywd">return</span> openBufferFile(openFileInTar(tar, filePath, mode));
</pre>
</body>
</html>
