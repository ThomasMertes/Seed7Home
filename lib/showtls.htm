<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  showtls.s7i   Show TLS messages. Use it to debug tls.s7i.       *)</span>
<span class="comment">(*  Copyright (C) 2013 - 2020, 2022  Thomas Mertes                  *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/tls.htm">tls.s7i</a>"</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showChangeCipherSpec (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"change_cipher_spec"</span>);
    writeln(<span class="stri">"type: "</span> &lt;&amp; ord(stri[6]));
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showAlert (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"alert"</span>);
    writeln(<span class="stri">"Version: "</span> &lt;&amp; ord(stri[2]) &lt;&amp; <span class="stri">"."</span> &lt;&amp; ord(stri[3]));
    writeln(<span class="stri">"Length: "</span> &lt;&amp; bytes2Int(stri[4 fixLen 2], UNSIGNED, BE));
    writeln(<span class="stri">"level: "</span> &lt;&amp; ord(stri[6]));
    write(<span class="stri">"description: "</span> &lt;&amp; ord(stri[7]));
    <span class="keywd">case</span> ord(stri[7]) <span class="keywd">of</span>
      <span class="keywd">when</span> {  0}: write(<span class="stri">" - close_notify"</span>);
      <span class="keywd">when</span> { 10}: write(<span class="stri">" - unexpected_message"</span>);
      <span class="keywd">when</span> { 20}: write(<span class="stri">" - bad_record_mac"</span>);
      <span class="keywd">when</span> { 21}: write(<span class="stri">" - decryption_failed"</span>);
      <span class="keywd">when</span> { 22}: write(<span class="stri">" - record_overflow"</span>);
      <span class="keywd">when</span> { 30}: write(<span class="stri">" - decompression_failure"</span>);
      <span class="keywd">when</span> { 40}: write(<span class="stri">" - handshake_failure"</span>);
      <span class="keywd">when</span> { 41}: write(<span class="stri">" - no_certificate"</span>);
      <span class="keywd">when</span> { 42}: write(<span class="stri">" - bad_certificate"</span>);
      <span class="keywd">when</span> { 43}: write(<span class="stri">" - unsupported_certificate"</span>);
      <span class="keywd">when</span> { 44}: write(<span class="stri">" - certificate_revoked"</span>);
      <span class="keywd">when</span> { 45}: write(<span class="stri">" - certificate_expired"</span>);
      <span class="keywd">when</span> { 46}: write(<span class="stri">" - certificate_unknown"</span>);
      <span class="keywd">when</span> { 47}: write(<span class="stri">" - illegal_parameter"</span>);
      <span class="keywd">when</span> { 48}: write(<span class="stri">" - unknown_ca"</span>);
      <span class="keywd">when</span> { 49}: write(<span class="stri">" - access_denied"</span>);
      <span class="keywd">when</span> { 50}: write(<span class="stri">" - decode_error"</span>);
      <span class="keywd">when</span> { 51}: write(<span class="stri">" - decrypt_error"</span>);
      <span class="keywd">when</span> { 60}: write(<span class="stri">" - export_restriction"</span>);
      <span class="keywd">when</span> { 70}: write(<span class="stri">" - protocol_version"</span>);
      <span class="keywd">when</span> { 71}: write(<span class="stri">" - insufficient_security"</span>);
      <span class="keywd">when</span> { 80}: write(<span class="stri">" - internal_error"</span>);
      <span class="keywd">when</span> { 86}: write(<span class="stri">" - inappropriate_fallback"</span>);
      <span class="keywd">when</span> { 90}: write(<span class="stri">" - user_canceled"</span>);
      <span class="keywd">when</span> {100}: write(<span class="stri">" - no_renegotiation"</span>);
      <span class="keywd">when</span> {109}: write(<span class="stri">" - missing_extension"</span>);
      <span class="keywd">when</span> {110}: write(<span class="stri">" - unsupported_extension"</span>);
      <span class="keywd">when</span> {111}: write(<span class="stri">" - certificate_unobtainable"</span>);
      <span class="keywd">when</span> {112}: write(<span class="stri">" - unrecognized_name"</span>);
      <span class="keywd">when</span> {113}: write(<span class="stri">" - bad_certificate_status_response"</span>);
      <span class="keywd">when</span> {114}: write(<span class="stri">" - bad_certificate_hash_value"</span>);
    <span class="keywd">end</span> <span class="keywd">case</span>;
    writeln;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showExtensions (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">integer</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: extensionBytes <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: beyond <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: extensionType <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: dataSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: data <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: dataPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: dataWritten <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    extensionBytes := bytes2Int(stri[pos fixLen 2], UNSIGNED, BE);
    writeln(<span class="stri">"Extension bytes: "</span> &lt;&amp; extensionBytes);
    pos +:= 2;
    beyond := pos + extensionBytes;
    index := 1;
    <span class="keywd">while</span> pos &lt; beyond <span class="keywd">do</span>
      write(<span class="stri">"Extension-"</span> &lt;&amp; index &lt;&amp; <span class="stri">": "</span>);
      extensionType := bytes2Int(stri[pos fixLen 2], UNSIGNED, BE);
      pos +:= 2;
      dataSize := bytes2Int(stri[pos fixLen 2], UNSIGNED, BE);
      pos +:= 2;
      data := stri[pos len dataSize];
      pos +:= dataSize;
      dataWritten := FALSE;
      <span class="keywd">case</span> extensionType <span class="keywd">of</span>
        <span class="keywd">when</span> {SERVER_NAME}:                            writeln(<span class="stri">"server_name"</span>);
        <span class="keywd">when</span> {MAX_FRAGMENT_LENGTH}:                    writeln(<span class="stri">"max_fragment_length"</span>);
        <span class="keywd">when</span> {CLIENT_CERTIFICATE_URL}:                 writeln(<span class="stri">"client_certificate_url"</span>);
        <span class="keywd">when</span> {TRUSTED_CA_KEYS}:                        writeln(<span class="stri">"trusted_ca_keys"</span>);
        <span class="keywd">when</span> {TRUNCATED_HMAC}:                         writeln(<span class="stri">"truncated_hmac"</span>);
        <span class="keywd">when</span> {STATUS_REQUEST}:                         writeln(<span class="stri">"status_request"</span>);
        <span class="keywd">when</span> {USER_MAPPING}:                           writeln(<span class="stri">"user_mapping"</span>);
        <span class="keywd">when</span> {CLIENT_AUTHZ}:                           writeln(<span class="stri">"client_authz"</span>);
        <span class="keywd">when</span> {SERVER_AUTHZ}:                           writeln(<span class="stri">"server_authz"</span>);
        <span class="keywd">when</span> {CERT_TYPE}:                              writeln(<span class="stri">"cert_type"</span>);
        <span class="keywd">when</span> {ELLIPTIC_CURVES}:                        writeln(<span class="stri">"elliptic_curves"</span>);
          dataPos := 1;
          write(bytes2Int(data[dataPos fixLen 2], UNSIGNED, BE) <span class="op">mdiv</span> 2 &lt;&amp; <span class="stri">" curve numbers:"</span>);
          dataPos +:= 2;
          <span class="keywd">while</span> dataPos &lt; length(data) <span class="keywd">do</span>
            write(<span class="stri">" "</span> &lt;&amp; bytes2Int(data[dataPos fixLen 2], UNSIGNED, BE));
            dataPos +:= 2;
          <span class="keywd">end</span> <span class="keywd">while</span>;
          writeln;
          dataWritten := TRUE;
        <span class="keywd">when</span> {EC_POINT_FORMATS}:                       writeln(<span class="stri">"ec_point_formats"</span>);
        <span class="keywd">when</span> {SRP}:                                    writeln(<span class="stri">"srp"</span>);
        <span class="keywd">when</span> {SIGNATURE_ALGORITHMS}:                   writeln(<span class="stri">"signature_algorithms"</span>);
          dataPos := 1;
          write(bytes2Int(data[dataPos fixLen 2], UNSIGNED, BE) <span class="op">mdiv</span> 2 &lt;&amp; <span class="stri">" signature algorithms:"</span>);
          dataPos +:= 2;
          <span class="keywd">while</span> dataPos &lt; length(data) <span class="keywd">do</span>
            write(<span class="stri">" "</span> &lt;&amp; bytes2Int(data[dataPos fixLen 2], UNSIGNED, BE) radix 16 <span class="op">lpad0</span> 4);
            dataPos +:= 2;
          <span class="keywd">end</span> <span class="keywd">while</span>;
          writeln;
          dataWritten := TRUE;
        <span class="keywd">when</span> {USE_SRTP}:                               writeln(<span class="stri">"use_srtp"</span>);
        <span class="keywd">when</span> {HEARTBEAT}:                              writeln(<span class="stri">"heartbeat"</span>);
        <span class="keywd">when</span> {APPLICATION_LAYER_PROTOCOL_NEGOTIATION}: writeln(<span class="stri">"application_layer_protocol_negotiation"</span>);
        <span class="keywd">when</span> {STATUS_REQUEST_V2}:                      writeln(<span class="stri">"status_request_v2"</span>);
        <span class="keywd">when</span> {SIGNED_CERTIFICATE_TIMESTAMP}:           writeln(<span class="stri">"signed_certificate_timestamp"</span>);
        <span class="keywd">when</span> {CLIENT_CERTIFICATE_TYPE}:                writeln(<span class="stri">"client_certificate_type"</span>);
        <span class="keywd">when</span> {SERVER_CERTIFICATE_TYPE}:                writeln(<span class="stri">"server_certificate_type"</span>);
        <span class="keywd">when</span> {PADDING}:                                writeln(<span class="stri">"padding"</span>);
        <span class="keywd">when</span> {ENCRYPT_THEN_MAC}:                       writeln(<span class="stri">"encrypt_then_mac"</span>);
        <span class="keywd">when</span> {EXTENDED_MASTER_SECRET}:                 writeln(<span class="stri">"extended_master_secret"</span>);
        <span class="keywd">when</span> {TOKEN_BINDING}:                          writeln(<span class="stri">"token_binding"</span>);
        <span class="keywd">when</span> {CACHED_INFO}:                            writeln(<span class="stri">"cached_info"</span>);
        <span class="keywd">when</span> {TLS_LTS}:                                writeln(<span class="stri">"tls_lts"</span>);
        <span class="keywd">when</span> {COMPRESS_CERTIFICATE}:                   writeln(<span class="stri">"compress_certificate"</span>);
        <span class="keywd">when</span> {RECORD_SIZE_LIMIT}:                      writeln(<span class="stri">"record_size_limit"</span>);
        <span class="keywd">when</span> {PWD_PROTECT}:                            writeln(<span class="stri">"pwd_protect"</span>);
        <span class="keywd">when</span> {PWD_CLEAR}:                              writeln(<span class="stri">"pwd_clear"</span>);
        <span class="keywd">when</span> {PASSWORD_SALT}:                          writeln(<span class="stri">"password_salt"</span>);
        <span class="keywd">when</span> {TICKET_PINNING}:                         writeln(<span class="stri">"ticket_pinning"</span>);
        <span class="keywd">when</span> {TLS_CERT_WITH_EXTERN_PSK}:               writeln(<span class="stri">"tls_cert_with_extern_psk"</span>);
        <span class="keywd">when</span> {DELEGATED_CREDENTIAL}:                   writeln(<span class="stri">"delegated_credential"</span>);
        <span class="keywd">when</span> {SESSION_TICKET_TLS}:                     writeln(<span class="stri">"SessionTicket TLS"</span>);
        <span class="keywd">when</span> {PRE_SHARED_KEY}:                         writeln(<span class="stri">"pre_shared_key"</span>);
        <span class="keywd">when</span> {EARLY_DATA}:                             writeln(<span class="stri">"early_data"</span>);
        <span class="keywd">when</span> {SUPPORTED_VERSIONS}:                     writeln(<span class="stri">"supported_versions"</span>);
        <span class="keywd">when</span> {COOKIE}:                                 writeln(<span class="stri">"cookie"</span>);
        <span class="keywd">when</span> {PSK_KEY_EXCHANGE_MODES}:                 writeln(<span class="stri">"psk_key_exchange_modes"</span>);
        <span class="keywd">when</span> {CERTIFICATE_AUTHORITIES}:                writeln(<span class="stri">"certificate_authorities"</span>);
        <span class="keywd">when</span> {OID_FILTERS}:                            writeln(<span class="stri">"oid_filters"</span>);
        <span class="keywd">when</span> {POST_HANDSHAKE_AUTH}:                    writeln(<span class="stri">"post_handshake_auth"</span>);
        <span class="keywd">when</span> {SIGNATURE_ALGORITHMS_CERT}:              writeln(<span class="stri">"signature_algorithms_cert"</span>);
        <span class="keywd">when</span> {KEY_SHARE}:                              writeln(<span class="stri">"key_share"</span>);
        <span class="keywd">when</span> {TRANSPARENCY_INFO}:                      writeln(<span class="stri">"transparency_info"</span>);
        <span class="keywd">when</span> {CONNECTION_ID}:                          writeln(<span class="stri">"connection_id"</span>);
        <span class="keywd">when</span> {EXTERNAL_ID_HASH}:                       writeln(<span class="stri">"external_id_hash"</span>);
        <span class="keywd">when</span> {EXTERNAL_SESSION_ID}:                    writeln(<span class="stri">"external_session_id"</span>);
        <span class="keywd">when</span> {NEXT_PROTOCOL_NEGOTIATION}:              writeln(<span class="stri">"next_protocol_negotiation"</span>);
        <span class="keywd">when</span> {RENEGOTIATION_INFO}:                     writeln(<span class="stri">"renegotiation_info"</span>);
        <span class="keywd">when</span> {16#0a0a, 16#1a1a, 16#2a2a, 16#3a3a,
              16#4a4a, 16#5a5a, 16#6a6a, 16#7a7a,
              16#8a8a, 16#9a9a, 16#aaaa, 16#baba,
              16#caca, 16#dada, 16#eaea, 16#fafa}:
                                                       writeln(<span class="stri">"GREASE extension"</span>);
          writeln(<span class="stri">"GREASE value: "</span> &lt;&amp; extensionType &lt;&amp;
                  <span class="stri">" (16#"</span> &lt;&amp; extensionType radix 16 <span class="op">lpad0</span> 4 &lt;&amp; <span class="stri">")"</span>);
          <span class="keywd">if</span> data &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            writeln(<span class="stri">"Data: "</span> &lt;&amp; literal(data));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          dataWritten := TRUE;
        <span class="keywd">otherwise</span>:                                     writeln(extensionType);
      <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">if</span> <span class="op">not</span> dataWritten <span class="keywd">then</span>
        writeln(<span class="stri">"Data: "</span> &lt;&amp; literal(data));
      <span class="keywd">end</span> <span class="keywd">if</span>;
      incr(index);
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showClientHello (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">integer</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: beyond <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: vectorLen <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    writeln(<span class="stri">"client_hello"</span>);
    length := bytes2Int(stri[pos fixLen 3], UNSIGNED, BE);
    pos +:= 3;
    writeln(<span class="stri">"Length: "</span> &lt;&amp; length);
    beyond := pos + length;
    writeln(<span class="stri">"Bytes there: "</span> &lt;&amp; length(stri) - pos + 1);
    writeln(<span class="stri">"Version: "</span> &lt;&amp; ord(stri[pos]) &lt;&amp; <span class="stri">"."</span> &lt;&amp; ord(stri[succ(pos)]));
    pos +:= 2;
    writeln(<span class="stri">"Random: "</span> &lt;&amp; hex(stri[12 len 32]));
    pos +:= 32;
    vectorLen := ord(stri[pos]);
    incr(pos);
    writeln(<span class="stri">"SessionId: "</span> &lt;&amp; hex(stri[pos len vectorLen]));
    pos +:= vectorLen;
    vectorLen := bytes2Int(stri[pos fixLen 2], UNSIGNED, BE) <span class="op">mdiv</span> 2;
    writeln(<span class="stri">"Number of Ciphers: "</span> &lt;&amp; vectorLen);
    pos +:= 2;
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> vectorLen <span class="keywd">do</span>
      writeln(<span class="stri">"Cipher-"</span> &lt;&amp; index &lt;&amp; <span class="stri">": "</span> &lt;&amp;
              bytes2Int(stri[pos fixLen 2], UNSIGNED, BE) radix 16 <span class="op">lpad0</span> 4);
      pos +:= 2;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    vectorLen := ord(stri[pos]);
    writeln(<span class="stri">"Number of CompressionMethods: "</span> &lt;&amp; vectorLen);
    incr(pos);
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> vectorLen <span class="keywd">do</span>
      writeln(<span class="stri">"CompressionMethod-"</span> &lt;&amp; index &lt;&amp; <span class="stri">": "</span> &lt;&amp; ord(stri[pos]));
      incr(pos);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> pos &lt;= beyond - 2 <span class="keywd">then</span>
      showExtensions(stri, pos);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(<span class="stri">"Final pos: "</span> &lt;&amp; pos);
    writeln(<span class="stri">"Leftover bytes: "</span> &lt;&amp; literal(stri[pos ..]));
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showServerHello (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">integer</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: beyond <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: sessionIdLen <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    writeln(<span class="stri">"server_hello"</span>);
    length := bytes2Int(stri[pos fixLen 3], UNSIGNED, BE);
    pos +:= 3;
    writeln(<span class="stri">"Length: "</span> &lt;&amp; length);
    beyond := pos + length;
    writeln(<span class="stri">"Bytes there: "</span> &lt;&amp; length(stri) - pos + 1);
    writeln(<span class="stri">"Version: "</span> &lt;&amp; ord(stri[pos]) &lt;&amp; <span class="stri">"."</span> &lt;&amp; ord(stri[succ(pos)]));
    pos +:= 2;
    writeln(<span class="stri">"Random: "</span> &lt;&amp; hex(stri[12 len 32]));
    pos +:= 32;
    sessionIdLen := ord(stri[pos]);
    incr(pos);
    writeln(<span class="stri">"SessionId: "</span> &lt;&amp; hex(stri[pos len sessionIdLen]));
    pos +:= sessionIdLen;
    writeln(<span class="stri">"Cipher: "</span> &lt;&amp;
            bytes2Int(stri[pos fixLen 2], UNSIGNED, BE) radix 16 <span class="op">lpad0</span> 4);
    pos +:= 2;
    writeln(<span class="stri">"CompressionMethod: "</span> &lt;&amp; ord(stri[pos]));
    incr(pos);
    <span class="keywd">if</span> pos &lt;= beyond - 2 <span class="keywd">then</span>
      showExtensions(stri, pos);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(<span class="stri">"Final pos: "</span> &lt;&amp; pos);
    writeln(<span class="stri">"Leftover bytes: "</span> &lt;&amp; literal(stri[pos ..]));
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Shows the content of a X.509 public key certificate.
 *  This function can be used to debug the library tls.s7i.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: showX509Cert (<span class="op">in</span> <span class="type">x509Cert</span>: cert) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">tbsCertificateType</span>: tbsCertificate <span class="keywd">is</span> tbsCertificateType.value;
    <span class="keywd">var</span> <span class="type">string</span>: aKey <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">string</span>: publicKey <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    tbsCertificate := cert.tbsCertificate;
    writeln(<span class="stri">"Version: "</span> &lt;&amp; tbsCertificate.version);
    writeln(<span class="stri">"SerialNumber: "</span> &lt;&amp; literal(tbsCertificate.serialNumber));
    writeln(<span class="stri">"Signature algorithm: "</span> &lt;&amp; literal(tbsCertificate.signature.algorithm));
    writeln(<span class="stri">"Signature parameters: "</span> &lt;&amp; literal(tbsCertificate.signature.parameters));
    <span class="keywd">for</span> aKey <span class="keywd">range</span> keys(tbsCertificate.issuer) <span class="keywd">do</span>
      writeln(<span class="stri">"Issuer "</span> &lt;&amp; literal(aKey) &lt;&amp; <span class="stri">": "</span> &lt;&amp; tbsCertificate.issuer[aKey]);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    writeln(<span class="stri">"Valid not before: "</span> &lt;&amp; tbsCertificate.validity.notBefore);
    writeln(<span class="stri">"Valid not after: "</span> &lt;&amp; tbsCertificate.validity.notAfter);
    <span class="keywd">for</span> aKey <span class="keywd">range</span> keys(tbsCertificate.subject) <span class="keywd">do</span>
      writeln(<span class="stri">"Subject "</span> &lt;&amp; literal(aKey) &lt;&amp; <span class="stri">": "</span> &lt;&amp; tbsCertificate.subject[aKey]);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    writeln(<span class="stri">"Algorithm: "</span> &lt;&amp; literal(tbsCertificate.subjectPublicKeyInfo.algorithm.algorithm));
    write(<span class="stri">"Algorithm: "</span>);
    <span class="keywd">for</span> number <span class="keywd">range</span> decodeObjectIdentifier(tbsCertificate.subjectPublicKeyInfo.algorithm.algorithm) <span class="keywd">do</span>
      write(number &lt;&amp; <span class="stri">" "</span>);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    writeln;
    writeln(<span class="stri">"Algorithm parameters: "</span> &lt;&amp; literal(tbsCertificate.subjectPublicKeyInfo.algorithm.parameters));
    write(<span class="stri">"Algorithm parameters: "</span>);
    <span class="keywd">if</span> tbsCertificate.subjectPublicKeyInfo.algorithm.parameters &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      <span class="keywd">for</span> number <span class="keywd">range</span> decodeObjectIdentifier(tbsCertificate.subjectPublicKeyInfo.algorithm.parameters) <span class="keywd">do</span>
        write(number &lt;&amp; <span class="stri">" "</span>);
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln;
    writeln(<span class="stri">"Public key: "</span> &lt;&amp; literal(tbsCertificate.subjectPublicKeyInfo.subjectPublicKey));
    publicKey := tbsCertificate.subjectPublicKeyInfo.subjectPublicKey;
    writeln(<span class="stri">"Length of public key: "</span> &lt;&amp; length(publicKey));
    <span class="keywd">if</span> tbsCertificate.subjectPublicKeyInfo.algorithm.algorithm = RSA_ENCRYPTION_OID <span class="keywd">then</span>
      <span class="keywd">while</span> pos &lt; length(publicKey) <span class="keywd">do</span>
        printAsn1(publicKey, pos);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      writeln(<span class="stri">"rsa public key modulus:  "</span> &lt;&amp; tbsCertificate.subjectPublicKeyInfo.publicRsaKey.modulus radix 16);
      writeln(<span class="stri">"rsa public modulus len:  "</span> &lt;&amp; bitLength(tbsCertificate.subjectPublicKeyInfo.publicRsaKey.modulus));
      writeln(<span class="stri">"rsa public key exponent: "</span> &lt;&amp; tbsCertificate.subjectPublicKeyInfo.publicRsaKey.exponent radix 16);
    <span class="keywd">elsif</span> tbsCertificate.subjectPublicKeyInfo.algorithm.algorithm = EC_PUBLIC_KEY <span class="keywd">then</span>
      writeln(<span class="stri">"Elliptic curve: "</span> &lt;&amp;
              getEllipticCurveFromOid(tbsCertificate.subjectPublicKeyInfo.algorithm.parameters).name);
      writeln(<span class="stri">"publicEccKey.x: "</span> &lt;&amp; tbsCertificate.subjectPublicKeyInfo.publicEccKey.x radix 16);
      writeln(<span class="stri">"publicEccKey.y: "</span> &lt;&amp; tbsCertificate.subjectPublicKeyInfo.publicEccKey.y radix 16);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showCertificate (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">integer</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: sequenceLen <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: certLen <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">x509Cert</span>: cert <span class="keywd">is</span> x509Cert.value;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">x509Cert</span>: certList <span class="keywd">is</span> 0 <span class="op">times</span> x509Cert.value;
  <span class="keywd">begin</span>
    writeln(<span class="stri">"certificate: "</span> &lt;&amp; literal(stri));
    length := bytes2Int(stri[pos fixLen 3], UNSIGNED, BE);
    pos +:= 3;
    writeln(<span class="stri">"Length: "</span> &lt;&amp; length);
    writeln(<span class="stri">"Bytes there: "</span> &lt;&amp; length(stri) - pos + 1);
    sequenceLen := bytes2Int(stri[pos fixLen 3], UNSIGNED, BE);
    pos +:= 3;
    writeln(<span class="stri">"Sequence length: "</span> &lt;&amp; sequenceLen);
    writeln(<span class="stri">"Bytes there: "</span> &lt;&amp; length(stri) - pos + 1);
    <span class="keywd">while</span> pos &lt;= 3 + sequenceLen <span class="keywd">do</span>
      certLen := bytes2Int(stri[pos fixLen 3], UNSIGNED, BE);
      pos +:= 3;
      writeln(<span class="stri">"ASN.1Cert-"</span> &lt;&amp; index &lt;&amp; <span class="stri">" length: "</span> &lt;&amp; certLen);
      writeln(<span class="stri">"ASN.1Cert-"</span> &lt;&amp; index &lt;&amp; <span class="stri">": "</span> &lt;&amp; literal(stri[pos len certLen]));
      <span class="comment"># Activate if details of the ASN should be printed:</span>
      <span class="comment"># printAsn1(stri[pos len certLen]);</span>
      cert := getX509Cert(stri[pos len certLen]);
      showX509Cert(cert);
      certList &amp;:= cert;
      pos +:= certLen;
      incr(index);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    writeln(<span class="stri">"Final pos: "</span> &lt;&amp; pos);
    writeln(<span class="stri">"Leftover bytes: "</span> &lt;&amp; literal(stri[pos ..]));
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> pred(length(certList)) <span class="keywd">do</span>
      writeln(<span class="stri">"validate Cert-"</span> &lt;&amp; index &lt;&amp; <span class="stri">" with Cert-"</span> &lt;&amp; succ(index));
      writeln(validateSignature(certList[index], certList[succ(index)].tbsCertificate.subjectPublicKeyInfo));
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="comment"># writeln("validate Cert-" &lt;&amp; length(certList) &lt;&amp; " with Cert-" &lt;&amp; length(certList));</span>
    <span class="comment"># writeln(validateSignature(certList[length(certList)], certList[length(certList)].tbsCertificate.subjectPublicKeyInfo.publicRsaKey));</span>
    <span class="comment"># publicKey := certList[1].tbsCertificate.subjectPublicKeyInfo.publicRsaKey;</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showServerKeyExchange (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">integer</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: beyond <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: curveNumber <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">ellipticCurve</span>: curve <span class="keywd">is</span> ellipticCurve.value;
    <span class="keywd">var</span> <span class="type">integer</span>: pointLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: pointData <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">ecPoint</span>: publicEccKey <span class="keywd">is</span> ecPoint.value;
    <span class="keywd">var</span> <span class="type">integer</span>: signatureAlgorithm <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: signatureLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: intLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: signatureStri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    writeln(<span class="stri">"server_key_exchange"</span>);
    length := bytes2Int(stri[pos fixLen 3], UNSIGNED, BE);
    pos +:= 3;
    writeln(<span class="stri">"Length: "</span> &lt;&amp; length);
    beyond := pos + length;
    writeln(<span class="stri">"Bytes there: "</span> &lt;&amp; length(stri) - pos + 1);
    <span class="comment"># if parameters.key_exchange_algorithm = EC_DIFFIE_HELLMAN then</span>
      <span class="keywd">if</span> stri[pos] = NAMED_CURVE <span class="keywd">then</span>
        incr(pos);
        curveNumber := bytes2Int(stri[pos fixLen 2], UNSIGNED, BE);
        pos +:= 2;
        writeln(<span class="stri">"named curve: "</span> &lt;&amp; curveNumber);
        <span class="keywd">if</span> curveNumber >= minIdx(curveByNumber) <span class="op">and</span> curveNumber &lt;= maxIdx(curveByNumber) <span class="keywd">then</span>
          curve := curveByNumber[curveNumber];
        <span class="keywd">end</span> <span class="keywd">if</span>;
        pointLength := ord(stri[pos]);
        writeln(<span class="stri">"pointLength: "</span> &lt;&amp; pointLength);
        incr(pos);
        pointData := stri[pos len pointLength];
        writeln(<span class="stri">"publicEccKey: "</span> &lt;&amp; hex(pointData));
        publicEccKey := ecPointDecode(curve, pointData);
        writeln(<span class="stri">"publicEccKey.x: "</span> &lt;&amp; publicEccKey.x radix 16);
        writeln(<span class="stri">"publicEccKey.y: "</span> &lt;&amp; publicEccKey.y radix 16);
        pos +:= pointLength;
        signatureAlgorithm := bytes2Int(stri[pos fixLen 2], UNSIGNED, BE);
        writeln(<span class="stri">"signatureAlgorithm: "</span> &lt;&amp; signatureAlgorithm radix 16 <span class="op">lpad0</span> 4);
        pos +:= 2;
        signatureLength := bytes2Int(stri[pos fixLen 2], UNSIGNED, BE);
        writeln(<span class="stri">"signatureLength: "</span> &lt;&amp; signatureLength);
        pos +:= 2;
        signatureStri := stri[pos len signatureLength];
        writeln(<span class="stri">"signatureStri: "</span> &lt;&amp; hex(signatureStri));
        pos +:= signatureLength;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="comment"># end if;</span>
    writeln(<span class="stri">"Final pos: "</span> &lt;&amp; pos);
    writeln(<span class="stri">"Leftover bytes: "</span> &lt;&amp; literal(stri[pos ..]));
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showCertificateRequest (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">integer</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: version <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: certificateTypesLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: supportedSignatureAlgorithmsLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: certificateAuthoritiesLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: certificateAuthorities <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    writeln(<span class="stri">"certificate_request"</span>);
    version := stri[pos - 5 len 2];
    writeln(<span class="stri">"Version: "</span> &lt;&amp; ord(stri[pos - 5]) &lt;&amp; <span class="stri">"."</span> &lt;&amp; ord(stri[pos - 4]));
    length := bytes2Int(stri[pos fixLen 3], UNSIGNED, BE);
    pos +:= 3;
    writeln(<span class="stri">"length: "</span> &lt;&amp; length);
    writeln(<span class="stri">"Bytes there: "</span> &lt;&amp; length(stri) - pos + 1);
    certificateTypesLength := ord(stri[pos]);
    incr(pos);
    writeln(<span class="stri">"certificateTypesLength: "</span> &lt;&amp; certificateTypesLength);
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> certificateTypesLength <span class="keywd">do</span>
      writeln(<span class="stri">"ClientCertificateType "</span> &lt;&amp; index &lt;&amp; <span class="stri">": "</span> &lt;&amp; ord(stri[pos]));
      incr(pos);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> version >= TLS_1_2 <span class="keywd">then</span>
      supportedSignatureAlgorithmsLength := bytes2Int(stri[pos fixLen 2], UNSIGNED, BE);
      pos +:= 2;
      writeln(<span class="stri">"supportedSignatureAlgorithmsLength: "</span> &lt;&amp; supportedSignatureAlgorithmsLength);
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> supportedSignatureAlgorithmsLength <span class="op">div</span> 2 <span class="keywd">do</span>
        writeln(<span class="stri">" supportedSignatureAlgorithm "</span> &lt;&amp; index &lt;&amp; <span class="stri">": "</span> &lt;&amp;
                ord(stri[pos]) <span class="op">lpad0</span> 2 &lt;&amp; <span class="stri">" "</span> &lt;&amp; ord(stri[succ(pos)]) <span class="op">lpad0</span> 2);
        pos +:= 2;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    certificateAuthoritiesLength := bytes2Int(stri[pos fixLen 2], UNSIGNED, BE);
    pos +:= 2;
    writeln(<span class="stri">"certificateAuthoritiesLength: "</span> &lt;&amp; certificateAuthoritiesLength);
    certificateAuthorities := stri[pos len certificateAuthoritiesLength];
    pos +:= certificateAuthoritiesLength;
    writeln(literal(certificateAuthorities));
    writeln(<span class="stri">"Final pos: "</span> &lt;&amp; pos);
    writeln(<span class="stri">"Leftover bytes: "</span> &lt;&amp; literal(stri[pos ..]));
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showServerHelloDone (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">integer</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    writeln(<span class="stri">"server_hello_done"</span>);
    length := bytes2Int(stri[pos fixLen 3], UNSIGNED, BE);
    pos +:= 3;
    writeln(<span class="stri">"Length: "</span> &lt;&amp; length);
    writeln(<span class="stri">"Bytes there: "</span> &lt;&amp; length(stri) - pos + 1);
    writeln(<span class="stri">"Final pos: "</span> &lt;&amp; pos);
    writeln(<span class="stri">"Leftover bytes: "</span> &lt;&amp; literal(stri[pos ..]));
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showCertificateVerify (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">integer</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    writeln(<span class="stri">"certificate_verify"</span>);
    length := bytes2Int(stri[pos fixLen 3], UNSIGNED, BE);
    pos +:= 3;
    writeln(<span class="stri">"Length: "</span> &lt;&amp; length);
    writeln(<span class="stri">"Bytes there: "</span> &lt;&amp; length(stri) - pos + 1);
    writeln(<span class="stri">"Data: "</span> &lt;&amp; literal(stri[pos len length]));
    pos +:= length;
    writeln(<span class="stri">"Final pos: "</span> &lt;&amp; pos);
    writeln(<span class="stri">"Leftover bytes: "</span> &lt;&amp; literal(stri[pos ..]));
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showClientKeyExchange (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">integer</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    writeln(<span class="stri">"client_key_exchange"</span>);
    length := bytes2Int(stri[pos fixLen 3], UNSIGNED, BE);
    pos +:= 3;
    writeln(<span class="stri">"Length: "</span> &lt;&amp; length);
    writeln(<span class="stri">"Bytes there: "</span> &lt;&amp; length(stri) - pos + 1);
    writeln(<span class="stri">"exchange_keys: "</span> &lt;&amp; hex(stri[pos len length]));
    pos +:= length;
    writeln(<span class="stri">"Final pos: "</span> &lt;&amp; pos);
    writeln(<span class="stri">"Leftover bytes: "</span> &lt;&amp; literal(stri[pos ..]));
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showFinished (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">integer</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    writeln(<span class="stri">"finished"</span>);
    length := bytes2Int(stri[pos fixLen 3], UNSIGNED, BE);
    pos +:= 3;
    writeln(<span class="stri">"Length: "</span> &lt;&amp; length);
    writeln(<span class="stri">"Bytes there: "</span> &lt;&amp; length(stri) - pos + 1);
    writeln(<span class="stri">"verify_data: "</span> &lt;&amp; hex(stri[pos len length]));
    pos +:= length;
    writeln(<span class="stri">"Final pos: "</span> &lt;&amp; pos);
    writeln(<span class="stri">"Leftover bytes: "</span> &lt;&amp; literal(stri[pos ..]));
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Shows the content of a TLS handshake message.
 *  This function can be used to debug the library tls.s7i.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: showHandshakeMsg (<span class="op">in</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: handshakeType <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    handshakeType := stri[pos];
    incr(pos);
    write(<span class="stri">"HandshakeType: "</span>);
    <span class="keywd">if</span> handshakeType = CLIENT_HELLO <span class="keywd">then</span>
      showClientHello(stri, pos);
    <span class="keywd">elsif</span> handshakeType = SERVER_HELLO <span class="keywd">then</span>
      showServerHello(stri, pos);
    <span class="keywd">elsif</span> handshakeType = CERTIFICATE <span class="keywd">then</span>
      showCertificate(stri, pos);
    <span class="keywd">elsif</span> handshakeType = SERVER_KEY_EXCHANGE <span class="keywd">then</span>
      showServerKeyExchange(stri, pos);
    <span class="keywd">elsif</span> handshakeType = CERTIFICATE_REQUEST <span class="keywd">then</span>
      showCertificateRequest(stri, pos);
    <span class="keywd">elsif</span> handshakeType = SERVER_HELLO_DONE <span class="keywd">then</span>
      showServerHelloDone(stri, pos);
    <span class="keywd">elsif</span> handshakeType = CERTIFICATE_VERIFY <span class="keywd">then</span>
      showCertificateVerify(stri, pos);
    <span class="keywd">elsif</span> handshakeType = CLIENT_KEY_EXCHANGE <span class="keywd">then</span>
      showClientKeyExchange(stri, pos);
    <span class="keywd">elsif</span> handshakeType = FINISHED <span class="keywd">then</span>
      showFinished(stri, pos);
    <span class="keywd">else</span>
      writeln(ord(handshakeType));
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showHandshake (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"handshake"</span>);
    writeln(<span class="stri">"Version: "</span> &lt;&amp; ord(stri[2]) &lt;&amp; <span class="stri">"."</span> &lt;&amp; ord(stri[3]));
    writeln(<span class="stri">"Length: "</span> &lt;&amp; bytes2Int(stri[4 fixLen 2], UNSIGNED, BE));
    writeln(<span class="stri">"Bytes there: "</span> &lt;&amp; length(stri) - 5);
    <span class="keywd">if</span> bytes2Int(stri[4 fixLen 2], UNSIGNED, BE) &lt;> length(stri) - 5 <span class="keywd">then</span>
      writeln(<span class="stri">" ***** TLS record length not ok"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> bytes2Int(stri[7 fixLen 3], UNSIGNED, BE) > length(stri) - 9 <span class="keywd">then</span>
      writeln(<span class="stri">" ***** TLS handshake length not ok"</span>);
      writeln(<span class="stri">"handshake length field: "</span> &lt;&amp; literal(stri[7 len 3]));
      writeln(<span class="stri">"handshake length from field: "</span> &lt;&amp; bytes2Int(stri[7 fixLen 3], UNSIGNED, BE));
      writeln(<span class="stri">"actual length: "</span> &lt;&amp; length(stri) - 9);
      writeln(<span class="stri">"record length field: "</span> &lt;&amp; literal(stri[4 len 2]));
      writeln(<span class="stri">"HandshakeType: "</span> &lt;&amp; ord(stri[6]));
    <span class="keywd">else</span>
      showHandshakeMsg(stri, 6);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showApplicationData (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"application data"</span>);
    writeln(<span class="stri">"Version: "</span> &lt;&amp; ord(stri[2]) &lt;&amp; <span class="stri">"."</span> &lt;&amp; ord(stri[3]));
    writeln(<span class="stri">"Length: "</span> &lt;&amp; bytes2Int(stri[4 fixLen 2], UNSIGNED, BE));
    writeln(<span class="stri">"Bytes there: "</span> &lt;&amp; length(stri) - 5);
    writeln(<span class="stri">"Data: "</span> &lt;&amp; literal(stri[6 ..]));
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Shows the content of a TLS message.
 *  This function can be used to debug the library tls.s7i.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: showTlsMsg (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"MsgLength: "</span> &lt;&amp; length(stri));
    <span class="keywd">if</span> length(stri) &lt;> 0 <span class="keywd">then</span>
      write(<span class="stri">"ContentType: "</span>);
      <span class="keywd">if</span> stri[1] = CHANGE_CIPHER_SPEC <span class="keywd">then</span>
        showChangeCipherSpec(stri);
      <span class="keywd">elsif</span> stri[1] = ALERT <span class="keywd">then</span>
        showAlert(stri);
      <span class="keywd">elsif</span> stri[1] = HANDSHAKE <span class="keywd">then</span>
        showHandshake(stri);
      <span class="keywd">elsif</span> stri[1] = APPLICATION_DATA <span class="keywd">then</span>
        showApplicationData(stri);
      <span class="keywd">else</span>
        writeln(ord(stri[1]));
        writeln(<span class="stri">"Final pos: 1"</span>);
        writeln(<span class="stri">"Leftover bytes: "</span> &lt;&amp; literal(stri));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Shows the message type of a TLS message.
 *  This function can be used to debug the library tls.s7i.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: showTlsMsgType (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(stri) &lt;> 0 <span class="keywd">then</span>
      <span class="keywd">if</span> stri[1] = CHANGE_CIPHER_SPEC <span class="keywd">then</span>
        writeln(<span class="stri">"ChangeCipherSpec"</span>);
      <span class="keywd">elsif</span> stri[1] = ALERT <span class="keywd">then</span>
        writeln(<span class="stri">"Alert"</span>);
      <span class="keywd">elsif</span> stri[1] = HANDSHAKE <span class="keywd">then</span>
        <span class="keywd">if</span> stri[6] = CLIENT_HELLO <span class="keywd">then</span>
          writeln(<span class="stri">"ClientHello"</span>);
        <span class="keywd">elsif</span> stri[6] = SERVER_HELLO <span class="keywd">then</span>
          writeln(<span class="stri">"ServerHello"</span>);
        <span class="keywd">elsif</span> stri[6] = SESSION_TICKET <span class="keywd">then</span>
          writeln(<span class="stri">"NewSessionTicket"</span>);
        <span class="keywd">elsif</span> stri[6] = CERTIFICATE <span class="keywd">then</span>
          writeln(<span class="stri">"Certificate"</span>);
        <span class="keywd">elsif</span> stri[6] = SERVER_KEY_EXCHANGE <span class="keywd">then</span>
          writeln(<span class="stri">"ServerKeyExchange"</span>);
        <span class="keywd">elsif</span> stri[6] = CERTIFICATE_REQUEST <span class="keywd">then</span>
          writeln(<span class="stri">"CertificateRequest"</span>);
        <span class="keywd">elsif</span> stri[6] = SERVER_HELLO_DONE <span class="keywd">then</span>
          writeln(<span class="stri">"ServerHelloDone"</span>);
        <span class="keywd">elsif</span> stri[6] = CERTIFICATE_VERIFY <span class="keywd">then</span>
          writeln(<span class="stri">"CertificateVerify"</span>);
        <span class="keywd">elsif</span> stri[6] = CLIENT_KEY_EXCHANGE <span class="keywd">then</span>
          writeln(<span class="stri">"ClientKeyExchange"</span>);
        <span class="keywd">elsif</span> stri[6] = FINISHED <span class="keywd">then</span>
          writeln(<span class="stri">"Finished"</span>);
        <span class="keywd">else</span>
          writeln(<span class="stri">"Handshake "</span> &lt;&amp; ord(stri[6]));
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> stri[1] = APPLICATION_DATA <span class="keywd">then</span>
        writeln(<span class="stri">"ApplicationData"</span>);
      <span class="keywd">else</span>
        writeln(ord(stri[1]));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
