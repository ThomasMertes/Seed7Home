<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  scanstri.s7i  String scanner functions                          *)</span>
<span class="comment">(*  Copyright (C) 2007 - 2011, 2013, 2019, 2021  Thomas Mertes      *)</span>
<span class="comment">(*  Copyright (C) 2023  Thomas Mertes                               *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/chartype.htm">chartype.s7i</a>"</span>;


<span class="comment">(**
 *  Skips a possibly nested comment from a [[string]].
 *  The comment starts with (* and ends with *) . When the function
 *  is called it is assumed that stri[1] contains the '*' of the
 *  comment start. When the function is left ''stri'' is empty or
 *  stri[1] contains the character after the ')'.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: skipComment (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">repeat</span>
      <span class="keywd">repeat</span>
        <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] <span class="op">not</span> <span class="op">in</span> special_comment_char <span class="keywd">do</span>
          incr(pos);
        <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'('</span> <span class="keywd">then</span>
          incr(pos);
          <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'*'</span> <span class="keywd">then</span>
            stri := stri[pos ..];
            skipComment(stri);
            leng := length(stri);
            pos := 1;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] = <span class="stri">'*'</span>;
      <span class="keywd">if</span> pos &lt;= leng <span class="keywd">then</span>
        incr(pos);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] = <span class="stri">')'</span>;
    stri := stri[succ(pos) ..];
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># skipComment</span>


<span class="comment">(**
 *  Reads a possibly nested comment from a [[string]].
 *  The comment starts with (* and ends with *) . When the function
 *  is called it is assumed that stri[1] contains the '*' of the
 *  comment start. When the function is left ''stri'' is empty or
 *  stri[1] contains the character after the ')'.
 *  @return the content of the comment, including the introducing (*
 *          and the ending *) .
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getComment (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">"("</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">repeat</span>
      <span class="keywd">repeat</span>
        <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] <span class="op">not</span> <span class="op">in</span> special_comment_char <span class="keywd">do</span>
          incr(pos);
        <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'('</span> <span class="keywd">then</span>
          incr(pos);
          <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'*'</span> <span class="keywd">then</span>
            symbol &amp;:= stri[.. pos - 2];
            stri := stri[pos ..];
            symbol &amp;:= getComment(stri);
            leng := length(stri);
            pos := 1;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] = <span class="stri">'*'</span>;
      <span class="keywd">if</span> pos &lt;= leng <span class="keywd">then</span>
        incr(pos);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] = <span class="stri">')'</span>;
    symbol &amp;:= stri[.. pos];
    stri := stri[succ(pos) ..];
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># getComment</span>


<span class="comment">(**
 *  Skips a classic C comment from a [[string]].
 *  The comment starts with /* and ends with */ . In a classic
 *  C comment no nesting of comments is allowed. When the function
 *  is called it is assumed that stri[1] contains the '*'
 *  of the comment start.  When the function is left ''stri''
 *  is empty or stri[1] contains the character after the '/'.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: skipClassicComment (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 2;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">repeat</span>
      <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] &lt;> <span class="stri">'*'</span> <span class="keywd">do</span>
        incr(pos);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      incr(pos);
    <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] = <span class="stri">'/'</span>;
    stri := stri[succ(pos) ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Skips a line comment from a [[string]].
 *  A line comment starts with an introducing character (like '#')
 *  and ends with the end of the line. When the function is called
 *  it is assumed that ''stri'' is empty or stri[1] contains the
 *  introducing character (e.g. '#'). When the function is left
 *  ''stri'' is empty or stri[1] contains the line end character
 *  ('\n').
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: skipLineComment (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">repeat</span>
      incr(pos);
    <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] = <span class="stri">'\n'</span>;
    stri := stri[pos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># skipLineComment</span>


<span class="comment">(**
 *  Reads a line comment from a [[string]].
 *  A line comment starts with an introducing character (like '#')
 *  and ends with the end of the line. When the function is called
 *  it is assumed that ''stri'' is empty or stri[1] contains the
 *  introducing character (e.g. '#'). When the function is left
 *  ''stri'' is empty or stri[1] contains the line end character
 *  ('\n').
 *  @return the content of the comment, including the start marker
 *          (e.g. '#') but without line end character ('\n').
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getLineComment (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">repeat</span>
      incr(pos);
    <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] = <span class="stri">'\n'</span>;
    symbol := stri[.. pred(pos)];
    stri := stri[pos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># getLineComment</span>


<span class="comment">(**
 *  Reads a sequence of digits from a [[string]].
 *  When the function is called it is assumed that ''stri'' is empty or
 *  stri[1] contains the first character to be handled. When the
 *  function is left ''stri'' is empty or stri[1] contains the character
 *  after the digits.
 *  @return the digit sequence, and
 *          "" if no digit was found.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getDigits (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] >= <span class="stri">'0'</span> <span class="op">and</span> stri[pos] &lt;= <span class="stri">'9'</span> <span class="keywd">do</span>
      incr(pos);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    symbol := stri[.. pred(pos)];
    stri := stri[pos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads a decimal integer with optional sign from a [[string]].
 *  A decimal integer accepted by ''getInteger'' consists of an optional
 *  + or - sign followed by a possibly empty sequence of digits. Because
 *  of the LL(1) approach, a sign without following digits is accepted.
 *  When the function is called it is assumed that ''stri'' is empty or
 *  stri[1] contains the first character to be handled. When the
 *  function is left ''stri'' is empty or stri[1] contains the character
 *  after the integer.
 *  @return the decimal integer string, and
 *          "" if no integer was found.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getInteger (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> (stri[pos] = <span class="stri">'-'</span> <span class="op">or</span> stri[pos] = <span class="stri">'+'</span>) <span class="keywd">then</span>
      incr(pos);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] >= <span class="stri">'0'</span> <span class="op">and</span> stri[pos] &lt;= <span class="stri">'9'</span> <span class="keywd">do</span>
      incr(pos);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    symbol := stri[.. pred(pos)];
    stri := stri[pos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads a numeric literal from a [[string]].
 *  When the function is called it is assumed that ''stri'' is empty or
 *  stri[1] contains the introducing digit. When the function is left
 *  ''stri'' is empty or stri[1] contains the character after the
 *  literal.
 *  @return The function returns the numeric literal.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getNumber (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] <span class="op">in</span> digit_char <span class="keywd">do</span>
      incr(pos);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'.'</span> <span class="keywd">then</span>
      <span class="comment"># float literal</span>
      incr(pos);
      <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] <span class="op">in</span> digit_char <span class="keywd">do</span>
        incr(pos);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> (stri[pos] = <span class="stri">'E'</span> <span class="op">or</span> stri[pos] = <span class="stri">'e'</span>) <span class="keywd">then</span>
        incr(pos);
        <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'+'</span> <span class="keywd">then</span>
          incr(pos);
        <span class="keywd">elsif</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'-'</span> <span class="keywd">then</span>
          incr(pos);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] <span class="op">in</span> digit_char <span class="keywd">do</span>
          incr(pos);
        <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'#'</span> <span class="keywd">then</span>
      <span class="comment"># based integer literal</span>
      incr(pos);
      <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] <span class="op">in</span> alphanum_char <span class="keywd">do</span>
        incr(pos);
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">elsif</span> pos &lt;= leng <span class="op">and</span> (stri[pos] = <span class="stri">'E'</span> <span class="op">or</span> stri[pos] = <span class="stri">'e'</span>) <span class="keywd">then</span>
      <span class="comment"># integer literal with exponent</span>
      incr(pos);
      <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> (stri[pos] = <span class="stri">'+'</span> <span class="op">or</span> stri[pos] = <span class="stri">'-'</span>) <span class="keywd">then</span>
        incr(pos);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] <span class="op">in</span> digit_char <span class="keywd">do</span>
        incr(pos);
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">elsif</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'_'</span> <span class="keywd">then</span>
      <span class="comment"># bigInteger literal</span>
      incr(pos);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    symbol := stri[.. pred(pos)];
    stri := stri[pos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads a sequence of non digits from a [[string]].
 *  When the function is called it is assumed that ''stri'' is empty or
 *  stri[1] contains the first character to be handled. When the
 *  function is left ''stri'' is empty or stri[1] contains a digit.
 *  @return the non digit sequence, and
 *          "" if a digit was found.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getNonDigits (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> (stri[pos] &lt; <span class="stri">'0'</span> <span class="op">or</span> stri[pos] > <span class="stri">'9'</span>) <span class="keywd">do</span>
      incr(pos);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    symbol := stri[.. pred(pos)];
    stri := stri[pos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads a text quoted with " or ' from a [[string]].
 *  The introducing and the closing character ( " or ' ) of the quoted
 *  text must be identical. When the function is called it is assumed
 *  that stri[1] contains the introducing " or ' . When the function
 *  is left ''stri'' is empty or stri[1] contains the character after
 *  the closing character.
 *  @return the string literal without introducing or closing
 *          characters ( " or ' ).
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getQuotedText (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">char</span>: quoteChar <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    quoteChar := stri[1];
    leng := length(stri);
    <span class="keywd">repeat</span>
      incr(pos);
    <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] = quoteChar;
    symbol := stri[2 .. pred(pos)];
    stri := stri[succ(pos) ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Read a space terminated command line word, from a [[string]].
 *  Before reading the word it skips whitespace characters. A command
 *  line word can consist of unquoted and quoted parts. A quoted part
 *  is introduced with double quotes (") and ends with unescaped
 *  double quotes. A \ (backslash) is used to escape characters that
 *  would terminate the word respectively the quoted part. The
 *  backslash is ignored and the character after it is added to the
 *  word. To represent a backslash it must be doubled. When the
 *  function is left ''stri'' is empty or stri[1] contains the character
 *  after the terminating space. Examples:
 *   stri := "a b c";        # getCommandLineWord(stri) returns "a"
 *   stri := "a\\ b c";      # getCommandLineWord(stri) returns "a b"
 *   stri := " a b c";       # getCommandLineWord(stri) returns "a"
 *   stri := "\\ a b c";     # getCommandLineWord(stri) returns " a"
 *   stri := "a\\\"b c";     # getCommandLineWord(stri) returns "a\"b"
 *   stri := "a\" b\" c";    # getCommandLineWord(stri) returns "a b"
 *   stri := "\"a b\" c";    # getCommandLineWord(stri) returns "a b"
 *   stri := " \"a\" b c";   # getCommandLineWord(stri) returns "a"
 *   stri := "\" a\" b c";   # getCommandLineWord(stri) returns " a"
 *   stri := " \" a\" b c";  # getCommandLineWord(stri) returns " a"
 *   stri := "\"a\\\"b\" c"; # getCommandLineWord(stri) returns "a\"b"
 *   stri := "a\\\\b c";     # getCommandLineWord(stri) returns "a\\b"
 *  @return the space terminated word (without terminating space).
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getCommandLineWord (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">' '</span> <span class="keywd">do</span>
      incr(pos);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] &lt;> <span class="stri">' '</span> <span class="keywd">do</span>
      <span class="keywd">if</span> stri[pos] = <span class="stri">'"'</span> <span class="keywd">then</span>
        incr(pos);
        <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] &lt;> <span class="stri">'"'</span> <span class="keywd">do</span>
          <span class="keywd">if</span> stri[pos] = <span class="stri">'\\'</span> <span class="op">and</span> pos &lt; leng <span class="keywd">then</span>
            incr(pos);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          symbol &amp;:= stri[pos];
          incr(pos);
        <span class="keywd">end</span> <span class="keywd">while</span>;
        incr(pos);
      <span class="keywd">else</span>
        <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] &lt;> <span class="stri">' '</span> <span class="op">and</span> stri[pos] &lt;> <span class="stri">'"'</span> <span class="keywd">do</span>
          <span class="keywd">if</span> stri[pos] = <span class="stri">'\\'</span> <span class="op">and</span> pos &lt; leng <span class="keywd">then</span>
            incr(pos);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          symbol &amp;:= stri[pos];
          incr(pos);
        <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    stri := stri[succ(pos) ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Read a simple [[string]] literal from a [[string]].
 *  A simple string literal is enclosed in delimiter characters
 *  (e.g. " or ' ). Delimiter characters within the simple string
 *  literal must be doubled. A simple string literal does not
 *  support an escape character. All characters, including control
 *  characters (e.g. linefeed) are allowed inside a simple string
 *  literal. When the function is called it is assumed that
 *  stri[1] contains the introducing delimiter character.
 *  When the function is left ''stri'' is empty or stri[1]
 *  contains the character after the closing delimiter.
 *  @return the string literal including the introducing and
 *          closing delimiter character. Double delimiter chars in
 *          the literal are converted to single delimiter chars.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getSimpleStringLiteral (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: delimiter <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    leng := length(stri);
    delimiter := stri[1];
    symbol := str(delimiter);
    <span class="keywd">repeat</span>
      incr(pos);
      <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] &lt;> delimiter <span class="keywd">do</span>
        symbol &amp;:= stri[pos];
        incr(pos);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">if</span> pos &lt;= leng <span class="keywd">then</span>
        incr(pos);
        <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] = delimiter <span class="keywd">then</span>
          symbol &amp;:= delimiter;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] &lt;> delimiter;
    symbol &amp;:= delimiter;
    stri := stri[pos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads an escape sequence from ''stri'' and appends it to ''symbol''.
 *  The function accepts escape sequences from character and string
 *  literals. When the function is called it is assumed that stri[1]
 *  contains the introducing \ . When the function is left stri[1]
 *  contains the character after the escape sequence. The complete
 *  escape sequence including the introducing \ is appended to
 *  ''symbol''.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: getEscapeSequence (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">integer</span>: pos, <span class="keywd">inout</span> <span class="type">string</span>: symbol) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: semicolonPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: numberStri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    leng := length(stri);
    symbol &amp;:= <span class="stri">"\\"</span>;
    incr(pos);
    <span class="keywd">if</span> pos &lt;= leng <span class="keywd">then</span>
      <span class="keywd">if</span> stri[pos] = <span class="stri">'\n'</span> <span class="op">or</span> stri[pos] = <span class="stri">' '</span> <span class="op">or</span> stri[pos] = <span class="stri">'\t'</span> <span class="op">or</span> stri[pos] = <span class="stri">'\r'</span> <span class="keywd">then</span>
        <span class="keywd">repeat</span>
          symbol &amp;:= stri[pos];
          incr(pos);
        <span class="keywd">until</span> pos > leng <span class="op">or</span>
            stri[pos] &lt;> <span class="stri">'\n'</span> <span class="op">and</span> stri[pos] &lt;> <span class="stri">' '</span> <span class="op">and</span> stri[pos] &lt;> <span class="stri">'\t'</span> <span class="op">and</span> stri[pos] &lt;> <span class="stri">'\r'</span>;
        <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'\\'</span> <span class="keywd">then</span>
          symbol &amp;:= stri[pos];
          incr(pos);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> stri[pos] <span class="op">in</span> digit_char <span class="keywd">then</span>
        semicolonPos := pos(stri, <span class="stri">';'</span>, succ(pos));
        <span class="keywd">if</span> semicolonPos &lt;> 0 <span class="keywd">then</span>
          numberStri := stri[pos .. pred(semicolonPos)];
        <span class="keywd">else</span>
          numberStri := stri[pos ..];
        <span class="keywd">end</span> <span class="keywd">if</span>;
        symbol &amp;:= getNumber(numberStri);
        <span class="keywd">if</span> numberStri = <span class="stri">""</span> <span class="keywd">then</span>
          symbol &amp;:= <span class="stri">";"</span>;
          pos := succ(semicolonPos);
        <span class="keywd">else</span>
          pos := semicolonPos - length(numberStri);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        symbol &amp;:= stri[pos];
        incr(pos);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads a character literal from a [[string]].
 *  When the function is called it is assumed that stri[1] contains
 *  the introducing ' . When the function is left ''stri'' is empty or
 *  stri[1] contains the character after the closing ' .
 *  @return the character literal including the introducing ' and
 *          the closing ' .
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getCharLiteral (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">"'"</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 2;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] &lt;> <span class="stri">'\n'</span> <span class="op">and</span> stri[pos] &lt;> <span class="stri">'\r'</span> <span class="keywd">then</span>
      <span class="keywd">if</span> stri[pos] = <span class="stri">'\\'</span> <span class="keywd">then</span>
        <span class="keywd">repeat</span>
          getEscapeSequence(stri, pos, symbol);
        <span class="keywd">until</span> stri[pos] &lt;> <span class="stri">'\\'</span>;
      <span class="keywd">else</span>
        symbol &amp;:= stri[pos];
        incr(pos);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> pos > leng <span class="op">or</span> stri[pos] &lt;> <span class="stri">'\''</span> <span class="keywd">then</span>
        <span class="keywd">if</span> stri[pos] &lt;> <span class="stri">'\n'</span> <span class="op">and</span> stri[pos] &lt;> <span class="stri">'\r'</span> <span class="keywd">then</span>
          <span class="keywd">repeat</span>
            symbol &amp;:= stri[pos];
            incr(pos);
          <span class="keywd">until</span> pos > leng <span class="op">or</span>
              stri[pos] = <span class="stri">'\''</span> <span class="op">or</span>
              stri[pos] = <span class="stri">'\n'</span> <span class="op">or</span>
              stri[pos] = <span class="stri">'\r'</span>;
          <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'\''</span> <span class="keywd">then</span>
            symbol &amp;:= stri[pos];
            incr(pos);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        symbol &amp;:= stri[pos];
        incr(pos);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    stri := stri[pos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads a string literal from a [[string]].
 *  When the function is called it is assumed that stri[1] contains
 *  the introducing " . When the function is left ''stri'' is empty or
 *  stri[1] contains the character after the closing " .
 *  @return the string literal including the introducing " and the
 *          closing " .
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getStringLiteral (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">"\""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">boolean</span>: reading_string <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    leng := length(stri);
    incr(pos);
    <span class="keywd">repeat</span>
      <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] <span class="op">in</span> no_escape_char <span class="keywd">do</span>
        symbol &amp;:= stri[pos];
        incr(pos);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">if</span> pos > leng <span class="op">or</span> stri[pos] = <span class="stri">'\n'</span> <span class="op">or</span> stri[pos] = <span class="stri">'\r'</span> <span class="keywd">then</span>
        reading_string := FALSE;
      <span class="keywd">elsif</span> stri[pos] = <span class="stri">'\"'</span> <span class="keywd">then</span>
        symbol &amp;:= stri[pos];
        incr(pos);
        <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'\"'</span> <span class="keywd">then</span>
          symbol &amp;:= stri[pos];
          incr(pos);
        <span class="keywd">else</span>
          reading_string := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> stri[pos] = <span class="stri">'\\'</span> <span class="keywd">then</span>
        getEscapeSequence(stri, pos, symbol);
      <span class="keywd">else</span>
        <span class="keywd">repeat</span>
          symbol &amp;:= stri[pos];
          incr(pos);
        <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] >= <span class="stri">' '</span> <span class="op">or</span> stri[pos] &lt;= <span class="stri">'~'</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> <span class="op">not</span> reading_string;
    stri := stri[pos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads the text of a string literal from a [[string]].
 *  When the function is called it is assumed that stri[1] contains
 *  the introducing " . When the function is left ''stri'' is empty or
 *  stri[1] contains the character after the closing " .
 *  @return the text of the string literal without introducing or
 *          closing " .
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getCStringLiteralText (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: startPos <span class="keywd">is</span> 2;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 2;
    <span class="keywd">var</span> <span class="type">boolean</span>: reading_string <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">integer</span>: charValue <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">repeat</span>
      startPos := pos;
      <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] <span class="op">in</span> no_escape_char <span class="keywd">do</span>
        incr(pos);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      symbol &amp;:= stri[startPos .. pred(pos)];
      <span class="keywd">if</span> pos > leng <span class="op">or</span> stri[pos] = <span class="stri">'\n'</span> <span class="op">or</span> stri[pos] = <span class="stri">'\r'</span> <span class="keywd">then</span>
        reading_string := FALSE;
      <span class="keywd">elsif</span> stri[pos] = <span class="stri">'\"'</span> <span class="keywd">then</span>
        incr(pos);
        <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'\"'</span> <span class="keywd">then</span>
          symbol &amp;:= stri[pos];
          incr(pos);
        <span class="keywd">else</span>
          reading_string := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> stri[pos] = <span class="stri">'\\'</span> <span class="keywd">then</span>
        incr(pos);
        <span class="keywd">if</span> pos &lt;= leng <span class="keywd">then</span>
          <span class="keywd">case</span> stri[pos] <span class="keywd">of</span>
            <span class="keywd">when</span> {<span class="stri">'a'</span>}:
              symbol &amp;:= <span class="stri">"\a"</span>;
              incr(pos);
            <span class="keywd">when</span> {<span class="stri">'b'</span>}:
              symbol &amp;:= <span class="stri">"\b"</span>;
              incr(pos);
            <span class="keywd">when</span> {<span class="stri">'f'</span>}:
              symbol &amp;:= <span class="stri">"\f"</span>;
              incr(pos);
            <span class="keywd">when</span> {<span class="stri">'n'</span>}:
              symbol &amp;:= <span class="stri">"\n"</span>;
              incr(pos);
            <span class="keywd">when</span> {<span class="stri">'r'</span>}:
              symbol &amp;:= <span class="stri">"\r"</span>;
              incr(pos);
            <span class="keywd">when</span> {<span class="stri">'t'</span>}:
              symbol &amp;:= <span class="stri">"\t"</span>;
              incr(pos);
            <span class="keywd">when</span> {<span class="stri">'v'</span>}:
              symbol &amp;:= <span class="stri">"\v"</span>;
              incr(pos);
            <span class="keywd">when</span> {<span class="stri">'\\'</span>, <span class="stri">'?'</span>, <span class="stri">'''</span>, <span class="stri">'"'</span>}:
              symbol &amp;:= stri[pos];
              incr(pos);
            <span class="keywd">when</span> octdigit_char:
              incr(pos);
              <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] <span class="op">in</span> octdigit_char <span class="keywd">then</span>
                incr(pos);
                <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] <span class="op">in</span> octdigit_char <span class="keywd">then</span>
                  charValue := integer(stri[pos - 2 fixLen 3], 8);
                  incr(pos);
                <span class="keywd">else</span>
                  charValue := integer(stri[pos - 2 fixLen 2], 8);
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">else</span>
                charValue := integer(stri[pred(pos) fixLen 1], 8);
              <span class="keywd">end</span> <span class="keywd">if</span>;
              symbol &amp;:= chr(charValue);
            <span class="keywd">when</span> {<span class="stri">'x'</span>}:
              incr(pos);
              <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] <span class="op">in</span> hexdigit_char <span class="keywd">then</span>
                incr(pos);
                <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] <span class="op">in</span> hexdigit_char <span class="keywd">then</span>
                  charValue := integer(stri[pred(pos) fixLen 2], 16);
                  incr(pos);
                <span class="keywd">else</span>
                  charValue := integer(stri[pred(pos) fixLen 1], 16);
                <span class="keywd">end</span> <span class="keywd">if</span>;
                symbol &amp;:= chr(charValue);
              <span class="keywd">else</span>
                symbol &amp;:= <span class="stri">"\\x"</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">otherwise</span>:
              symbol &amp;:= <span class="stri">"\\"</span>;
          <span class="keywd">end</span> <span class="keywd">case</span>;
        <span class="keywd">else</span>
          symbol &amp;:= <span class="stri">"\\"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        <span class="keywd">repeat</span>
          symbol &amp;:= stri[pos];
          incr(pos);
        <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] >= <span class="stri">' '</span> <span class="op">or</span> stri[pos] &lt;= <span class="stri">'~'</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> <span class="op">not</span> reading_string;
    stri := stri[pos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads an alphanumeric name from a [[string]].
 *  A name consists of a letter or underscore followed by letters,
 *  digits or underscores. When the function is called it is assumed
 *  that ''stri'' is empty or stri[1] contains the first character to be
 *  handled. When the function is left ''stri'' is empty or stri[1]
 *  contains the character after the name.
 *  @return the name, and
 *          "" if no letter or underscore was found.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getName (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] <span class="op">in</span> name_start_char <span class="keywd">then</span>
      incr(pos);
      <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] <span class="op">in</span> name_char <span class="keywd">do</span>
        incr(pos);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      symbol := stri[.. pred(pos)];
      stri := stri[pos ..];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Skips space characters from a [[string]].
 *  When the function is called it is assumed that ''stri'' is empty or
 *  stri[1] contains the first character to be handled. When the
 *  function is left ''stri'' is empty or stri[1] contains the character
 *  after the space characters.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: skipSpace (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">if</span> leng >= 1 <span class="op">and</span> stri[1] = <span class="stri">' '</span> <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        incr(pos);
      <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] &lt;> <span class="stri">' '</span>;
      stri := stri[pos ..];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Skips space and tab characters from a [[string]].
 *  When the function is called it is assumed that ''stri'' is empty or
 *  stri[1] contains the first character to be handled. When the
 *  function is left ''stri'' is empty or stri[1] contains the character
 *  after the sequence of space and tab characters.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: skipSpaceOrTab (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">if</span> leng >= 1 <span class="op">and</span> (stri[1] = <span class="stri">' '</span> <span class="op">or</span> stri[1] = <span class="stri">'\t'</span>) <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        incr(pos);
      <span class="keywd">until</span> pos > leng <span class="op">or</span> (stri[pos] &lt;> <span class="stri">' '</span> <span class="op">and</span> stri[pos] &lt;> <span class="stri">'\t'</span>);
      stri := stri[pos ..];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Skips whitespace characters from a [[string]].
 *  When the function is called it is assumed that ''stri'' is empty or
 *  stri[1] contains the first character to be handled. When the
 *  function is left ''stri'' is empty or stri[1] contains the character
 *  after the whitespace characters.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: skipWhiteSpace (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] <span class="op">in</span> white_space_char <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        incr(pos);
      <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] <span class="op">not</span> <span class="op">in</span> white_space_char;
      stri := stri[pos ..];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads whitespace characters from a [[string]].
 *  When the function is called it is assumed that ''stri'' is empty or
 *  stri[1] contains the first character to be handled. When the
 *  function is left ''stri'' is empty or stri[1] contains the character
 *  after the whitespace characters.
 *  @return the string of whitespace characters, and
 *          "" if no whitespace character was found.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getWhiteSpace (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] <span class="op">in</span> white_space_char <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        incr(pos);
      <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] <span class="op">not</span> <span class="op">in</span> white_space_char;
      symbol := stri[.. pred(pos)];
      stri := stri[pos ..];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads a white space delimited word from a [[string]].
 *  Before reading the word it skips whitespace characters. A word is
 *  a sequence of characters which does not contain a whitespace
 *  character. When the function is called it is assumed that ''stri''
 *  is empty or stri[1] contains the first character to be handled.
 *  When the function is left ''stri'' is empty or stri[1] contains the
 *  character after the word.
 *  @return the word, and
 *          "" if no word was found.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getWord (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: start <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">while</span> start &lt;= leng <span class="op">and</span> stri[start] <span class="op">in</span> white_space_char <span class="keywd">do</span>
      incr(start);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> start &lt;= leng <span class="keywd">then</span>
      pos := start;
      <span class="keywd">repeat</span>
        incr(pos);
      <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] <span class="op">in</span> white_space_char;
      symbol := stri[start .. pred(pos)];
      stri := stri[pos ..];
    <span class="keywd">else</span>
      stri := <span class="stri">""</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Skips a line from a [[string]].
 *  When the function is called it is assumed that ''stri'' is empty or
 *  stri[1] contains the first character to be handled. When the
 *  function is left ''stri'' is empty or stri[1] contains '\n'.
 *  If stri[1] already contains '\n' nothing is done.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: skipLine (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    pos := pos(stri, <span class="stri">'\n'</span>);
    <span class="keywd">if</span> pos &lt;> 0 <span class="keywd">then</span>
      stri := stri[pos ..];
    <span class="keywd">else</span>
      stri := <span class="stri">""</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads a line from a [[string]].
 *  When the function is called it is assumed that ''stri'' is empty or
 *  stri[1] contains the first character to be handled. When the
 *  function is left ''stri'' is empty or stri[1] contains '\n'.
 *  If stri[1] already contains '\n' nothing is done and the
 *  function returns "" .
 *  @return the line read, and
 *          "" if ''stri'' is empty or stri[1] contains '\n'.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getLine (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    pos := pos(stri, <span class="stri">'\n'</span>);
    <span class="keywd">if</span> pos &lt;> 0 <span class="keywd">then</span>
      symbol := stri[.. pred(pos)];
      stri := stri[pos ..];
    <span class="keywd">else</span>
      symbol := stri;
      stri := <span class="stri">""</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads a symbol or a comment from a [[string]].
 *  Before reading the symbol or comment it skips whitespace
 *  characters. A symbol can be a literal (numeric, character or
 *  string), a name, a special symbol (sequence of special characters)
 *  or a parenthesis. A comment can be a normal comment or a line
 *  comment. When the function is called it is assumed that ''stri'' is
 *  empty or stri[1] contains a whitespace character or the first
 *  character of a symbol or comment. When the function is left ''stri''
 *  is empty or stri[1] contains the character after the symbol or
 *  comment.
 *  @return the symbol or comment, and
 *          "" if the end of ''stri'' was reached.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getSymbolOrComment (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: start <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">while</span> start &lt;= leng <span class="op">and</span> stri[start] <span class="op">in</span> white_space_char <span class="keywd">do</span>
      incr(start);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> start &lt;= leng <span class="keywd">then</span>
      pos := start;
      <span class="keywd">case</span> stri[pos] <span class="keywd">of</span>
        <span class="keywd">when</span> name_start_char:
          <span class="keywd">repeat</span>
            incr(pos);
          <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] <span class="op">not</span> <span class="op">in</span> name_char;
          symbol := stri[start .. pred(pos)];
          stri := stri[pos ..];
        <span class="keywd">when</span> special_char:
          <span class="keywd">repeat</span>
            incr(pos);
          <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] <span class="op">not</span> <span class="op">in</span> special_char;
          symbol := stri[start .. pred(pos)];
          stri := stri[pos ..];
        <span class="keywd">when</span> left_paren_char:
          stri := stri[succ(pos) ..];
          <span class="keywd">if</span> pos &lt;= length(stri) <span class="op">and</span> stri[pos] = <span class="stri">'*'</span> <span class="keywd">then</span>
            symbol := getComment(stri);
          <span class="keywd">else</span>
            symbol := <span class="stri">"("</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> other_paren_char:
          symbol := stri[pos fixLen 1];
          stri := stri[succ(pos) ..];
        <span class="keywd">when</span> digit_char:
          stri := stri[pos ..];
          symbol := getNumber(stri);
        <span class="keywd">when</span> single_quotation_char:
          stri := stri[pos ..];
          symbol := getCharLiteral(stri);
        <span class="keywd">when</span> double_quotation_char:
          stri := stri[pos ..];
          symbol := getStringLiteral(stri);
        <span class="keywd">when</span> sharp_char:
          stri := stri[pos ..];
          symbol := getLineComment(stri);
        <span class="keywd">otherwise</span>:
          incr(pos);
          symbol := stri[start .. pred(pos)];
          stri := stri[pos ..];
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">else</span>
      stri := <span class="stri">""</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads a symbol from a [[string]].
 *  Before reading the symbol it skips whitespace characters and
 *  comments (normal comments and line comments). A symbol can be a
 *  literal (numeric, character or string), a name, a special symbol
 *  (sequence of special characters) or a parenthesis. When the
 *  function is called it is assumed that ''stri'' is empty or stri[1]
 *  contains a whitespace character or the first character of a symbol
 *  or comment. When the function is left ''stri'' is empty or stri[1]
 *  contains the character after the symbol.
 *  @return the symbol, and
 *          "" if end of ''stri'' was reached.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getSymbol (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: start <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">while</span> start &lt;= leng <span class="op">and</span> stri[start] <span class="op">in</span> white_space_char <span class="keywd">do</span>
      incr(start);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> start &lt;= leng <span class="keywd">then</span>
      pos := start;
      <span class="keywd">case</span> stri[pos] <span class="keywd">of</span>
        <span class="keywd">when</span> name_start_char:
          <span class="keywd">repeat</span>
            incr(pos);
          <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] <span class="op">not</span> <span class="op">in</span> name_char;
          symbol := stri[start .. pred(pos)];
          stri := stri[pos ..];
        <span class="keywd">when</span> special_char:
          <span class="keywd">repeat</span>
            incr(pos);
          <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] <span class="op">not</span> <span class="op">in</span> special_char;
          symbol := stri[start .. pred(pos)];
          stri := stri[pos ..];
        <span class="keywd">when</span> left_paren_char:
          stri := stri[succ(pos) ..];
          <span class="keywd">if</span> length(stri) >= 1 <span class="op">and</span> stri[1] = <span class="stri">'*'</span> <span class="keywd">then</span>
            skipComment(stri);
            symbol := getSymbol(stri);
          <span class="keywd">else</span>
            symbol := <span class="stri">"("</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> other_paren_char:
          symbol := stri[pos fixLen 1];
          stri := stri[succ(pos) ..];
        <span class="keywd">when</span> digit_char:
          stri := stri[pos ..];
          symbol := getNumber(stri);
        <span class="keywd">when</span> single_quotation_char:
          stri := stri[pos ..];
          symbol := getCharLiteral(stri);
        <span class="keywd">when</span> double_quotation_char:
          stri := stri[pos ..];
          symbol := getStringLiteral(stri);
        <span class="keywd">when</span> sharp_char:
          <span class="keywd">repeat</span>
            incr(pos);
          <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] = <span class="stri">'\n'</span>;
          stri := stri[pos ..];
        <span class="keywd">otherwise</span>:
          incr(pos);
          symbol := stri[start .. pred(pos)];
          stri := stri[pos ..];
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">else</span>
      stri := <span class="stri">""</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Skips an XML comment from a [[string]].
 *  The XML comment starts with &lt;!-- and ends with --> . When the
 *  function is called it is assumed that stri[1] contains the
 *  last '-' of the introducing &lt;!-- . When the function is left
 *  ''stri'' is empty or stri[1] contains the character after --> .
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: skipXmlComment (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">boolean</span>: endOfCommentReached <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">repeat</span>
      <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] &lt;> <span class="stri">'-'</span> <span class="keywd">do</span>
        incr(pos);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">if</span> pos &lt;= leng <span class="keywd">then</span>
        <span class="comment"># stri[pos] = '-'</span>
        incr(pos);
        <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'-'</span> <span class="keywd">then</span>
          <span class="keywd">repeat</span>
            incr(pos);
          <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] &lt;> <span class="stri">'-'</span>;
          <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'>'</span> <span class="keywd">then</span>
            incr(pos);
            endOfCommentReached := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> endOfCommentReached <span class="op">or</span> pos > leng;
    stri := stri[pos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads an XML/HTML tag or the XML/HTML content text from a [[string]].
 *  An XML/HTML tag starts with &lt; and ends with > . The content text
 *  starts with everything else and ends just before a &lt; or with the end
 *  of ''stri''. When the function is called it is assumed that stri[1]
 *  contains the introducing &lt; of an XML/HTML tag or the first character
 *  of the content text. When the function is left the character after
 *  the XML/HTML tag or the content text is in stri[1].
 *  @return the XML/HTML tag or XML/HTML content text, and
 *          "" if the end of ''stri'' was reached.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getXmlTagOrContent (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">if</span> pos &lt;= leng <span class="keywd">then</span>
      <span class="keywd">if</span> stri[pos] = <span class="stri">'&lt;'</span> <span class="keywd">then</span>
        <span class="keywd">repeat</span>
          incr(pos);
        <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] = <span class="stri">'>'</span>;
        symbol := stri[.. pos];
        stri := stri[succ(pos) ..];
      <span class="keywd">else</span>
        <span class="keywd">repeat</span>
          incr(pos);
        <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] = <span class="stri">'&lt;'</span>;
        symbol := stri[.. pred(pos)];
        stri := stri[pos ..];
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Read the content text of a CDATA section.
 *  In a CDATA section the text between &lt;![CDATA[ and ]]> is considered
 *  content text. Inside a CDATA section the characters &lt; and &amp; have no
 *  special meaning. All occurances of &lt; and &amp; inside CDATA are returned
 *  as &amp;lt; and &amp;amp; respectively. When the function is called it is
 *  assumed that ''stri'' is empty or stri[1] contains the first character
 *  after the introducing &lt;![CDATA[ sequence. When the function is left
 *  ''stri'' is empty or stri[1] contains the character after final
 *  ]]> sequence.
 *  @param stri Input [[string]] from which the consumed characters are removed.
 *  @return the content text of the CDATA section that has been read.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getXmlCdataContent (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: cdata <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">char</span>: character <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">repeat</span>
      <span class="keywd">repeat</span>
        <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] &lt;> <span class="stri">']'</span> <span class="keywd">do</span>
          character :=  stri[pos];
          <span class="keywd">if</span> character = <span class="stri">'&lt;'</span> <span class="keywd">then</span>
            cdata &amp;:= <span class="stri">"&amp;lt;"</span>;
          <span class="keywd">elsif</span> character = <span class="stri">'&amp;'</span> <span class="keywd">then</span>
            cdata &amp;:= <span class="stri">"&amp;amp;"</span>;
          <span class="keywd">else</span>
            cdata &amp;:= character;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          incr(pos);
        <span class="keywd">end</span> <span class="keywd">while</span>;
        incr(pos);
        <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] &lt;> <span class="stri">']'</span> <span class="keywd">then</span>
          cdata &amp;:= <span class="stri">']'</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] = <span class="stri">']'</span>;
      incr(pos);
      <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] &lt;> <span class="stri">'>'</span> <span class="keywd">then</span>
        cdata &amp;:= <span class="stri">"]]"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] = <span class="stri">'>'</span>;
    incr(pos);
    stri := stri[pos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads an XML/HTML tag head or an XML/HTML content from a [[string]].
 *  Examples of XML/HTML tag heads are:
 *   &lt;html
 *   &lt;meta
 *   &lt;table
 *   &lt;/span
 *  Before reading a tag head or content, it skips whitespace characters
 *  and XML comments. An XML/HTML tag head starts with &lt; and ends
 *  before a > or a / or a whitespace character or the end of ''stri''.
 *  The content text starts with a non whitespace character and ends
 *  just before a &lt; or with the end of ''stri''. Content text can be
 *  also in a CDATA section. In a CDATA section the text between
 *  &lt;![CDATA[ and ]]> is considered content text. Inside a CDATA section
 *  the characters &lt; and &amp; have no special meaning. All occurances of
 *  &lt; and &amp; inside CDATA are returned as &amp;lt; and &amp;amp; respectively.
 *  When the function is called it is assumed that ''stri'' is empty
 *  or stri[1] contains either a whitespace character, the introducing
 *  &lt; of an XML/HTML tag or the first character of the content text.
 *  When the function is left, ''stri'' is empty or stri[1] contains
 *  the character after the XML/HTML tag head or the content text.
 *  Text between &lt;!-- and --> is considered an XML comment. An XML
 *  comment is ignored and getXmlTagHeadOrContent() is called recursive.
 *  The function can be used as follows:
 *   symbol := getXmlTagHeadOrContent(stri);
 *   if startsWith(symbol, "&lt;/") then
 *     ... handle the XML/HTML end-tag ...
 *   elsif startsWith(symbol, "&lt;") then
 *     ... handle the attributes of the XML/HTML start-tag ...
 *   else
 *     ... handle the content text ...
 *   end if;
 *  @param stri Input [[string]] from which the consumed characters are removed.
 *  @return the XML/HTML tag head or XML/HTML content text, and
 *          "" if the end of ''stri'' was reached.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getXmlTagHeadOrContent (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: start <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">boolean</span>: finished <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">while</span> start &lt;= leng <span class="op">and</span> stri[start] <span class="op">in</span> white_space_char <span class="keywd">do</span>
      incr(start);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'&lt;'</span> <span class="keywd">then</span>
      incr(pos);
      <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'!'</span> <span class="keywd">then</span>
        incr(pos);
        <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'-'</span> <span class="keywd">then</span>
          incr(pos);
          <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'-'</span> <span class="keywd">then</span>
            stri := stri[pos ..];
            skipXmlComment(stri);
            symbol := getXmlTagHeadOrContent(stri);
            finished  := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'['</span> <span class="keywd">then</span>
          symbol := <span class="stri">"&lt;!["</span>;
          incr(pos);
          <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] <span class="op">in</span> letter_char <span class="keywd">do</span>
            symbol &amp;:= stri[pos];
            incr(pos);
          <span class="keywd">end</span> <span class="keywd">while</span>;
          <span class="keywd">if</span> symbol = <span class="stri">"&lt;![CDATA"</span> <span class="op">and</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'['</span> <span class="keywd">then</span>
            incr(pos);
            stri := stri[pos ..];
            symbol := getXmlCdataContent(stri);
            <span class="keywd">if</span> symbol = <span class="stri">""</span> <span class="keywd">then</span>
              symbol := getXmlTagHeadOrContent(stri);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            finished  := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> pos &lt;= leng <span class="op">and</span> stri[pos] = <span class="stri">'/'</span> <span class="keywd">then</span>
        incr(pos);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> <span class="op">not</span> finished <span class="keywd">then</span>
        <span class="keywd">if</span> pos &lt;= leng <span class="op">and</span> (isLetter(stri[pos]) <span class="op">or</span> stri[pos] = <span class="stri">'_'</span>) <span class="keywd">then</span>
          <span class="keywd">repeat</span>
            incr(pos);
          <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] <span class="op">in</span> white_space_char <span class="op">or</span>
              stri[pos] = <span class="stri">'>'</span> <span class="op">or</span> stri[pos] = <span class="stri">'/'</span>;
          symbol := stri[start .. pred(pos)];
        <span class="keywd">else</span>
          <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] &lt;> <span class="stri">'&lt;'</span> <span class="keywd">do</span>
            incr(pos);
          <span class="keywd">end</span> <span class="keywd">while</span>;
          symbol := <span class="stri">"&amp;lt;"</span> &amp; stri[succ(start) .. pred(pos)];
        <span class="keywd">end</span> <span class="keywd">if</span>;
        stri := stri[pos ..];
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      <span class="keywd">repeat</span>
        incr(pos);
      <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] = <span class="stri">'&lt;'</span>;
      symbol := stri[start .. pred(pos)];
      stri := stri[pos ..];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;

<span class="comment">(**
 *  Reads a symbol which can appear inside an XML/HTML tag from [[string]].
 *  Before reading the symbol it skips whitespace characters. A symbol
 *  inside an XML/HTML tag can be a name, a string literal (quoted with "
 *  or ' ), the equals sign (=), the end of tag character (>), the slash
 *  character (/) or a special symbol (a sequence of characters that
 *  does not include the character > or a whitespace character). Special
 *  symbols can only appear in HTML tags. When the function is called it
 *  is assumed that ''stri'' is empty or stri[1] contains a whitespace
 *  character or the first character of a symbol. When the function is
 *  left ''stri'' is empty or stri[1] contains the character after the
 *  symbol.
 *  @param stri Input [[string]] from which the consumed characters are removed.
 *  @return the symbol, and
 *          "" if the end of ''stri'' was reached.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getSymbolInXmlTag (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: start <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">while</span> start &lt;= leng <span class="op">and</span> stri[start] <span class="op">in</span> white_space_char <span class="keywd">do</span>
      incr(start);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> start &lt;= leng <span class="keywd">then</span>
      pos := start;
      <span class="keywd">case</span> stri[pos] <span class="keywd">of</span>
        <span class="keywd">when</span> html_name_start_char:
          <span class="keywd">repeat</span>
            incr(pos);
          <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] <span class="op">not</span> <span class="op">in</span> html_name_char;
          symbol := stri[start .. pred(pos)];
          stri := stri[pos ..];
        <span class="keywd">when</span> double_quotation_char:
          <span class="keywd">repeat</span>
            incr(pos);
          <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] = <span class="stri">'"'</span>;
          symbol := stri[succ(start) .. pred(pos)];
          stri := stri[succ(pos) ..];
        <span class="keywd">when</span> single_quotation_char:
          <span class="keywd">repeat</span>
            incr(pos);
          <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] = <span class="stri">'''</span>;
          symbol := stri[succ(start) .. pred(pos)];
          stri := stri[succ(pos) ..];
        <span class="keywd">when</span> equals_or_end_tag:
          symbol := stri[pos fixLen 1];
          stri := stri[succ(pos) ..];
        <span class="keywd">otherwise</span>:
          <span class="keywd">repeat</span>
            incr(pos);
          <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] <span class="op">in</span> white_space_or_end_tag;
          symbol := stri[start .. pred(pos)];
          stri := stri[pos ..];
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">else</span>
      stri := <span class="stri">""</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Skips beyond an XML Tag in a [[string]].
 *  When the function is left ''stri'' is empty or stri[1] contains
 *  the character after '>'.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: skipXmlTag (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      symbol := getSymbolInXmlTag(stri);
    <span class="keywd">until</span> symbol = <span class="stri">">"</span> <span class="op">or</span> symbol = <span class="stri">""</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Skips beyond an XML Tag in a [[string]].
 *  The parameter ''symbol'' is used to provide the current symbol
 *  which possibly can be ">" or "". When the function is left
 *  ''stri'' is empty or stri[1] contains the character after '>'.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: skipXmlTag (<span class="keywd">inout</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: symbol) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">while</span> symbol &lt;> <span class="stri">">"</span> <span class="op">and</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      symbol := getSymbolInXmlTag(stri);
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads name and value of an attribute inside an XML tag from a [[string]].
 *  The function skips possible leading whitespace characters. Attribute
 *  name and value are returned in ''attributeName'' and ''attributeValue''
 *  respectively. Attribute assignments can have the following forms:
 *   aName="aValue"
 *   aName='aValue'
 *  Surrounding single or double quotes of the attribute value are omitted.
 *  It is a syntax error if an attribute value is not quoted. White
 *  space characters before and after the = are ignored. XML entities
 *  in ''attributeValue'' are left as is. If no more attributes are
 *  present in the XML tag ''attributeName'' is set to "". In this case
 *  ''attributeValue'' contains the end of the XML tag (">" or "/>") and
 *  ''stri'' is empty or stri[1] contains the character after '>'.
 *  If a syntax error occurs the function skips beyond the end of
 *  the XML tag (''stri'' is empty or stri[1] contains the character
 *  after '>'). To indicate the syntax error ''attributeName'' is
 *  set to "" and ''attributeValue'' is set to a symbol shortly before
 *  the error (this will never be ">" or "/>"). The attributes of
 *  an XML start-tag or empty-element tag can be processed with:
 *   getNextXmlAttribute(stri, attributeName, attributeValue);
 *   while attributeName &lt;> "" do
 *     ... process the current attribute ...
 *     getNextXmlAttribute(stri, attributeName, attributeValue);
 *   end while;
 *   if attributeValue = "/>" then
 *     ... this is an empty-element tag ...
 *   elsif attributeValue = ">" then
 *     ... this is a start-tag ...
 *   else
 *     ... there is a syntax error ...
 *   end if;
 *  @param stri Input [[string]] from which the consumed characters are removed.
 *  @param attributeName Destination for the attribute name.
 *  @param attributeValue Destination for the attribute value:
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: getNextXmlAttribute (<span class="keywd">inout</span> <span class="type">string</span>: stri,
    <span class="keywd">inout</span> <span class="type">string</span>: attributeName, <span class="keywd">inout</span> <span class="type">string</span>: attributeValue) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    attributeName := getSymbolInXmlTag(stri);
    <span class="keywd">if</span> attributeName = <span class="stri">"/"</span> <span class="keywd">then</span>
      attributeName := <span class="stri">""</span>;
      attributeValue := getSymbolInXmlTag(stri);
      <span class="keywd">if</span> attributeValue = <span class="stri">">"</span> <span class="keywd">then</span>
        attributeValue := <span class="stri">"/>"</span>;
      <span class="keywd">else</span>
        attributeValue := <span class="stri">"/"</span>;
        skipXmlTag(stri, attributeValue);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> attributeName = <span class="stri">">"</span> <span class="keywd">then</span>
      attributeName := <span class="stri">""</span>;
      attributeValue := <span class="stri">">"</span>;
    <span class="keywd">else</span>
      attributeValue := getSymbolInXmlTag(stri);
      <span class="keywd">if</span> attributeValue = <span class="stri">"="</span> <span class="keywd">then</span>
        attributeValue := getSymbolInXmlTag(stri);
        <span class="keywd">if</span>  startsWith(attributeValue, <span class="stri">"\""</span>) <span class="op">or</span>
            startsWith(attributeValue, <span class="stri">"'"</span>) <span class="keywd">then</span>
          attributeValue := attributeValue[2 ..];
        <span class="keywd">else</span>
          attributeValue := attributeName;
          attributeName := <span class="stri">""</span>;
          skipXmlTag(stri, attributeValue);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        attributeValue := attributeName;
        attributeName := <span class="stri">""</span>;
        skipXmlTag(stri, attributeValue);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads a HTML tag attribute value from a [[string]].
 *  Before reading the value it skips whitespace characters. A HTML
 *  tag attribute value can be quoted with " or ' or it is terminated
 *  with the character > or a whitespace character. When the function
 *  is called it is assumed that ''stri'' is empty or stri[1] contains
 *  a whitespace character or the first character of a value. When the
 *  function is left ''stri'' is empty or stri[1] contains the character
 *  after the attribute value.
 *  @param stri Input [[string]] from which the consumed characters are removed.
 *  @return the attribute value, and
 *          "" if the end of the HTML tag or the end of ''stri'' is
 *              directly after the skipped whitespace characters.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getHtmlAttributeValue (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: attributeValue <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: start <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">while</span> start &lt;= leng <span class="op">and</span> stri[start] <span class="op">in</span> white_space_char <span class="keywd">do</span>
      incr(start);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> start &lt;= leng <span class="keywd">then</span>
      pos := start;
      <span class="keywd">case</span> stri[pos] <span class="keywd">of</span>
        <span class="keywd">when</span> double_quotation_char:
          <span class="keywd">repeat</span>
            incr(pos);
          <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] = <span class="stri">'"'</span>;
          attributeValue := stri[succ(start) .. pred(pos)];
          stri := stri[succ(pos) ..];
        <span class="keywd">when</span> single_quotation_char:
          <span class="keywd">repeat</span>
            incr(pos);
          <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] = <span class="stri">'''</span>;
          attributeValue := stri[succ(start) .. pred(pos)];
          stri := stri[succ(pos) ..];
        <span class="keywd">when</span> {<span class="stri">'>'</span>}:
          stri := stri[pos ..];
        <span class="keywd">otherwise</span>:
          <span class="keywd">repeat</span>
            incr(pos);
          <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] <span class="op">in</span> white_space_or_end_tag;
          attributeValue := stri[start .. pred(pos)];
          stri := stri[pos ..];
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">else</span>
      stri := <span class="stri">""</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads name and value of an attribute inside a HTML tag from a [[string]].
 *  The function skips possible leading whitespace characters. Attribute
 *  name and value are returned in ''attributeName'' and ''attributeValue''
 *  respectively. Attribute assignments can have the following forms:
 *   aName="aValue"
 *   aName='aValue'
 *   aName=aValue
 *   aName
 *  Possible surrounding single or double quotes of the attribute value
 *  are omitted. White space characters before and after the = are
 *  ignored. HTML entities in ''attributeValue'' are left as is.
 *  If no more attributes are present in the XML tag ''attributeName''
 *  is set to "". In this case ''attributeValue'' contains the end of
 *  the HTML tag (">" or "/>") and ''stri'' is empty or stri[1] contains
 *  the character after '>'. The attributes of a HTML start-tag or
 *  empty-element tag can be processed with:
 *   getNextHtmlAttribute(stri, attributeName, attributeValue);
 *   while attributeName &lt;> "" do
 *     ... process the current attribute ...
 *     getNextHtmlAttribute(stri, attributeName, attributeValue);
 *   end while;
 *   if attributeValue = "/>" then
 *     ... this is an empty-element tag ...
 *   else  # attributeValue = ">"
 *     ... this is a start-tag ...
 *   end if;
 *  @param stri Input [[string]] from which the consumed characters are removed.
 *  @param attributeName Destination for the attribute name.
 *  @param attributeValue Destination for the attribute value:
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: getNextHtmlAttribute (<span class="keywd">inout</span> <span class="type">string</span>: stri,
    <span class="keywd">inout</span> <span class="type">string</span>: attributeName, <span class="keywd">inout</span> <span class="type">string</span>: attributeValue) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    attributeName := getSymbolInXmlTag(stri);
    <span class="keywd">if</span> attributeName = <span class="stri">"/"</span> <span class="op">and</span> stri &lt;> <span class="stri">""</span> <span class="op">and</span> stri[1] = <span class="stri">'>'</span> <span class="keywd">then</span>
      stri := stri[2 ..];
      attributeName := <span class="stri">""</span>;
      attributeValue := <span class="stri">"/>"</span>;
    <span class="keywd">elsif</span> attributeName = <span class="stri">">"</span> <span class="keywd">then</span>
      attributeName := <span class="stri">""</span>;
      attributeValue := <span class="stri">">"</span>;
    <span class="keywd">else</span>
      skipWhiteSpace(stri);
      <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="op">and</span> stri[1] = <span class="stri">'='</span> <span class="keywd">then</span>
        stri := stri[2 ..];
        attributeValue := getHtmlAttributeValue(stri);
        <span class="keywd">if</span>  startsWith(attributeValue, <span class="stri">"\""</span>) <span class="op">or</span>
            startsWith(attributeValue, <span class="stri">"'"</span>) <span class="keywd">then</span>
          attributeValue := attributeValue[2 ..];
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        attributeValue := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads a symbol which appears in a HTTP header from a [[string]].
 *  Before reading the symbol it skips whitespace characters. A symbol
 *  from a HTTP header can be a token a string literal or a separator.
 *  When the function is called it is assumed that ''stri'' is empty or
 *  stri[1] contains a whitespace character or the first character of
 *  a symbol. When the function is left ''stri'' is empty or stri[1]
 *  contains the character after the symbol.
 *  @return the symbol, and
 *          "" if the end of ''stri'' was reached.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getHttpSymbol (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: start <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">while</span> start &lt;= leng <span class="op">and</span> stri[start] <span class="op">in</span> space_or_tab <span class="keywd">do</span>
      incr(start);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> start &lt;= leng <span class="keywd">then</span>
      pos := start;
      <span class="keywd">case</span> stri[pos] <span class="keywd">of</span>
        <span class="keywd">when</span> http_token_char:
          <span class="keywd">repeat</span>
            incr(pos);
          <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] <span class="op">not</span> <span class="op">in</span> http_token_char;
          symbol := stri[start .. pred(pos)];
          stri := stri[pos ..];
        <span class="keywd">when</span> double_quotation_char:
          incr(start);
          incr(pos);
          <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> stri[pos] &lt;> <span class="stri">'"'</span> <span class="keywd">do</span>
            <span class="keywd">if</span> stri[pos] = <span class="stri">'\\'</span> <span class="op">and</span> pos &lt; leng <span class="keywd">then</span>
              symbol &amp;:= stri[start .. pred(pos)] &amp; stri[succ(pos) fixLen 1];
              pos +:= 2;
              start := pos;
            <span class="keywd">else</span>
              incr(pos);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">while</span>;
          symbol &amp;:= stri[start .. pred(pos)];
          stri := stri[succ(pos) ..];
        <span class="keywd">when</span> http_separators:
          symbol := stri[pos fixLen 1];
          stri := stri[succ(pos) ..];
        <span class="keywd">otherwise</span>:
          <span class="keywd">repeat</span>
            incr(pos);
          <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] <span class="op">in</span> white_space_or_end_tag;
          symbol := stri[start .. pred(pos)];
          stri := stri[pos ..];
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">else</span>
      stri := <span class="stri">""</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getValueOfHeaderAttribute (<span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: headerLine, <span class="op">in</span> <span class="type">string</span>: attribute) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: attrValue <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      symbol := getHttpSymbol(headerLine);
    <span class="keywd">until</span> symbol = attribute <span class="op">or</span> symbol = <span class="stri">""</span>;
    <span class="keywd">if</span> symbol = attribute <span class="keywd">then</span>
      symbol := getHttpSymbol(headerLine);
      <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="keywd">then</span>
        attrValue := getHttpSymbol(headerLine);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
