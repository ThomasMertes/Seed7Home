<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  bin16.s7i     16-bit binary value support library               *)</span>
<span class="comment">(*  Copyright (C) 2026  Thomas Mertes                               *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bin64.htm">bin64.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/float.htm">float.s7i</a>"</span>;


<span class="comment">(**
 *  Binary values with 16 bits.
 *  This type supports bitwise operations but no integer arithmetic.
 *  The internal representation is the same as for integer.
 *)</span>
<span class="keywd">const</span> <span class="type">type</span>: bin16 <span class="keywd">is</span> subtype object;

<span class="keywd">const</span> <span class="type">creator</span>: (<span class="keywd">ref</span> <span class="type">bin16</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">bin16</span>: source)       <span class="keywd">is</span> action <span class="stri">"INT_CREATE"</span>;
<span class="keywd">const</span> <span class="type">destroyer</span>: destroy (<span class="keywd">ref</span> <span class="type">bin16</span>: aValue)                   <span class="keywd">is</span> action <span class="stri">"GEN_DESTR"</span>;
IN_PARAM_IS_VALUE(bin16);

<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">bin16</span>: dest) := (<span class="op">in</span> <span class="type">bin16</span>: source)          <span class="keywd">is</span> action <span class="stri">"INT_CPY"</span>;


<span class="comment">(**
 *  Convert to bin16.
 *  @return the unchanged value as bin16.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bin16</span>: bin16 (<span class="op">in</span> <span class="type">integer</span>: number)                   <span class="keywd">is</span> action <span class="stri">"INT_ICONV1"</span>;


<span class="comment">(**
 *  Default value of ''bin16'' (bin16(0)).
 *)</span>
<span class="keywd">const</span> <span class="type">bin16</span>: (attr bin16) . value   <span class="keywd">is</span> bin16(0);


<span class="comment">(**
 *  Convert to bin16.
 *  @return the unchanged value as bin16.
 *  @exception RANGE_ERROR If the result does not fit into 16 bits.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bin16</span>: bin16 (<span class="op">in</span> <span class="type">char</span>: ch) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">bin16</span>: bits <span class="keywd">is</span> bin16(0);
  <span class="keywd">begin</span>
    <span class="keywd">if</span> ch &lt; <span class="stri">'\0;'</span> <span class="op">or</span> ch > <span class="stri">'\65535;'</span> <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      bits := bin16(ord(ch));
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Convert to integer.
 *  @return the unchanged value as integer.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: (attr integer) <span class="op">conv</span> (<span class="op">in</span> <span class="type">bin16</span>: bits)       <span class="keywd">is</span> action <span class="stri">"INT_ICONV3"</span>;


<span class="comment">(**
 *  Convert to bin16.
 *  @return the unchanged value as bin16.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bin16</span>: (attr bin16) <span class="op">conv</span> (<span class="op">in</span> <span class="type">integer</span>: anInt)        <span class="keywd">is</span> action <span class="stri">"INT_ICONV3"</span>;


<span class="comment">(**
 *  Convert to integer.
 *  @return the unchanged value as integer.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: ord (<span class="op">in</span> <span class="type">bin16</span>: bits)                       <span class="keywd">is</span> action <span class="stri">"INT_ICONV1"</span>;


<span class="comment">(**
 *  Convert to integer.
 *  @return the unchanged value as integer.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: integer (<span class="op">in</span> <span class="type">bin16</span>: bits)                   <span class="keywd">is</span> action <span class="stri">"INT_ICONV1"</span>;


<span class="comment">(**
 *  Convert to char.
 *  @return the unchanged value as char.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">char</span>: char (<span class="op">in</span> <span class="type">bin16</span>: bits) <span class="keywd">is</span>
  <span class="keywd">return</span> char(integer(bits));


<span class="comment">(**
 *  Convert to bin64.
 *  @return the unchanged value as bin64.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bin64</span>: bin64 (<span class="op">in</span> <span class="type">bin16</span>: bits)                       <span class="keywd">is</span> action <span class="stri">"INT_ICONV1"</span>;


<span class="comment">(**
 *  Convert to bin16.
 *  @return the unchanged value as bin16.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bin16</span>: bin16 (<span class="op">in</span> <span class="type">bin64</span>: bits)                       <span class="keywd">is</span> action <span class="stri">"INT_ICONV1"</span>;


<span class="comment">(**
 *  Compare two bin16 values.
 *  @return -1, 0 or 1 if the first argument is considered to be
 *          respectively less than, equal to, or greater than the
 *          second.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: compare (<span class="op">in</span> <span class="type">bin16</span>: bits1, <span class="op">in</span> <span class="type">bin16</span>: bits2) <span class="keywd">is</span> action <span class="stri">"BIN_CMP"</span>;


<span class="comment">(**
 *  Compute the hash value of a bin16 value.
 *  @return the hash value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: hashCode (<span class="op">in</span> <span class="type">bin16</span>: bits)                  <span class="keywd">is</span> action <span class="stri">"INT_HASHCODE"</span>;


<span class="comment">(**
 *  Compute pseudo-random bin16 value.
 *  The random values are uniform distributed.
 *  @return a random bin16 value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bin16</span>: rand (attr bin16) <span class="keywd">is</span>
  <span class="keywd">return</span> bin16(rand(0, 65535));


<span class="comment">(**
 *  Number of bits in the minimum binary representation.
 *  Leading zero bits are not part of the minimum binary representation.
 *   bitLength(bin16(0))  returns 0
 *   bitLength(bin16(1))  returns 1
 *   bitLength(bin16(4))  returns 3
 *  @return the number of bits.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: bitLength (<span class="op">in</span> <span class="type">bin16</span>: bits)                 <span class="keywd">is</span> action <span class="stri">"BIN_BIT_LENGTH"</span>;


<span class="comment">(**
 *  Number of lowest-order zero bits in the binary representation.
 *  This is equal to the index of the lowest-order one bit (indices start with 0).
 *  If there are only zero bits (''bits'' is bin16(0)) the result is -1.
 *   lowestSetBit(bin16(0))  returns -1
 *   lowestSetBit(bin16(1))  returns  0
 *   lowestSetBit(bin16(4))  returns  2
 *  @return the number of lowest-order zero bits or -1 for lowestSetBit(bin16(0)).
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: lowestSetBit (<span class="op">in</span> <span class="type">bin16</span>: bits)              <span class="keywd">is</span> action <span class="stri">"BIN_LOWEST_SET_BIT"</span>;


<span class="comment">(**
 *  Convert an ''bin16'' value to a [[string]].
 *  The values is converted to a string with decimal representation.
 *  @return the string result of the conversion.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">bin16</span>: bits)                        <span class="keywd">is</span> action <span class="stri">"BIN_STR"</span>;


<span class="comment">(**
 *  Convert a ''bin16'' value to a [[string]] using a radix.
 *  The conversion uses the numeral system with the given ''base''.
 *  Digit values from 10 upward are encoded with lower case letters.
 *  E.g.: 10 is encoded with a, 11 with b, etc.
 *   bin16(48879) radix 16   returns "beef"
 *  @return the string result of the conversion.
 *  @exception RANGE_ERROR If base &lt; 2 or base > 36 holds.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">bin16</span>: bits) radix (<span class="op">in</span> <span class="type">integer</span>: base)   <span class="keywd">is</span> action <span class="stri">"BIN_radix"</span>;


<span class="comment">(**
 *  Convert a ''bin16'' value to a [[string]] using a radix.
 *  The conversion uses the numeral system with the given ''base''.
 *  Digit values from 10 upward are encoded with upper case letters.
 *  E.g.: 10 is encoded with A, 11 with B, etc.
 *   bin16(48879) RADIX 16   returns "BEEF"
 *  @return the string result of the conversion.
 *  @exception RANGE_ERROR If base &lt; 2 or base > 36 holds.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">bin16</span>: bits) RADIX (<span class="op">in</span> <span class="type">integer</span>: base)   <span class="keywd">is</span> action <span class="stri">"BIN_RADIX"</span>;


<span class="comment">(**
 *  Convert a ''bin16'' into a [[string]] of bytes with big-endian encoding.
 *  The result uses binary representation with a base of 256.
 *  The result contains chars (bytes) with an ordinal &lt;= 255.
 *   bytes(bin16(20299), BE, 3)  returns "\0;OK"
 *   bytes(bin16(20299), BE, 2)  returns "OK"
 *   bytes(bin16(20299), BE, 1)  raises RANGE_ERROR
 *  @param bits Bin16 to be converted.
 *  @param length Determines the length of the result string.
 *  @return a string of ''length'' bytes with the unsigned binary
 *          representation of ''bits''.
 *  @exception RANGE_ERROR If ''length'' is negative or zero, or
 *                         if the result would not fit in ''length'' bytes.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: bytes (<span class="op">in</span> <span class="type">bin16</span>: bits, BE, <span class="op">in</span> <span class="type">integer</span>: length) <span class="keywd">is</span> action <span class="stri">"BIN_N_BYTES_BE"</span>;


<span class="comment">(**
 *  Convert a ''bin16'' into a [[string]] of bytes with little-endian encoding.
 *  The result uses binary representation with a base of 256.
 *  The result contains chars (bytes) with an ordinal &lt;= 255.
 *   bytes(bin16(20299), LE, 3)  returns "OK\0;"
 *   bytes(bin16(20299), LE, 2)  returns "OK"
 *   bytes(bin16(20299), LE, 1)  raises RANGE_ERROR
 *  @param bits Bin16 to be converted.
 *  @param length Determines the length of the result string.
 *  @return a string of ''length'' bytes with the unsigned binary
 *          representation of ''bits''.
 *  @exception RANGE_ERROR If ''length'' is negative or zero, or
 *                         if the result would not fit in ''length'' bytes.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: bytes (<span class="op">in</span> <span class="type">bin16</span>: bits, LE, <span class="op">in</span> <span class="type">integer</span>: length) <span class="keywd">is</span> action <span class="stri">"BIN_N_BYTES_LE"</span>;


<span class="comment">(**
 *  Check if two bin16 values are equal.
 *  @return TRUE if the two values are equal,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">bin16</span>: bits1) = (<span class="op">in</span> <span class="type">bin16</span>: bits2)      <span class="keywd">is</span> action <span class="stri">"INT_EQ"</span>;


<span class="comment">(**
 *  Check if two bin16 values are not equal.
 *  @return FALSE if both values are equal,
 *          TRUE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">bin16</span>: bits1) &lt;> (<span class="op">in</span> <span class="type">bin16</span>: bits2)     <span class="keywd">is</span> action <span class="stri">"INT_NE"</span>;


<span class="comment">(**
 *  Compute a bitwise ''and'' of two bin16 values.
 *   bin16(2#1100) &amp; bin16(2#1010)  returns  bin16(2#1000)
 *  @return the bitwise ''and'' of the two values.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bin16</span>: (<span class="op">in</span> <span class="type">bin16</span>: bits1) &amp; (<span class="op">in</span> <span class="type">bin16</span>: bits2)        <span class="keywd">is</span> action <span class="stri">"BIN_AND"</span>;


<span class="comment">(**
 *  Compute a bitwise inclusive ''or'' of two bin16 values.
 *   bin16(2#1100) | bin16(2#1010)  returns  bin16(2#1110)
 *  @return the bitwise inclusive ''or'' of the two values.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bin16</span>: (<span class="op">in</span> <span class="type">bin16</span>: bits1) | (<span class="op">in</span> <span class="type">bin16</span>: bits2)        <span class="keywd">is</span> action <span class="stri">"BIN_OR"</span>;


<span class="comment">(**
 *  Compute a bitwise exclusive or (''xor'') of two bin16 values.
 *   bin16(2#1100) >&lt; bin16(2#1010)  returns  bin16(2#0110)
 *  @return the bitwise ''xor'' of the two values.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bin16</span>: (<span class="op">in</span> <span class="type">bin16</span>: bits1) >&lt; (<span class="op">in</span> <span class="type">bin16</span>: bits2)       <span class="keywd">is</span> action <span class="stri">"BIN_XOR"</span>;


<span class="comment">(**
 *  Compute a bitwise ''not'' of a bin16 value.
 *   ~bin16(2#1)  returns  bin16(16#fffe)
 *  @return the bitwise ''not'' of the value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bin16</span>: ~ (<span class="op">in</span> <span class="type">bin16</span>: bits) <span class="keywd">is</span>
  <span class="keywd">return</span> bits >&lt; bin16(16#ffff);


<span class="comment">(**
 *  Compute ''bits'' logically left shifted by ''lshift''.
 *   bin16(16#abc) &lt;&lt; 4  returns  bin16(16#abc0)
 *   bin16(1) &lt;&lt; 64         raises OVERFLOW_ERROR
 *  @return the left shifted value.
 *  @exception OVERFLOW_ERROR If the shift amount is
 *             negative or greater equal 64.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bin16</span>: (<span class="op">in</span> <span class="type">bin16</span>: bits) &lt;&lt; (<span class="op">in</span> <span class="type">integer</span>: lshift)     <span class="keywd">is</span> action <span class="stri">"BIN_LSHIFT"</span>;


<span class="comment">(**
 *  Compute ''bits'' logically right shifted by ''rshift''.
 *  Bits shifted beyond the lowest bit position are lost.
 *   bin16(16#abcd) >> 4  returns  bin16(16#abc)
 *  @return the right shifted value.
 *  @exception OVERFLOW_ERROR If the shift amount is
 *             negative or greater equal 64.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bin16</span>: (<span class="op">in</span> <span class="type">bin16</span>: bits) >> (<span class="op">in</span> <span class="type">integer</span>: rshift)     <span class="keywd">is</span> action <span class="stri">"BIN_RSHIFT"</span>;


<span class="comment">(**
 *  Logical left shift ''bits'' by ''lshift'' and assign the result back to ''bits''.
 *  @exception OVERFLOW_ERROR If the shift amount is
 *             negative or greater equal 64.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">bin16</span>: bits) &lt;&lt;:= (<span class="op">in</span> <span class="type">integer</span>: lshift)      <span class="keywd">is</span> action <span class="stri">"BIN_LSHIFT_ASSIGN"</span>;


<span class="comment">(**
 *  Logical right shift ''bits'' by ''rshift'' and assign the result back to ''bits''.
 *  Bits shifted beyond the lowest bit position are lost.
 *  @exception OVERFLOW_ERROR If the shift amount is
 *             negative or greater equal 64.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">bin16</span>: bits) >>:= (<span class="op">in</span> <span class="type">integer</span>: rshift)      <span class="keywd">is</span> action <span class="stri">"BIN_RSHIFT_ASSIGN"</span>;


<span class="comment">(**
 *  Compute a bitwise ''and'' and assign the result back to ''bits1''.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">bin16</span>: bits1) &amp;:= (<span class="op">in</span> <span class="type">bin16</span>: bits2)         <span class="keywd">is</span> action <span class="stri">"BIN_AND_ASSIGN"</span>;


<span class="comment">(**
 *  Compute a bitwise inclusive ''or'' and assign the result back to ''bits1''.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">bin16</span>: bits1) |:= (<span class="op">in</span> <span class="type">bin16</span>: bits2)         <span class="keywd">is</span> action <span class="stri">"BIN_OR_ASSIGN"</span>;


<span class="comment">(**
 *  Compute a bitwise exclusive or (''xor'') and assign the result back to ''bits1''.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">bin16</span>: bits1) >&lt;:= (<span class="op">in</span> <span class="type">bin16</span>: bits2)        <span class="keywd">is</span> action <span class="stri">"BIN_XOR_ASSIGN"</span>;


<span class="comment">(**
 *  Rotate the bits of a bin16 value left by shiftCount bits.
 *  The vacant bit positions at the right side are filled in with
 *  the bits that are shifted out at the left side.
 *   rotLeft(bin16(16#1234), 4)  returns  bin16(16#2341)
 *  @return the left rotated value.
 *  @exception OVERFLOW_ERROR If the shift amount is negative
 *             or greater than 16.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bin16</span>: rotLeft (<span class="op">in</span> <span class="type">bin16</span>: x, <span class="op">in</span> <span class="type">integer</span>: shiftCount) <span class="keywd">is</span>
  <span class="keywd">return</span> (x &lt;&lt; shiftCount | x >> (16 - shiftCount)) &amp; bin16(16#ffff);


<span class="comment">(**
 *  Rotate the bits of a bin16 value right by shiftCount bits.
 *  The vacant bit positions at the left side are filled in with
 *  the bits that are shifted out at the right side.
 *   rotRight(bin16(16#1234), 4)  returns  bin16(16#4123)
 *  @return the right rotated value.
 *  @exception OVERFLOW_ERROR If the shift amount is negative
 *             or greater than 16.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bin16</span>: rotRight (<span class="op">in</span> <span class="type">bin16</span>: x, <span class="op">in</span> <span class="type">integer</span>: shiftCount) <span class="keywd">is</span>
  <span class="keywd">return</span> (x >> shiftCount | x &lt;&lt; (16 - shiftCount)) &amp; bin16(16#ffff);


<span class="keywd">const</span> <span class="type">integer</span>: FLOAT64_SIZE <span class="keywd">is</span> 64;
<span class="keywd">const</span> <span class="type">integer</span>: FLOAT64_MANTISSA_BITS        <span class="keywd">is</span> 52;
<span class="keywd">const</span> <span class="type">integer</span>: FLOAT64_INF_AND_NAN_EXPONENT <span class="keywd">is</span> 16#7ff;
<span class="keywd">const</span> <span class="type">integer</span>: FLOAT64_EXPONENT_BITS        <span class="keywd">is</span> 11;
<span class="keywd">const</span> <span class="type">integer</span>: FLOAT64_EXPONENT_OFFSET      <span class="keywd">is</span> 1023;
<span class="keywd">const</span> <span class="type">bin64</span>: FLOAT64_EXPONENT_MASK <span class="keywd">is</span> bin64((1 &lt;&lt; FLOAT64_EXPONENT_BITS) - 1);
<span class="keywd">const</span> <span class="type">bin64</span>: FLOAT64_MANTISSA_MASK <span class="keywd">is</span> bin64((1 &lt;&lt; FLOAT64_MANTISSA_BITS) - 1);

<span class="keywd">const</span> <span class="type">integer</span>: FLOAT16_SIZE <span class="keywd">is</span> 16;
<span class="keywd">const</span> <span class="type">integer</span>: FLOAT16_MANTISSA_BITS        <span class="keywd">is</span> 10;
<span class="keywd">const</span> <span class="type">integer</span>: FLOAT16_INF_AND_NAN_EXPONENT <span class="keywd">is</span> 16#1f;
<span class="keywd">const</span> <span class="type">integer</span>: FLOAT16_EXPONENT_OFFSET      <span class="keywd">is</span> 15;

<span class="keywd">const</span> <span class="type">integer</span>: FLOAT64_16_MANTISSA_SHIFT <span class="keywd">is</span>
                   FLOAT64_MANTISSA_BITS - FLOAT16_MANTISSA_BITS;
<span class="keywd">const</span> <span class="type">integer</span>: FLOAT64_16_EXPONENT_OFFSET_DIFF <span class="keywd">is</span>
                   FLOAT64_EXPONENT_OFFSET - FLOAT16_EXPONENT_OFFSET;


<span class="comment">(**
 *  Get a float from bits in IEEE 754 16-bit half-precision representation.
 *  IEEE 754 is a standard for floating point arithmetic.
 *  The 16-bit half-precision format of IEEE 754 (called FP16 or float16)
 *  has a sign bit, a 5 bit exponent, and a 10 bit mantissa.
 *   float(bin16(16#3c00))  returns  1.0
 *  @param bits 16 bits to be converted to a float.
 *  @return a float from 16 bits in half-precision float representation.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: float (<span class="op">in</span> <span class="type">bin16</span>: bits) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: number <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">bin64</span>: sign <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <span class="type">integer</span>: exponent <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">bin64</span>: mantissa <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <span class="type">boolean</span>: doConvert <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">bin64</span>: binaryValue <span class="keywd">is</span> bin64(0);
  <span class="keywd">begin</span>
    <span class="keywd">if</span> bits >> 16 &lt;> bin16(0) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      sign     :=     (bin64(bits) >> 15) &amp; bin64(1);
      exponent := ord((bin64(bits) >> 10) &amp; bin64(16#1f));
      mantissa :=      bin64(bits)        &amp; bin64(16#3ff);
      <span class="keywd">if</span> exponent = 0 <span class="keywd">then</span>
        <span class="keywd">if</span> mantissa = bin64(0) <span class="keywd">then</span>
          number := sign = bin64(0) ? 0.0 : -0.0;
          doConvert := FALSE;
        <span class="keywd">else</span>
          <span class="comment"># Denormalized float: Renormalize it</span>
          <span class="keywd">while</span> mantissa &amp; bin64(16#400) = bin64(0) <span class="keywd">do</span>
            mantissa &lt;&lt;:= 1;
            decr(exponent);
          <span class="keywd">end</span> <span class="keywd">while</span>;
          incr(exponent);
          <span class="comment"># The leading one bit of the mantissa is not stored</span>
          mantissa &amp;:= ~bin64(16#400);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> exponent = FLOAT16_INF_AND_NAN_EXPONENT <span class="keywd">then</span>
        <span class="keywd">if</span> mantissa = bin64(0) <span class="keywd">then</span>
          number := sign = bin64(0) ? Infinity : -Infinity;
        <span class="keywd">else</span>
          <span class="comment"># NaN: Preserve sign and mantissa bits</span>
          exponent := FLOAT64_INF_AND_NAN_EXPONENT;
          mantissa &lt;&lt;:= FLOAT64_16_MANTISSA_SHIFT;
          binaryValue := sign &lt;&lt; pred(FLOAT64_SIZE) |
                         bin64(exponent) &lt;&lt; FLOAT64_MANTISSA_BITS |
                         mantissa;
          number := float(binaryValue);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        doConvert := FALSE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> doConvert <span class="keywd">then</span>
        <span class="comment"># Convert to float64</span>
        exponent +:= FLOAT64_16_EXPONENT_OFFSET_DIFF;
        mantissa &lt;&lt;:= FLOAT64_16_MANTISSA_SHIFT;
        binaryValue := sign &lt;&lt; pred(FLOAT64_SIZE) |
                       bin64(exponent) &lt;&lt; FLOAT64_MANTISSA_BITS |
                       mantissa;
        number := float(binaryValue);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get bits in IEEE 754 16-bit half-precision representation from a float.
 *  IEEE 754 is a standard for floating point arithmetic.
 *  The 16-bit half-precision format of IEEE 754 (called FP16 or float16)
 *  has a sign bit, a 5 bit exponent, and a 10 bit mantissa.
 *   bin16(1.0)  returns  bin16(16#3c00)
 *  @param number Float value to be converted to bin16.
 *  @return 16 bits in IEEE 754 half-precision float representation.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bin16</span>: bin16 (<span class="op">in</span> <span class="type">float</span>: number) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">bin16</span>: bits <span class="keywd">is</span> bin16(0);
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">bin64</span>: binaryValue <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <span class="type">bin16</span>: sign <span class="keywd">is</span> bin16(0);
    <span class="keywd">var</span> <span class="type">integer</span>: exponent <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">bin64</span>: mantissa <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <span class="type">integer</span>: mantissaShift <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: oneBits <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: lowestBit <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    binaryValue := bin64(number);
    sign     := bin16(binaryValue >> (FLOAT64_SIZE - FLOAT16_SIZE)) &amp;
                bin16(16#8000);
    exponent := ord((binaryValue >> FLOAT64_MANTISSA_BITS) &amp;
                    FLOAT64_EXPONENT_MASK) -
                FLOAT64_16_EXPONENT_OFFSET_DIFF;
    mantissa := binaryValue &amp; FLOAT64_MANTISSA_MASK;
    <span class="keywd">if</span> exponent &lt;= 0 <span class="keywd">then</span>
      <span class="keywd">if</span> exponent &lt; -10 <span class="keywd">then</span>
        <span class="comment"># Underflow: The number cannot be represented as float16.</span>
        <span class="comment"># Return zero with the same sign as number.</span>
        bits := sign;
      <span class="keywd">else</span>
        <span class="comment"># Normalized float which cannot be represented as</span>
        <span class="comment"># normalized float16. Convert to denormalized float16.</span>

        <span class="comment"># Add an explicit leading 1 bit to the mantissa.</span>
        mantissa |:= bin64(1) &lt;&lt; FLOAT64_MANTISSA_BITS;

        <span class="comment"># Round the mantissa to the nearest (10+e)-bit value</span>
        <span class="comment"># (with exponent between -10 and 0).</span>
        <span class="comment"># In case of a tie, round to the nearest even value.</span>

        <span class="comment"># The rounding may cause that the number is not representable</span>
        <span class="comment"># as denormalized float16. The code below handles this</span>
        <span class="comment"># case correctly: The leading one bit of the mantissa is</span>
        <span class="comment"># shifted into the exponent area. This results in an</span>
        <span class="comment"># exponent of one and a mantissa of zero, which is the</span>
        <span class="comment"># normalized float16 representation of the rounded result.</span>

        mantissaShift := FLOAT64_16_MANTISSA_SHIFT + 1 - exponent;
        oneBits := pred(1 &lt;&lt; pred(mantissaShift));
        lowestBit := ord(mantissa >> mantissaShift) <span class="op">mod</span> 2;
        mantissa := bin64(ord(mantissa) + oneBits + lowestBit);
        bits := sign | bin16(mantissa) >> mantissaShift;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exponent = FLOAT64_INF_AND_NAN_EXPONENT -
          FLOAT64_16_EXPONENT_OFFSET_DIFF <span class="keywd">then</span>
      <span class="keywd">if</span> mantissa = bin64(0) <span class="keywd">then</span>
        <span class="comment"># Infinity: Return float16 infinity with the same sign.</span>
        bits := sign | bin16(16#7c00);
      <span class="keywd">else</span>
        <span class="comment"># NaN: Return a float16 NaN that preserves the sign bit and</span>
        <span class="comment"># the 10 leftmost bits of the mantissa. If the 10 leftmost</span>
        <span class="comment"># mantissa bits are all zero, the NaN would turn into infinity.</span>
        <span class="comment"># In this case the lowest bit of the mantissa is set to one.</span>
        <span class="comment"># This generates NaN instead of infinity.</span>

        mantissa >>:= FLOAT64_16_MANTISSA_SHIFT;
        bits := sign | bin16(16#7c00) | bin16(mantissa) |
                bin16(ord(mantissa = bin64(0)));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      <span class="comment"># Normalized float with an exponent greater than zero:</span>
      <span class="comment"># Try to convert it to a normalized float16.</span>

      <span class="comment"># Round mantissa to the nearest 10-bit value.</span>
      <span class="comment"># In case of a tie, round to the nearest even value.</span>

      oneBits := pred(1 &lt;&lt; pred(FLOAT64_16_MANTISSA_SHIFT));
      lowestBit := ord(mantissa >> FLOAT64_16_MANTISSA_SHIFT) <span class="op">mod</span> 2;
      mantissa := bin64(ord(mantissa) + oneBits + lowestBit);

      <span class="keywd">if</span> mantissa &amp; (bin64(1) &lt;&lt; FLOAT64_MANTISSA_BITS) &lt;> bin64(0) <span class="keywd">then</span>
        <span class="comment"># Overflow in mantissa: Adjust the exponent</span>
        mantissa := bin64(0);
        incr(exponent);
      <span class="keywd">end</span> <span class="keywd">if</span>;

      <span class="keywd">if</span> exponent >= FLOAT16_INF_AND_NAN_EXPONENT <span class="keywd">then</span>
        <span class="comment"># Exponent overflow:</span>
        <span class="comment"># Return float16 infinity with the same sign as number.</span>
        bits := sign | bin16(16#7c00);
      <span class="keywd">else</span>
        bits := sign |
                bin16(exponent &lt;&lt; FLOAT16_MANTISSA_BITS) |
                bin16(mantissa >> FLOAT64_16_MANTISSA_SHIFT);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Convert a string of two little-endian bytes to a bin16 value.
 *  @return the bin16 value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bin16</span>: bin16 (<span class="op">in</span> <span class="type">string</span>: twoBytes, LE) <span class="keywd">is</span>
  <span class="keywd">return</span> bin16(twoBytes[1])       |
         bin16(twoBytes[2]) &lt;&lt;  8;


<span class="comment">(**
 *  Convert a string of two big-endian bytes to a bin16 value.
 *  @return the bin16 value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bin16</span>: bin16 (<span class="op">in</span> <span class="type">string</span>: twoBytes, BE) <span class="keywd">is</span>
  <span class="keywd">return</span> bin16(twoBytes[1]) &lt;&lt;  8 |
         bin16(twoBytes[2]);


<span class="comment"># Allows 'array bin16' everywhere without extra type definition.</span>
<span class="keywd">const</span> <span class="type">type</span>: _bin16Array <span class="keywd">is</span> <span class="type">array</span> <span class="type">bin16</span>;


enable_output(bin16);

CASE_DECLS(bin16);
DECLARE_TERNARY(bin16);
</pre>
</body>
</html>
