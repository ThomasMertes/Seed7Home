<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  dnafight.sd7  Bacterial dna fight programming game              *)</span>
<span class="comment">(*  Copyright (C) 1985  Johannes Gritsch                            *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">const</span> <span class="type">type</span>: actionType <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">enum</span>
    OnlyEat, Murder, Canibalism, OnlySplit
  <span class="keywd">end</span> <span class="keywd">enum</span>;

<span class="keywd">const</span> <span class="type">type</span>: mainDir <span class="keywd">is</span> direction; <span class="comment">(* HERE .. LastDir *)</span>
<span class="keywd">const</span> <span class="type">type</span>: mainDirArr <span class="keywd">is</span> <span class="type">array</span> <span class="type">[</span>mainDir] mainDir;

<span class="keywd">const</span> <span class="type">type</span>: place <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
     <span class="keywd">var</span> <span class="type">bactColor</span>: occupant <span class="keywd">is</span> CLEAR;
     <span class="keywd">var</span> <span class="type">power</span>: occSize <span class="keywd">is</span> 0;
     <span class="keywd">var</span> <span class="type">power</span>: foodMass <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: surrounding <span class="keywd">is</span> <span class="type">array</span> <span class="type">[</span>direction] place;
<span class="keywd">const</span> <span class="type">type</span>: mvChangeTyp <span class="keywd">is</span> <span class="type">array</span> <span class="type">[</span>direction] <span class="type">array</span> <span class="type">[</span>direction] direction;


<span class="keywd">const</span> <span class="type">proc</span>: dna (INDIGO) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">direction</span>: firstDir  <span class="keywd">is</span> NORTH;
    <span class="keywd">const</span> <span class="type">direction</span>: lastDir   <span class="keywd">is</span> EAST;
    <span class="keywd">const</span> <span class="type">direction</span>: firstDiag <span class="keywd">is</span> NW;
    <span class="keywd">const</span> <span class="type">direction</span>: lastDiag  <span class="keywd">is</span> SE;
    <span class="keywd">const</span> <span class="type">bactColor</span>: SELF <span class="keywd">is</span> INDIGO;

    <span class="comment">(* Parameters *)</span>

    <span class="keywd">const</span> <span class="type">power</span>: ownSizeVal <span class="keywd">is</span>     8; <span class="comment">(* Value of own size *)</span>
    <span class="keywd">const</span> <span class="type">power</span>: hereFoodVal <span class="keywd">is</span>    4; <span class="comment">(* Value of Food at place *)</span>
    <span class="keywd">const</span> <span class="type">power</span>: thereFoodVal <span class="keywd">is</span>   2; <span class="comment">(* Value of Food at neighbour place in main direction *)</span>
    <span class="keywd">const</span> <span class="type">power</span>: overThFoodVal <span class="keywd">is</span>  1; <span class="comment">(* Value of Food at neighbour place in secondary dir  *)</span>
    <span class="keywd">const</span> <span class="type">power</span>: killBonus <span class="keywd">is</span>      1; <span class="comment">(* Bonus for killing a stranger *)</span>
    <span class="keywd">const</span> <span class="type">power</span>: cannFine <span class="keywd">is</span>       4; <span class="comment">(* Fine for killing a relative *)</span>




    <span class="keywd">const</span> <span class="type">mvChangeTyp</span>: mvChange <span class="keywd">is</span> <span class="comment">(* new order of movement in Dir NORTH .. EAST *)</span>
                                   <span class="comment">(* HERE,  NORTH, SOUTH, WEST,  EAST,  NW,    NE,    SW,    SE *)</span>
              [direction]([direction](HERE,  HERE,  HERE,  HERE,  HERE,  HERE,  HERE,  HERE,  HERE), <span class="comment">(* unused *)</span>
              <span class="comment">(* NORTH *)</span> [direction](NORTH, SOUTH, HERE,  NW,    NE,    SW,    SE,    WEST,  EAST),
              <span class="comment">(* WEST *)</span>  [direction](SOUTH, HERE,  NORTH, SW,    SE,    WEST,  EAST,  NW,    NE),
              <span class="comment">(* SOUTH *)</span> [direction](WEST,  NW,    SW,    EAST,  HERE,  NE,    NORTH, SE,    SOUTH),
              <span class="comment">(* EAST *)</span>  [direction](EAST,  NE,    SE,    HERE,  WEST,  NORTH, NW,    SOUTH, SW));

    <span class="keywd">const</span> <span class="type">mainDirArr</span>: oppositDir <span class="keywd">is</span> [mainDir](HERE, SOUTH, NORTH, EAST, WEST);


    <span class="keywd">var</span> <span class="type">power</span>: avFood <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: avFoodMax <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: ownSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: splHereSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: splThereSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">lifeSpan</span>: ownHunger <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: foodSum <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: foodFields <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">directSet</span>: mvOptDir <span class="keywd">is</span> directSet.EMPTY_SET;
    <span class="keywd">var</span> <span class="type">directSet</span>: splOptDir <span class="keywd">is</span> directSet.EMPTY_SET;
    <span class="keywd">var</span> <span class="type">boolean</span>: doSplit <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: maxState <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">direction</span>: dir <span class="keywd">is</span> HERE;
    <span class="keywd">var</span> <span class="type">surrounding</span>: landscape <span class="keywd">is</span> direction <span class="op">times</span> place.value;


    <span class="keywd">const</span> <span class="type">proc</span>: initSurr (<span class="keywd">inout</span> <span class="type">surrounding</span>: landscape) <span class="keywd">is</span> <span class="keywd">func</span>

      <span class="keywd">local</span>
        <span class="keywd">var</span> <span class="type">direction</span>: dir <span class="keywd">is</span> HERE;

      <span class="keywd">begin</span> <span class="comment">(* initSurr *)</span>
        foodSum := 0;
        avFoodMax := 0;
        foodFields := 9;
        ownHunger := hunger;
        ownSize := strength(HERE);
        splThereSize := ownSize <span class="op">div</span> 2;
        splHereSize := ownSize - splThereSize;
        <span class="keywd">for</span> dir <span class="keywd">range</span> HERE <span class="keywd">to</span> lastDiag <span class="keywd">do</span>
          landscape[dir].occupant := view(dir);
          landscape[dir].occSize := strength(dir);
          landscape[dir].foodMass := food(dir);
          foodSum +:= landscape[dir].foodMass;
          <span class="keywd">if</span> landscape[dir].occupant = EDGE <span class="keywd">then</span>
            decr(foodFields)
          <span class="keywd">elsif</span> landscape[dir].occupant = CLEAR <span class="keywd">then</span>
            <span class="keywd">if</span> avFoodMax &lt; landscape[dir].foodMass <span class="keywd">then</span>
              avFoodMax := landscape[dir].foodMass;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> dir &lt;> HERE <span class="op">and</span>
              landscape[dir].occSize &lt; avFoodMax <span class="op">and</span>
              landscape[dir].occSize &lt;= ownSize <span class="keywd">then</span>
            avFoodMax := landscape[dir].occSize;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
        avFood := foodSum <span class="op">div</span> foodFields + 1;
      <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* initSurr *)</span>


    <span class="keywd">const</span> <span class="type">proc</span>: setSurr (<span class="keywd">inout</span> <span class="type">place</span>: surr, <span class="op">in</span> <span class="type">bactColor</span>: setColor, <span class="op">in</span> <span class="type">power</span>: setSize, <span class="op">in</span> <span class="type">power</span>: setFood) <span class="keywd">is</span> <span class="keywd">func</span>

      <span class="keywd">begin</span> <span class="comment">(* setSurr *)</span>
        surr.occupant := setColor;
        surr.occSize := setSize;
        surr.foodMass := setFood
      <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* setSurr *)</span>


    <span class="keywd">const</span> <span class="type">func</span> <span class="type">power</span>: showNextSize (<span class="op">in</span> <span class="type">power</span>: ownSize, <span class="op">in</span> <span class="type">place</span>: surrField) <span class="keywd">is</span> <span class="keywd">func</span>

      <span class="keywd">result</span>
        <span class="keywd">var</span> <span class="type">power</span>: nextSize <span class="keywd">is</span> 0;

      <span class="keywd">begin</span> <span class="comment">(* showNextSize *)</span>
        <span class="keywd">if</span> surrField.occupant = EDGE <span class="keywd">then</span>
          nextSize := 0;
        <span class="keywd">else</span>
          <span class="keywd">if</span> surrField.occupant = CLEAR <span class="keywd">then</span>
            nextSize := nextSize(ownSize, surrField.foodMass, MAXLIFESPAN);
          <span class="keywd">else</span>
            <span class="keywd">if</span> surrField.occSize > ownSize <span class="keywd">then</span>
              nextSize := 0;
            <span class="keywd">else</span>
              nextSize := nextSize(ownSize, surrField.occSize, MAXLIFESPAN);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* showNextSize *)</span>


    <span class="keywd">const</span> <span class="type">func</span> <span class="type">power</span>: possNextSize (<span class="op">in</span> <span class="type">surrounding</span>: surr, <span class="op">in</span> <span class="type">direction</span>: dir) <span class="keywd">is</span> <span class="keywd">func</span>

      <span class="keywd">result</span>
        <span class="keywd">var</span> <span class="type">power</span>: nextSize <span class="keywd">is</span> 0;

      <span class="keywd">begin</span> <span class="comment">(* possNextSize *)</span>
        nextSize := nextSize(surr[dir].occSize, surr[dir].foodMass, MAXLIFESPAN);
        nextSize := max(nextSize, showNextSize(surr[dir].occSize, surr[left[dir]]));
        nextSize := max(nextSize, showNextSize(surr[dir].occSize, surr[right[dir]]));
      <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* possNextSize *)</span>


    <span class="keywd">const</span> <span class="type">proc</span>: feed (<span class="keywd">inout</span> <span class="type">place</span>: surr, <span class="op">in</span> <span class="type">power</span>: foe, <span class="op">in</span> <span class="type">bactColor</span>: foeCol) <span class="keywd">is</span> <span class="keywd">func</span>

      <span class="comment">(* assumes surr.occSize to be ownSize, foe to be size of previous owner *)</span>

      <span class="keywd">local</span>
        <span class="keywd">var</span> <span class="type">power</span>: dinner <span class="keywd">is</span> 0;

      <span class="keywd">begin</span> <span class="comment">(* feed *)</span>
        <span class="keywd">if</span> foeCol = CLEAR <span class="keywd">then</span>
          dinner := min(surr.foodMass, surr.occSize);
          surr.foodMass := surr.foodMass - dinner;
          surr.occSize := nextSize(surr.occSize, dinner, ownHunger);
        <span class="keywd">else</span>
          surr.occSize := nextSize(surr.occSize, foe, ownHunger);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* feed *)</span>


    <span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: stateVal (<span class="op">in</span> <span class="type">surrounding</span>: surr, <span class="op">in</span> <span class="type">actionType</span>: wotHap) <span class="keywd">is</span> <span class="keywd">func</span>

      <span class="keywd">result</span>
        <span class="keywd">var</span> <span class="type">integer</span>: state <span class="keywd">is</span> 0;
      <span class="keywd">local</span>
        <span class="keywd">var</span> <span class="type">direction</span>: dir <span class="keywd">is</span> HERE;
        <span class="keywd">var</span> <span class="type">power</span>: foeSize <span class="keywd">is</span> 0;

      <span class="keywd">begin</span> <span class="comment">(* stateVal *)</span>
        state := ownSizeVal * surr[HERE].occSize +
                 hereFoodVal * surr[HERE].foodMass;

        <span class="keywd">for</span> dir <span class="keywd">range</span> firstDir <span class="keywd">to</span> lastDir <span class="keywd">do</span>
          <span class="keywd">case</span> surr[dir].occupant <span class="keywd">of</span>
            <span class="keywd">when</span> {EDGE}:  noop;
            <span class="keywd">when</span> {CLEAR}: state +:= thereFoodVal * surr[dir].foodMass;
            <span class="keywd">when</span> {SELF}:  state +:= -cannFine * possNextSize(surr, dir) +
                                    thereFoodVal * surr[dir].foodMass;
            <span class="keywd">otherwise</span>:
              <span class="keywd">if</span> surr[dir].occSize &lt; surr[HERE].occSize <span class="keywd">then</span>
                foeSize := possNextSize(surr, dir);
                <span class="keywd">if</span> foeSize &lt;= surr[HERE].occSize <span class="keywd">then</span>
                  state +:= foeSize * thereFoodVal + killBonus +
                            overThFoodVal * surr[dir].foodMass;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">case</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;

        <span class="keywd">for</span> dir <span class="keywd">range</span> firstDiag <span class="keywd">to</span> lastDiag <span class="keywd">do</span>
          <span class="keywd">if</span> surr[dir].occupant &lt;> EDGE <span class="keywd">then</span>
            state +:= overThFoodVal * surr[dir].foodMass;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* stateVal *)</span>


    <span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: doMove (<span class="op">in</span> <span class="type">direction</span>: dir, <span class="op">in</span> <span class="type">boolean</span>: doSplit) <span class="keywd">is</span> <span class="keywd">func</span>

      <span class="keywd">result</span>
        <span class="keywd">var</span> <span class="type">integer</span>: state <span class="keywd">is</span> 0;
      <span class="keywd">local</span>
        <span class="keywd">var</span> <span class="type">surrounding</span>: newSurr <span class="keywd">is</span> direction <span class="op">times</span> place.value;
        <span class="keywd">var</span> <span class="type">surrounding</span>: splitSurr <span class="keywd">is</span> direction <span class="op">times</span> place.value;
        <span class="keywd">var</span> <span class="type">direction</span>: di <span class="keywd">is</span> HERE;
        <span class="keywd">var</span> <span class="type">direction</span>: oldPlace <span class="keywd">is</span> HERE;
        <span class="keywd">var</span> <span class="type">power</span>: splitSize <span class="keywd">is</span> 0;

      <span class="keywd">begin</span>
        <span class="keywd">if</span> dir = HERE <span class="keywd">then</span>
          newSurr := landscape;
          feed(newSurr[HERE], 0, CLEAR);
          state := stateVal(newSurr, OnlyEat);
        <span class="keywd">elsif</span> landscape[dir].occupant = EDGE <span class="op">or</span>
            landscape[dir].occupant > CLEAR <span class="op">and</span> (landscape[dir].occSize > 0 <span class="op">or</span> doSplit) <span class="keywd">then</span>
          state := 0;
        <span class="keywd">else</span>
          oldPlace := oppositDir[dir];
          <span class="keywd">for</span> di <span class="keywd">range</span> HERE <span class="keywd">to</span> lastDiag <span class="keywd">do</span>
            newSurr[di] := landscape[mvChange[dir][di]];
          <span class="keywd">end</span> <span class="keywd">for</span>;
          <span class="keywd">if</span> landscape[left[dir]].occupant = EDGE <span class="keywd">then</span>
            <span class="comment">(* movement along the left edge *)</span>
            setSurr(newSurr[right[dir]], CLEAR, 0, avFood);
          <span class="keywd">elsif</span> landscape[right[dir]].occupant = EDGE <span class="keywd">then</span>
            <span class="comment">(* movement along the right edge *)</span>
            setSurr(newSurr[left[dir]], CLEAR, 0, avFood);
          <span class="keywd">else</span>
            setSurr(newSurr[right[dir]], CLEAR, 0, avFood);
            setSurr(newSurr[left[dir]], CLEAR, 0, avFood);
          <span class="keywd">end</span> <span class="keywd">if</span>;

          <span class="keywd">if</span> doSplit <span class="keywd">then</span>
            splitSize := ownSize <span class="op">div</span> 2;
            newSurr[HERE].occSize := splitSize;
            newSurr[oldPlace].occSize := ownSize - splitSize;
            splitSurr := landscape;
            setSurr(splitSurr[dir], SELF, splitSize, splitSurr[dir].foodMass);
            splitSurr[HERE].occSize := ownSize - splitSize;
            feed(newSurr[HERE], 0, CLEAR);
            feed(newSurr[oldPlace], 0, CLEAR);
            feed(splitSurr[dir], 0, CLEAR);
            feed(splitSurr[HERE], 0, CLEAR);
            state := stateVal(newSurr, OnlySplit) + stateVal(splitSurr, OnlySplit);
          <span class="keywd">else</span>
            setSurr(newSurr[HERE], SELF, landscape[dir].occSize, landscape[dir].foodMass);
            setSurr(newSurr[oldPlace], CLEAR, 0, landscape[HERE].foodMass);
            feed(newSurr[dir], landscape[dir].occSize, landscape[dir].occupant);
            state := stateVal(newSurr, actionType <span class="op">conv</span> (ord(landscape[dir].occupant > CLEAR) +
                                                         ord(landscape[dir].occupant = SELF)));
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* doMove *)</span>


    <span class="keywd">const</span> <span class="type">proc</span>: compare (<span class="op">in</span> <span class="type">direction</span>: dir, <span class="op">in</span> <span class="type">integer</span>: newState,
                         <span class="keywd">inout</span> <span class="type">directSet</span>: optDir, <span class="keywd">inout</span> <span class="type">directSet</span>: notOptDir,
                         <span class="keywd">inout</span> <span class="type">integer</span>: maxState) <span class="keywd">is</span> <span class="keywd">func</span>

      <span class="keywd">begin</span> <span class="comment">(* compare *)</span>
        <span class="keywd">if</span> newState > maxState <span class="keywd">then</span>
          maxState := newState;
          optDir := {dir};
          notOptDir := directSet.EMPTY_SET;
        <span class="keywd">elsif</span> newState = maxState <span class="keywd">then</span>
          incl(optDir, dir);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* compare *)</span>


  <span class="keywd">begin</span> <span class="comment">(* dna (INDIGO) *)</span>
    initSurr(landscape);
    maxState := doMove(HERE, FALSE);
    mvOptDir := {HERE};
    splOptDir := directSet.EMPTY_SET;
    <span class="keywd">for</span> dir <span class="keywd">range</span> firstDir <span class="keywd">to</span> lastDir <span class="keywd">do</span>
      <span class="keywd">if</span> landscape[dir].occupant &lt;> EDGE <span class="keywd">then</span>
        compare(dir, doMove(dir, FALSE), mvOptDir, splOptDir, maxState);
        <span class="keywd">if</span> landscape[dir].occupant = CLEAR <span class="keywd">then</span>
          compare(dir, doMove(dir, TRUE), splOptDir, mvOptDir, maxState);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;

    <span class="keywd">if</span> splOptDir &lt;> directSet.EMPTY_SET <span class="keywd">then</span>
      split(ranDir(splOptDir), splHereSize, splThereSize);
    <span class="keywd">else</span>
      dir := ranDir(mvOptDir);
      <span class="keywd">if</span> view(dir) &lt;> CLEAR <span class="op">and</span> dir &lt;> HERE <span class="keywd">then</span>
        kill(dir);
      <span class="keywd">else</span>
        eat(dir, ownSize);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* dna (INDIGO) *)</span>
</pre>
</body>
</html>
