<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  db_prop.s7i   Collection of database properties.                *)</span>
<span class="comment">(*  Copyright (C) 2014, 2017 - 2019  Thomas Mertes                  *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/sql_base.htm">sql_base.s7i</a>"</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">set</span> <span class="type">of</span> <span class="type">char</span>: forbiddenInFieldName (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">set</span> <span class="type">of</span> <span class="type">char</span>: forbidden <span class="keywd">is</span> (<span class="type">set</span> <span class="type">of</span> <span class="type">char</span>).EMPTY_SET;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      forbidden := {<span class="stri">'\0;'</span>, <span class="stri">' '</span>, <span class="stri">'\t'</span>, <span class="stri">'\n'</span>};
      <span class="keywd">when</span> {DB_SQLITE}:     forbidden := {<span class="stri">'\0;'</span>};
      <span class="keywd">when</span> {DB_POSTGRESQL}: forbidden := {<span class="stri">'\0;'</span>};
      <span class="keywd">when</span> {DB_OCI}:        forbidden := {<span class="stri">'\0;'</span>, <span class="stri">'\"'</span>};
      <span class="keywd">when</span> {DB_FIRE}:       forbidden := (<span class="type">set</span> <span class="type">of</span> <span class="type">char</span>).EMPTY_SET;
      <span class="keywd">when</span> {DB_SQL_SERVER}: forbidden := {<span class="stri">'\0;'</span>};
      <span class="keywd">when</span> {DB_DB2}:        forbidden := (<span class="type">set</span> <span class="type">of</span> <span class="type">char</span>).EMPTY_SET;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: allowedInFieldName (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind, <span class="op">in</span> <span class="type">char</span>: ch) <span class="keywd">is</span>
    <span class="keywd">return</span> ch <span class="op">not</span> <span class="op">in</span> forbiddenInFieldName(databaseKind);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: transactionLocks (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: transactionLocks <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      transactionLocks := FALSE;
      <span class="keywd">when</span> {DB_SQLITE}:     transactionLocks := FALSE;
      <span class="keywd">when</span> {DB_POSTGRESQL}: transactionLocks := FALSE;
      <span class="keywd">when</span> {DB_OCI}:        transactionLocks := FALSE;
      <span class="keywd">when</span> {DB_FIRE}:       transactionLocks := FALSE;
      <span class="keywd">when</span> {DB_SQL_SERVER}: transactionLocks := TRUE;
      <span class="keywd">when</span> {DB_DB2}:        transactionLocks := TRUE;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the SQL datatype capable to store 8-bit integers.
 *  This 8-bit integer datatype might be signed or unsigned.
 *  @return the name of the SQL datatype for 8-bit integers.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: int8Type (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: int8Type <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      int8Type := <span class="stri">"TINYINT"</span>;
      <span class="keywd">when</span> {DB_SQLITE}:     int8Type := <span class="stri">"TINYINT"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}: int8Type := <span class="stri">"SMALLINT"</span>;
      <span class="keywd">when</span> {DB_OCI}:        int8Type := <span class="stri">"SMALLINT"</span>;
      <span class="keywd">when</span> {DB_FIRE}:       int8Type := <span class="stri">"SMALLINT"</span>;
      <span class="keywd">when</span> {DB_SQL_SERVER}: int8Type := <span class="stri">"TINYINT"</span>;
      <span class="keywd">when</span> {DB_DB2}:        int8Type := <span class="stri">"SMALLINT"</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the maximum value for the 8-bit integer datatype.
 *  This maximum shows if the 8-bit integer datatype is signed or unsigned.
 *  @return the maximum value for the 8-bit integer datatype.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: maxInt8Value (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: maxInt8Value <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      maxInt8Value := 127;
      <span class="keywd">when</span> {DB_SQLITE}:     maxInt8Value := 127;
      <span class="keywd">when</span> {DB_POSTGRESQL}: maxInt8Value := 127;
      <span class="keywd">when</span> {DB_OCI}:        maxInt8Value := 127;
      <span class="keywd">when</span> {DB_FIRE}:       maxInt8Value := 127;
      <span class="keywd">when</span> {DB_SQL_SERVER}: maxInt8Value := 255;
      <span class="keywd">when</span> {DB_DB2}:        maxInt8Value := 127;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the SQL datatype capable to store 64-bit signed integers.
 *  @return the name of the SQL datatype for 64-bit integers.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: int64Type (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: int64Type <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      int64Type := <span class="stri">"BIGINT"</span>;
      <span class="keywd">when</span> {DB_SQLITE}:     int64Type := <span class="stri">"BIGINT"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}: int64Type := <span class="stri">"BIGINT"</span>;
      <span class="keywd">when</span> {DB_OCI}:        int64Type := <span class="stri">"INTEGER"</span>;
      <span class="keywd">when</span> {DB_FIRE}:       int64Type := <span class="stri">"BIGINT"</span>;
      <span class="keywd">when</span> {DB_SQL_SERVER}: int64Type := <span class="stri">"BIGINT"</span>;
      <span class="keywd">when</span> {DB_DB2}:        int64Type := <span class="stri">"BIGINT"</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: withRangeCheck (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: withRangeCheck <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      withRangeCheck := FALSE;
      <span class="keywd">when</span> {DB_SQLITE}:     withRangeCheck := FALSE;
      <span class="keywd">when</span> {DB_POSTGRESQL}: withRangeCheck := TRUE;
      <span class="keywd">when</span> {DB_OCI}:        withRangeCheck := FALSE;
      <span class="keywd">when</span> {DB_FIRE}:       withRangeCheck := TRUE;
      <span class="keywd">when</span> {DB_SQL_SERVER}: withRangeCheck := TRUE;
      <span class="keywd">when</span> {DB_DB2}:        withRangeCheck := TRUE;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: bigIntType (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: bigIntType <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      bigIntType := <span class="stri">"DECIMAL(65)"</span>;
      <span class="keywd">when</span> {DB_SQLITE}:     bigIntType := <span class="stri">"DECIMAL"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}: bigIntType := <span class="stri">"DECIMAL"</span>;
      <span class="keywd">when</span> {DB_OCI}:        bigIntType := <span class="stri">"DECIMAL"</span>;
      <span class="keywd">when</span> {DB_FIRE}:       bigIntType := <span class="stri">"DECIMAL(18)"</span>;
      <span class="keywd">when</span> {DB_SQL_SERVER}: bigIntType := <span class="stri">"DECIMAL(38)"</span>;
      <span class="keywd">when</span> {DB_DB2}:        bigIntType := <span class="stri">"DECIMAL(31)"</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: sqlIntLiteralBits (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: sqlIntLiteralBits <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      sqlIntLiteralBits := 216;
      <span class="keywd">when</span> {DB_SQLITE}:     sqlIntLiteralBits := 64;
      <span class="keywd">when</span> {DB_POSTGRESQL}: sqlIntLiteralBits := 435411;
      <span class="keywd">when</span> {DB_OCI}:        sqlIntLiteralBits := 127;
      <span class="keywd">when</span> {DB_FIRE}:       sqlIntLiteralBits := 64;
      <span class="keywd">when</span> {DB_SQL_SERVER}: sqlIntLiteralBits := 127;
      <span class="keywd">when</span> {DB_DB2}:        sqlIntLiteralBits := 103;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: bigIntTypeBits (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: bigIntTypeBits <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      bigIntTypeBits := 216;
      <span class="keywd">when</span> {DB_SQLITE}:     bigIntTypeBits := integer.last;
      <span class="keywd">when</span> {DB_POSTGRESQL}: bigIntTypeBits := 435411;
      <span class="keywd">when</span> {DB_OCI}:        bigIntTypeBits := 127;
      <span class="keywd">when</span> {DB_FIRE}:       bigIntTypeBits := 64;
      <span class="keywd">when</span> {DB_SQL_SERVER}: bigIntTypeBits := 127;
      <span class="keywd">when</span> {DB_DB2}:        bigIntTypeBits := 103;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the SQL datatype capable to store single precision floats.
 *  @return the name of the SQL datatype for single precision floats.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: floatType (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: floatType <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      floatType := <span class="stri">"FLOAT"</span>;
      <span class="keywd">when</span> {DB_SQLITE}:     floatType := <span class="stri">"REAL"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}: floatType := <span class="stri">"REAL"</span>;
      <span class="keywd">when</span> {DB_OCI}:        floatType := <span class="stri">"FLOAT"</span>;
      <span class="keywd">when</span> {DB_FIRE}:       floatType := <span class="stri">"FLOAT"</span>;
      <span class="keywd">when</span> {DB_SQL_SERVER}: floatType := <span class="stri">"REAL"</span>;
      <span class="keywd">when</span> {DB_DB2}:        floatType := <span class="stri">"REAL"</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: compareFloatAsDecimalString (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: compareFloatAsDecimalString <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      compareFloatAsDecimalString := FALSE;
      <span class="keywd">when</span> {DB_SQLITE}:     compareFloatAsDecimalString := FALSE;
      <span class="keywd">when</span> {DB_POSTGRESQL}: compareFloatAsDecimalString := FALSE;
      <span class="keywd">when</span> {DB_OCI}:        compareFloatAsDecimalString := TRUE;
      <span class="keywd">when</span> {DB_FIRE}:       compareFloatAsDecimalString := FALSE;
      <span class="keywd">when</span> {DB_SQL_SERVER}: compareFloatAsDecimalString := FALSE;
      <span class="keywd">when</span> {DB_DB2}:        compareFloatAsDecimalString := FALSE;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the SQL datatype capable to store double precision floats.
 *  @return the name of the SQL datatype for double precision floats.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: doubleType (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: doubleType <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      doubleType := <span class="stri">"DOUBLE"</span>;
      <span class="keywd">when</span> {DB_SQLITE}:     doubleType := <span class="stri">"DOUBLE"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}: doubleType := <span class="stri">"DOUBLE PRECISION"</span>;
      <span class="keywd">when</span> {DB_OCI}:        doubleType := <span class="stri">"DOUBLE PRECISION"</span>;
      <span class="keywd">when</span> {DB_FIRE}:       doubleType := <span class="stri">"DOUBLE PRECISION"</span>;
      <span class="keywd">when</span> {DB_SQL_SERVER}: doubleType := <span class="stri">"DOUBLE PRECISION"</span>;
      <span class="keywd">when</span> {DB_DB2}:        doubleType := <span class="stri">"DOUBLE"</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: compareDoubleAsDecimalString (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: compareDoubleAsDecimalString <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      compareDoubleAsDecimalString := FALSE;
      <span class="keywd">when</span> {DB_SQLITE}:     compareDoubleAsDecimalString := FALSE;
      <span class="keywd">when</span> {DB_POSTGRESQL}: compareDoubleAsDecimalString := FALSE;
      <span class="keywd">when</span> {DB_OCI}:        compareDoubleAsDecimalString := TRUE;
      <span class="keywd">when</span> {DB_FIRE}:       compareDoubleAsDecimalString := FALSE;
      <span class="keywd">when</span> {DB_SQL_SERVER}: compareDoubleAsDecimalString := FALSE;
      <span class="keywd">when</span> {DB_DB2}:        compareDoubleAsDecimalString := FALSE;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: bigRatType (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: bigRatType <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      bigRatType := <span class="stri">"DECIMAL(65,30)"</span>;
      <span class="keywd">when</span> {DB_SQLITE}:     bigRatType := <span class="stri">"NUMBER"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}: bigRatType := <span class="stri">"DECIMAL"</span>;
      <span class="keywd">when</span> {DB_OCI}:        bigRatType := <span class="stri">"NUMBER"</span>;
      <span class="keywd">when</span> {DB_FIRE}:       bigRatType := <span class="stri">"DECIMAL(18, 9)"</span>;
      <span class="keywd">when</span> {DB_SQL_SERVER}: bigRatType := <span class="stri">"NUMERIC(38,15)"</span>;
      <span class="keywd">when</span> {DB_DB2}:        bigRatType := <span class="stri">"DECIMAL(31,15)"</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the SQL datatype capable to store the biggest decimal integers.
 *  @return the name of the SQL datatype for the biggest decimal integers.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: decimalIntType (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: decimalType <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      decimalType := <span class="stri">"DECIMAL(65)"</span>;   <span class="comment"># DECIMAL(p), 1 &lt;= p &lt;= 65</span>
      <span class="keywd">when</span> {DB_SQLITE}:     decimalType := <span class="stri">"NUMBER"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}: decimalType := <span class="stri">"DECIMAL(100)"</span>;  <span class="comment"># DECIMAL(p), 1 &lt;= p &lt;= 1000</span>
      <span class="keywd">when</span> {DB_OCI}:        decimalType := <span class="stri">"NUMBER(38)"</span>;    <span class="comment"># NUMBER(p),  1 &lt;= p &lt;= 38</span>
      <span class="keywd">when</span> {DB_FIRE}:       decimalType := <span class="stri">"DECIMAL(18)"</span>;   <span class="comment"># DECIMAL(p), 1 &lt;= p &lt;= 18</span>
      <span class="keywd">when</span> {DB_SQL_SERVER}: decimalType := <span class="stri">"DECIMAL(38)"</span>;   <span class="comment"># DECIMAL(p), 1 &lt;= p &lt;= 38</span>
      <span class="keywd">when</span> {DB_DB2}:        decimalType := <span class="stri">"DECIMAL(31)"</span>;   <span class="comment"># DECIMAL(p), 1 &lt;= p &lt;= 31</span>
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the maximum precision of the decimal datatype.
 *  @return the precision (number of digits) of the decimal datatype.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: maxDecimalPrecision (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: precision <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      precision := 65;
      <span class="keywd">when</span> {DB_SQLITE}:     precision := 100;  <span class="comment"># NUMBER works without precision.</span>
      <span class="keywd">when</span> {DB_POSTGRESQL}: precision := 100;  <span class="comment"># PostgreSQL is tested with maximum precision of 100.</span>
      <span class="keywd">when</span> {DB_OCI}:        precision := 38;
      <span class="keywd">when</span> {DB_FIRE}:       precision := 18;
      <span class="keywd">when</span> {DB_SQL_SERVER}: precision := 38;
      <span class="keywd">when</span> {DB_DB2}:        precision := 31;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: maxDecimalLiteralPrecision (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: precision <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      precision := 65;
      <span class="keywd">when</span> {DB_SQLITE}:     precision := 13;
      <span class="keywd">when</span> {DB_POSTGRESQL}: precision := 100;
      <span class="keywd">when</span> {DB_OCI}:        precision := 38;
      <span class="keywd">when</span> {DB_FIRE}:       precision := 18;
      <span class="keywd">when</span> {DB_SQL_SERVER}: precision := 38;
      <span class="keywd">when</span> {DB_DB2}:        precision := 31;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the SQL datatype capable to store the biggest numeric integers.
 *  @return the name of the SQL datatype for the biggest numeric integers.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: numericIntType (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: numericType <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      numericType := <span class="stri">"NUMERIC(65)"</span>;   <span class="comment"># NUMERIC(p), 1 &lt;= p &lt;= 65</span>
      <span class="keywd">when</span> {DB_SQLITE}:     numericType := <span class="stri">"NUMBER"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}: numericType := <span class="stri">"NUMERIC(100)"</span>;  <span class="comment"># NUMERIC(p), 1 &lt;= p &lt;= 1000</span>
      <span class="keywd">when</span> {DB_OCI}:        numericType := <span class="stri">"NUMBER(38)"</span>;    <span class="comment"># NUMBER(p),  1 &lt;= p &lt;= 38</span>
      <span class="keywd">when</span> {DB_FIRE}:       numericType := <span class="stri">"NUMERIC(18)"</span>;   <span class="comment"># NUMERIC(p), 1 &lt;= p &lt;= 18</span>
      <span class="keywd">when</span> {DB_SQL_SERVER}: numericType := <span class="stri">"NUMERIC(38)"</span>;   <span class="comment"># NUMERIC(p), 1 &lt;= p &lt;= 38</span>
      <span class="keywd">when</span> {DB_DB2}:        numericType := <span class="stri">"NUMERIC(31)"</span>;   <span class="comment"># NUMERIC(p), 1 &lt;= p &lt;= 31</span>
     <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the maximum precision of the numeric datatype.
 *  @return the precision (number of digits) of the numeric datatype.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: maxNumericPrecision (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: precision <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      precision := 65;
      <span class="keywd">when</span> {DB_SQLITE}:     precision := 100;  <span class="comment"># NUMBER works without precision.</span>
      <span class="keywd">when</span> {DB_POSTGRESQL}: precision := 100;  <span class="comment"># PostgreSQL is tested with maximum precision of 100.</span>
      <span class="keywd">when</span> {DB_OCI}:        precision := 38;
      <span class="keywd">when</span> {DB_FIRE}:       precision := 18;
      <span class="keywd">when</span> {DB_SQL_SERVER}: precision := 38;
      <span class="keywd">when</span> {DB_DB2}:        precision := 31;
     <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: maxNumericLiteralPrecision (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: precision <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      precision := 65;
      <span class="keywd">when</span> {DB_SQLITE}:     precision := 13;
      <span class="keywd">when</span> {DB_POSTGRESQL}: precision := 100;
      <span class="keywd">when</span> {DB_OCI}:        precision := 38;
      <span class="keywd">when</span> {DB_FIRE}:       precision := 18;
      <span class="keywd">when</span> {DB_SQL_SERVER}: precision := 38;
      <span class="keywd">when</span> {DB_DB2}:        precision := 31;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the decimal datatype with the highest precision and a given scale.
 *  @return the name of the decimal datatype.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: decimalType (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind, <span class="op">in</span> <span class="type">integer</span>: scale) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: decimalType <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      decimalType := <span class="stri">"DECIMAL(65,"</span> &lt;&amp; scale &lt;&amp; <span class="stri">")"</span>;   <span class="comment"># DECIMAL(p,s), 1 &lt;= p &lt;= 65, 0 &lt;= s &lt;= 30</span>
      <span class="keywd">when</span> {DB_SQLITE}:     decimalType := <span class="stri">"NUMBER"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}: decimalType := <span class="stri">"DECIMAL(100,"</span> &lt;&amp; scale &lt;&amp; <span class="stri">")"</span>;  <span class="comment"># DECIMAL(p,s), 1 &lt;= p &lt;= 1000, 0 &lt;= s &lt;= p</span>
      <span class="keywd">when</span> {DB_OCI}:        decimalType := <span class="stri">"NUMBER(38,"</span> &lt;&amp; scale &lt;&amp; <span class="stri">")"</span>;    <span class="comment"># NUMBER(p,s),  1 &lt;= p &lt;= 38, -84 &lt;= s &lt;= 127</span>
      <span class="keywd">when</span> {DB_FIRE}:       decimalType := <span class="stri">"DECIMAL(18,"</span> &lt;&amp; scale &lt;&amp; <span class="stri">")"</span>;   <span class="comment"># DECIMAL(p,s), 1 &lt;= p &lt;= 18, 0 &lt;= s &lt;= p</span>
      <span class="keywd">when</span> {DB_SQL_SERVER}: decimalType := <span class="stri">"DECIMAL(38,"</span> &lt;&amp; scale &lt;&amp; <span class="stri">")"</span>;   <span class="comment"># DECIMAL(p,s), 1 &lt;= p &lt;= 38, 0 &lt;= s &lt;= p</span>
      <span class="keywd">when</span> {DB_DB2}:        decimalType := <span class="stri">"DECIMAL(31,"</span> &lt;&amp; scale &lt;&amp; <span class="stri">")"</span>;   <span class="comment"># DECIMAL(p,s), 1 &lt;= p &lt;= 31, 0 &lt;= s &lt;= p</span>
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the minimum scale allowed for the decimal datatype.
 *  @return the minimum scale allowed for the decimal datatype.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: minDecimalScale (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: scale <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      scale := 0;
      <span class="keywd">when</span> {DB_SQLITE}:     scale := -5;   <span class="comment"># NUMBER works without scale.</span>
      <span class="keywd">when</span> {DB_POSTGRESQL}: scale := 0;
      <span class="keywd">when</span> {DB_OCI}:        scale := -84;
      <span class="keywd">when</span> {DB_FIRE}:       scale := 0;
      <span class="keywd">when</span> {DB_SQL_SERVER}: scale := 0;
      <span class="keywd">when</span> {DB_DB2}:        scale := 0;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the maximum scale allowed for the decimal datatype.
 *  In several databases the scale must be less or equal to the precision.
 *  This function returns the maximum scale for the maximum precision.
 *  @return the maximum scale allowed for the decimal datatype.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: maxDecimalScale (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: scale <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      scale := 30;
      <span class="keywd">when</span> {DB_SQLITE}:     scale := 10;   <span class="comment"># NUMBER works without scale.</span>
      <span class="keywd">when</span> {DB_POSTGRESQL}: scale := 100;  <span class="comment"># PostgreSQL is tested with maximum precision of 100.</span>
      <span class="keywd">when</span> {DB_OCI}:        scale := 127;  <span class="comment"># The scale can be bigger than the precision.</span>
      <span class="keywd">when</span> {DB_FIRE}:       scale := 18;
      <span class="keywd">when</span> {DB_SQL_SERVER}: scale := 38;
      <span class="keywd">when</span> {DB_DB2}:        scale := 30;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the numeric datatype with the highest precision and a given scale.
 *  @return the name of the numeric datatype.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: numericType (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind, <span class="op">in</span> <span class="type">integer</span>: scale) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: numericType <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      numericType := <span class="stri">"NUMERIC(65,"</span> &lt;&amp; scale &lt;&amp; <span class="stri">")"</span>;   <span class="comment"># NUMERIC(p,s), 1 &lt;= p &lt;= 65, 0 &lt;= s &lt;= 30</span>
      <span class="keywd">when</span> {DB_SQLITE}:     numericType := <span class="stri">"NUMBER"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}: numericType := <span class="stri">"NUMERIC(100,"</span> &lt;&amp; scale &lt;&amp; <span class="stri">")"</span>;  <span class="comment"># NUMERIC(p,s), 1 &lt;= p &lt;= 1000, 0 &lt;= s &lt;= p</span>
      <span class="keywd">when</span> {DB_OCI}:        numericType := <span class="stri">"NUMBER(38,"</span> &lt;&amp; scale &lt;&amp; <span class="stri">")"</span>;    <span class="comment"># NUMBER(p,s),  1 &lt;= p &lt;= 38, -84 &lt;= s &lt;= 127</span>
      <span class="keywd">when</span> {DB_FIRE}:       numericType := <span class="stri">"NUMERIC(18,"</span> &lt;&amp; scale &lt;&amp; <span class="stri">")"</span>;   <span class="comment"># NUMERIC(p,s), 1 &lt;= p &lt;= 18, 0 &lt;= s &lt;= p</span>
      <span class="keywd">when</span> {DB_SQL_SERVER}: numericType := <span class="stri">"NUMERIC(38,"</span> &lt;&amp; scale &lt;&amp; <span class="stri">")"</span>;   <span class="comment"># NUMERIC(p,s), 1 &lt;= p &lt;= 38, 0 &lt;= s &lt;= p</span>
      <span class="keywd">when</span> {DB_DB2}:        numericType := <span class="stri">"NUMERIC(31,"</span> &lt;&amp; scale &lt;&amp; <span class="stri">")"</span>;   <span class="comment"># NUMERIC(p,s), 1 &lt;= p &lt;= 31, 0 &lt;= s &lt;= p</span>
     <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the minimum scale allowed for the numeric datatype.
 *  @return the minimum scale allowed for the numeric datatype.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: minNumericScale (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: scale <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      scale := 0;
      <span class="keywd">when</span> {DB_SQLITE}:     scale := -5;   <span class="comment"># NUMBER works without scale.</span>
      <span class="keywd">when</span> {DB_POSTGRESQL}: scale := 0;
      <span class="keywd">when</span> {DB_OCI}:        scale := -84;
      <span class="keywd">when</span> {DB_FIRE}:       scale := 0;
      <span class="keywd">when</span> {DB_SQL_SERVER}: scale := 0;
      <span class="keywd">when</span> {DB_DB2}:        scale := 0;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the maximum scale allowed for the numeric datatype.
 *  In several databases the scale must be less or equal to the precision.
 *  This function returns the maximum scale for the maximum precision.
 *  @return the maximum scale allowed for the numeric datatype.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: maxNumericScale (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: scale <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      scale := 30;
      <span class="keywd">when</span> {DB_SQLITE}:     scale := 10;   <span class="comment"># NUMBER works without scale.</span>
      <span class="keywd">when</span> {DB_POSTGRESQL}: scale := 100;  <span class="comment"># PostgreSQL is tested with maximum precision of 100.</span>
      <span class="keywd">when</span> {DB_OCI}:        scale := 127;  <span class="comment"># The scale can be bigger than the precision.</span>
      <span class="keywd">when</span> {DB_FIRE}:       scale := 18;
      <span class="keywd">when</span> {DB_SQL_SERVER}: scale := 38;
      <span class="keywd">when</span> {DB_DB2}:        scale := 30;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">char</span>: maxChar1FieldCharacter (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">char</span>: maxChar1FieldCharacter <span class="keywd">is</span> char.last;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      maxChar1FieldCharacter := <span class="stri">'\8888;'</span>; <span class="comment"># Code page 1252</span>
      <span class="keywd">when</span> {DB_SQLITE}:     maxChar1FieldCharacter := char.last;
      <span class="keywd">when</span> {DB_POSTGRESQL}: maxChar1FieldCharacter := char.last;
      <span class="keywd">when</span> {DB_OCI}:        maxChar1FieldCharacter := char.last;
      <span class="keywd">when</span> {DB_FIRE}:       maxChar1FieldCharacter := <span class="stri">'\127;'</span>;
      <span class="keywd">when</span> {DB_SQL_SERVER}: maxChar1FieldCharacter := char.last;
      <span class="keywd">when</span> {DB_DB2}:        maxChar1FieldCharacter := char.last;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: charFieldPreservesTrailingSpaces (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: charFieldPreservesTrailingSpaces <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      charFieldPreservesTrailingSpaces := FALSE;
      <span class="keywd">when</span> {DB_SQLITE}:     charFieldPreservesTrailingSpaces := TRUE;
      <span class="keywd">when</span> {DB_POSTGRESQL}: charFieldPreservesTrailingSpaces := FALSE;
      <span class="keywd">when</span> {DB_OCI}:        charFieldPreservesTrailingSpaces := FALSE;
      <span class="keywd">when</span> {DB_FIRE}:       charFieldPreservesTrailingSpaces := FALSE;
      <span class="keywd">when</span> {DB_SQL_SERVER}: charFieldPreservesTrailingSpaces := FALSE;
      <span class="keywd">when</span> {DB_DB2}:        charFieldPreservesTrailingSpaces := FALSE;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: nullAllowedInStringLiteral (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: nullAllowedInStringLiteral <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      nullAllowedInStringLiteral := TRUE;
      <span class="keywd">when</span> {DB_SQLITE}:     nullAllowedInStringLiteral := FALSE;
      <span class="keywd">when</span> {DB_POSTGRESQL}: nullAllowedInStringLiteral := FALSE;
      <span class="keywd">when</span> {DB_OCI}:        nullAllowedInStringLiteral := TRUE;
      <span class="keywd">when</span> {DB_FIRE}:       nullAllowedInStringLiteral := TRUE;
      <span class="keywd">when</span> {DB_SQL_SERVER}: nullAllowedInStringLiteral := FALSE;
      <span class="keywd">when</span> {DB_DB2}:        nullAllowedInStringLiteral := TRUE;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: nullAllowedInString (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: nullAllowedInString <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      nullAllowedInString := TRUE;
      <span class="keywd">when</span> {DB_SQLITE}:     nullAllowedInString := TRUE;
      <span class="keywd">when</span> {DB_POSTGRESQL}: nullAllowedInString := FALSE;
      <span class="keywd">when</span> {DB_OCI}:        nullAllowedInString := TRUE;
      <span class="keywd">when</span> {DB_FIRE}:       nullAllowedInString := TRUE;
      <span class="keywd">when</span> {DB_SQL_SERVER}: nullAllowedInString := FALSE;
      <span class="keywd">when</span> {DB_DB2}:        nullAllowedInString := TRUE;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the VARCHAR datatype of the database.
 *  @return the name of the VARCHAR datatype.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: varcharType (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: varcharType <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      varcharType := <span class="stri">"VARCHAR"</span>;
      <span class="keywd">when</span> {DB_SQLITE}:     varcharType := <span class="stri">"VARCHAR"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}: varcharType := <span class="stri">"VARCHAR"</span>;
      <span class="keywd">when</span> {DB_OCI}:        varcharType := <span class="stri">"VARCHAR2"</span>;
      <span class="keywd">when</span> {DB_FIRE}:       varcharType := <span class="stri">"VARCHAR"</span>;
      <span class="keywd">when</span> {DB_SQL_SERVER}: varcharType := <span class="stri">"VARCHAR"</span>;
      <span class="keywd">when</span> {DB_DB2}:        varcharType := <span class="stri">"VARCHAR"</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the BLOB datatype of the database.
 *  @return the name of the BLOB datatype.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: blobType (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: blobType <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      blobType := <span class="stri">"LONGBLOB"</span>;
      <span class="keywd">when</span> {DB_SQLITE}:     blobType := <span class="stri">"BLOB"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}: blobType := <span class="stri">"BYTEA"</span>;
      <span class="keywd">when</span> {DB_OCI}:        blobType := <span class="stri">"BLOB"</span>;
      <span class="keywd">when</span> {DB_FIRE}:       blobType := <span class="stri">"BLOB"</span>;
      <span class="keywd">when</span> {DB_SQL_SERVER}: blobType := <span class="stri">"VARBINARY(MAX)"</span>;
      <span class="keywd">when</span> {DB_DB2}:        blobType := <span class="stri">"BLOB(2G)"</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the CBLOB datatype of the database.
 *  @return the name of the CBLOB datatype.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: clobType (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: clobType <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      clobType := <span class="stri">"LONGTEXT"</span>;
      <span class="keywd">when</span> {DB_SQLITE}:     clobType := <span class="stri">"BLOB"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}: clobType := <span class="stri">"TEXT"</span>;
      <span class="keywd">when</span> {DB_OCI}:        clobType := <span class="stri">"CLOB"</span>;
      <span class="keywd">when</span> {DB_FIRE}:       clobType := <span class="stri">"BLOB SUB_TYPE TEXT"</span>;
      <span class="keywd">when</span> {DB_SQL_SERVER}: clobType := <span class="stri">"VARCHAR(MAX)"</span>;
      <span class="keywd">when</span> {DB_DB2}:        clobType := <span class="stri">"CLOB(2G)"</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: minDate (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: minDate <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      minDate := time(<span class="stri">"0-1-1 0:0:0"</span>);
      <span class="keywd">when</span> {DB_SQLITE}:     minDate := time(<span class="stri">"0-1-1 0:0:0"</span>);
      <span class="keywd">when</span> {DB_POSTGRESQL}: minDate := time(<span class="stri">"-4712-1-1 0:0:0"</span>);
      <span class="keywd">when</span> {DB_OCI}:        minDate := time(<span class="stri">"-4711-1-1 0:0:0"</span>);
      <span class="keywd">when</span> {DB_FIRE}:       minDate := time(<span class="stri">"0-1-1 0:0:0"</span>);
      <span class="keywd">when</span> {DB_SQL_SERVER}: minDate := time(<span class="stri">"1-1-1 0:0:0"</span>);
      <span class="keywd">when</span> {DB_DB2}:        minDate := time(<span class="stri">"1-1-1 0:0:0"</span>);
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: toDate (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind, <span class="op">in</span> <span class="type">string</span>: dateStri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: toDate <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">time</span>: aTime <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:
          aTime := time(dateStri);
          toDate := <span class="stri">"'"</span> &lt;&amp; aTime.year <span class="op">lpad0</span> 4 &lt;&amp; <span class="stri">"-"</span> &lt;&amp;
                    aTime.month &lt;&amp; <span class="stri">"-"</span> &lt;&amp; aTime.day &lt;&amp; <span class="stri">"'"</span>;
      <span class="keywd">when</span> {DB_SQLITE}:     toDate := <span class="stri">"'"</span> &amp; dateStri &amp; <span class="stri">"'"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}:
          aTime := time(dateStri);
          <span class="keywd">if</span> aTime.year &lt;= 0 <span class="keywd">then</span>
            toDate := <span class="stri">"make_date("</span> &lt;&amp; pred(aTime.year) &lt;&amp; <span class="stri">", "</span> &lt;&amp;
                      aTime.month &lt;&amp; <span class="stri">", "</span> &lt;&amp; aTime.day &lt;&amp; <span class="stri">")"</span>;
          <span class="keywd">else</span>
            toDate := <span class="stri">"make_date("</span> &lt;&amp; aTime.year &lt;&amp; <span class="stri">", "</span> &lt;&amp;
                      aTime.month &lt;&amp; <span class="stri">", "</span> &lt;&amp; aTime.day &lt;&amp; <span class="stri">")"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {DB_OCI}:
          <span class="keywd">if</span> dateStri[1] = <span class="stri">'-'</span> <span class="op">or</span> dateStri[1] = <span class="stri">'0'</span> <span class="keywd">then</span>
            aTime := time(dateStri);
            toDate := <span class="stri">"to_date('BC "</span> &lt;&amp;
                succ(-aTime.year) &lt;&amp; <span class="stri">"-"</span> &lt;&amp; aTime.month &lt;&amp; <span class="stri">"-"</span> &lt;&amp; aTime.day &lt;&amp;
                <span class="stri">"', 'BC YYYY-MM-DD')"</span>;
          <span class="keywd">else</span>
            toDate := <span class="stri">"to_date('"</span> &lt;&amp; dateStri &lt;&amp; <span class="stri">"', 'YYYY-MM-DD')"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {DB_FIRE}:       toDate := <span class="stri">"'"</span> &amp; dateStri &amp; <span class="stri">"'"</span>;
      <span class="keywd">when</span> {DB_SQL_SERVER}:
          aTime := time(dateStri);
          toDate := <span class="stri">"'"</span> &lt;&amp; aTime.year <span class="op">lpad0</span> 4 &lt;&amp; <span class="stri">"-"</span> &lt;&amp;
                    aTime.month &lt;&amp; <span class="stri">"-"</span> &lt;&amp; aTime.day &lt;&amp; <span class="stri">"'"</span>;
      <span class="keywd">when</span> {DB_DB2}:
          <span class="keywd">if</span> dateStri[1] = <span class="stri">'-'</span> <span class="op">or</span> dateStri[1] = <span class="stri">'0'</span> <span class="keywd">then</span>
            aTime := time(dateStri);
            toDate := <span class="stri">"to_date('"</span> &lt;&amp;
                pred(aTime.year) &lt;&amp; <span class="stri">"-"</span> &lt;&amp; aTime.month &lt;&amp; <span class="stri">"-"</span> &lt;&amp; aTime.day &lt;&amp;
                <span class="stri">"', 'YYYY-MM-DD')"</span>;
          <span class="keywd">else</span>
            toDate := <span class="stri">"to_date('"</span> &lt;&amp; dateStri &lt;&amp; <span class="stri">"', 'YYYY-MM-DD')"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: timeType (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: timeType <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      timeType := <span class="stri">"TIME"</span>;
      <span class="keywd">when</span> {DB_SQLITE}:     timeType := <span class="stri">"TIME"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}: timeType := <span class="stri">"TIME"</span>;
      <span class="keywd">when</span> {DB_OCI}:        timeType := <span class="stri">"DATE"</span>;
      <span class="keywd">when</span> {DB_FIRE}:       timeType := <span class="stri">"TIME"</span>;
      <span class="keywd">when</span> {DB_SQL_SERVER}: timeType := <span class="stri">"TIME"</span>;
      <span class="keywd">when</span> {DB_DB2}:        timeType := <span class="stri">"TIME"</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: toTime (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind, <span class="op">in</span> <span class="type">string</span>: timeStri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: toTime <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">time</span>: aTime <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      toTime := <span class="stri">"'"</span> &amp; timeStri &amp; <span class="stri">"'"</span>;
      <span class="keywd">when</span> {DB_SQLITE}:     toTime := <span class="stri">"'"</span> &amp; timeStri &amp; <span class="stri">"'"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}: toTime := <span class="stri">"'"</span> &amp; timeStri &amp; <span class="stri">"'"</span>;
      <span class="keywd">when</span> {DB_OCI}:
        toTime := <span class="stri">"to_date('BC 1-01-01 "</span> &lt;&amp; timeStri &lt;&amp; <span class="stri">"', 'BC YYYY-MM-DD HH24:MI:SS')"</span>;
      <span class="keywd">when</span> {DB_FIRE}:       toTime := <span class="stri">"'"</span> &amp; timeStri &amp; <span class="stri">"'"</span>;
      <span class="keywd">when</span> {DB_SQL_SERVER}: toTime := <span class="stri">"'"</span> &amp; timeStri &amp; <span class="stri">"'"</span>;
      <span class="keywd">when</span> {DB_DB2}:        toTime := <span class="stri">"'"</span> &amp; timeStri &amp; <span class="stri">"'"</span>;
        aTime := time(timeStri);
        toTime := <span class="stri">"time(to_timestamp('"</span> &lt;&amp;
                  aTime.hour &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.minute &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.second &lt;&amp;
                  <span class="stri">"."</span> &lt;&amp; aTime.micro_second <span class="op">lpad0</span> 6 &lt;&amp;
                  <span class="stri">"', 'HH24:MI:SS.FF'))"</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: dateTimeType (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: dateTimeType <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      dateTimeType := <span class="stri">"DATETIME"</span>;
      <span class="keywd">when</span> {DB_SQLITE}:     dateTimeType := <span class="stri">"DATETIME"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}: dateTimeType := <span class="stri">"TIMESTAMP"</span>;
      <span class="keywd">when</span> {DB_OCI}:        dateTimeType := <span class="stri">"DATE"</span>;
      <span class="keywd">when</span> {DB_FIRE}:       dateTimeType := <span class="stri">"DATETIME"</span>;
      <span class="keywd">when</span> {DB_SQL_SERVER}: dateTimeType := <span class="stri">"DATETIME2"</span>;
      <span class="keywd">when</span> {DB_DB2}:        dateTimeType := <span class="stri">"TIMESTAMP"</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: toDateTime (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind, <span class="op">in</span> <span class="type">string</span>: dateTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: toDateTime <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">time</span>: aTime <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:
          aTime := time(dateTime);
          toDateTime := <span class="stri">"'"</span> &lt;&amp; aTime.year <span class="op">lpad0</span> 4 &lt;&amp; <span class="stri">"-"</span> &lt;&amp;
              aTime.month &lt;&amp; <span class="stri">"-"</span> &lt;&amp; aTime.day &lt;&amp; <span class="stri">" "</span> &lt;&amp;
              aTime.hour &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.minute &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.second &lt;&amp; <span class="stri">"'"</span>;
      <span class="keywd">when</span> {DB_SQLITE}:     toDateTime := <span class="stri">"'"</span> &amp; dateTime &amp; <span class="stri">"'"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}:
          aTime := time(dateTime);
          <span class="keywd">if</span> aTime.year &lt;= 0 <span class="keywd">then</span>
            <span class="comment"># make_timestamp does not work for BC.</span>
            toDateTime := <span class="stri">"make_date("</span> &lt;&amp; pred(aTime.year) &lt;&amp; <span class="stri">", "</span> &lt;&amp;
                aTime.month &lt;&amp; <span class="stri">", "</span> &lt;&amp; aTime.day &lt;&amp; <span class="stri">") + time '"</span> &lt;&amp;
                aTime.hour &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.minute &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.second &lt;&amp; <span class="stri">"'"</span>;
          <span class="keywd">else</span>
            toDateTime := <span class="stri">"make_timestamp("</span> &lt;&amp;
                aTime.year &lt;&amp; <span class="stri">", "</span> &lt;&amp; aTime.month &lt;&amp; <span class="stri">", "</span> &lt;&amp; aTime.day &lt;&amp; <span class="stri">", "</span> &lt;&amp;
                aTime.hour &lt;&amp; <span class="stri">", "</span> &lt;&amp; aTime.minute &lt;&amp; <span class="stri">", "</span> &lt;&amp; aTime.second &lt;&amp; <span class="stri">")"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {DB_OCI}:
          <span class="keywd">if</span> dateTime[1] = <span class="stri">'-'</span> <span class="op">or</span> dateTime[1] = <span class="stri">'0'</span> <span class="keywd">then</span>
            aTime := time(dateTime);
            toDateTime := <span class="stri">"to_date('BC "</span> &lt;&amp;
                succ(-aTime.year) &lt;&amp; <span class="stri">"-"</span> &lt;&amp; aTime.month &lt;&amp; <span class="stri">"-"</span> &lt;&amp; aTime.day &lt;&amp;
                <span class="stri">" "</span> &lt;&amp; aTime.hour &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.minute &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.second &lt;&amp;
                <span class="stri">"', 'BC YYYY-MM-DD HH24:MI:SS')"</span>;
          <span class="keywd">else</span>
            toDateTime := <span class="stri">"to_date('"</span> &lt;&amp; dateTime &lt;&amp; <span class="stri">"', 'YYYY-MM-DD HH24:MI:SS')"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {DB_FIRE}:       toDateTime := <span class="stri">"'"</span> &amp; dateTime &amp; <span class="stri">"'"</span>;
      <span class="keywd">when</span> {DB_SQL_SERVER}:
          aTime := time(dateTime);
          toDateTime := <span class="stri">"'"</span> &lt;&amp; aTime.year <span class="op">lpad0</span> 4 &lt;&amp; <span class="stri">"-"</span> &lt;&amp;
              aTime.month &lt;&amp; <span class="stri">"-"</span> &lt;&amp; aTime.day &lt;&amp; <span class="stri">" "</span> &lt;&amp;
              aTime.hour &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.minute &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.second &lt;&amp; <span class="stri">"'"</span>;
      <span class="keywd">when</span> {DB_DB2}:
          <span class="keywd">if</span> dateTime[1] = <span class="stri">'-'</span> <span class="op">or</span> dateTime[1] = <span class="stri">'0'</span> <span class="keywd">then</span>
            aTime := time(dateTime);
            toDateTime := <span class="stri">"to_date('"</span> &lt;&amp;
                pred(aTime.year) &lt;&amp; <span class="stri">"-"</span> &lt;&amp; aTime.month &lt;&amp; <span class="stri">"-"</span> &lt;&amp; aTime.day &lt;&amp;
                <span class="stri">" "</span> &lt;&amp; aTime.hour &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.minute &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.second &lt;&amp;
                <span class="stri">"', 'YYYY-MM-DD HH24:MI:SS')"</span>;
          <span class="keywd">else</span>
            toDateTime := <span class="stri">"to_date('"</span> &lt;&amp; dateTime &lt;&amp; <span class="stri">"', 'YYYY-MM-DD HH24:MI:SS')"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: timeStampType (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: timeStampType <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      timeStampType := <span class="stri">"TIMESTAMP(6) NULL"</span>;
      <span class="keywd">when</span> {DB_SQLITE}:     timeStampType := <span class="stri">"VARCHAR"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}: timeStampType := <span class="stri">"TIMESTAMP"</span>;
      <span class="keywd">when</span> {DB_OCI}:        timeStampType := <span class="stri">"TIMESTAMP"</span>;
      <span class="keywd">when</span> {DB_FIRE}:       timeStampType := <span class="stri">"TIMESTAMP"</span>;
      <span class="keywd">when</span> {DB_SQL_SERVER}: timeStampType := <span class="stri">"DATETIME2"</span>;
      <span class="keywd">when</span> {DB_DB2}:        timeStampType := <span class="stri">"TIMESTAMP"</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: minTimeStamp (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: minTimeStamp <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      minTimeStamp := time(<span class="stri">"1970-1-2 0:0:0"</span>);
      <span class="keywd">when</span> {DB_SQLITE}:     minTimeStamp := time(<span class="stri">"0-1-1 0:0:0"</span>);
      <span class="keywd">when</span> {DB_POSTGRESQL}: minTimeStamp := time(<span class="stri">"-4712-1-1 0:0:0"</span>);
      <span class="keywd">when</span> {DB_OCI}:        minTimeStamp := time(<span class="stri">"0-1-1 0:0:0"</span>);
      <span class="keywd">when</span> {DB_FIRE}:       minTimeStamp := time(<span class="stri">"0-1-1 0:0:0"</span>);
      <span class="keywd">when</span> {DB_SQL_SERVER}: minTimeStamp := time(<span class="stri">"1-1-1 0:0:0"</span>);
      <span class="keywd">when</span> {DB_DB2}:        minTimeStamp := time(<span class="stri">"1-1-1 0:0:0"</span>);
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: toTimeStamp (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind, <span class="op">in</span> <span class="type">string</span>: timeStamp) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: toTimeStamp <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">time</span>: aTime <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      toTimeStamp := <span class="stri">"'"</span> &amp; timeStamp &amp; <span class="stri">"'"</span>;
      <span class="keywd">when</span> {DB_SQLITE}:     toTimeStamp := <span class="stri">"'"</span> &amp; timeStamp &amp; <span class="stri">"'"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}:
          aTime := time(timeStamp);
          <span class="keywd">if</span> aTime.year &lt;= 0 <span class="keywd">then</span>
            <span class="comment"># make_timestamp does not work for BC.</span>
            toTimeStamp := <span class="stri">"make_date("</span> &lt;&amp; pred(aTime.year) &lt;&amp; <span class="stri">", "</span> &lt;&amp;
                aTime.month &lt;&amp; <span class="stri">", "</span> &lt;&amp; aTime.day &lt;&amp; <span class="stri">") + time '"</span> &lt;&amp;
                aTime.hour &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.minute &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.second &lt;&amp; <span class="stri">"."</span> &lt;&amp;
                aTime.micro_second <span class="op">lpad0</span> 6 &lt;&amp; <span class="stri">"'"</span>;
          <span class="keywd">else</span>
            toTimeStamp := <span class="stri">"make_timestamp("</span> &lt;&amp;
                aTime.year &lt;&amp; <span class="stri">", "</span> &lt;&amp; aTime.month &lt;&amp; <span class="stri">", "</span> &lt;&amp; aTime.day &lt;&amp; <span class="stri">", "</span> &lt;&amp;
                aTime.hour &lt;&amp; <span class="stri">", "</span> &lt;&amp; aTime.minute &lt;&amp; <span class="stri">", "</span> &lt;&amp; aTime.second &lt;&amp; <span class="stri">"."</span> &lt;&amp;
                aTime.micro_second <span class="op">lpad0</span> 6 &lt;&amp; <span class="stri">")"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {DB_OCI}:
          <span class="keywd">if</span> timeStamp[1] = <span class="stri">'-'</span> <span class="op">or</span> timeStamp[1] = <span class="stri">'0'</span> <span class="keywd">then</span>
            aTime := time(timeStamp);
            toTimeStamp := <span class="stri">"to_timestamp('BC "</span> &lt;&amp;
                succ(-aTime.year) &lt;&amp; <span class="stri">"-"</span> &lt;&amp; aTime.month &lt;&amp; <span class="stri">"-"</span> &lt;&amp; aTime.day &lt;&amp;
                <span class="stri">" "</span> &lt;&amp; aTime.hour &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.minute &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.second &lt;&amp;
                <span class="stri">"."</span> &lt;&amp; aTime.micro_second <span class="op">lpad0</span> 6 &lt;&amp;
                <span class="stri">"', 'BC YYYY-MM-DD HH24:MI:SS.FF')"</span>;
          <span class="keywd">else</span>
            toTimeStamp := <span class="stri">"to_timestamp('"</span> &lt;&amp; timeStamp &lt;&amp; <span class="stri">"', 'YYYY-MM-DD HH24:MI:SS.FF')"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {DB_FIRE}:       toTimeStamp := <span class="stri">"'"</span> &amp; timeStamp &amp; <span class="stri">"'"</span>;
      <span class="keywd">when</span> {DB_SQL_SERVER}:
          aTime := time(timeStamp);
          toTimeStamp := <span class="stri">"'"</span> &lt;&amp; aTime.year <span class="op">lpad0</span> 4 &lt;&amp; <span class="stri">"-"</span> &lt;&amp;
              aTime.month &lt;&amp; <span class="stri">"-"</span> &lt;&amp; aTime.day &lt;&amp; <span class="stri">" "</span> &lt;&amp;
              aTime.hour &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.minute &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.second &lt;&amp;
              <span class="stri">"."</span> &lt;&amp; aTime.micro_second <span class="op">lpad0</span> 6 &lt;&amp; <span class="stri">"'"</span>;
      <span class="keywd">when</span> {DB_DB2}:
          aTime := time(timeStamp);
          <span class="keywd">if</span> aTime.year &lt;= 0 <span class="keywd">then</span>
            toTimeStamp := <span class="stri">"to_timestamp('"</span> &lt;&amp;
                pred(aTime.year) &lt;&amp; <span class="stri">"-"</span> &lt;&amp; aTime.month &lt;&amp; <span class="stri">"-"</span> &lt;&amp; aTime.day &lt;&amp;
                <span class="stri">" "</span> &lt;&amp; aTime.hour &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.minute &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.second &lt;&amp;
                <span class="stri">"."</span> &lt;&amp; aTime.micro_second <span class="op">lpad0</span> 6 &lt;&amp;
                <span class="stri">"', 'YYYY-MM-DD HH24:MI:SS.FF')"</span>;
          <span class="keywd">else</span>
            toTimeStamp := <span class="stri">"to_timestamp('"</span> &lt;&amp;
                aTime.year &lt;&amp; <span class="stri">"-"</span> &lt;&amp; aTime.month &lt;&amp; <span class="stri">"-"</span> &lt;&amp; aTime.day &lt;&amp;
                <span class="stri">" "</span> &lt;&amp; aTime.hour &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.minute &lt;&amp; <span class="stri">":"</span> &lt;&amp; aTime.second &lt;&amp;
                <span class="stri">"."</span> &lt;&amp; aTime.micro_second <span class="op">lpad0</span> 6 &lt;&amp;
                <span class="stri">"', 'YYYY-MM-DD HH24:MI:SS.FF')"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: timeStampTzType (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: timeStampTzType <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      timeStampTzType := <span class="stri">"TIMESTAMP(6) NULL"</span>;
      <span class="keywd">when</span> {DB_SQLITE}:     timeStampTzType := <span class="stri">"VARCHAR"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}: timeStampTzType := <span class="stri">"TIMESTAMP"</span>;
      <span class="keywd">when</span> {DB_OCI}:        timeStampTzType := <span class="stri">"TIMESTAMP WITH TIME ZONE"</span>;
      <span class="keywd">when</span> {DB_FIRE}:       timeStampTzType := <span class="stri">"TIMESTAMP"</span>;
      <span class="keywd">when</span> {DB_SQL_SERVER}: timeStampTzType := <span class="stri">"DATETIME2"</span>;
      <span class="keywd">when</span> {DB_DB2}:        timeStampTzType := <span class="stri">"TIMESTAMP"</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: durationType (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: durationType <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      durationType := <span class="stri">"DATETIME"</span>;
      <span class="keywd">when</span> {DB_SQLITE}:     durationType := <span class="stri">"VARCHAR(32)"</span>;
      <span class="keywd">when</span> {DB_POSTGRESQL}: durationType := <span class="stri">"INTERVAL"</span>;
      <span class="keywd">when</span> {DB_OCI}:        durationType := <span class="stri">"INTERVAL DAY TO SECOND"</span>;
      <span class="keywd">when</span> {DB_FIRE}:       durationType := <span class="stri">"TIMESTAMP"</span>;
      <span class="keywd">when</span> {DB_SQL_SERVER}: durationType := <span class="stri">"DATETIMEOFFSET"</span>; <span class="comment"># "INTERVAL DAY(3) TO SECOND(6)";</span>
      <span class="keywd">when</span> {DB_DB2}:        durationType := <span class="stri">"TIMESTAMP"</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: supportsFloatingDecimals (<span class="op">in</span> <span class="type">dbCategory</span>: databaseKind) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: supportsFloatingDecimals <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> databaseKind <span class="keywd">of</span>
      <span class="keywd">when</span> {DB_MYSQL}:      supportsFloatingDecimals := FALSE;
      <span class="keywd">when</span> {DB_SQLITE}:     supportsFloatingDecimals := TRUE;
      <span class="keywd">when</span> {DB_POSTGRESQL}: supportsFloatingDecimals := TRUE;
      <span class="keywd">when</span> {DB_OCI}:        supportsFloatingDecimals := TRUE;
      <span class="keywd">when</span> {DB_SQL_SERVER}: supportsFloatingDecimals := FALSE;
      <span class="keywd">when</span> {DB_DB2}:        supportsFloatingDecimals := TRUE;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


</pre>
</body>
</html>
