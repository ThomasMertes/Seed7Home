<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  seed7_05.s7i  Standard Seed7 library                            *)</span>
<span class="comment">(*  Copyright (C) 1989 - 2013  Thomas Mertes                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/syntax.htm">syntax.s7i</a>"</span>;

<span class="comment">(*
$ const $ type: type   is $ newtype;

$ const type: void     is $ newtype;
$ const type: proc     is $ func void;
$ const void: empty    is $ enumlit;

$ const type: expr     is $ newtype;
$ const type: object   is $ newtype;
$ const type: string   is $ subtype object;
$ const type: ACTION   is $ newtype;
$ const type: f_param  is $ newtype;
*)</span>

$ <span class="keywd">const</span> $ <span class="type">func</span> <span class="type">type</span>: $ <span class="type">func</span> (<span class="keywd">ref</span> <span class="type">type</span> <span class="keywd">param</span>)    <span class="keywd">is</span> $ action <span class="stri">"TYP_FUNC"</span>;
$ <span class="keywd">const</span> $ <span class="type">func</span> <span class="type">type</span>: $ <span class="type">varfunc</span> (<span class="keywd">ref</span> <span class="type">type</span> <span class="keywd">param</span>) <span class="keywd">is</span> $ action <span class="stri">"TYP_VARFUNC"</span>;

$ <span class="keywd">const</span> <span class="type">func</span> ACTION: $ action (<span class="keywd">ref</span> <span class="type">string</span> <span class="keywd">param</span>)                    <span class="keywd">is</span> $ action <span class="stri">"ACT_GEN"</span>;
$ <span class="keywd">const</span> creator:     $ (<span class="keywd">ref</span> creator <span class="keywd">param</span>) ::= (<span class="keywd">ref</span> ACTION <span class="keywd">param</span>)   <span class="keywd">is</span> $ action <span class="stri">"ACT_CREATE"</span>;
$ <span class="keywd">const</span> creator:     $ (<span class="keywd">ref</span> destroyer <span class="keywd">param</span>) ::= (<span class="keywd">ref</span> ACTION <span class="keywd">param</span>) <span class="keywd">is</span> $ action <span class="stri">"ACT_CREATE"</span>;
$ <span class="keywd">const</span> destroyer:   $ destroy (<span class="keywd">ref</span> <span class="type">string</span> <span class="keywd">param</span>)                   <span class="keywd">is</span>   action <span class="stri">"STR_DESTR"</span>;
$ <span class="keywd">const</span> creator:     $ (<span class="keywd">ref</span> <span class="type">proc</span> <span class="keywd">param</span>) ::= (<span class="keywd">ref</span> ACTION <span class="keywd">param</span>)      <span class="keywd">is</span>   action <span class="stri">"ACT_CREATE"</span>;

$ <span class="keywd">const</span> creator:      $ (<span class="keywd">ref</span> <span class="type">func</span> f_param <span class="keywd">param</span>) ::= (<span class="keywd">ref</span> ACTION <span class="keywd">param</span>) <span class="keywd">is</span> action <span class="stri">"ACT_CREATE"</span>;
$ <span class="keywd">const</span> <span class="type">func</span> f_param: $ <span class="keywd">ref</span> (<span class="keywd">ref</span> <span class="type">type</span> <span class="keywd">param</span>) <span class="keywd">param</span>                      <span class="keywd">is</span> action <span class="stri">"DCL_REF1"</span>;

$ <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">const</span> (<span class="keywd">ref</span> <span class="type">type</span> <span class="keywd">param</span>) : (<span class="keywd">ref</span> <span class="type">expr</span> <span class="keywd">param</span>) <span class="keywd">is</span> (<span class="keywd">ref</span> <span class="type">expr</span> <span class="keywd">param</span>) <span class="keywd">is</span> action <span class="stri">"DCL_CONST"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">const</span>  (<span class="keywd">ref</span> <span class="type">type</span> <span class="keywd">param</span>) : (<span class="keywd">ref</span> <span class="type">expr</span> <span class="keywd">param</span>) <span class="keywd">is</span> <span class="keywd">forward</span>           <span class="keywd">is</span> action <span class="stri">"DCL_FWD"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">var</span>    (<span class="keywd">ref</span> <span class="type">type</span> <span class="keywd">param</span>) : (<span class="keywd">ref</span> <span class="type">expr</span> <span class="keywd">param</span>) <span class="keywd">is</span> (<span class="keywd">ref</span> <span class="type">expr</span> <span class="keywd">param</span>)  <span class="keywd">is</span> action <span class="stri">"DCL_VAR"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">var</span>    (<span class="keywd">ref</span> <span class="type">type</span> <span class="keywd">param</span>) : (<span class="keywd">ref</span> <span class="type">expr</span> <span class="keywd">param</span>) <span class="keywd">is</span> <span class="keywd">forward</span>           <span class="keywd">is</span> action <span class="stri">"DCL_FWDVAR"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">syntax</span> (<span class="keywd">ref</span> <span class="type">type</span> <span class="keywd">param</span>) : (<span class="keywd">ref</span> <span class="type">expr</span> <span class="keywd">param</span>) <span class="keywd">is</span> (<span class="keywd">ref</span> <span class="type">expr</span> <span class="keywd">param</span>)  <span class="keywd">is</span> action <span class="stri">"DCL_SYNTAX"</span>;

<span class="keywd">const</span> <span class="type">func</span> f_param: <span class="keywd">ref</span> (<span class="keywd">ref</span> <span class="type">type</span> <span class="keywd">param</span>) : (<span class="keywd">ref</span> <span class="type">expr</span> <span class="keywd">param</span>)     <span class="keywd">is</span> action <span class="stri">"DCL_REF2"</span>;
<span class="keywd">const</span> <span class="type">func</span> f_param: <span class="keywd">val</span> (<span class="keywd">ref</span> <span class="type">type</span>: aType) <span class="keywd">param</span>                 <span class="keywd">is</span> action <span class="stri">"DCL_VAL1"</span>;
<span class="keywd">const</span> <span class="type">func</span> f_param: <span class="keywd">val</span> (<span class="keywd">ref</span> <span class="type">type</span>: aType) : (<span class="keywd">ref</span> <span class="type">expr</span>: name)    <span class="keywd">is</span> action <span class="stri">"DCL_VAL2"</span>;
<span class="keywd">const</span> <span class="type">func</span> f_param: <span class="op">in</span> (<span class="keywd">ref</span> <span class="type">type</span>: aType) <span class="keywd">param</span>                  <span class="keywd">is</span> action <span class="stri">"DCL_IN1"</span>;
<span class="keywd">const</span> <span class="type">func</span> f_param: <span class="op">in</span> (<span class="keywd">ref</span> <span class="type">type</span>: aType) : (<span class="keywd">ref</span> <span class="type">expr</span>: name)     <span class="keywd">is</span> action <span class="stri">"DCL_IN2"</span>;
<span class="keywd">const</span> <span class="type">func</span> f_param: <span class="op">in</span> <span class="keywd">var</span> (<span class="keywd">ref</span> <span class="type">type</span>: aType) <span class="keywd">param</span>              <span class="keywd">is</span> action <span class="stri">"DCL_IN1VAR"</span>;
<span class="keywd">const</span> <span class="type">func</span> f_param: <span class="op">in</span> <span class="keywd">var</span> (<span class="keywd">ref</span> <span class="type">type</span>: aType) : (<span class="keywd">ref</span> <span class="type">expr</span>: name) <span class="keywd">is</span> action <span class="stri">"DCL_IN2VAR"</span>;
<span class="keywd">const</span> <span class="type">func</span> f_param: <span class="keywd">inout</span> (<span class="keywd">ref</span> <span class="type">type</span>: aType) <span class="keywd">param</span>               <span class="keywd">is</span> action <span class="stri">"DCL_INOUT1"</span>;
<span class="keywd">const</span> <span class="type">func</span> f_param: <span class="keywd">inout</span> (<span class="keywd">ref</span> <span class="type">type</span>: aType) : (<span class="keywd">ref</span> <span class="type">expr</span>: name)  <span class="keywd">is</span> action <span class="stri">"DCL_INOUT2"</span>;
<span class="keywd">const</span> <span class="type">func</span> f_param: attr (<span class="keywd">ref</span> <span class="type">type</span>: aType)                      <span class="keywd">is</span> action <span class="stri">"DCL_ATTR"</span>;
<span class="keywd">const</span> <span class="type">func</span> f_param: attr (<span class="keywd">ref</span> f_param: aParam)                  <span class="keywd">is</span> action <span class="stri">"DCL_PARAM_ATTR"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: global (<span class="keywd">ref</span> <span class="type">proc</span>: statement) <span class="keywd">end</span> global             <span class="keywd">is</span> action <span class="stri">"DCL_GLOBAL"</span>;

<span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">type</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">type</span>: source)          <span class="keywd">is</span> action <span class="stri">"TYP_CREATE"</span>;
<span class="keywd">const</span> destroyer: destroy (<span class="keywd">ref</span> <span class="type">type</span>: aValue)                     <span class="keywd">is</span> action <span class="stri">"TYP_DESTR"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">type</span>: dest) := (<span class="keywd">ref</span> <span class="type">type</span>: source)             <span class="keywd">is</span> action <span class="stri">"TYP_CPY"</span>;
<span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">proc</span>: dest) ::= (<span class="keywd">ref</span> ACTION: source)    <span class="keywd">is</span> action <span class="stri">"ACT_CREATE"</span>;
<span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">varfunc</span> <span class="type">proc</span>: dest) ::= (<span class="keywd">ref</span> ACTION: source) <span class="keywd">is</span> action <span class="stri">"ACT_CREATE"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">proc</span>: <span class="type">func</span> <span class="keywd">begin</span> (<span class="keywd">ref</span> <span class="type">expr</span>: statements) <span class="keywd">end</span> <span class="keywd">func</span>      <span class="keywd">is</span> action <span class="stri">"PRC_BEGIN"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">proc</span>: <span class="type">func</span> <span class="keywd">begin</span> <span class="keywd">end</span> <span class="keywd">func</span>                             <span class="keywd">is</span> action <span class="stri">"PRC_BEGIN_NOOP"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">proc</span>: <span class="type">func</span> <span class="keywd">local</span> (<span class="keywd">ref</span> <span class="type">proc</span>: localDefinitions)
                 <span class="keywd">begin</span> (<span class="keywd">ref</span> <span class="type">expr</span>: statements) <span class="keywd">end</span> <span class="keywd">func</span>        <span class="keywd">is</span> action <span class="stri">"PRC_LOCAL"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">proc</span>: <span class="keywd">return</span> (<span class="keywd">ref</span> <span class="type">void</span>: statement)                 <span class="keywd">is</span> action <span class="stri">"PRC_RETURN"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">proc</span>: <span class="keywd">return</span> (<span class="keywd">ref</span> <span class="type">proc</span>: statement)                 <span class="keywd">is</span> action <span class="stri">"PRC_RETURN"</span>;
<span class="keywd">const</span> creator: (<span class="keywd">ref</span> creator: dest) ::= (<span class="keywd">ref</span> <span class="type">proc</span>: source)     <span class="keywd">is</span> action <span class="stri">"PRC_CREATE"</span>;
<span class="keywd">const</span> creator: (<span class="keywd">ref</span> destroyer: dest) ::= (<span class="keywd">ref</span> <span class="type">proc</span>: source)   <span class="keywd">is</span> action <span class="stri">"PRC_CREATE"</span>;
<span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">proc</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">proc</span>: source)        <span class="keywd">is</span> action <span class="stri">"PRC_CREATE"</span>;
<span class="keywd">const</span> destroyer: destroy (<span class="keywd">ref</span> <span class="type">proc</span>: aValue)                   <span class="keywd">is</span> action <span class="stri">"PRC_DESTR"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">proc</span>: dest) := (<span class="keywd">ref</span> <span class="type">proc</span>: source)          <span class="keywd">is</span> action <span class="stri">"PRC_CPY"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: noop                                              <span class="keywd">is</span> action <span class="stri">"PRC_NOOP"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">ref</span> <span class="type">void</span>: statement1) ; (<span class="keywd">ref</span> <span class="type">void</span>: statement2)   <span class="keywd">is</span> noop;
<span class="keywd">const</span> <span class="type">proc</span>: ignore (<span class="keywd">ref</span> f_param: aParam)                      <span class="keywd">is</span> noop;

<span class="keywd">const</span> <span class="type">proc</span>: PRINT (<span class="keywd">ref</span> <span class="type">string</span>: stri)                          <span class="keywd">is</span> action <span class="stri">"FIL_PRINT"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: IN_PARAM_IS_VALUE (<span class="keywd">ref</span> <span class="type">type</span>: aType)               <span class="keywd">is</span> action <span class="stri">"TYP_SET_IN_PARAM_VALUE"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: IN_PARAM_IS_REFERENCE (<span class="keywd">ref</span> <span class="type">type</span>: aType)           <span class="keywd">is</span> action <span class="stri">"TYP_SET_IN_PARAM_REF"</span>;

IN_PARAM_IS_VALUE(type);
IN_PARAM_IS_VALUE(void);
IN_PARAM_IS_REFERENCE(proc);
IN_PARAM_IS_REFERENCE(expr);
IN_PARAM_IS_REFERENCE(object);
IN_PARAM_IS_REFERENCE(string);
IN_PARAM_IS_REFERENCE(ACTION);
IN_PARAM_IS_REFERENCE(creator);
IN_PARAM_IS_REFERENCE(destroyer);

<span class="keywd">const</span> <span class="type">proc</span>: BASIC_TYPE_DECLS (<span class="op">in</span> <span class="type">type</span>: aType) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    global
<span class="comment">(*    PRINT("in BASIC_TYPE_DECLS\n"); *)</span>
    <span class="keywd">const</span> <span class="type">proc</span>: TRACE (<span class="keywd">ref</span> <span class="type">aType</span>: aValue)                                     <span class="keywd">is</span> action <span class="stri">"REF_TRACE"</span>;
    <span class="keywd">const</span> <span class="type">proc</span>: ignore (<span class="keywd">ref</span> <span class="type">aType</span>: aValue)                                    <span class="keywd">is</span> noop;
    <span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">aType</span>: dest) ::= (<span class="keywd">ref</span> ACTION: source)            <span class="keywd">is</span> action <span class="stri">"ACT_CREATE"</span>;
    <span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">varfunc</span> <span class="type">aType</span>: dest) ::= (<span class="keywd">ref</span> ACTION: source)         <span class="keywd">is</span> action <span class="stri">"ACT_CREATE"</span>;
    <span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">aType</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">aType</span>: source)        <span class="keywd">is</span> action <span class="stri">"PRC_CREATE"</span>;
    <span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">varfunc</span> <span class="type">aType</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">varfunc</span> <span class="type">aType</span>: source)  <span class="keywd">is</span> action <span class="stri">"PRC_CREATE"</span>;
    <span class="keywd">const</span> destroyer: destroy (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">aType</span>: aValue)                         <span class="keywd">is</span> action <span class="stri">"PRC_DESTR"</span>;
    <span class="keywd">const</span> destroyer: destroy (<span class="keywd">ref</span> <span class="type">varfunc</span> <span class="type">aType</span>: aValue)                      <span class="keywd">is</span> action <span class="stri">"PRC_DESTR"</span>;
    <span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">func</span> <span class="type">aType</span>: dest) := (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">aType</span>: source)          <span class="keywd">is</span> action <span class="stri">"PRC_CPY"</span>;
    <span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">varfunc</span> <span class="type">aType</span>: dest) := (<span class="keywd">ref</span> <span class="type">varfunc</span> <span class="type">aType</span>: source)    <span class="keywd">is</span> action <span class="stri">"PRC_CPY"</span>;
    <span class="keywd">const</span> <span class="type">type</span>: typeof (<span class="keywd">ref</span> <span class="type">aType</span>: aValue)                                    <span class="keywd">is</span> aType;
    <span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: dest) ::= (<span class="keywd">ref</span> ACTION: source)       <span class="keywd">is</span> action <span class="stri">"ACT_CREATE"</span>;
    <span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">varfunc</span> <span class="type">aType</span>: dest) ::= (<span class="keywd">ref</span> ACTION: source)    <span class="keywd">is</span> action <span class="stri">"ACT_CREATE"</span>;
    <span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: source)        <span class="keywd">is</span> action <span class="stri">"PRC_CREATE"</span>;
    <span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">varfunc</span> <span class="type">aType</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">varfunc</span> <span class="type">aType</span>: source)  <span class="keywd">is</span> action <span class="stri">"PRC_CREATE"</span>;
    <span class="comment"># const destroyer: destroy (ref func func aType: aValue)                  is action "GEN_DESTR";</span>
    <span class="comment"># const destroyer: destroy (ref func varfunc aType: aValue)               is action "GEN_DESTR";</span>
    IN_PARAM_IS_REFERENCE(<span class="type">func</span> aType);
    IN_PARAM_IS_REFERENCE(<span class="type">varfunc</span> aType);

    <span class="keywd">const</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: <span class="type">func</span>
                           result
                             <span class="keywd">var</span> (attr aType) : (<span class="keywd">ref</span> <span class="type">expr</span>: name) <span class="keywd">is</span> (<span class="keywd">ref</span> <span class="type">aType</span>: initValue)
                           <span class="keywd">local</span>
                             (<span class="keywd">ref</span> <span class="type">proc</span>: localDecls)
                           <span class="keywd">begin</span>
                             (<span class="keywd">ref</span> <span class="type">expr</span>: functionBody)
                           <span class="keywd">end</span> <span class="keywd">func</span>                                   <span class="keywd">is</span> action <span class="stri">"PRC_RES_LOCAL"</span>;

    <span class="keywd">const</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: <span class="type">func</span>
                           result
                             <span class="keywd">var</span> (attr aType) : (<span class="keywd">ref</span> <span class="type">expr</span>: name) <span class="keywd">is</span> (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">aType</span>: initExpression)
                           <span class="keywd">local</span>
                             (<span class="keywd">ref</span> <span class="type">proc</span>: localDecls)
                           <span class="keywd">begin</span>
                             (<span class="keywd">ref</span> <span class="type">expr</span>: functionBody)
                           <span class="keywd">end</span> <span class="keywd">func</span>                                   <span class="keywd">is</span> action <span class="stri">"PRC_RES_LOCAL"</span>;

    <span class="keywd">const</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: <span class="type">func</span>
                           result
                             <span class="keywd">var</span> (attr aType) : (<span class="keywd">ref</span> <span class="type">expr</span>: name) <span class="keywd">is</span> (<span class="keywd">ref</span> <span class="type">aType</span>: initValue)
                           <span class="keywd">begin</span>
                             (<span class="keywd">ref</span> <span class="type">expr</span>: functionBody)
                           <span class="keywd">end</span> <span class="keywd">func</span>                                   <span class="keywd">is</span> action <span class="stri">"PRC_RES_BEGIN"</span>;

    <span class="keywd">const</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: <span class="type">func</span>
                           result
                             <span class="keywd">var</span> (attr aType) : (<span class="keywd">ref</span> <span class="type">expr</span>: name) <span class="keywd">is</span> (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">aType</span>: initExpression)
                           <span class="keywd">begin</span>
                             (<span class="keywd">ref</span> <span class="type">expr</span>: functionBody)
                           <span class="keywd">end</span> <span class="keywd">func</span>                                   <span class="keywd">is</span> action <span class="stri">"PRC_RES_BEGIN"</span>;

    <span class="keywd">const</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: <span class="keywd">return</span> (<span class="keywd">ref</span> <span class="type">aType</span>: resultValue)            <span class="keywd">is</span> action <span class="stri">"PRC_RETURN"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: <span class="keywd">return</span> (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">aType</span>: resultExpression)  <span class="keywd">is</span> action <span class="stri">"PRC_RETURN"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">varfunc</span> <span class="type">aType</span>: <span class="keywd">return</span> <span class="keywd">var</span> (<span class="keywd">inout</span> <span class="type">aType</span>: resultValue)               <span class="keywd">is</span> action <span class="stri">"PRC_RETURN_VAR"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">varfunc</span> <span class="type">aType</span>: <span class="keywd">return</span> <span class="keywd">var</span> (<span class="keywd">ref</span> <span class="type">varfunc</span> <span class="type">aType</span>: resultExpression)    <span class="keywd">is</span> action <span class="stri">"PRC_RETURN_VAR"</span>;

    <span class="keywd">const</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: (attr aType) <span class="keywd">return</span> (<span class="keywd">ref</span> <span class="type">aType</span>: resultValue)           <span class="keywd">is</span> action <span class="stri">"PRC_RETURN2"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: (attr aType) <span class="keywd">return</span> (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">aType</span>: resultExpression) <span class="keywd">is</span> action <span class="stri">"PRC_RETURN2"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">varfunc</span> <span class="type">aType</span>: (attr aType) <span class="keywd">return</span> <span class="keywd">var</span> (<span class="keywd">inout</span> <span class="type">aType</span>: resultValue)            <span class="keywd">is</span> action <span class="stri">"PRC_RETURN_VAR2"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">varfunc</span> <span class="type">aType</span>: (attr aType) <span class="keywd">return</span> <span class="keywd">var</span> (<span class="keywd">ref</span> <span class="type">varfunc</span> <span class="type">aType</span>: resultExpression) <span class="keywd">is</span> action <span class="stri">"PRC_RETURN_VAR2"</span>;

    <span class="keywd">const</span> <span class="type">func</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: <span class="keywd">return</span> (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: resultExpression)              <span class="keywd">is</span> action <span class="stri">"PRC_RETURN"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: (attr aType) <span class="keywd">return</span> (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: resultExpression) <span class="keywd">is</span> action <span class="stri">"PRC_RETURN2"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: <span class="type">func</span>
                                result
                                  <span class="keywd">var</span> (attr <span class="type">func</span> aType) : (<span class="keywd">ref</span> <span class="type">expr</span>: name) <span class="keywd">is</span> (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">aType</span>: initExpression)
                                <span class="keywd">begin</span>
                                  (<span class="keywd">ref</span> <span class="type">expr</span>: functionBody)
                                <span class="keywd">end</span> <span class="keywd">func</span>                              <span class="keywd">is</span> action <span class="stri">"PRC_RES_BEGIN"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: <span class="type">func</span>
                                result
                                  <span class="keywd">var</span> (attr <span class="type">func</span> aType) : (<span class="keywd">ref</span> <span class="type">expr</span>: name) <span class="keywd">is</span> (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: initExpression)
                                <span class="keywd">begin</span>
                                  (<span class="keywd">ref</span> <span class="type">expr</span>: functionBody)
                                <span class="keywd">end</span> <span class="keywd">func</span>                              <span class="keywd">is</span> action <span class="stri">"PRC_RES_BEGIN"</span>;
    <span class="keywd">end</span> global;
  <span class="keywd">end</span> <span class="keywd">func</span>;

BASIC_TYPE_DECLS(type);
BASIC_TYPE_DECLS(string);
BASIC_TYPE_DECLS(ACTION);
BASIC_TYPE_DECLS(creator);
BASIC_TYPE_DECLS(destroyer);


<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">var</span> (<span class="keywd">ref</span> <span class="type">type</span>: aType) : (<span class="keywd">ref</span> <span class="type">expr</span>: name) <span class="keywd">is</span> default <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">var</span> <span class="type">aType</span>: name <span class="keywd">is</span> aType.value;
  <span class="keywd">end</span> <span class="keywd">func</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">type</span>: aType)                    <span class="keywd">is</span> action <span class="stri">"TYP_STR"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">type</span>: gentype                                   <span class="keywd">is</span> action <span class="stri">"TYP_GENTYPE"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">type</span>: gensub (<span class="op">in</span> <span class="type">type</span>: baseType)                <span class="keywd">is</span> action <span class="stri">"TYP_GENSUB"</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">type</span>: newtype <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">type</span>: aType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    aType := gentype;
<span class="comment">(*    PRINT("GENERATE type: newtype as "); PRINT(str(aType)); PRINT("\n"); *)</span>
    BASIC_TYPE_DECLS(aType);
<span class="comment">(*  TRACE(aType);
    PRINT("\n"); *)</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">type</span>: subtype (<span class="op">in</span> <span class="type">type</span>: baseType) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">type</span>: aType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    global
    aType := gensub(baseType);
<span class="comment">(*    PRINT("GENERATE type: subtype "); PRINT(str(baseType)); PRINT(" as "); PRINT(str(aType)); PRINT("\n"); *)</span>
    BASIC_TYPE_DECLS(aType);

    <span class="keywd">const</span> <span class="type">type</span>: base_type (attr aType) <span class="keywd">is</span> baseType;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: <span class="type">func</span>
                           result
                             <span class="keywd">var</span> (attr aType) : (<span class="keywd">ref</span> <span class="type">expr</span>: name) <span class="keywd">is</span> (<span class="keywd">ref</span> <span class="type">baseType</span>: initValue)
                           <span class="keywd">local</span>
                             (<span class="keywd">ref</span> <span class="type">proc</span>: localDecls)
                           <span class="keywd">begin</span>
                             (<span class="keywd">ref</span> <span class="type">expr</span>: functionBody)
                           <span class="keywd">end</span> <span class="keywd">func</span>                                   <span class="keywd">is</span> action <span class="stri">"PRC_RES_LOCAL"</span>;

    <span class="keywd">const</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: <span class="type">func</span>
                           result
                             <span class="keywd">var</span> (attr aType) : (<span class="keywd">ref</span> <span class="type">expr</span>: name) <span class="keywd">is</span> (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">baseType</span>: initExpression)
                           <span class="keywd">local</span>
                             (<span class="keywd">ref</span> <span class="type">proc</span>: localDecls)
                           <span class="keywd">begin</span>
                             (<span class="keywd">ref</span> <span class="type">expr</span>: functionBody)
                           <span class="keywd">end</span> <span class="keywd">func</span>                                   <span class="keywd">is</span> action <span class="stri">"PRC_RES_LOCAL"</span>;

    <span class="keywd">const</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: <span class="type">func</span>
                           result
                             <span class="keywd">var</span> (attr aType) : (<span class="keywd">ref</span> <span class="type">expr</span>: name) <span class="keywd">is</span> (<span class="keywd">ref</span> <span class="type">baseType</span>: initValue)
                           <span class="keywd">begin</span>
                             (<span class="keywd">ref</span> <span class="type">expr</span>: functionBody)
                           <span class="keywd">end</span> <span class="keywd">func</span>                                   <span class="keywd">is</span> action <span class="stri">"PRC_RES_BEGIN"</span>;

    <span class="keywd">const</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: <span class="type">func</span>
                           result
                             <span class="keywd">var</span> (attr aType) : (<span class="keywd">ref</span> <span class="type">expr</span>: name) <span class="keywd">is</span> (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">baseType</span>: initExpression)
                           <span class="keywd">begin</span>
                             (<span class="keywd">ref</span> <span class="type">expr</span>: functionBody)
                           <span class="keywd">end</span> <span class="keywd">func</span>                                   <span class="keywd">is</span> action <span class="stri">"PRC_RES_BEGIN"</span>;

    <span class="keywd">const</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: (attr aType) <span class="keywd">return</span> (<span class="keywd">ref</span> <span class="type">baseType</span>: resultValue)                     <span class="keywd">is</span> action <span class="stri">"PRC_RETURN2"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">func</span> <span class="type">aType</span>: (attr aType) <span class="keywd">return</span> (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">baseType</span>: resultExpression)           <span class="keywd">is</span> action <span class="stri">"PRC_RETURN2"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">varfunc</span> <span class="type">aType</span>: (attr aType) <span class="keywd">return</span> <span class="keywd">var</span> (<span class="keywd">inout</span> <span class="type">baseType</span>: resultValue)            <span class="keywd">is</span> action <span class="stri">"PRC_RETURN_VAR2"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">varfunc</span> <span class="type">aType</span>: (attr aType) <span class="keywd">return</span> <span class="keywd">var</span> (<span class="keywd">ref</span> <span class="type">varfunc</span> <span class="type">baseType</span>: resultExpression) <span class="keywd">is</span> action <span class="stri">"PRC_RETURN_VAR2"</span>;

<span class="comment">(*  TRACE(aType);
    PRINT("\n"); *)</span>
    <span class="keywd">end</span> global;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(*
const func type: func (in type: baseType) is func
  result
    var type: aType is void;
  begin
    aType := gentype;
    const func type: func baseType                        is aType;
    const proc: TRACE (ref aType param)                   is action "REF_TRACE";
    const creator: (ref aType param) ::= (ref ACTION param)  is action "ACT_CREATE";
    const creator: (ref aType param) ::= (ref aType param)   is action "PRC_CREATE";
  end func;
*)</span>


<span class="keywd">const</span> <span class="type">type</span>: EXCEPTION      <span class="keywd">is</span> newtype;

<span class="keywd">const</span> <span class="type">type</span>: DISCRETE       <span class="keywd">is</span> subtype object;
<span class="keywd">const</span> <span class="type">type</span>: integer        <span class="keywd">is</span> subtype DISCRETE;
IN_PARAM_IS_VALUE(integer);
<span class="keywd">const</span> <span class="type">type</span>: ENUMERATION    <span class="keywd">is</span> subtype DISCRETE;
IN_PARAM_IS_VALUE(ENUMERATION);
<span class="keywd">const</span> <span class="type">type</span>: INDEXABLE      <span class="keywd">is</span> subtype object;
<span class="keywd">const</span> <span class="type">type</span>: MODULE         <span class="keywd">is</span> subtype object;

<span class="keywd">const</span> destroyer: destroy (<span class="keywd">ref</span> ACTION: aValue)      <span class="keywd">is</span> action <span class="stri">"GEN_DESTR"</span>;
<span class="keywd">const</span> destroyer: destroy (<span class="keywd">ref</span> <span class="type">ENUMERATION</span>: aValue) <span class="keywd">is</span> action <span class="stri">"GEN_DESTR"</span>;
<span class="keywd">const</span> destroyer: destroy (<span class="keywd">ref</span> <span class="type">integer</span>: aValue)     <span class="keywd">is</span> action <span class="stri">"GEN_DESTR"</span>;
<span class="keywd">const</span> destroyer: destroy (<span class="keywd">ref</span> <span class="type">EXCEPTION</span>: aValue)   <span class="keywd">is</span> action <span class="stri">"GEN_DESTR"</span>;

<span class="keywd">const</span> creator: (<span class="keywd">ref</span> ACTION: dest) ::= (<span class="op">in</span> ACTION: source)            <span class="keywd">is</span> action <span class="stri">"ACT_CREATE"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> ACTION: dest) := (<span class="op">in</span> ACTION: source)              <span class="keywd">is</span> action <span class="stri">"ACT_CPY"</span>;
<span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">ENUMERATION</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">ENUMERATION</span>: source) <span class="keywd">is</span> action <span class="stri">"ENU_CREATE"</span>;
<span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">ENUMERATION</span>: dest) ::= enumlit                   <span class="keywd">is</span> action <span class="stri">"ENU_GENLIT"</span>;
<span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">object</span>: dest) ::= (<span class="op">in</span> ACTION: source)       <span class="keywd">is</span> action <span class="stri">"ACT_CREATE"</span>;
<span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">EXCEPTION</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">EXCEPTION</span>: source)     <span class="keywd">is</span> action <span class="stri">"ENU_CREATE"</span>;
<span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">EXCEPTION</span>: dest) ::= enumlit                     <span class="keywd">is</span> action <span class="stri">"ENU_GENLIT"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">EXCEPTION</span>: dest) := (<span class="keywd">ref</span> <span class="type">EXCEPTION</span>: source)       <span class="keywd">is</span> action <span class="stri">"ENU_CPY"</span>;

<span class="keywd">const</span> <span class="type">EXCEPTION</span>: MEMORY_ERROR   <span class="keywd">is</span> enumlit;
<span class="keywd">const</span> <span class="type">EXCEPTION</span>: NUMERIC_ERROR  <span class="keywd">is</span> enumlit;
<span class="keywd">const</span> <span class="type">EXCEPTION</span>: OVERFLOW_ERROR <span class="keywd">is</span> enumlit;
<span class="keywd">const</span> <span class="type">EXCEPTION</span>: RANGE_ERROR    <span class="keywd">is</span> enumlit;
<span class="keywd">const</span> <span class="type">EXCEPTION</span>: INDEX_ERROR    <span class="keywd">is</span> enumlit;
<span class="keywd">const</span> <span class="type">EXCEPTION</span>: FILE_ERROR     <span class="keywd">is</span> enumlit;
<span class="keywd">const</span> <span class="type">EXCEPTION</span>: DATABASE_ERROR <span class="keywd">is</span> enumlit;
<span class="keywd">const</span> <span class="type">EXCEPTION</span>: GRAPHIC_ERROR  <span class="keywd">is</span> enumlit;
<span class="keywd">const</span> <span class="type">EXCEPTION</span>: ILLEGAL_ACTION <span class="keywd">is</span> enumlit;
<span class="keywd">const</span> <span class="type">EXCEPTION</span>: CREATE_ERROR   <span class="keywd">is</span> enumlit;
<span class="keywd">const</span> <span class="type">EXCEPTION</span>: DESTROY_ERROR  <span class="keywd">is</span> enumlit;
<span class="keywd">const</span> <span class="type">EXCEPTION</span>: COPY_ERROR     <span class="keywd">is</span> enumlit;
<span class="keywd">const</span> <span class="type">EXCEPTION</span>: IN_ERROR       <span class="keywd">is</span> enumlit;

$ <span class="keywd">system</span> <span class="stri">"memory_error"</span>   <span class="keywd">is</span> MEMORY_ERROR;
$ <span class="keywd">system</span> <span class="stri">"numeric_error"</span>  <span class="keywd">is</span> NUMERIC_ERROR;
$ <span class="keywd">system</span> <span class="stri">"overflow_error"</span> <span class="keywd">is</span> OVERFLOW_ERROR;
$ <span class="keywd">system</span> <span class="stri">"range_error"</span>    <span class="keywd">is</span> RANGE_ERROR;
$ <span class="keywd">system</span> <span class="stri">"index_error"</span>    <span class="keywd">is</span> INDEX_ERROR;
$ <span class="keywd">system</span> <span class="stri">"file_error"</span>     <span class="keywd">is</span> FILE_ERROR;
$ <span class="keywd">system</span> <span class="stri">"database_error"</span> <span class="keywd">is</span> DATABASE_ERROR;
$ <span class="keywd">system</span> <span class="stri">"graphic_error"</span>  <span class="keywd">is</span> GRAPHIC_ERROR;
$ <span class="keywd">system</span> <span class="stri">"illegal_action"</span> <span class="keywd">is</span> ILLEGAL_ACTION;

<span class="keywd">const</span> <span class="type">proc</span>: raise (<span class="keywd">ref</span> <span class="type">EXCEPTION</span>: anException)     <span class="keywd">is</span> action <span class="stri">"PRC_RAISE"</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> ACTION: anAction)       <span class="keywd">is</span> action <span class="stri">"ACT_STR"</span>;

<span class="keywd">const</span> ACTION: DYNAMIC <span class="keywd">is</span> action <span class="stri">"PRC_DYNAMIC"</span>;


<span class="keywd">const</span> <span class="type">proc</span>: TRACE_OPTIONS (<span class="op">in</span> <span class="type">string</span>: traceLevel)  <span class="keywd">is</span> action <span class="stri">"PRC_SETTRACE"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: TRACE_OBJ (<span class="op">in</span> <span class="type">object</span>: traceobject)     <span class="keywd">is</span> action <span class="stri">"REF_TRACE"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: TRACE_PROC (<span class="op">in</span> <span class="type">proc</span>: traceobject)      <span class="keywd">is</span> action <span class="stri">"REF_TRACE"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: DECLS                                  <span class="keywd">is</span> action <span class="stri">"PRC_DECLS"</span>;


<span class="comment">(* void *)</span>

<span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">void</span>: dest) ::= (<span class="op">in</span> <span class="type">void</span>: source) <span class="keywd">is</span> action <span class="stri">"ENU_CREATE"</span>;
<span class="keywd">const</span> destroyer: destroy (<span class="keywd">ref</span> <span class="type">void</span>: aVoid)            <span class="keywd">is</span> action <span class="stri">"GEN_DESTR"</span>;
<span class="keywd">const</span> <span class="type">void</span>: (attr void) . value                       <span class="keywd">is</span> empty;


<span class="comment">(* boolean *)</span>

$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/boolean.htm">boolean.s7i</a>"</span>;


<span class="comment">(* type *)</span>

<span class="keywd">const</span> <span class="type">type</span>: (attr type) . value <span class="keywd">is</span> void;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">type</span>: aType1) = (<span class="op">in</span> <span class="type">type</span>: aType2)         <span class="keywd">is</span> action <span class="stri">"TYP_EQ"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">type</span>: aType1) &lt;> (<span class="op">in</span> <span class="type">type</span>: aType2)        <span class="keywd">is</span> action <span class="stri">"TYP_NE"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: compare (<span class="op">in</span> <span class="type">type</span>: aType1, <span class="op">in</span> <span class="type">type</span>: aType2)    <span class="keywd">is</span> action <span class="stri">"TYP_CMP"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: hashCode (<span class="op">in</span> <span class="type">type</span>: aType)                     <span class="keywd">is</span> action <span class="stri">"TYP_HASHCODE"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isFunc (<span class="op">in</span> <span class="type">type</span>: aType)                       <span class="keywd">is</span> action <span class="stri">"TYP_ISFUNC"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isVarfunc (<span class="op">in</span> <span class="type">type</span>: aType)                    <span class="keywd">is</span> action <span class="stri">"TYP_ISVARFUNC"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">type</span>: resultType (<span class="op">in</span> <span class="type">type</span>: funcType)                   <span class="keywd">is</span> action <span class="stri">"TYP_RESULT"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isDerived (<span class="op">in</span> <span class="type">type</span>: aType)                    <span class="keywd">is</span> action <span class="stri">"TYP_ISDERIVED"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">type</span>: meta (<span class="op">in</span> <span class="type">type</span>: aType)                            <span class="keywd">is</span> action <span class="stri">"TYP_META"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: addInterface (<span class="op">in</span> <span class="type">type</span>: aType, <span class="op">in</span> <span class="type">type</span>: interfaceType) <span class="keywd">is</span> action <span class="stri">"TYP_ADDINTERFACE"</span>;

DECLARE_TERNARY(type);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">void</span>: void1) = (<span class="op">in</span> <span class="type">void</span>: void2) <span class="keywd">is</span> <span class="keywd">return</span> TRUE;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">void</span>: void1) &lt;> (<span class="op">in</span> <span class="type">void</span>: void2) <span class="keywd">is</span> <span class="keywd">return</span> FALSE;


<span class="comment">(* IF *)</span>

<span class="keywd">const</span> <span class="type">type</span>: ELSIF_RESULT <span class="keywd">is</span> newtype;
<span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">ELSIF_RESULT</span>: dest) ::= (<span class="keywd">val</span> <span class="type">ELSIF_RESULT</span>: source) <span class="keywd">is</span> action <span class="stri">"ENU_CREATE"</span>;
<span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">ELSIF_RESULT</span>: dest) ::= enumlit                    <span class="keywd">is</span> action <span class="stri">"ENU_GENLIT"</span>;
<span class="keywd">const</span> destroyer: destroy (<span class="keywd">ref</span> <span class="type">ELSIF_RESULT</span>: aValue)                    <span class="keywd">is</span> action <span class="stri">"GEN_DESTR"</span>;
<span class="keywd">const</span> <span class="type">ELSIF_RESULT</span>: ELSIF_EMPTY <span class="keywd">is</span> enumlit;
<span class="keywd">const</span> <span class="type">type</span>: ELSIF_PROC                                              <span class="keywd">is</span> <span class="keywd">func</span> ELSIF_RESULT;
IN_PARAM_IS_REFERENCE(ELSIF_PROC);
<span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">ELSIF_PROC</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">ELSIF_RESULT</span>: source)   <span class="keywd">is</span> action <span class="stri">"ENU_CREATE"</span>;

<span class="keywd">const</span> <span class="type">proc</span>:       <span class="keywd">if</span> (<span class="op">in</span> <span class="type">boolean</span>: condition) <span class="keywd">then</span>
                  <span class="keywd">end</span> <span class="keywd">if</span>                               <span class="keywd">is</span> noop;

<span class="keywd">const</span> <span class="type">proc</span>:       <span class="keywd">if</span> (<span class="op">in</span> <span class="type">boolean</span>: condition) <span class="keywd">then</span>
                    (<span class="op">in</span> <span class="type">proc</span>: statements)
                  <span class="keywd">end</span> <span class="keywd">if</span>                               <span class="keywd">is</span> action <span class="stri">"PRC_IF"</span>;

<span class="keywd">const</span> <span class="type">proc</span>:       <span class="keywd">if</span> (<span class="op">in</span> <span class="type">boolean</span>: condition) <span class="keywd">then</span>
                    (<span class="op">in</span> <span class="type">proc</span>: statements)
                  (<span class="op">in</span> <span class="type">ELSIF_PROC</span>: elsifPart)
                  <span class="keywd">end</span> <span class="keywd">if</span>                               <span class="keywd">is</span> action <span class="stri">"PRC_IF_ELSIF"</span>;

<span class="keywd">const</span> <span class="type">proc</span>:       <span class="keywd">if</span> (<span class="op">in</span> <span class="type">boolean</span>: condition) <span class="keywd">then</span>
                  (<span class="op">in</span> <span class="type">ELSIF_PROC</span>: elsifPart)
                  <span class="keywd">end</span> <span class="keywd">if</span>                               <span class="keywd">is</span> action <span class="stri">"PRC_IF_NOOP"</span>;

<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: <span class="keywd">elsif</span> (<span class="op">in</span> <span class="type">boolean</span>: condition) <span class="keywd">then</span>
                    (<span class="op">in</span> <span class="type">proc</span>: statements)              <span class="keywd">is</span> action <span class="stri">"PRC_IF"</span>;

<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: <span class="keywd">elsif</span> (<span class="op">in</span> <span class="type">boolean</span>: condition) <span class="keywd">then</span>
                    (<span class="op">in</span> <span class="type">proc</span>: statements)
                  (<span class="op">in</span> <span class="type">ELSIF_PROC</span>: elsifPart)           <span class="keywd">is</span> action <span class="stri">"PRC_IF_ELSIF"</span>;

<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: <span class="keywd">elsif</span> (<span class="op">in</span> <span class="type">boolean</span>: condition) <span class="keywd">then</span>
                  (<span class="op">in</span> <span class="type">ELSIF_PROC</span>: elsifPart)           <span class="keywd">is</span> action <span class="stri">"PRC_IF_NOOP"</span>;

<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: <span class="keywd">else</span>
                    (<span class="op">in</span> <span class="type">void</span>: elsePart)                <span class="keywd">is</span> <span class="keywd">return</span> ELSIF_EMPTY;

<span class="comment">(*
const proc: if TRUE  then (in void param) end if is                           noop;
const proc: if TRUE  then (in void param) (in ELSIF_PROC param) end if is     noop;
const proc: if FALSE then (in proc param) end if is                           noop;
const proc: if FALSE then (in proc param) (in ELSIF_RESULT param) end if is   noop;
const ELSIF_PROC: elsif TRUE  then (in void param) is                         ELSIF_EMPTY;
const ELSIF_PROC: elsif TRUE then (in void param) (in ELSIF_PROC param)   is  ELSIF_EMPTY;
const ELSIF_PROC: elsif FALSE then (in proc param) is                         ELSIF_EMPTY;
const ELSIF_PROC: elsif FALSE then (in proc param) (in ELSIF_RESULT param) is ELSIF_EMPTY;
*)</span>


<span class="comment">(* WHILE + REPEAT *)</span>

<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">while</span> (<span class="op">in</span> <span class="type">func</span> <span class="type">boolean</span>: condition) <span class="keywd">do</span> (<span class="op">in</span> <span class="type">proc</span>: statement) <span class="keywd">end</span> <span class="keywd">while</span>     <span class="keywd">is</span> action <span class="stri">"PRC_WHILE"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">while</span> (<span class="op">in</span> <span class="type">varfunc</span> <span class="type">boolean</span>: condition) <span class="keywd">do</span> (<span class="op">in</span> <span class="type">proc</span>: statement) <span class="keywd">end</span> <span class="keywd">while</span>  <span class="keywd">is</span> action <span class="stri">"PRC_WHILE"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">while</span> (<span class="keywd">ref</span> <span class="type">boolean</span>: condition) <span class="keywd">do</span> (<span class="op">in</span> <span class="type">proc</span>: statement) <span class="keywd">end</span> <span class="keywd">while</span>         <span class="keywd">is</span> action <span class="stri">"PRC_WHILE"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">while</span> (<span class="op">in</span> <span class="type">func</span> <span class="type">boolean</span>: condition) <span class="keywd">do</span> <span class="keywd">end</span> <span class="keywd">while</span>     <span class="keywd">is</span> action <span class="stri">"PRC_WHILE_NOOP"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">while</span> (<span class="op">in</span> <span class="type">varfunc</span> <span class="type">boolean</span>: condition) <span class="keywd">do</span> <span class="keywd">end</span> <span class="keywd">while</span>  <span class="keywd">is</span> action <span class="stri">"PRC_WHILE_NOOP"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">while</span> (<span class="keywd">ref</span> <span class="type">boolean</span>: condition) <span class="keywd">do</span> <span class="keywd">end</span> <span class="keywd">while</span>         <span class="keywd">is</span> action <span class="stri">"PRC_WHILE_NOOP"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">repeat</span> (<span class="op">in</span> <span class="type">proc</span>: statement) <span class="keywd">until</span> (<span class="op">in</span> <span class="type">func</span> <span class="type">boolean</span>: condition)     <span class="keywd">is</span> action <span class="stri">"PRC_REPEAT"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">repeat</span> (<span class="op">in</span> <span class="type">proc</span>: statement) <span class="keywd">until</span> (<span class="op">in</span> <span class="type">varfunc</span> <span class="type">boolean</span>: condition)  <span class="keywd">is</span> action <span class="stri">"PRC_REPEAT"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">repeat</span> (<span class="op">in</span> <span class="type">proc</span>: statement) <span class="keywd">until</span> (<span class="keywd">ref</span> <span class="type">boolean</span>: condition)         <span class="keywd">is</span> action <span class="stri">"PRC_REPEAT"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">repeat</span> <span class="keywd">until</span> (<span class="op">in</span> <span class="type">func</span> <span class="type">boolean</span>: condition)     <span class="keywd">is</span> action <span class="stri">"PRC_REPEAT_NOOP"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">repeat</span> <span class="keywd">until</span> (<span class="op">in</span> <span class="type">varfunc</span> <span class="type">boolean</span>: condition)  <span class="keywd">is</span> action <span class="stri">"PRC_REPEAT_NOOP"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">repeat</span> <span class="keywd">until</span> (<span class="keywd">ref</span> <span class="type">boolean</span>: condition)         <span class="keywd">is</span> action <span class="stri">"PRC_REPEAT_NOOP"</span>;


<span class="comment">(* integer *)</span>

$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/integer.htm">integer.s7i</a>"</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: (attr integer) <span class="op">conv</span> (<span class="op">in</span> <span class="type">boolean</span>: boolValue) <span class="keywd">is</span>
  <span class="keywd">return</span> ord(boolValue);

<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: rand (<span class="op">in</span> <span class="type">boolean</span>: low, <span class="op">in</span> <span class="type">boolean</span>: high) <span class="keywd">is</span>
  <span class="keywd">return</span> odd(rand(ord(low), ord(high)));

<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: compare (<span class="op">in</span> <span class="type">boolean</span>: aBoolean1, <span class="op">in</span> <span class="type">boolean</span>: aBoolean2) <span class="keywd">is</span>
  <span class="keywd">return</span> compare(ord(aBoolean1), ord(aBoolean2));


<span class="comment">(* char *)</span>

$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/char.htm">char.s7i</a>"</span>;

<span class="comment">(* Function c_literal defined after string *)</span>

<span class="comment">(* Procedure read defined after operations for IN and OUT *)</span>


<span class="comment">(* string *)</span>

$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/string.htm">string.s7i</a>"</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">char</span>: (attr char) <span class="op">parse</span> (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">char</span>: aChar <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(stri) = 1 <span class="keywd">then</span>
      aChar := stri[1];
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: trimValue (attr char, <span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: trimmed <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    trimmed := trim(stri);
    <span class="keywd">if</span> trimmed = <span class="stri">""</span> <span class="op">and</span> stri &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      trimmed := stri[1 len 1];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (attr boolean) <span class="op">parse</span> (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: aBoolean <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> stri = <span class="stri">"TRUE"</span> <span class="keywd">then</span>
      aBoolean := TRUE;
    <span class="keywd">elsif</span> stri = <span class="stri">"FALSE"</span> <span class="keywd">then</span>
      aBoolean := FALSE;
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;

<span class="keywd">const</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">void</span>: aVoid) <span class="keywd">is</span> <span class="stri">"empty"</span>;

<span class="comment">(* Procedure literal from char *)</span>

<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: literal (<span class="op">in</span> <span class="type">char</span>: ch) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> ch = <span class="stri">'''</span> <span class="keywd">then</span>
      stri := <span class="stri">"'\\''"</span>;
    <span class="keywd">elsif</span> ch &lt;= char(255) <span class="keywd">then</span>
      stri := literal(str(ch));
      stri := <span class="stri">"'"</span> &amp; stri[2 .. length(stri) - 1] &amp; <span class="stri">"'"</span>;
    <span class="keywd">else</span>
      stri := <span class="stri">"'\\"</span> &amp; str(ord(ch)) &amp; <span class="stri">";'"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(* REFERENCE *)</span>

$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/reference.htm">reference.s7i</a>"</span>;

<span class="comment">(* REF_LIST *)</span>

$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/ref_list.htm">ref_list.s7i</a>"</span>;

<span class="comment">(* POINTER *)</span>

<span class="keywd">var</span> <span class="type">type</span>: CURR_STRUCT_PTR <span class="keywd">is</span> void;
<span class="keywd">var</span> <span class="type">type</span>: FORWARD_PTR <span class="keywd">is</span> void;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: is_declared (<span class="op">in</span> <span class="type">type</span>: aType)                     <span class="keywd">is</span> action <span class="stri">"TYP_ISDECLARED"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: is_forward (<span class="op">in</span> <span class="type">type</span>: aType)                      <span class="keywd">is</span> action <span class="stri">"TYP_ISFORWARD"</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">type</span>: forward_ptr (<span class="keywd">ref</span> <span class="type">expr</span>: baseTypeName) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">type</span>: ptrType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    PRINT(<span class="stri">"forward_ptr\n"</span>);
<span class="comment">(*
    TRACE(baseTypeName);
*)</span>
    <span class="keywd">const</span> <span class="type">type</span>: baseTypeName <span class="keywd">is</span> <span class="keywd">forward</span>;
    ptrType := newtype;
    FORWARD_PTR := ptrType;
    IN_PARAM_IS_VALUE(ptrType);
    <span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">ptrType</span>: dest) ::= (<span class="op">in</span> <span class="type">ptrType</span>: source)      <span class="keywd">is</span> action <span class="stri">"REF_CREATE"</span>;
    <span class="keywd">const</span> destroyer: destroy (<span class="keywd">ref</span> <span class="type">ptrType</span>: aPtr)                     <span class="keywd">is</span> action <span class="stri">"GEN_DESTR"</span>;
    <span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">ptrType</span>: dest) := (<span class="op">in</span> <span class="type">ptrType</span>: source)        <span class="keywd">is</span> action <span class="stri">"REF_CPY"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">ptrType</span>: ptr1) = (<span class="op">in</span> <span class="type">ptrType</span>: ptr2)      <span class="keywd">is</span> action <span class="stri">"REF_EQ"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">ptrType</span>: ptr1) &lt;> (<span class="op">in</span> <span class="type">ptrType</span>: ptr2)     <span class="keywd">is</span> action <span class="stri">"REF_NE"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">ptrType</span>: _GENERATE_NIL(attr ptrType)                  <span class="keywd">is</span> action <span class="stri">"REF_NIL"</span>;
    <span class="keywd">const</span> <span class="type">ptrType</span>: (attr ptrType) . NIL                              <span class="keywd">is</span> _GENERATE_NIL(ptrType);
    <span class="keywd">const</span> <span class="type">ptrType</span>: (attr ptrType) . value                            <span class="keywd">is</span> ptrType.NIL;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: finish_ptr (<span class="op">in</span> <span class="type">type</span>: baseType, <span class="op">in</span> <span class="type">type</span>: ptrType) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> FORWARD_PTR &lt;> void <span class="keywd">then</span>
      PRINT(<span class="stri">"finish_ptr\n"</span>);
      FORWARD_PTR := void;
      <span class="keywd">const</span> <span class="type">type</span>: ptr (attr baseType)                                <span class="keywd">is</span> ptrType;
      <span class="keywd">const</span> <span class="type">type</span>: base_type (attr ptrType)                           <span class="keywd">is</span> baseType;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">ptrType</span>: &amp; (<span class="op">in</span> <span class="type">baseType</span>: aValue)                    <span class="keywd">is</span> action <span class="stri">"REF_ADDR"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">baseType</span>: (<span class="op">in</span> <span class="type">ptrType</span>: aPtr) ^                      <span class="keywd">is</span> action <span class="stri">"REF_DEREF"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">type</span>: ptr (<span class="op">in</span> <span class="type">type</span>: baseType) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">type</span>: ptrType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> FORWARD_PTR &lt;> void <span class="keywd">then</span>
      <span class="keywd">if</span> is_declared(baseType) <span class="keywd">then</span>
        PRINT(<span class="stri">"declared\n"</span>);
       <span class="keywd">elsif</span> is_forward(baseType) <span class="keywd">then</span>
        PRINT(<span class="stri">"forward\n"</span>);
      <span class="keywd">else</span>
        PRINT(<span class="stri">"undeclared\n"</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      ptrType := FORWARD_PTR;
      finish_ptr(baseType, ptrType);
    <span class="keywd">else</span>
      <span class="keywd">if</span> is_declared(baseType) <span class="keywd">then</span>
        PRINT(<span class="stri">"declared\n"</span>);
        ptrType := CURR_STRUCT_PTR;
      <span class="keywd">elsif</span> is_forward(baseType) <span class="keywd">then</span>
        PRINT(<span class="stri">"forward\n"</span>);
      <span class="keywd">else</span>
        ptrType := get_type(getobj(ptr (attr baseType)));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> ptrType = void <span class="keywd">then</span>
      global
      ptrType := newtype;
      IN_PARAM_IS_VALUE(ptrType);
      <span class="keywd">const</span> <span class="type">type</span>: ptr (attr baseType)                                <span class="keywd">is</span>   ptrType;
      <span class="keywd">const</span> <span class="type">type</span>: base_type (attr ptrType)                           <span class="keywd">is</span>   baseType;
      <span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">ptrType</span>: dest) ::= (<span class="op">in</span> <span class="type">ptrType</span>: source)    <span class="keywd">is</span> action <span class="stri">"REF_CREATE"</span>;
      <span class="keywd">const</span> destroyer: destroy (<span class="keywd">ref</span> <span class="type">ptrType</span>: aPtr)                   <span class="keywd">is</span> action <span class="stri">"GEN_DESTR"</span>;
      <span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">ptrType</span>: dest) := (<span class="op">in</span> <span class="type">ptrType</span>: source)      <span class="keywd">is</span> action <span class="stri">"REF_CPY"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">ptrType</span>: ptr1) = (<span class="op">in</span> <span class="type">ptrType</span>: ptr2)    <span class="keywd">is</span> action <span class="stri">"REF_EQ"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">ptrType</span>: ptr1) &lt;> (<span class="op">in</span> <span class="type">ptrType</span>: ptr2)   <span class="keywd">is</span> action <span class="stri">"REF_NE"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">ptrType</span>: &amp; (<span class="op">in</span> <span class="type">baseType</span>: aValue)                    <span class="keywd">is</span> action <span class="stri">"REF_ADDR"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">baseType</span>: (<span class="op">in</span> <span class="type">ptrType</span>: aPtr) ^                      <span class="keywd">is</span> action <span class="stri">"REF_DEREF"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">ptrType</span>: _GENERATE_NIL(attr ptrType)                <span class="keywd">is</span> action <span class="stri">"REF_NIL"</span>;
      <span class="keywd">const</span> <span class="type">ptrType</span>: (attr ptrType) . NIL                            <span class="keywd">is</span> _GENERATE_NIL(ptrType);
      <span class="keywd">const</span> <span class="type">ptrType</span>: (attr ptrType) . value                          <span class="keywd">is</span> ptrType.NIL;
      <span class="keywd">end</span> global;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">type</span>: varptr (<span class="op">in</span> <span class="type">type</span>: baseType) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">type</span>: varptrType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    varptrType := get_type(getobj(varptr (attr baseType)));
    <span class="keywd">if</span> varptrType = void <span class="keywd">then</span>
      global
      varptrType := newtype;
      IN_PARAM_IS_VALUE(varptrType);
      <span class="keywd">const</span> <span class="type">type</span>: varptr (attr baseType)                                 <span class="keywd">is</span> varptrType;
      <span class="keywd">const</span> <span class="type">type</span>: base_type (attr varptrType)                            <span class="keywd">is</span> baseType;
      <span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">varptrType</span>: dest) ::= (<span class="op">in</span> <span class="type">varptrType</span>: source)  <span class="keywd">is</span> action <span class="stri">"REF_CREATE"</span>;
      <span class="keywd">const</span> destroyer: destroy (<span class="keywd">ref</span> <span class="type">varptrType</span>: aPtr)                    <span class="keywd">is</span> action <span class="stri">"GEN_DESTR"</span>;
      <span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">varptrType</span>: dest) := (<span class="op">in</span> <span class="type">varptrType</span>: source)    <span class="keywd">is</span> action <span class="stri">"REF_CPY"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">varptrType</span>: ptr1) = (<span class="op">in</span> <span class="type">varptrType</span>: ptr2)  <span class="keywd">is</span> action <span class="stri">"REF_EQ"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">varptrType</span>: ptr1) &lt;> (<span class="op">in</span> <span class="type">varptrType</span>: ptr2) <span class="keywd">is</span> action <span class="stri">"REF_NE"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">varptrType</span>: &amp; (<span class="keywd">inout</span> <span class="type">baseType</span>: aValue)                  <span class="keywd">is</span> action <span class="stri">"REF_ADDR"</span>;
      <span class="keywd">const</span> <span class="type">varfunc</span> <span class="type">baseType</span>: (<span class="op">in</span> <span class="type">varptrType</span>: aPtr) ^                    <span class="keywd">is</span> action <span class="stri">"REF_DEREF"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">varptrType</span>: _GENERATE_NIL(attr varptrType)              <span class="keywd">is</span> action <span class="stri">"REF_NIL"</span>;
      <span class="keywd">const</span> <span class="type">varptrType</span>: (attr varptrType) . NIL                          <span class="keywd">is</span> _GENERATE_NIL(varptrType);
      <span class="keywd">const</span> <span class="type">varptrType</span>: (attr varptrType) . value                        <span class="keywd">is</span> varptrType.NIL;
      <span class="keywd">end</span> global;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(* FOR *)</span>

$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/forloop.htm">forloop.s7i</a>"</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: width (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: width <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> ch <span class="keywd">range</span> stri <span class="keywd">do</span>
      width +:= width(ch);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: reverse (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: reversed <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    reversed := <span class="stri">" "</span> <span class="op">mult</span> length(stri);
    index := length(stri);
    <span class="keywd">for</span> ch <span class="keywd">range</span> stri <span class="keywd">do</span>
      reversed @:= [index] ch;
      decr(index);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get string with question marks (?) instead of control characters.
 *  @return the string without control characters.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: noCtrlChars (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: noCtrlChars <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    noCtrlChars := stri;
    <span class="keywd">for</span> ch <span class="keywd">key</span> index <span class="keywd">range</span> stri <span class="keywd">do</span>
      <span class="keywd">if</span> ch &lt; <span class="stri">' '</span> <span class="op">or</span> ch >= <span class="stri">'\127;'</span> <span class="op">and</span> ch &lt;= <span class="stri">'\160;'</span> <span class="keywd">then</span>
        noCtrlChars @:= [index] <span class="stri">'?'</span>;
      <span class="keywd">elsif</span> ch = <span class="stri">'\173;'</span> <span class="keywd">then</span>
        noCtrlChars @:= [index] <span class="stri">'-'</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(* TUPLE *)</span>

<span class="keywd">const</span> <span class="type">func</span> <span class="type">type</span>: tuple (<span class="op">in</span> <span class="type">type</span>: baseType) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">type</span>: tupleType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    tupleType := get_type(getfunc(tuple (attr baseType)));
    <span class="keywd">if</span> tupleType = void <span class="keywd">then</span>
      global
      tupleType := newtype;
      IN_PARAM_IS_REFERENCE(tupleType);
      <span class="keywd">const</span> <span class="type">type</span>: tuple (attr baseType) <span class="keywd">is</span> tupleType;
      <span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">tupleType</span>: dest) ::= (<span class="op">in</span> <span class="type">tupleType</span>: source)         <span class="keywd">is</span> action <span class="stri">"ARR_CREATE"</span>;
      <span class="keywd">const</span> destroyer: destroy (<span class="keywd">ref</span> <span class="type">tupleType</span>: aValue)                        <span class="keywd">is</span> action <span class="stri">"ARR_DESTR"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">tupleType</span>: (<span class="op">in</span> <span class="type">baseType</span>: element1) , (<span class="op">in</span> <span class="type">baseType</span>: element2) <span class="keywd">is</span> action <span class="stri">"ARR_GEN"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">tupleType</span>: (<span class="op">in</span> <span class="type">tupleType</span>: arr1) , (<span class="op">in</span> <span class="type">baseType</span>: element)     <span class="keywd">is</span> action <span class="stri">"ARR_EXTEND"</span>;
<span class="comment">(*
      const func tupleType: (in baseType: lower_limit) .. (in baseType: upper_limit) is func
        result
          var tupleType: aTuple is
        local
          var baseType: element is baseType.value;
       begin
          element := lower_limit;
          if variable &lt;= upper_limit then
            aTuple &amp;:= element;
            while element &lt; upper_limit then
              aTuple &amp;:= element;
              incr(element);
            end while;
          end if;
        end func;
*)</span>
      <span class="keywd">end</span> global;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;

<span class="keywd">const</span> <span class="type">type</span>: TST_1 <span class="keywd">is</span> tuple integer;
<span class="keywd">const</span> <span class="type">type</span>: TST_2 <span class="keywd">is</span> tuple integer;


$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/fixarray.htm">fixarray.s7i</a>"</span>;
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/basearray.htm">basearray.s7i</a>"</span>;

<span class="comment">(* STRUCT *)</span>

$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/struct.htm">struct.s7i</a>"</span>;

<span class="comment">(* SUBRANGE *)</span>

$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/subrange.htm">subrange.s7i</a>"</span>;

<span class="comment">(* ARRAY *)</span>

$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/array.htm">array.s7i</a>"</span>;
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/idxarray.htm">idxarray.s7i</a>"</span>;


<span class="comment">(* Functions with arrays of strings *)</span>

<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: split (<span class="op">in</span> <span class="type">string</span>: main_stri, <span class="op">in</span> <span class="type">char</span>: delimiter)   <span class="keywd">is</span> action <span class="stri">"STR_CHSPLIT"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: split (<span class="op">in</span> <span class="type">string</span>: main_stri, <span class="op">in</span> <span class="type">string</span>: delimiter) <span class="keywd">is</span> action <span class="stri">"STR_SPLIT"</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: join (<span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: striArray, <span class="op">in</span> <span class="type">char</span>: delimiter) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: joined <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    joined := striArray[minIdx(striArray)];
    <span class="keywd">for</span> pos <span class="keywd">range</span> succ(minIdx(striArray)) <span class="keywd">to</span> maxIdx(striArray) <span class="keywd">do</span>
      joined &amp;:= delimiter;
      joined &amp;:= striArray[pos];
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: join (<span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: striArray, <span class="op">in</span> <span class="type">string</span>: delimiter) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: joined <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    joined := striArray[minIdx(striArray)];
    <span class="keywd">for</span> pos <span class="keywd">range</span> succ(minIdx(striArray)) <span class="keywd">to</span> maxIdx(striArray) <span class="keywd">do</span>
      joined &amp;:= delimiter;
      joined &amp;:= striArray[pos];
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: noEmptyStrings (<span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: striArray) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: noEmptyStrings <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> stri <span class="keywd">range</span> striArray <span class="keywd">do</span>
      <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        noEmptyStrings &amp;:= stri;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isDigitString (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: isDigitString <span class="keywd">is</span> TRUE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    isDigitString := stri &lt;> <span class="stri">""</span>;
    <span class="keywd">for</span> ch <span class="keywd">range</span> stri <span class="keywd">do</span>
      <span class="keywd">if</span> ch &lt; <span class="stri">'0'</span> <span class="op">or</span> ch > <span class="stri">'9'</span> <span class="keywd">then</span>
        isDigitString := FALSE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isDigitString (<span class="op">in</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="type">integer</span>: base) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: isDigitString <span class="keywd">is</span> TRUE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">char</span>: maxBaseDigit <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">char</span>: maxBaseDigit2 <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    isDigitString := stri &lt;> <span class="stri">""</span>;
    <span class="keywd">if</span> base &lt;= 1 <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> base &lt;= 10 <span class="keywd">then</span>
      maxBaseDigit := char(ord(<span class="stri">'0'</span>) + base - 1);
      <span class="keywd">for</span> ch <span class="keywd">range</span> stri <span class="keywd">do</span>
        <span class="keywd">if</span> ch &lt; <span class="stri">'0'</span> <span class="op">or</span> ch > maxBaseDigit <span class="keywd">then</span>
          isDigitString := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">elsif</span> base &lt;= 36 <span class="keywd">then</span>
      maxBaseDigit := char(ord(<span class="stri">'a'</span>) + base - 11);
      maxBaseDigit2 := char(ord(<span class="stri">'A'</span>) + base - 11);
      <span class="keywd">for</span> ch <span class="keywd">range</span> stri <span class="keywd">do</span>
        <span class="keywd">if</span> (ch &lt; <span class="stri">'0'</span> <span class="op">or</span> ch > <span class="stri">'9'</span>) <span class="op">and</span>
            (ch &lt; <span class="stri">'a'</span> <span class="op">or</span> ch > maxBaseDigit) <span class="op">and</span>
            (ch &lt; <span class="stri">'A'</span> <span class="op">or</span> ch > maxBaseDigit2) <span class="keywd">then</span>
          isDigitString := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(* HASH *)</span>

$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/hash.htm">hash.s7i</a>"</span>;

<span class="comment">(* SET *)</span>

$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bitset.htm">bitset.s7i</a>"</span>;
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bitsetof.htm">bitsetof.s7i</a>"</span>;
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/hashsetof.htm">hashsetof.s7i</a>"</span>;
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/set.htm">set.s7i</a>"</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: integer (<span class="op">in</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="type">integer</span>: base) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: anInteger <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">array</span> <span class="type">integer</span>: digitval <span class="keywd">is</span> [] (                    <span class="comment"># -1 is illegal</span>
         0,  1,  2,  3,  4,  5,  6,  7,  8,  9,              <span class="comment"># 0 - 9</span>
        -1, -1, -1, -1, -1, -1, -1,                          <span class="comment">#</span>
        10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,  <span class="comment"># A - M</span>
        23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,  <span class="comment"># N - Z</span>
        -1, -1, -1, -1, -1, -1,
        10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,  <span class="comment"># a - m</span>
        23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35); <span class="comment"># n - z</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: negative <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: digit <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="op">and</span> base >= 2 <span class="op">and</span> base &lt;= 36 <span class="keywd">then</span>
      <span class="keywd">if</span> stri[1] = <span class="stri">'-'</span> <span class="keywd">then</span>
        negative := TRUE;
        incr(pos);
      <span class="keywd">elsif</span> stri[1] = <span class="stri">'+'</span> <span class="keywd">then</span>
        incr(pos);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">while</span> pos &lt;= length(stri) <span class="keywd">do</span>
        <span class="keywd">if</span> stri[pos] >= <span class="stri">'0'</span> <span class="op">and</span> stri[pos] &lt;= <span class="stri">'z'</span> <span class="keywd">then</span>
          digit := digitval[ord(stri[pos]) - ord(<span class="stri">'0'</span>) + 1];
          <span class="keywd">if</span> digit = -1 <span class="op">or</span> digit >= base <span class="keywd">then</span>
            raise RANGE_ERROR;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          anInteger := anInteger * base + digit;
          incr(pos);
        <span class="keywd">else</span>
          raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">if</span> negative <span class="keywd">then</span>
        anInteger := -anInteger;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">integer</span>: number) <span class="op">sci</span> (<span class="op">in</span> <span class="type">integer</span>: precision) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: exponent <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: mantissa <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> precision &lt; 0 <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> number = 0 <span class="keywd">then</span>
      <span class="keywd">if</span> precision = 0 <span class="keywd">then</span>
        stri := <span class="stri">"0e+0"</span>;
      <span class="keywd">else</span>
        stri := <span class="stri">"0."</span> &amp; <span class="stri">"0"</span> <span class="op">mult</span> precision &amp; <span class="stri">"e+0"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      exponent := ord(log10(abs(number)));
      <span class="keywd">if</span> precision >= exponent <span class="keywd">then</span>
        stri := str(abs(number));
        stri &amp;:= <span class="stri">"0"</span> <span class="op">mult</span> (precision - exponent);
      <span class="keywd">else</span>
        mantissa := (abs(number) <span class="op">div</span> 10 ** pred(exponent - precision) + 5) <span class="op">div</span> 10;
        stri := str(mantissa);
        <span class="keywd">if</span> length(stri) > succ(precision) <span class="keywd">then</span>
          <span class="comment"># Rounding up increased the number of digits.</span>
          incr(exponent);
          stri := stri[.. succ(precision)];
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> precision &lt;> 0 <span class="keywd">then</span>
        stri := stri[1 len 1] &amp; <span class="stri">"."</span> &amp; stri[2 .. ];
      <span class="keywd">end</span> <span class="keywd">if</span>;
      stri &amp;:= <span class="stri">"e+"</span> &amp; str(exponent);
      <span class="keywd">if</span> number &lt; 0 <span class="keywd">then</span>
        stri := <span class="stri">"-"</span> &amp; stri;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(* INTERFACE *)</span>

<span class="keywd">const</span> <span class="type">func</span> <span class="type">type</span>: new <span class="keywd">interface</span> <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">type</span>: interfaceType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    global
    interfaceType := newtype;
    IN_PARAM_IS_REFERENCE(interfaceType);
    <span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">interfaceType</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">interfaceType</span>: source) <span class="keywd">is</span> action <span class="stri">"ITF_CREATE"</span>;
    <span class="keywd">const</span> destroyer: destroy (<span class="keywd">ref</span> <span class="type">interfaceType</span>: aValue)                     <span class="keywd">is</span> action <span class="stri">"ITF_DESTR"</span>;
    <span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">interfaceType</span>: dest) := (<span class="keywd">ref</span> <span class="type">interfaceType</span>: source)   <span class="keywd">is</span> action <span class="stri">"ITF_CPY"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">interfaceType</span>: itf1) = (<span class="op">in</span> <span class="type">interfaceType</span>: itf2)  <span class="keywd">is</span> action <span class="stri">"ITF_EQ"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">interfaceType</span>: itf1) &lt;> (<span class="op">in</span> <span class="type">interfaceType</span>: itf2) <span class="keywd">is</span> action <span class="stri">"ITF_NE"</span>;
    <span class="keywd">end</span> global;
  <span class="keywd">end</span> <span class="keywd">func</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">type</span>: sub (<span class="op">in</span> <span class="type">type</span>: baseType) <span class="keywd">interface</span> <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">type</span>: interfaceType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    global
    interfaceType := subtype baseType;
    IN_PARAM_IS_REFERENCE(interfaceType);
    <span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">interfaceType</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">interfaceType</span>: source) <span class="keywd">is</span> action <span class="stri">"ITF_CREATE"</span>;
    <span class="keywd">const</span> destroyer: destroy (<span class="keywd">ref</span> <span class="type">interfaceType</span>: aValue)                     <span class="keywd">is</span> action <span class="stri">"ITF_DESTR"</span>;
    <span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">interfaceType</span>: dest) := (<span class="keywd">ref</span> <span class="type">interfaceType</span>: source)   <span class="keywd">is</span> action <span class="stri">"ITF_CPY"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">interfaceType</span>: itf1) = (<span class="op">in</span> <span class="type">interfaceType</span>: itf2)  <span class="keywd">is</span> action <span class="stri">"ITF_EQ"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">interfaceType</span>: itf1) &lt;> (<span class="op">in</span> <span class="type">interfaceType</span>: itf2) <span class="keywd">is</span> action <span class="stri">"ITF_NE"</span>;
    <span class="keywd">end</span> global;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(* body *)</span>
<span class="comment">(*
const proc: body (ref type: STRU) is (ref expr: DECLS) end body is func
  begin
    const proc: DECL_BODY (attr STRU) is func
        DECLS;
      end func;
    DECL_BODY(STRU);
  end func;
*)</span>


<span class="keywd">const</span> <span class="type">proc</span>: type_implements_interface (<span class="op">in</span> <span class="type">type</span>: aType, <span class="op">in</span> <span class="type">type</span>: interfaceType) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">interfaceType</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">aType</span>: source)           <span class="keywd">is</span> action <span class="stri">"ITF_CREATE"</span>;
    <span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">interfaceType</span>: dest) := (<span class="keywd">ref</span> <span class="type">aType</span>: source)          <span class="keywd">is</span> action <span class="stri">"ITF_CPY2"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">interfaceType</span>: (attr interfaceType) <span class="op">conv</span> (<span class="keywd">ref</span> <span class="type">aType</span>: aValue) <span class="keywd">is</span> action <span class="stri">"ITF_CONV2"</span>;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">interfaceType</span>: toInterface (<span class="keywd">ref</span> <span class="type">aType</span>: aValue)               <span class="keywd">is</span> action <span class="stri">"ITF_TO_INTERFACE"</span>;

    <span class="keywd">const</span> <span class="type">func</span> <span class="type">aType</span>: (attr aType) <span class="op">conv</span> (<span class="keywd">ref</span> <span class="type">interfaceType</span>: aValue)         <span class="keywd">is</span> DYNAMIC;
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">aType</span>: (attr aType) <span class="op">conv</span> (<span class="keywd">ref</span> <span class="type">aType</span>: aValue)                 <span class="keywd">is</span>
      <span class="keywd">return</span> aValue;

    addInterface(aType, interfaceType);

    <span class="keywd">const</span> <span class="type">func</span> <span class="type">interfaceType</span>: create (attr aType) <span class="keywd">is</span> <span class="keywd">func</span>
      <span class="keywd">result</span>
        <span class="keywd">var</span> <span class="type">interfaceType</span>: allocated <span class="keywd">is</span> aType.value;
      <span class="keywd">local</span>
        <span class="keywd">var</span> <span class="type">aType</span>: newStuct <span class="keywd">is</span> aType.value;
      <span class="keywd">begin</span>
        allocated := toInterface(newStuct);
      <span class="keywd">end</span> <span class="keywd">func</span>;

    <span class="keywd">const</span> <span class="type">func</span> <span class="type">interfaceType</span>: create (<span class="op">in</span> <span class="type">aType</span>: newStuct) <span class="keywd">is</span> <span class="keywd">func</span>
      <span class="keywd">result</span>
        <span class="keywd">var</span> <span class="type">interfaceType</span>: allocated <span class="keywd">is</span> aType.value;
      <span class="keywd">begin</span>
        allocated := toInterface(newStuct);
      <span class="keywd">end</span> <span class="keywd">func</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(* CASE_DECLS *)</span>

<span class="keywd">const</span> <span class="type">proc</span>: CASE_DECLS (<span class="op">in</span> <span class="type">type</span>: aType) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: WHEN_RESULT <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: WHEN_PROC <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: SELECTOR_TYPE <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
<span class="comment">(*    PRINT("in CASE_DECLS "); PRINT(str(aType)); PRINT("\n"); *)</span>
    WHEN_RESULT := newtype;
    WHEN_PROC := (<span class="type">func</span> WHEN_RESULT);
    SELECTOR_TYPE := <span class="type">set</span> <span class="type">of</span> <span class="type">aType</span>;
    <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">case</span> (<span class="keywd">ref</span> <span class="type">aType</span>: decisionValue) <span class="keywd">of</span> <span class="keywd">end</span> <span class="keywd">case</span>                     <span class="keywd">is</span> noop;
    <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">case</span> (<span class="keywd">ref</span> <span class="type">aType</span>: decisionValue) <span class="keywd">of</span>
                    <span class="keywd">otherwise</span> : (<span class="keywd">ref</span> <span class="type">proc</span>: statements)
                  <span class="keywd">end</span> <span class="keywd">case</span>                                                      <span class="keywd">is</span> <span class="keywd">func</span>
      <span class="keywd">begin</span>
        statements;
      <span class="keywd">end</span> <span class="keywd">func</span>;
    <span class="keywd">if</span> getobj(ord(<span class="keywd">ref</span> <span class="type">aType</span>: decisionValue)) &lt;> NIL <span class="op">and</span>
        getobj(ord(<span class="keywd">ref</span> <span class="type">aType</span>: decisionValue, mayRaiseRangeError)) = NIL <span class="keywd">then</span>
      <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">case</span> (<span class="keywd">ref</span> <span class="type">aType</span>: decisionValue) <span class="keywd">of</span>
                    (<span class="keywd">ref</span> <span class="type">WHEN_PROC</span>: whenPart)
                  <span class="keywd">end</span> <span class="keywd">case</span>                                                      <span class="keywd">is</span> action <span class="stri">"PRC_CASE"</span>;
      <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">case</span> (<span class="keywd">ref</span> <span class="type">aType</span>: decisionValue) <span class="keywd">of</span>
                    (<span class="keywd">ref</span> <span class="type">WHEN_PROC</span>: whenPart)
                    <span class="keywd">otherwise</span> : (<span class="keywd">ref</span> <span class="type">proc</span>: statements)
                  <span class="keywd">end</span> <span class="keywd">case</span>                                                      <span class="keywd">is</span> action <span class="stri">"PRC_CASE_DEF"</span>;
    <span class="keywd">else</span>
      <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">case</span> (<span class="keywd">ref</span> <span class="type">aType</span>: decisionValue) <span class="keywd">of</span>
                    (<span class="keywd">ref</span> <span class="type">WHEN_PROC</span>: whenPart)
                  <span class="keywd">end</span> <span class="keywd">case</span>                                                      <span class="keywd">is</span> action <span class="stri">"PRC_CASE_HASHSET"</span>;
      <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">case</span> (<span class="keywd">ref</span> <span class="type">aType</span>: decisionValue) <span class="keywd">of</span>
                    (<span class="keywd">ref</span> <span class="type">WHEN_PROC</span>: whenPart)
                    <span class="keywd">otherwise</span> : (<span class="keywd">ref</span> <span class="type">proc</span>: statements)
                  <span class="keywd">end</span> <span class="keywd">case</span>                                                      <span class="keywd">is</span> action <span class="stri">"PRC_CASE_HASHSET_DEF"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">WHEN_RESULT</span>: dest) ::= enumlit                             <span class="keywd">is</span> action <span class="stri">"ENU_GENLIT"</span>;
    <span class="keywd">const</span> <span class="type">WHEN_RESULT</span>: WHEN_EMPTY (attr aType) <span class="keywd">is</span> enumlit;
    <span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">WHEN_PROC</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">WHEN_RESULT</span>: source)             <span class="keywd">is</span> action <span class="stri">"ENU_CREATE"</span>;
    <span class="keywd">const</span> <span class="type">WHEN_PROC</span>: <span class="keywd">when</span> (<span class="keywd">ref</span> <span class="type">SELECTOR_TYPE</span>: whenSet) : (<span class="keywd">ref</span> <span class="type">proc</span>: statement)  <span class="keywd">is</span> WHEN_EMPTY(aType);
    <span class="keywd">const</span> <span class="type">WHEN_PROC</span>: <span class="keywd">when</span> (<span class="keywd">ref</span> <span class="type">SELECTOR_TYPE</span>: whenSet) : (<span class="keywd">ref</span> <span class="type">proc</span>: statement)
                       (<span class="keywd">ref</span> <span class="type">WHEN_PROC</span>: whenPart)                                <span class="keywd">is</span> WHEN_EMPTY(aType);
  <span class="keywd">end</span> <span class="keywd">func</span>;

CASE_DECLS(integer);
CASE_DECLS(char);
CASE_DECLS(boolean);
CASE_DECLS(string);

<span class="keywd">const</span> <span class="type">proc</span>: TRACE (<span class="keywd">ref</span> <span class="type">expr</span>: traceobject)               <span class="keywd">is</span> action <span class="stri">"REF_TRACE"</span>;

<span class="comment">(* ENUMERATION *)</span>

$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/enumeration.htm">enumeration.s7i</a>"</span>;

<span class="comment">(* BLOCK *)</span>

<span class="keywd">const</span> <span class="type">proc</span>: BLOCK_DECLS (<span class="op">in</span> <span class="type">type</span>: unusedType) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: CATCH_RESULT <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: CATCH_PROC <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
<span class="comment">(*    PRINT("in BLOCK_DECLS\n"); *)</span>
    CATCH_RESULT := new <span class="keywd">enum</span> CATCH_EMPTY <span class="keywd">end</span> <span class="keywd">enum</span>;
    CATCH_PROC := (<span class="type">func</span> CATCH_RESULT);
    <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">block</span> (<span class="keywd">ref</span> <span class="type">proc</span>: statements) exception <span class="keywd">end</span> <span class="keywd">block</span>                   <span class="keywd">is</span> noop;
    <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">block</span> (<span class="keywd">ref</span> <span class="type">proc</span>: statements) exception
                  (<span class="keywd">ref</span> <span class="type">CATCH_PROC</span>: catchPart)
                <span class="keywd">end</span> <span class="keywd">block</span>                                                          <span class="keywd">is</span> action <span class="stri">"PRC_BLOCK"</span>;
    <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">block</span> (<span class="keywd">ref</span> <span class="type">proc</span>: statements) exception
                  (<span class="keywd">ref</span> <span class="type">CATCH_PROC</span>: catchPart)
                  <span class="keywd">otherwise</span> : (<span class="keywd">ref</span> <span class="type">proc</span>: otherwiseStatements)
                <span class="keywd">end</span> <span class="keywd">block</span>                                                          <span class="keywd">is</span> action <span class="stri">"PRC_BLOCK_OTHERWISE"</span>;
    <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">block</span> (<span class="keywd">ref</span> <span class="type">proc</span>: statements) exception
                  <span class="keywd">otherwise</span> : (<span class="keywd">ref</span> <span class="type">proc</span>: otherwiseStatements)
                <span class="keywd">end</span> <span class="keywd">block</span>                                                          <span class="keywd">is</span> action <span class="stri">"PRC_BLOCK_CATCH_ALL"</span>;
    <span class="keywd">const</span> creator: (<span class="keywd">ref</span> <span class="type">CATCH_PROC</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">CATCH_RESULT</span>: source)              <span class="keywd">is</span> action <span class="stri">"ENU_CREATE"</span>;
    <span class="keywd">const</span> <span class="type">CATCH_PROC</span>: catch (<span class="keywd">ref</span> <span class="type">EXCEPTION</span>: anException) : (<span class="keywd">ref</span> <span class="type">proc</span>: statements)  <span class="keywd">is</span> CATCH_RESULT.value;
    <span class="keywd">const</span> <span class="type">CATCH_PROC</span>: catch (<span class="keywd">ref</span> <span class="type">EXCEPTION</span>: anException) : (<span class="keywd">ref</span> <span class="type">proc</span>: statements)
                       (<span class="keywd">ref</span> <span class="type">CATCH_PROC</span>: catchPart)                                 <span class="keywd">is</span> CATCH_RESULT.value;
  <span class="keywd">end</span> <span class="keywd">func</span>;

BLOCK_DECLS(void);

<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: succeeds (<span class="keywd">ref</span> <span class="type">proc</span>: statement) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: success <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">block</span>
      statement;
    exception
      <span class="keywd">otherwise</span>: success := FALSE;
    <span class="keywd">end</span> <span class="keywd">block</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(* ARGS + ENV *)</span>

$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/environment.htm">environment.s7i</a>"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: heapstat (PROGRAM)              <span class="keywd">is</span> action <span class="stri">"PRC_HEAPSTAT"</span>;
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: heapsize (PROGRAM)      <span class="keywd">is</span> action <span class="stri">"PRC_HSIZE"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">include</span> (<span class="op">in</span> <span class="type">string</span>: fileName)  <span class="keywd">is</span> action <span class="stri">"PRC_INCLUDE"</span>;

<span class="comment">(*
const proc: var (ref expr: typeExpr) : (ref expr: nameExpr) is (ref expr: initExpr) is action "PRC_TRACE";
*)</span>

<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is</span> <span class="keywd">forward</span>;

$ <span class="keywd">system</span> <span class="stri">"main"</span> <span class="keywd">is</span> main;

<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/stdio.htm">stdio.s7i</a>"</span>;
</pre>
</body>
</html>
