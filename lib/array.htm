<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  array.s7i     Support for arrays with integer index             *)</span>
<span class="comment">(*  Copyright (C) 1989 - 2014, 2017, 2020 - 2022  Thomas Mertes     *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">const</span> <span class="type">type</span>: ARRAY_IDX_RANGE <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: minIdx <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: maxIdx <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">ARRAY_IDX_RANGE</span>: [ (<span class="op">in</span> <span class="type">integer</span>: minIdx) .. (<span class="op">in</span> <span class="type">integer</span>: maxIdx) ] <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">ARRAY_IDX_RANGE</span>: indexRange <span class="keywd">is</span> ARRAY_IDX_RANGE.value;
  <span class="keywd">begin</span>
    indexRange.minIdx := minIdx;
    indexRange.maxIdx := maxIdx;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">ARRAY_IDX_RANGE</span>: [ (<span class="op">in</span> <span class="type">integer</span>: minIdx) len (<span class="op">in</span> <span class="type">integer</span>: length) ] <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">ARRAY_IDX_RANGE</span>: indexRange <span class="keywd">is</span> ARRAY_IDX_RANGE.value;
  <span class="keywd">begin</span>
    indexRange.minIdx := minIdx;
    indexRange.maxIdx := pred(minIdx + length);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Abstract data type, describing resizable arrays with [[integer]] index.
 *  Arrays with non-integer index are described in [[idxarray]].
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">type</span>: <span class="type">array</span> <span class="type">(</span><span class="op">in</span> <span class="type">type</span>: baseType) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">type</span>: arrayType <span class="keywd">is</span> void;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: tupleType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    arrayType := get_type(getfunc(<span class="type">array</span> <span class="type">(</span>attr baseType)));
    <span class="keywd">if</span> arrayType = void <span class="keywd">then</span>
      global
      arrayType := newtype;
      IN_PARAM_IS_REFERENCE(arrayType);
      tupleType := tuple(baseType);
      <span class="keywd">const</span> <span class="type">type</span>: <span class="type">array</span> <span class="type">(</span>attr baseType)                                       <span class="keywd">is</span> arrayType;
      <span class="keywd">const</span> <span class="type">type</span>: base_type (attr arrayType)                                  <span class="keywd">is</span> baseType;

      <span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">ref</span> <span class="type">arrayType</span>: dest) ::= (<span class="op">in</span> <span class="type">arrayType</span>: source)            <span class="keywd">is</span> action <span class="stri">"ARR_CREATE"</span>;
      <span class="keywd">const</span> <span class="type">proc</span>: destroy (<span class="keywd">ref</span> <span class="type">arrayType</span>: aValue)                             <span class="keywd">is</span> action <span class="stri">"ARR_DESTR"</span>;
      <span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">arrayType</span>: dest) := (<span class="op">in</span> <span class="type">arrayType</span>: source)           <span class="keywd">is</span> action <span class="stri">"ARR_CPY"</span>;

      <span class="comment">(**
       *  Append the array ''extension'' to the array ''arr''.
       *  @exception MEMORY_ERROR Not enough memory for the concatenated
       *             array.
       *)</span>
      <span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">arrayType</span>: arr) &amp;:= (<span class="op">in</span> <span class="type">arrayType</span>: extension)        <span class="keywd">is</span> action <span class="stri">"ARR_APPEND"</span>;

      <span class="comment">(**
       *  Append the given ''element'' to the array ''arr''.
       *  @exception MEMORY_ERROR Not enough memory for the concatenated
       *             array.
       *)</span>
      <span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">arrayType</span>: arr) &amp;:= (<span class="op">in</span> <span class="type">baseType</span>: element)           <span class="keywd">is</span> action <span class="stri">"ARR_PUSH"</span>;

      <span class="keywd">const</span> <span class="type">func</span> <span class="type">arrayType</span>: [] (<span class="op">in</span> <span class="type">tupleType</span>: aTuple)                         <span class="keywd">is</span> action <span class="stri">"ARR_ARRLIT"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">arrayType</span>: [] (<span class="op">in</span> <span class="type">baseType</span>: anElement)                       <span class="keywd">is</span> action <span class="stri">"ARR_BASELIT"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">arrayType</span>: [ (<span class="op">in</span> <span class="type">integer</span>: start) ] (<span class="op">in</span> <span class="type">tupleType</span>: aTuple)    <span class="keywd">is</span> action <span class="stri">"ARR_ARRLIT2"</span>;
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">arrayType</span>: [ (<span class="op">in</span> <span class="type">integer</span>: start) ] (<span class="op">in</span> <span class="type">baseType</span>: anElement)  <span class="keywd">is</span> action <span class="stri">"ARR_BASELIT2"</span>;

      <span class="comment">(**
       *  Concatenate two arrays.
       *  @return the result of the concatenation.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">arrayType</span>: (<span class="op">in</span> <span class="type">arrayType</span>: arr1) &amp; (<span class="op">in</span> <span class="type">arrayType</span>: arr2)       <span class="keywd">is</span> action <span class="stri">"ARR_CAT"</span>;

      <span class="comment">(**
       *  Access one element from the array ''arr''.
       *  @return the element with the specified ''index'' from ''arr''.
       *  @exception INDEX_ERROR If ''index'' is less than [[#minIdx(in_arrayType)|minIdx]](arr) or
       *                         greater than [[#minIdx(in_arrayType)|maxIdx]](arr)
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">baseType</span>: (<span class="op">in</span> <span class="type">arrayType</span>: arr) [ (<span class="op">in</span> <span class="type">integer</span>: index) ]        <span class="keywd">is</span> action <span class="stri">"ARR_IDX"</span>;

      <span class="keywd">const</span> <span class="type">varfunc</span> <span class="type">baseType</span>: (<span class="keywd">inout</span> <span class="type">arrayType</span>: arr) [ (<span class="op">in</span> <span class="type">integer</span>: index) ]  <span class="keywd">is</span> action <span class="stri">"ARR_IDX"</span>;

      <span class="comment">(**
       *  Get a sub array beginning at the position ''start''.
       *  @return the sub array beginning at the start position.
       *  @exception INDEX_ERROR The start position is less than minIdx(arr).
       *  @exception MEMORY_ERROR Not enough memory to represent the result.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">arrayType</span>: (<span class="op">in</span> <span class="type">arrayType</span>: arr) [ (<span class="op">in</span> <span class="type">integer</span>: start) .. ]    <span class="keywd">is</span> action <span class="stri">"ARR_TAIL"</span>;

      <span class="comment">(**
       *  Get a sub array ending at the position ''stop''.
       *  @return the sub array ending at the stop position.
       *  @exception INDEX_ERROR The stop position is less than pred(minIdx(arr)).
       *  @exception MEMORY_ERROR Not enough memory to represent the result.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">arrayType</span>: (<span class="op">in</span> <span class="type">arrayType</span>: arr) [ .. (<span class="op">in</span> <span class="type">integer</span>: stop) ]     <span class="keywd">is</span> action <span class="stri">"ARR_HEAD"</span>;

      <span class="comment">(**
       *  Get a sub array from the position ''start'' to the position ''stop''.
       *  @return the sub array from position ''start'' to ''stop''.
       *  @exception INDEX_ERROR The start position is less than minIdx(arr1), or
       *                         the stop position is less than pred(start).
       *  @exception MEMORY_ERROR Not enough memory to represent the result.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">arrayType</span>: (<span class="op">in</span> <span class="type">arrayType</span>: arr) [ (<span class="op">in</span> <span class="type">integer</span>: start) ..
                                                  (<span class="op">in</span> <span class="type">integer</span>: stop) ]        <span class="keywd">is</span> action <span class="stri">"ARR_RANGE"</span>;

      <span class="comment">(**
       *  Get a sub array from the position ''start'' with maximum length ''len''.
       *  @return the sub array from position ''start'' with maximum length ''len''.
       *  @exception INDEX_ERROR The start position is less than minIdx(arr), or
       *                         the length is negative.
       *  @exception MEMORY_ERROR Not enough memory to represent the result.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">arrayType</span>: (<span class="op">in</span> <span class="type">arrayType</span>: arr) [ (<span class="op">in</span> <span class="type">integer</span>: start) len
                                                  (<span class="op">in</span> <span class="type">integer</span>: length) ]      <span class="keywd">is</span> action <span class="stri">"ARR_SUBARR"</span>;

      <span class="comment">(**
       *  Insert ''element'' at ''index'' into ''arr''.
       *  Elements are moved backward to create space for the element to be
       *  inserted. This function is tuned for performance and the movement
       *  works without copying elements.
       *  @exception INDEX_ERROR If ''index'' is less than minIdx(arr) or
       *                         greater than succ(maxIdx(arr))
       *)</span>
      <span class="keywd">const</span> <span class="type">proc</span>: insert (<span class="keywd">inout</span> <span class="type">arrayType</span>: arr, <span class="op">in</span> <span class="type">integer</span>: index,
                          <span class="op">in</span> <span class="type">baseType</span>: element)                               <span class="keywd">is</span> action <span class="stri">"ARR_INSERT"</span>;

      <span class="comment">(**
       *  Insert ''elements'' at ''index'' into ''arr''.
       *  Elements are moved backward to create space for the elements to be
       *  inserted. This function is tuned for performance and the movement
       *  works without copying elements.
       *  @exception INDEX_ERROR If ''index'' is less than minIdx(arr) or
       *                         greater than succ(maxIdx(arr))
       *)</span>
      <span class="keywd">const</span> <span class="type">proc</span>: insert (<span class="keywd">inout</span> <span class="type">arrayType</span>: arr, <span class="op">in</span> <span class="type">integer</span>: index,
                          <span class="op">in</span> <span class="type">arrayType</span>: elements)                             <span class="keywd">is</span> action <span class="stri">"ARR_INSERT_ARRAY"</span>;

      <span class="comment">(**
       *  Remove the element with ''index'' from ''arr''.
       *  The elements after the removed element are moved forward.
       *  This function is tuned for performance and the movement works
       *  without copying elements.
       *  @return the removed element.
       *  @exception INDEX_ERROR If ''index'' is less than [[#minIdx(in_arrayType)|minIdx]](arr) or
       *                         greater than [[#minIdx(in_arrayType)|maxIdx]](arr)
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">baseType</span>: remove (<span class="keywd">inout</span> <span class="type">arrayType</span>: arr, <span class="op">in</span> <span class="type">integer</span>: index)   <span class="keywd">is</span> action <span class="stri">"ARR_REMOVE"</span>;

      <span class="comment">(**
       *  Remove the sub-array with ''index'' and ''length'' from ''arr''.
       *  The elements after the removed sub-array are moved forward.
       *  This function is tuned for performance and the movement works
       *  without copying elements.
       *  @return the removed sub-array.
       *  @exception INDEX_ERROR If ''index'' is less than [[#minIdx(in_arrayType)|minIdx]](arr) or
       *                         greater than [[#minIdx(in_arrayType)|maxIdx]](arr)
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">arrayType</span>: remove (<span class="keywd">inout</span> <span class="type">arrayType</span>: arr, <span class="op">in</span> <span class="type">integer</span>: index,
                                    <span class="op">in</span> <span class="type">integer</span>: length)                       <span class="keywd">is</span> action <span class="stri">"ARR_REMOVE_ARRAY"</span>;

      <span class="comment">(**
       *  Determine the length of the array ''arr''.
       *   length([] (2, 3, 5))   returns  3
       *   length([0] (2, 3, 5))  returns  3
       *   length([2] (2, 3, 5))  returns  3
       *  @return the length of the array.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: length (<span class="op">in</span> <span class="type">arrayType</span>: arr)                          <span class="keywd">is</span> action <span class="stri">"ARR_LNG"</span>;

      <span class="comment">(**
       *  Minimum index of array ''arr''.
       *   minIdx([] (2, 3, 5))   returns  1
       *   minIdx([0] (2, 3, 5))  returns  0
       *   minIdx([2] (2, 3, 5))  returns  2
       *  @return the minimum index of the array.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: minIdx (<span class="op">in</span> <span class="type">arrayType</span>: arr)                          <span class="keywd">is</span> action <span class="stri">"ARR_MINIDX"</span>;

      <span class="comment">(**
       *  Maximum index of array ''arr''.
       *   maxIdx([] (2, 3, 5))   returns  3
       *   maxIdx([0] (2, 3, 5))  returns  2
       *   maxIdx([2] (2, 3, 5))  returns  4
       *  @return the maximum index of the array.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: maxIdx (<span class="op">in</span> <span class="type">arrayType</span>: arr)                          <span class="keywd">is</span> action <span class="stri">"ARR_MAXIDX"</span>;

      <span class="comment">(**
       *  Generate an array by using ''factor'' ''elements''.
       *  @return an array with ''factor'' ''elements''.
       *  @exception RANGE_ERROR If ''factor'' is negative.
       *  @exception MEMORY_ERROR Not enough memory to represent the result.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">arrayType</span>: (<span class="op">in</span> <span class="type">integer</span>: factor) <span class="op">times</span> (<span class="op">in</span> <span class="type">baseType</span>: element) <span class="keywd">is</span> action <span class="stri">"ARR_TIMES"</span>;

      <span class="keywd">const</span> <span class="type">func</span> <span class="type">arrayType</span>: (attr arrayType) . _GENERATE_EMPTY_ARRAY          <span class="keywd">is</span> action <span class="stri">"ARR_EMPTY"</span>;
      <span class="keywd">const</span> <span class="type">arrayType</span>: (attr arrayType) . value                               <span class="keywd">is</span> arrayType._GENERATE_EMPTY_ARRAY;

      <span class="keywd">const</span> <span class="type">func</span> <span class="type">tupleType</span>: (attr tupleType) <span class="op">conv</span> (<span class="op">in</span> <span class="type">arrayType</span>: arr)         <span class="keywd">is</span> action <span class="stri">"ARR_CONV"</span>;

      <span class="comment">(**
       *  Generate an array of ''elements'' with indices in a specified range.
       *  The range is specified with a bracketed range expression like
       *  [A .. B] or [A len L]. An array with 5 char elements indexed
       *  from 0 to 4 is created with:
       *   [0 .. 4] times 'x'    or    [0 len 5] times 'x'
       *  This is equivalent to
       *   [0] ('x', 'x', 'x', 'x', 'x')
       *  An empty array can be generated with
       *   [0 .. -1] times ""    or    [0 len 0] times ""
       *  @return an array with B - A + 1 ''elements'' (when [A .. B] is used), or
       *          an array with L ''elements'' (when [A len L] is used).
       *  @exception RANGE_ERROR If B - A is less than -1, or if L is less than 0.
       *  @exception MEMORY_ERROR Not enough memory to represent the result.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">arrayType</span>: (<span class="op">in</span> <span class="type">ARRAY_IDX_RANGE</span>: indexRange) <span class="op">times</span>
          (<span class="op">in</span> <span class="type">baseType</span>: element) <span class="keywd">is</span>
        <span class="keywd">return</span> [indexRange.minIdx] (tupleType <span class="op">conv</span>
               (succ(indexRange.maxIdx - indexRange.minIdx) <span class="op">times</span> element));

      <span class="comment">(**
       *  For-loop where ''forVar'' loops over the elements of the array ''arr''.
       *)</span>
      <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">for</span> (<span class="keywd">inout</span> <span class="type">baseType</span>: forVar) <span class="keywd">range</span> (<span class="op">in</span> <span class="type">arrayType</span>: arr) <span class="keywd">do</span>
                    (<span class="op">in</span> <span class="type">proc</span>: statements)
                  <span class="keywd">end</span> <span class="keywd">for</span> <span class="keywd">is</span> <span class="keywd">func</span>
        <span class="keywd">local</span>
          <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
        <span class="keywd">begin</span>
          <span class="keywd">for</span> number <span class="keywd">range</span> minIdx(arr) <span class="keywd">to</span> maxIdx(arr) <span class="keywd">do</span>
            forVar := arr[number];
            statements;
          <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="comment">(**
       *  For-loop where ''keyVar'' loops over the indices of the array ''arr''.
       *)</span>
      <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">for</span> <span class="keywd">key</span> (<span class="keywd">inout</span> <span class="type">integer</span>: keyVar) <span class="keywd">range</span> (<span class="op">in</span> <span class="type">arrayType</span>: arr) <span class="keywd">do</span>
                    (<span class="op">in</span> <span class="type">proc</span>: statements)
                  <span class="keywd">end</span> <span class="keywd">for</span> <span class="keywd">is</span> <span class="keywd">func</span>
        <span class="keywd">begin</span>
          <span class="keywd">for</span> keyVar <span class="keywd">range</span> minIdx(arr) <span class="keywd">to</span> maxIdx(arr) <span class="keywd">do</span>
            statements;
          <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="comment">(**
       *  For-loop where ''forVar'' and ''keyVar'' loop over the array ''arr''.
       *  The variable ''forVar'' loops over the elements of ''arr''
       *  and ''keyVar'' loops over the indices of ''arr''.
       *)</span>
      <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">for</span> (<span class="keywd">inout</span> <span class="type">baseType</span>: forVar) <span class="keywd">key</span> (<span class="keywd">inout</span> <span class="type">integer</span>: keyVar) <span class="keywd">range</span> (<span class="op">in</span> <span class="type">arrayType</span>: arr) <span class="keywd">do</span>
                    (<span class="op">in</span> <span class="type">proc</span>: statements)
                  <span class="keywd">end</span> <span class="keywd">for</span> <span class="keywd">is</span> <span class="keywd">func</span>
        <span class="keywd">begin</span>
          <span class="keywd">for</span> keyVar <span class="keywd">range</span> minIdx(arr) <span class="keywd">to</span> maxIdx(arr) <span class="keywd">do</span>
            forVar := arr[keyVar];
            statements;
          <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="comment">(**
       *  For-loop where ''forVar'' loops over the elements of the array ''arr''.
       *  Additionally a ''condition'' is checked before the statements in
       *  the loop body are executed.
       *)</span>
      <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">for</span> (<span class="keywd">inout</span> <span class="type">baseType</span>: forVar)
                  <span class="keywd">range</span> (<span class="op">in</span> <span class="type">arrayType</span>: arr)
                  <span class="keywd">until</span> (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">boolean</span>: condition) <span class="keywd">do</span>
                    (<span class="op">in</span> <span class="type">proc</span>: statements)
                  <span class="keywd">end</span> <span class="keywd">for</span> <span class="keywd">is</span> <span class="keywd">func</span>
        <span class="keywd">local</span>
          <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
          <span class="keywd">var</span> <span class="type">integer</span>: maxIdx <span class="keywd">is</span> 0;
        <span class="keywd">begin</span>
          index := minIdx(arr);
          maxIdx := maxIdx(arr);
          <span class="keywd">if</span> index &lt;= maxIdx <span class="keywd">then</span>
            forVar := arr[index];
            <span class="keywd">while</span> index &lt;= maxIdx <span class="op">and</span> <span class="op">not</span> condition <span class="keywd">do</span>
              statements;
              incr(index);
              <span class="keywd">if</span> index &lt;= maxIdx <span class="keywd">then</span>
                forVar := arr[index];
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">while</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">for</span> (<span class="keywd">inout</span> <span class="type">baseType</span>: forVar)
                  <span class="keywd">range</span> (<span class="op">in</span> <span class="type">arrayType</span>: arr)
                  <span class="keywd">until</span> (<span class="keywd">ref</span> <span class="type">boolean</span>: condition) <span class="keywd">do</span>
                    (<span class="op">in</span> <span class="type">proc</span>: statements)
                  <span class="keywd">end</span> <span class="keywd">for</span> <span class="keywd">is</span> <span class="keywd">func</span>
        <span class="keywd">local</span>
          <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
          <span class="keywd">var</span> <span class="type">integer</span>: maxIdx <span class="keywd">is</span> 0;
        <span class="keywd">begin</span>
          index := minIdx(arr);
          maxIdx := maxIdx(arr);
          <span class="keywd">if</span> index &lt;= maxIdx <span class="keywd">then</span>
            forVar := arr[index];
            <span class="keywd">while</span> index &lt;= maxIdx <span class="op">and</span> <span class="op">not</span> condition <span class="keywd">do</span>
              statements;
              incr(index);
              <span class="keywd">if</span> index &lt;= maxIdx <span class="keywd">then</span>
                forVar := arr[index];
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">while</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="comment">(**
       *  For-loop where ''keyVar'' loops over the indices of the array ''arr''.
       *  Additionally a ''condition'' is checked before the statements in
       *  the loop body are executed.
       *)</span>
      <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">for</span> <span class="keywd">key</span> (<span class="keywd">inout</span> <span class="type">integer</span>: keyVar)
                  <span class="keywd">range</span> (<span class="op">in</span> <span class="type">arrayType</span>: arr)
                  <span class="keywd">until</span> (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">boolean</span>: condition) <span class="keywd">do</span>
                    (<span class="op">in</span> <span class="type">proc</span>: statements)
                  <span class="keywd">end</span> <span class="keywd">for</span> <span class="keywd">is</span> <span class="keywd">func</span>
        <span class="keywd">begin</span>
          <span class="keywd">for</span> keyVar <span class="keywd">range</span> minIdx(arr) <span class="keywd">to</span> maxIdx(arr) <span class="keywd">until</span> condition <span class="keywd">do</span>
            statements;
          <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">for</span> <span class="keywd">key</span> (<span class="keywd">inout</span> <span class="type">integer</span>: keyVar)
                  <span class="keywd">range</span> (<span class="op">in</span> <span class="type">arrayType</span>: arr)
                  <span class="keywd">until</span> (<span class="keywd">ref</span> <span class="type">boolean</span>: condition) <span class="keywd">do</span>
                    (<span class="op">in</span> <span class="type">proc</span>: statements)
                  <span class="keywd">end</span> <span class="keywd">for</span> <span class="keywd">is</span> <span class="keywd">func</span>
        <span class="keywd">begin</span>
          <span class="keywd">for</span> keyVar <span class="keywd">range</span> minIdx(arr) <span class="keywd">to</span> maxIdx(arr) <span class="keywd">until</span> condition <span class="keywd">do</span>
            statements;
          <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="comment">(**
       *  For-loop where ''forVar'' and ''keyVar'' loop over the array ''arr''.
       *  The variable ''forVar'' loops over the elements of ''arr''
       *  and ''keyVar'' loops over the indices of ''arr''.
       *  Additionally a ''condition'' is checked before the statements in
       *  the loop body are executed.
       *)</span>
      <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">for</span> (<span class="keywd">inout</span> <span class="type">baseType</span>: forVar)
                  <span class="keywd">key</span> (<span class="keywd">inout</span> <span class="type">integer</span>: keyVar)
                  <span class="keywd">range</span> (<span class="op">in</span> <span class="type">arrayType</span>: arr)
                  <span class="keywd">until</span> (<span class="keywd">ref</span> <span class="type">func</span> <span class="type">boolean</span>: condition) <span class="keywd">do</span>
                    (<span class="op">in</span> <span class="type">proc</span>: statements)
                  <span class="keywd">end</span> <span class="keywd">for</span> <span class="keywd">is</span> <span class="keywd">func</span>
        <span class="keywd">local</span>
          <span class="keywd">var</span> <span class="type">integer</span>: maxIdx <span class="keywd">is</span> 0;
        <span class="keywd">begin</span>
          keyVar := minIdx(arr);
          maxIdx := maxIdx(arr);
          <span class="keywd">if</span> keyVar &lt;= maxIdx <span class="keywd">then</span>
            forVar := arr[keyVar];
            <span class="keywd">while</span> keyVar &lt;= maxIdx <span class="op">and</span> <span class="op">not</span> condition <span class="keywd">do</span>
              statements;
              incr(keyVar);
              <span class="keywd">if</span> keyVar &lt;= maxIdx <span class="keywd">then</span>
                forVar := arr[keyVar];
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">while</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">for</span> (<span class="keywd">inout</span> <span class="type">baseType</span>: forVar)
                  <span class="keywd">key</span> (<span class="keywd">inout</span> <span class="type">integer</span>: keyVar)
                  <span class="keywd">range</span> (<span class="op">in</span> <span class="type">arrayType</span>: arr)
                  <span class="keywd">until</span> (<span class="keywd">ref</span> <span class="type">boolean</span>: condition) <span class="keywd">do</span>
                    (<span class="op">in</span> <span class="type">proc</span>: statements)
                  <span class="keywd">end</span> <span class="keywd">for</span> <span class="keywd">is</span> <span class="keywd">func</span>
        <span class="keywd">local</span>
          <span class="keywd">var</span> <span class="type">integer</span>: maxIdx <span class="keywd">is</span> 0;
        <span class="keywd">begin</span>
          keyVar := minIdx(arr);
          maxIdx := maxIdx(arr);
          <span class="keywd">if</span> keyVar &lt;= maxIdx <span class="keywd">then</span>
            forVar := arr[keyVar];
            <span class="keywd">while</span> keyVar &lt;= maxIdx <span class="op">and</span> <span class="op">not</span> condition <span class="keywd">do</span>
              statements;
              incr(keyVar);
              <span class="keywd">if</span> keyVar &lt;= maxIdx <span class="keywd">then</span>
                forVar := arr[keyVar];
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">while</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="comment">(**
       *  Select a random element from ''arr''.
       *  The pseudo-random indices of the elements are uniform distributed.
       *  @return a random element from ''arr''.
       *  @exception RANGE_ERROR If ''arr'' is empty.
       *)</span>
      <span class="keywd">const</span> <span class="type">func</span> <span class="type">baseType</span>: rand (<span class="op">in</span> <span class="type">arrayType</span>: arr) <span class="keywd">is</span>
        <span class="keywd">return</span> arr[rand(minIdx(arr), maxIdx(arr))];

      <span class="keywd">if</span> getobj((<span class="op">in</span> <span class="type">baseType</span>: element1) = (<span class="op">in</span> <span class="type">baseType</span>: element2)) &lt;> NIL <span class="op">and</span>
          getobj((<span class="op">in</span> <span class="type">baseType</span>: element1) &lt;> (<span class="op">in</span> <span class="type">baseType</span>: element2)) &lt;> NIL <span class="keywd">then</span>

        <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">arrayType</span>: arr1) = (<span class="op">in</span> <span class="type">arrayType</span>: arr2) <span class="keywd">is</span> <span class="keywd">func</span>
          <span class="keywd">result</span>
            <span class="keywd">var</span> <span class="type">boolean</span>: isEqual <span class="keywd">is</span> FALSE;
          <span class="keywd">local</span>
            <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 1;
          <span class="keywd">begin</span>
            <span class="keywd">if</span> minIdx(arr1) = minIdx(arr2) <span class="op">and</span> maxIdx(arr1) = maxIdx(arr2) <span class="keywd">then</span>
              isEqual := TRUE;
              number := minIdx(arr1);
              <span class="keywd">while</span> number &lt;= maxIdx(arr1) <span class="op">and</span> isEqual <span class="keywd">do</span>
                isEqual := arr1[number] = arr2[number];
                incr(number);
              <span class="keywd">end</span> <span class="keywd">while</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">func</span>;

        <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">arrayType</span>: arr1) &lt;> (<span class="op">in</span> <span class="type">arrayType</span>: arr2) <span class="keywd">is</span> <span class="keywd">func</span>
          <span class="keywd">result</span>
            <span class="keywd">var</span> <span class="type">boolean</span>: isNotEqual <span class="keywd">is</span> TRUE;
          <span class="keywd">local</span>
            <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 1;
          <span class="keywd">begin</span>
            <span class="keywd">if</span> minIdx(arr1) = minIdx(arr2) <span class="op">and</span> maxIdx(arr1) = maxIdx(arr2) <span class="keywd">then</span>
              isNotEqual := FALSE;
              number := minIdx(arr1);
              <span class="keywd">while</span> number &lt;= maxIdx(arr1) <span class="op">and</span> <span class="op">not</span> isNotEqual <span class="keywd">do</span>
                isNotEqual := arr1[number] &lt;> arr2[number];
                incr(number);
              <span class="keywd">end</span> <span class="keywd">while</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="keywd">end</span> <span class="keywd">if</span>;

      <span class="keywd">if</span> getobj((<span class="op">in</span> <span class="type">baseType</span>: element1) &lt; (<span class="op">in</span> <span class="type">baseType</span>: element2)) &lt;> NIL <span class="op">and</span>
          getobj((<span class="op">in</span> <span class="type">baseType</span>: element1) > (<span class="op">in</span> <span class="type">baseType</span>: element2)) &lt;> NIL <span class="keywd">then</span>

        <span class="keywd">const</span> <span class="type">proc</span>: insert (<span class="keywd">inout</span> <span class="type">arrayType</span>: arr, <span class="op">in</span> <span class="type">baseType</span>: element) <span class="keywd">is</span> <span class="keywd">func</span>
          <span class="keywd">local</span>
            <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 1;
          <span class="keywd">begin</span>
            number := minIdx(arr);
            <span class="keywd">while</span> number &lt;= maxIdx(arr) <span class="op">and</span> arr[number] &lt; element <span class="keywd">do</span>
              incr(number);
            <span class="keywd">end</span> <span class="keywd">while</span>;
            <span class="keywd">if</span> number > maxIdx(arr) <span class="keywd">then</span>
              arr := arr &amp; [] (element);
            <span class="keywd">elsif</span> arr[number] > element <span class="keywd">then</span>
              arr := arr[.. pred(number)] &amp; [] (element) &amp; arr[number ..];
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">func</span>;

      <span class="keywd">end</span> <span class="keywd">if</span>;

      <span class="keywd">if</span> getobj(compare(<span class="op">in</span> <span class="type">baseType</span>: element1, <span class="op">in</span> <span class="type">baseType</span>: element2)) &lt;> NIL <span class="keywd">then</span>

        <span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: compare (<span class="op">in</span> <span class="type">arrayType</span>: arr1, <span class="op">in</span> <span class="type">arrayType</span>: arr2) <span class="keywd">is</span> <span class="keywd">func</span>
          <span class="keywd">result</span>
            <span class="keywd">var</span> <span class="type">integer</span>: signumValue <span class="keywd">is</span> 0;
          <span class="keywd">local</span>
            <span class="keywd">var</span> <span class="type">integer</span>: idx1 <span class="keywd">is</span> 0;
            <span class="keywd">var</span> <span class="type">integer</span>: idx2 <span class="keywd">is</span> 0;
          <span class="keywd">begin</span>
            idx1 := minIdx(arr1);
            idx2 := minIdx(arr2);
            <span class="keywd">while</span> idx1 &lt;= maxIdx(arr1) <span class="op">and</span> idx2 &lt;= maxIdx(arr2) <span class="op">and</span> compare(arr1[idx1], arr2[idx2]) = 0 <span class="keywd">do</span>
              incr(idx1);
              incr(idx2);
            <span class="keywd">end</span> <span class="keywd">while</span>;
            <span class="keywd">if</span> idx1 &lt;= maxIdx(arr1) <span class="op">and</span> idx2 &lt;= maxIdx(arr2) <span class="keywd">then</span>
              signumValue := compare(arr1[idx1], arr2[idx2]);
            <span class="keywd">else</span>
              signumValue := compare(length(arr1), length(arr2));
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">func</span>;

        <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">arrayType</span>: arr1) &lt; (<span class="op">in</span> <span class="type">arrayType</span>: arr2) <span class="keywd">is</span>
          <span class="keywd">return</span> compare(arr1, arr2) &lt; 0;

        <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">arrayType</span>: arr1) > (<span class="op">in</span> <span class="type">arrayType</span>: arr2) <span class="keywd">is</span>
          <span class="keywd">return</span> compare(arr1, arr2) > 0;

        <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">arrayType</span>: arr1) &lt;= (<span class="op">in</span> <span class="type">arrayType</span>: arr2) <span class="keywd">is</span>
          <span class="keywd">return</span> compare(arr1, arr2) &lt;= 0;

        <span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">arrayType</span>: arr1) >= (<span class="op">in</span> <span class="type">arrayType</span>: arr2) <span class="keywd">is</span>
          <span class="keywd">return</span> compare(arr1, arr2) >= 0;

        <span class="keywd">const</span> <span class="type">reference</span>: (attr arrayType) . dataCompare  <span class="keywd">is</span> getobj(compare(<span class="op">in</span> <span class="type">baseType</span>: element1, <span class="op">in</span> <span class="type">baseType</span>: element2));

        <span class="keywd">const</span> <span class="type">func</span> <span class="type">arrayType</span>: SORT (<span class="op">in</span> <span class="type">arrayType</span>: arr, <span class="op">in</span> <span class="type">reference</span>: dataCompare) <span class="keywd">is</span>   action <span class="stri">"ARR_SORT"</span>;

        <span class="keywd">const</span> <span class="type">func</span> <span class="type">arrayType</span>: sort (<span class="op">in</span> <span class="type">arrayType</span>: arr_obj) <span class="keywd">is</span>
          <span class="keywd">return</span> SORT(arr_obj, arrayType.dataCompare);

      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> global;

    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;

<span class="keywd">const</span> <span class="type">type</span>: TEST_1 <span class="keywd">is</span> <span class="type">array</span> <span class="type">integer</span>;
<span class="keywd">const</span> <span class="type">type</span>: TEST_2 <span class="keywd">is</span> <span class="type">array</span> <span class="type">integer</span>;
<span class="keywd">const</span> <span class="type">type</span>: TEST_3 <span class="keywd">is</span> <span class="type">array</span> <span class="type">string</span>;


<span class="keywd">const</span> <span class="type">proc</span>: ENABLE_SORT (<span class="op">in</span> <span class="type">type</span>: arrayType) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">const</span> <span class="type">reference</span>: (attr arrayType) . dataCompare  <span class="keywd">is</span> getobj(compare(<span class="op">in</span> base_type(arrayType): element1, <span class="op">in</span> base_type(arrayType): element2));

    <span class="keywd">const</span> <span class="type">func</span> <span class="type">arrayType</span>: SORT (<span class="op">in</span> <span class="type">arrayType</span>: arr, <span class="op">in</span> <span class="type">reference</span>: dataCompare) <span class="keywd">is</span>   action <span class="stri">"ARR_SORT"</span>;

    <span class="keywd">const</span> <span class="type">func</span> <span class="type">arrayType</span>: sort (<span class="op">in</span> <span class="type">arrayType</span>: arr_obj) <span class="keywd">is</span>
      <span class="keywd">return</span> SORT(arr_obj, arrayType.dataCompare);
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
