<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style2.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  bigint.s7i    Unlimited precision integer support library       *)</span>
<span class="comment">(*  Copyright (C) 2006  Thomas Mertes                               *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/enable_io.htm">enable_io.s7i</a>"</span>;


<span class="comment">(**
 *  Signed integer numbers of unlimited size.
 *  The literals of the type ''bigInteger'' are sequences of digits
 *  followed by an underscore character (for example 1_ ). Although
 *  ''bigInteger'' operations cannot overflow, it can happen that
 *  there is not enough memory to represent a ''bigInteger'' value.
 *  In this case the exception MEMORY_ERROR is raised.
 *)</span>
<span class="keywd">const</span> <span class="type">type</span>: bigInteger          <span class="keywd">is</span> subtype object;

$ <span class="keywd">system</span> <span class="stri">"bigInteger"</span> <span class="keywd">is</span> bigInteger;


<span class="keywd">const</span> <span class="type">proc</span>: destroy (<span class="keywd">ref</span> <span class="type">bigInteger</span>: aValue)                             <span class="keywd">is</span> action <span class="stri">"BIG_DESTR"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">ref</span> <span class="type">bigInteger</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">bigInteger</span>: source)          <span class="keywd">is</span> action <span class="stri">"BIG_CREATE"</span>;
IN_PARAM_IS_REFERENCE(bigInteger);


<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">bigInteger</span>: dest) := (<span class="op">in</span> <span class="type">bigInteger</span>: source)          <span class="keywd">is</span> action <span class="stri">"BIG_CPY"</span>;


<span class="comment">(**
 *  Default value of ''bigInteger'' (0_).
 *)</span>
<span class="keywd">const</span> <span class="type">bigInteger</span>: (attr bigInteger) . value                              <span class="keywd">is</span> 0_;


<span class="comment">(**
 *  Plus sign for ''bigInteger'' numbers.
 *  @return its operand unchanged.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: + (<span class="op">in</span> <span class="type">bigInteger</span>: number)                         <span class="keywd">is</span> action <span class="stri">"BIG_PLUS"</span>;


<span class="comment">(**
 *  Minus sign, negate a ''bigInteger'' number.
 *  @return the negated value of the number.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: - (<span class="op">in</span> <span class="type">bigInteger</span>: number)                         <span class="keywd">is</span> action <span class="stri">"BIG_NEGATE"</span>;


<span class="comment">(**
 *  Add two ''bigInteger'' numbers.
 *  @return the sum of the two numbers.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: (<span class="op">in</span> <span class="type">bigInteger</span>: summand1) + (<span class="op">in</span> <span class="type">bigInteger</span>: summand2)  <span class="keywd">is</span> action <span class="stri">"BIG_ADD"</span>;


<span class="comment">(**
 *  Compute the subtraction of two ''bigInteger'' numbers.
 *  @return the difference of the two numbers.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: (<span class="op">in</span> <span class="type">bigInteger</span>: minuend) - (<span class="op">in</span> <span class="type">bigInteger</span>: subtrahend) <span class="keywd">is</span> action <span class="stri">"BIG_SBTR"</span>;


<span class="comment">(**
 *  Multiply two ''bigInteger'' numbers.
 *  @return the product of the two numbers.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: (<span class="op">in</span> <span class="type">bigInteger</span>: factor1) * (<span class="op">in</span> <span class="type">bigInteger</span>: factor2)    <span class="keywd">is</span> action <span class="stri">"BIG_MULT"</span>;


<span class="comment">(**
 *  Integer division truncated towards zero.
 *  The remainder of this division is computed with ''rem''.
 *  For the operations ''div'' and ''rem'' holds for all A:
 *   (A div B) * B + A rem B = A           when B &lt;> 0_
 *   -A div B = -(A div B)                 when B &lt;> 0_
 *   -A rem B = -(A rem B)                 when B &lt;> 0_
 *   A rem B >= 0_ and A rem B &lt; abs(B)    when B &lt;> 0_ and A >= 0_
 *   A rem B &lt;= 0_ and A rem B > -abs(B)   when B &lt;> 0_ and A &lt;= 0_
 *  @return the quotient of the integer division.
 *  @exception NUMERIC_ERROR If a division by zero occurs.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: (<span class="op">in</span> <span class="type">bigInteger</span>: dividend) <span class="op">div</span> (<span class="op">in</span> <span class="type">bigInteger</span>: divisor)   <span class="keywd">is</span> action <span class="stri">"BIG_DIV"</span>;


<span class="comment">(**
 *  Compute the remainder of the integer division ''div''.
 *  The remainder has the same sign as the dividend.
 *   A rem B
 *  is equivalent to
 *   A - (A div B) * B
 *  @return the remainder of the integer division.
 *  @exception NUMERIC_ERROR If a division by zero occurs.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: (<span class="op">in</span> <span class="type">bigInteger</span>: dividend) <span class="op">rem</span> (<span class="op">in</span> <span class="type">bigInteger</span>: divisor)   <span class="keywd">is</span> action <span class="stri">"BIG_REM"</span>;


<span class="comment">(**
 *  Integer division truncated towards negative infinity.
 *  The modulo (remainder) of this division is computed with 'mod'.
 *  Therefore this division is called modulo division (''mdiv'').
 *  For the operations ''mdiv'' and ''mod'' holds for all A:
 *   (A mdiv B) * B + A mod B = A          when B &lt;> 0_
 *   -A mdiv B = A mdiv -B                 when B &lt;> 0_
 *   -A mod -B = -(A mod B)                when B &lt;> 0_
 *   A mod B >= 0_ and A mod B &lt; B         when B > 0_
 *   A mod B &lt;= 0_ and A mod B > B         when B &lt; 0_
 *  @return the quotient of the integer division.
 *  @exception NUMERIC_ERROR If a division by zero occurs.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: (<span class="op">in</span> <span class="type">bigInteger</span>: dividend) <span class="op">mdiv</span> (<span class="op">in</span> <span class="type">bigInteger</span>: divisor)  <span class="keywd">is</span> action <span class="stri">"BIG_MDIV"</span>;


<span class="comment">(**
 *  Compute the modulo (remainder) of the integer division ''mdiv''.
 *  The modulo has the same sign as the divisor.
 *   A mod B
 *  is equivalent to
 *   A - (A mdiv B) * B
 *  @return the modulo of the integer division.
 *  @exception NUMERIC_ERROR If a division by zero occurs.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: (<span class="op">in</span> <span class="type">bigInteger</span>: dividend) <span class="op">mod</span> (<span class="op">in</span> <span class="type">bigInteger</span>: divisor)   <span class="keywd">is</span> action <span class="stri">"BIG_MOD"</span>;


<span class="comment">(**
 *  Compute the exponentiation of a ''bigInteger'' base with an [[integer]] exponent.
 *   A ** 0  returns 1_          for every A, even for A = 0_
 *   1 ** B  returns 1_          for B >= 0
 *   A ** B  returns -(-A) ** B  for A &lt;= 0_ and B >= 0 and odd(B)
 *   A ** B  returns (-A) ** B   for A &lt;= 0_ and B >= 0 and not odd(B)
 *  @return the result of the exponentiation.
 *  @exception NUMERIC_ERROR If the exponent is negative.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: (<span class="op">in</span> <span class="type">bigInteger</span>: base) ** (<span class="op">in</span> <span class="type">integer</span>: exponent)   <span class="keywd">is</span> action <span class="stri">"BIG_IPOW"</span>;


<span class="comment"># const func bigInteger: (in bigInteger: base) ** (in bigInteger: exponent) is action "BIG_POW";</span>


<span class="comment">(**
 *  Shift a ''bigInteger'' number left by lshift bits.
 *  If lshift is negative a right shift is done instead.
 *  A &lt;&lt; B is equivalent to A * 2_ ** B when B >= 0 holds.
 *  A &lt;&lt; B is equivalent to A mdiv 2_ ** -B when B &lt; 0 holds.
 *  @return the left shifted number.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: (<span class="op">in</span> <span class="type">bigInteger</span>: number) &lt;&lt; (<span class="op">in</span> <span class="type">integer</span>: lshift)   <span class="keywd">is</span> action <span class="stri">"BIG_LSHIFT"</span>;


<span class="comment">(**
 *  Shift a ''bigInteger'' number right by rshift bits.
 *  If rshift is negative a left shift is done instead.
 *  A >> B is equivalent to A mdiv 2_ ** B when B >= 0 holds.
 *  A >> B is equivalent to A * 2_ ** -B when B &lt; 0 holds.
 *  @return the right shifted number.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: (<span class="op">in</span> <span class="type">bigInteger</span>: number) >> (<span class="op">in</span> <span class="type">integer</span>: rshift)   <span class="keywd">is</span> action <span class="stri">"BIG_RSHIFT"</span>;


<span class="comment">(**
 *  Increment a ''bigInteger'' variable by a delta.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">bigInteger</span>: number) +:= (<span class="op">in</span> <span class="type">bigInteger</span>: delta)        <span class="keywd">is</span> action <span class="stri">"BIG_ADD_ASSIGN"</span>;


<span class="comment">(**
 *  Decrement a ''bigInteger'' variable by a delta.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">bigInteger</span>: number) -:= (<span class="op">in</span> <span class="type">bigInteger</span>: delta)        <span class="keywd">is</span> action <span class="stri">"BIG_SBTR_ASSIGN"</span>;


<span class="comment">(**
 *  Multiply a ''bigInteger'' number by a factor and assign the result back to number.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">bigInteger</span>: number) *:= (<span class="op">in</span> <span class="type">bigInteger</span>: factor)       <span class="keywd">is</span> action <span class="stri">"BIG_MULT_ASSIGN"</span>;


<span class="comment">(**
 *  Shift a number left by lshift bits and assign the result back to number.
 *  If lshift is negative a right shift is done instead.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">bigInteger</span>: number) &lt;&lt;:= (<span class="op">in</span> <span class="type">integer</span>: lshift)         <span class="keywd">is</span> action <span class="stri">"BIG_LSHIFT_ASSIGN"</span>;


<span class="comment">(**
 *  Shift a number right by rshift bits and assign the result back to number.
 *  If rshift is negative a left shift is done instead.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">bigInteger</span>: number) >>:= (<span class="op">in</span> <span class="type">integer</span>: rshift)         <span class="keywd">is</span> action <span class="stri">"BIG_RSHIFT_ASSIGN"</span>;


<span class="comment">(**
 *  Check if two ''bigInteger'' numbers are equal.
 *  @return TRUE if both numbers are equal,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">bigInteger</span>: number1) = (<span class="op">in</span> <span class="type">bigInteger</span>: number2)  <span class="keywd">is</span> action <span class="stri">"BIG_EQ"</span>;


<span class="comment">(**
 *  Check if two ''bigInteger'' numbers are not equal.
 *  @return FALSE if both numbers are equal,
 *          TRUE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">bigInteger</span>: number1) &lt;> (<span class="op">in</span> <span class="type">bigInteger</span>: number2) <span class="keywd">is</span> action <span class="stri">"BIG_NE"</span>;


<span class="comment">(**
 *  Check if number1 is less than number2.
 *  @return TRUE if number1 is less than number2,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">bigInteger</span>: number1) &lt; (<span class="op">in</span> <span class="type">bigInteger</span>: number2)  <span class="keywd">is</span> action <span class="stri">"BIG_LT"</span>;


<span class="comment">(**
 *  Check if number1 is greater than number2.
 *  @return TRUE if number1 is greater than number2,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">bigInteger</span>: number1) > (<span class="op">in</span> <span class="type">bigInteger</span>: number2)  <span class="keywd">is</span> action <span class="stri">"BIG_GT"</span>;


<span class="comment">(**
 *  Check if number1 is less than or equal to number2.
 *  @return TRUE if number1 is less than or equal to number2,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">bigInteger</span>: number1) &lt;= (<span class="op">in</span> <span class="type">bigInteger</span>: number2) <span class="keywd">is</span> action <span class="stri">"BIG_LE"</span>;


<span class="comment">(**
 *  Check if number1 is greater than or equal to number2.
 *  @return TRUE if number1 is greater than or equal to number2,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">bigInteger</span>: number1) >= (<span class="op">in</span> <span class="type">bigInteger</span>: number2) <span class="keywd">is</span> action <span class="stri">"BIG_GE"</span>;


<span class="comment">(**
 *  Compare two ''bigInteger'' numbers.
 *  @return -1, 0 or 1 if the first argument is considered to be
 *          respectively less than, equal to, or greater than the
 *          second.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: compare (<span class="op">in</span> <span class="type">bigInteger</span>: number1, <span class="op">in</span> <span class="type">bigInteger</span>:number2) <span class="keywd">is</span> action <span class="stri">"BIG_CMP"</span>;


<span class="comment">(**
 *  Compute the hash value of a ''bigInteger'' number.
 *  @return the hash value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: hashCode (<span class="op">in</span> <span class="type">bigInteger</span>: number)                     <span class="keywd">is</span> action <span class="stri">"BIG_HASHCODE"</span>;


<span class="keywd">const</span> <span class="type">type</span>: quotRem <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">bigInteger</span>: quotient <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <span class="type">bigInteger</span>: remainder <span class="keywd">is</span> 0_;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">quotRem</span>: quotRem (<span class="op">in</span> <span class="type">bigInteger</span>: quotient, <span class="op">in</span> <span class="type">bigInteger</span>: remainder) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">quotRem</span>: quotRemValue <span class="keywd">is</span> quotRem.value;
  <span class="keywd">begin</span>
    quotRemValue.quotient := quotient;
    quotRemValue.remainder := remainder;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">quotRem</span>: quotRem1) = (<span class="op">in</span> <span class="type">quotRem</span>: quotRem2)  <span class="keywd">is</span>
    <span class="keywd">return</span> quotRem1.quotient = quotRem2.quotient <span class="op">and</span>
           quotRem1.remainder = quotRem2.remainder;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">quotRem</span>: quotRem1) &lt;> (<span class="op">in</span> <span class="type">quotRem</span>: quotRem2)  <span class="keywd">is</span>
    <span class="keywd">return</span> quotRem1.quotient &lt;> quotRem2.quotient <span class="op">or</span>
           quotRem1.remainder &lt;> quotRem2.remainder;


<span class="comment">(**
 *  Quotient and remainder of integer division truncated towards zero.
 *  Compute quotient and remainder of the integer division ''div''.
 *  @return quotRem with quotient and remainder of the integer division.
 *  @exception NUMERIC_ERROR If a division by zero occurs.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">quotRem</span>: (<span class="op">in</span> <span class="type">bigInteger</span>: dividend) divRem (<span class="op">in</span> <span class="type">bigInteger</span>: divisor) <span class="keywd">is</span> action <span class="stri">"BIG_DIV_REM"</span>;


<span class="comment">(**
 *  Successor of a ''bigInteger'' number.
 *  succ(A) is equivalent to A+1 .
 *  @return number + 1 .
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: succ (<span class="op">in</span> <span class="type">bigInteger</span>: number)                      <span class="keywd">is</span> action <span class="stri">"BIG_SUCC"</span>;


<span class="comment">(**
 *  Predecessor of a ''bigInteger'' number.
 *  pred(A) is equivalent to A-1 .
 *  @return number - 1 .
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: pred (<span class="op">in</span> <span class="type">bigInteger</span>: number)                      <span class="keywd">is</span> action <span class="stri">"BIG_PRED"</span>;


<span class="comment">(**
 *  Compute the absolute value of a ''bigInteger'' number.
 *  @return the absolute value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: abs (<span class="op">in</span> <span class="type">bigInteger</span>: number)                       <span class="keywd">is</span> action <span class="stri">"BIG_ABS"</span>;


<span class="comment">(**
 *  Compute the truncated base 10 logarithm of a ''bigInteger'' number.
 *  The definition of ''log10'' is extended by defining log10(0_) = -1_.
 *   log10(10_ ** A)        returns A       for A >= 0
 *   log10(pred(10_ ** A))  returns pred(A) for A >= 0
 *   log10(10_)             returns 1
 *   log10(1_)              returns 0
 *   log10(0_)              returns -1
 *  @return the truncated base 10 logarithm.
 *  @exception NUMERIC_ERROR The number is negative.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: log10 (<span class="op">in</span> <span class="type">bigInteger</span>: number)                     <span class="keywd">is</span> action <span class="stri">"BIG_LOG10"</span>;


<span class="comment">(**
 *  Compute the truncated base 2 logarithm of a ''bigInteger'' number.
 *  The definition of ''log2'' is extended by defining log2(0_) = -1_.
 *   log2(2_ ** A)        returns A       for A >= 0
 *   log2(pred(2_ ** A))  returns pred(A) for A >= 0
 *   log2(2_)             returns 1
 *   log2(1_)             returns 0
 *   log2(0_)             returns -1
 *  @return the truncated base 2 logarithm.
 *  @exception NUMERIC_ERROR The number is negative.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: log2 (<span class="op">in</span> <span class="type">bigInteger</span>: number)                      <span class="keywd">is</span> action <span class="stri">"BIG_LOG2"</span>;


<span class="comment">(**
 *  Determine if a ''bigInteger'' number is odd.
 *  @return TRUE if the number is odd,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: odd (<span class="op">in</span> <span class="type">bigInteger</span>: number)                          <span class="keywd">is</span> action <span class="stri">"BIG_ODD"</span>;


<span class="comment">(**
 *  Convert a ''bigInteger'' number to [[integer]].
 *  @return the [[integer]] result of the conversion.
 *  @exception RANGE_ERROR The result does not fit into an [[integer]].
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: ord (<span class="op">in</span> <span class="type">bigInteger</span>: number)                          <span class="keywd">is</span> action <span class="stri">"BIG_ORD"</span>;


<span class="comment">(**
 *  Convert a ''bigInteger'' number to [[integer]].
 *  @return the [[integer]] result of the conversion.
 *  @exception RANGE_ERROR The result does not fit into an [[integer]].
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: integer (<span class="op">in</span> <span class="type">bigInteger</span>: number)                      <span class="keywd">is</span> action <span class="stri">"BIG_ORD"</span>;


<span class="comment">(**
 *  Compute the greatest common divisor of two ''bigInteger'' numbers.
 *  @return the greatest common divisor of the two numbers.
 *          The greatest common divisor is positive or zero.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: gcd (<span class="op">in</span> <span class="type">bigInteger</span>: number1, <span class="op">in</span> <span class="type">bigInteger</span>: number2)  <span class="keywd">is</span> action <span class="stri">"BIG_GCD"</span>;


<span class="comment">(**
 *  Convert an [[integer]] number to ''bigInteger''.
 *  @return the bigInteger result of the conversion.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: bigInteger (<span class="op">in</span> <span class="type">integer</span>: number)                   <span class="keywd">is</span> action <span class="stri">"BIG_ICONV1"</span>;


<span class="comment">(**
 *  Convert an [[integer]] number to ''bigInteger''.
 *  @return the bigInteger result of the conversion.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: (attr bigInteger) <span class="op">conv</span> (<span class="op">in</span> <span class="type">integer</span>: number)       <span class="keywd">is</span> action <span class="stri">"BIG_ICONV3"</span>;


<span class="comment">(**
 *  Convert a ''bigInteger'' number to a [[string]].
 *  The number is converted to a string with decimal representation.
 *  For negative numbers a minus sign is prepended.
 *  @return the string result of the conversion.
 *  @exception MEMORY_ERROR  Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">bigInteger</span>: number)                           <span class="keywd">is</span> action <span class="stri">"BIG_STR"</span>;


<span class="comment">(**
 *  Convert a ''bigInteger'' number to a ''bigInteger'' literal.
 *  @return the ''bigInteger'' literal.
 *  @exception MEMORY_ERROR  Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: literal (<span class="op">in</span> <span class="type">bigInteger</span>: number) <span class="keywd">is</span>
    <span class="keywd">return</span> str(number) &amp; <span class="stri">"_"</span>;


<span class="comment">(**
 *  Convert a ''bigInteger'' number to a [[string]] using a radix.
 *  The conversion uses the numeral system with the given ''base''.
 *  Digit values from 10 upward are encoded with lower case letters.
 *  E.g.: 10 is encoded with a, 11 with b, etc.
 *  For negative numbers a minus sign is prepended.
 *   3735928559_ radix 16 => "deadbeef"
 *   -3735928559_ radix 16 => "-deadbeef"
 *  @return the string result of the conversion.
 *  @exception RANGE_ERROR If base &lt; 2 or base > 36 holds.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="keywd">var</span> <span class="type">bigInteger</span>: number) radix (<span class="op">in</span> <span class="type">integer</span>: base)  <span class="keywd">is</span> action <span class="stri">"BIG_radix"</span>;


<span class="comment">(**
 *  Convert a ''bigInteger'' number to a [[string]] using a radix.
 *  The conversion uses the numeral system with the given ''base''.
 *  Digit values from 10 upward are encoded with upper case letters.
 *  E.g.: 10 is encoded with A, 11 with B, etc.
 *  For negative numbers a minus sign is prepended.
 *   3735928559_ RADIX 16 => "DEADBEEF"
 *   -3735928559_ RADIX 16 => "-DEADBEEF"
 *  @return the string result of the conversion.
 *  @exception RANGE_ERROR If base &lt; 2 or base > 36 holds.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="keywd">var</span> <span class="type">bigInteger</span>: number) RADIX (<span class="op">in</span> <span class="type">integer</span>: base)  <span class="keywd">is</span> action <span class="stri">"BIG_RADIX"</span>;


<span class="comment">(**
 *  Convert a [[string]] to a ''bigInteger'' number.
 *  The [[string]] must contain an integer literal consisting of an
 *  optional + or - sign, followed by a sequence of digits. Other
 *  characters as well as leading or trailing whitespace characters
 *  are not allowed. The sequence of digits is taken to be decimal.
 *  @return the ''bigInteger'' result of the conversion.
 *  @exception RANGE_ERROR If the string is empty or it does not contain
 *             an integer literal.
 *  @exception MEMORY_ERROR  Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: bigInteger (<span class="op">in</span> <span class="type">string</span>: stri)                      <span class="keywd">is</span> action <span class="stri">"BIG_PARSE1"</span>;


<span class="comment">(**
 *  Convert a [[string]] to a ''bigInteger'' number.
 *  The [[string]] must contain an integer literal consisting of an
 *  optional + or - sign, followed by a sequence of digits. Other
 *  characters as well as leading or trailing whitespace characters
 *  are not allowed. The sequence of digits is taken to be decimal.
 *  @return the ''bigInteger'' result of the conversion.
 *  @exception RANGE_ERROR If the string is empty or it does not contain
 *             an integer literal.
 *  @exception MEMORY_ERROR  Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: (attr bigInteger) <span class="op">parse</span> (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span>
    <span class="keywd">return</span> bigInteger(stri);


<span class="comment">(**
 *  Convert a numeric [[string]], with a specified radix, to a ''bigInteger''.
 *  The numeric [[string]] must contain the representation of an integer
 *  in the specified radix. It consists of an optional + or - sign,
 *  followed by a sequence of digits in the specified radix. Digit values
 *  from 10 upward can be encoded with upper or lower case letters.
 *  E.g.: 10 can be encoded with A or a, 11 with B or b, etc. Other
 *  characters as well as leading or trailing whitespace characters
 *  are not allowed.
 *   bigInteger("deadbeef", 16)     returns  3735928559_
 *   bigInteger("-77777777777", 8)  returns -8589934591_
 *   bigInteger("10101010", 2)      returns         170_
 *   bigInteger("Cafe", 16)         returns       51966_
 *  @param base Radix of the integer in the ''stri'' parameter.
 *  @return the ''bigInteger'' result of the conversion.
 *  @exception RANGE_ERROR If base &lt; 2 or base > 36 holds or
 *             the string is empty or it does not contain an integer
 *             literal with the specified base.
 *  @exception MEMORY_ERROR  Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: bigInteger (<span class="op">in</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="type">integer</span>: base)    <span class="keywd">is</span> action <span class="stri">"BIG_PARSE_BASED"</span>;


<span class="comment">(**
 *  Compute pseudo-random number in the range [low, high].
 *  The random values are uniform distributed.
 *  @return a random number such that low &lt;= rand(low, high) and
 *          rand(low, high) &lt;= high holds.
 *  @exception RANGE_ERROR The range is empty (low > high holds).
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: rand (<span class="op">in</span> <span class="type">bigInteger</span>: low, <span class="op">in</span> <span class="type">bigInteger</span>: high)    <span class="keywd">is</span> action <span class="stri">"BIG_RAND"</span>;


<span class="comment">(**
 *  Number of bits in the minimum two's-complement representation.
 *  The high bits equivalent to the sign bit are not part of the
 *  minimum two's-complement representation.
 *  @return the number of bits.
 *  @exception RANGE_ERROR The result does not fit into an integer.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: bitLength (<span class="op">in</span> <span class="type">bigInteger</span>: number)                    <span class="keywd">is</span> action <span class="stri">"BIG_BIT_LENGTH"</span>;


<span class="comment">(**
 *  Index of the lowest-order one bit.
 *  For A &lt;> 0 this is equal to the number of lowest-order zero bits.
 *  @return the number of lowest-order zero bits or -1 for lowestSetBit(0).
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: lowestSetBit (<span class="op">in</span> <span class="type">bigInteger</span>: number)                 <span class="keywd">is</span> action <span class="stri">"BIG_LOWEST_SET_BIT"</span>;


<span class="comment">(**
 *  Increment a ''bigInteger'' variable.
 *  Increments ''number'' by 1.
 *  This is equivalent to:
 *   number := succ(number);
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: incr (<span class="keywd">inout</span> <span class="type">bigInteger</span>: number)                              <span class="keywd">is</span> action <span class="stri">"BIG_INCR"</span>;


<span class="comment">(**
 *  Decrement a ''bigInteger'' variable.
 *  Decrements ''number'' by 1.
 *  This is equivalent to:
 *   number := pred(number);
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: decr (<span class="keywd">inout</span> <span class="type">bigInteger</span>: number)                              <span class="keywd">is</span> action <span class="stri">"BIG_DECR"</span>;


<span class="keywd">const</span> <span class="type">boolean</span>: ord (<span class="op">in</span> <span class="type">bigInteger</span>: number, mayRaiseRangeError)           <span class="keywd">is</span> TRUE;

enable_io(bigInteger);
FOR_DECLS(bigInteger);
CASE_DECLS(bigInteger);


<span class="comment">(**
 *  Convert a ''bigInteger'' number to a [[string]] in scientific notation.
 *  Scientific notation uses a decimal significand and a decimal exponent.
 *  The significand has an optional sign and exactly one digit before the
 *  decimal point. The fractional part of the significand is rounded
 *  to the specified number of digits (''precision''). Halfway cases are
 *  rounded away from zero. The fractional part is followed by the
 *  letter e and an exponent, which is always signed. The value zero is
 *  never written with a negative sign.
 *   12345_ sci 4     returns "1.2345e+4"
 *   12345_ sci 3     returns "1.235e+4"
 *   12345_ sci 2     returns "1.23e+4"
 *   3141592_ sci 0   returns "3e+6"
 *   27182818_ sci 0  returns "3e+7"
 *   2_**64 sci 6     returns "1.844674e+19"
 *   -1_ sci 3        returns "-1.000e+0"
 *   -0_ sci 2        returns "0.00e+0"
 *  @param precision Number of digits after the decimal point.
 *         If the ''precision'' is zero the decimal point is omitted.
 *  @return the string result of the conversion.
 *  @exception RANGE_ERROR If the ''precision'' is negative.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">bigInteger</span>: number) <span class="op">sci</span> (<span class="op">in</span> <span class="type">integer</span>: precision) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: exponent <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">bigInteger</span>: mantissa <span class="keywd">is</span> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> precision &lt; 0 <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> number = 0_ <span class="keywd">then</span>
      <span class="keywd">if</span> precision = 0 <span class="keywd">then</span>
        stri := <span class="stri">"0e+0"</span>;
      <span class="keywd">else</span>
        stri := <span class="stri">"0."</span> &amp; <span class="stri">"0"</span> <span class="op">mult</span> precision &amp; <span class="stri">"e+0"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      exponent := ord(log10(abs(number)));
      <span class="keywd">if</span> precision >= exponent <span class="keywd">then</span>
        stri := str(abs(number));
        stri &amp;:= <span class="stri">"0"</span> <span class="op">mult</span> (precision - exponent);
      <span class="keywd">else</span>
        mantissa := (abs(number) <span class="op">div</span> 10_ ** pred(exponent - precision) + 5_) <span class="op">div</span> 10_;
        stri := str(mantissa);
        <span class="keywd">if</span> length(stri) > succ(precision) <span class="keywd">then</span>
          <span class="comment"># Rounding up increased the number of digits.</span>
          incr(exponent);
          stri := stri[.. succ(precision)];
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> precision &lt;> 0 <span class="keywd">then</span>
        stri := stri[1 fixLen 1] &amp; <span class="stri">"."</span> &amp; stri[2 .. ];
      <span class="keywd">end</span> <span class="keywd">if</span>;
      stri &amp;:= <span class="stri">"e+"</span> &lt;&amp; exponent;
      <span class="keywd">if</span> number &lt; 0_ <span class="keywd">then</span>
        stri := <span class="stri">"-"</span> &amp; stri;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Compute the factorial of a ''bigInteger'' number.
 *  @return the factorial of the number.
 *  @exception NUMERIC_ERROR The number is negative.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: ! (<span class="op">in</span> <span class="type">bigInteger</span>: number) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">bigInteger</span>: factorial <span class="keywd">is</span> 1_;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">bigInteger</span>: num <span class="keywd">is</span> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> number &lt; 0_ <span class="keywd">then</span>
      raise NUMERIC_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">for</span> num <span class="keywd">range</span> 2_ <span class="keywd">to</span> number <span class="keywd">do</span>
        factorial *:= num;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Compute the binomial coefficient
 *   n ! k  returns  0                            for k &lt; 0,
 *   n ! 0_ returns  1_,
 *   n ! 1_ returns  n,
 *   n ! k  returns  0                            for n >= 0 and k > n,
 *   n ! k  returns  !n div (!k * !(n - k))       for k >= 0 and k &lt;= n,
 *   n ! k  returns  (-1) ** k * (n + k - 1 ! k)  for n &lt; 0 and k >= 0
 *  @return n over k
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: (<span class="op">in</span> <span class="type">bigInteger</span>: n) ! (<span class="op">in</span> <span class="keywd">var</span> <span class="type">bigInteger</span>: k) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">bigInteger</span>: binom <span class="keywd">is</span> 0_;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">bigInteger</span>: numerator <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <span class="type">bigInteger</span>: denominator <span class="keywd">is</span> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> n >= 0_ <span class="op">and</span> k > n >> 1 <span class="keywd">then</span>
      k := n - k;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> k &lt; 0_ <span class="keywd">then</span>
      binom := 0_;
    <span class="keywd">elsif</span> k = 0_ <span class="keywd">then</span>
      binom := 1_;
    <span class="keywd">else</span>
      binom := n;
      numerator := pred(n);
      denominator := 2_;
      <span class="keywd">while</span> denominator &lt;= k <span class="keywd">do</span>
        binom *:= numerator;
        binom := binom <span class="op">div</span> denominator;
        decr(numerator);
        incr(denominator);
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Compute the integer square root of a ''bigInteger'' number.
 *  @return the integer square root.
 *  @exception NUMERIC_ERROR If number is negative.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: sqrt (<span class="op">in</span> <span class="keywd">var</span> <span class="type">bigInteger</span>: number) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">bigInteger</span>: root <span class="keywd">is</span> 0_;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">bigInteger</span>: nextIteration <span class="keywd">is</span> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> number > 0_ <span class="keywd">then</span>
      nextIteration := number;
      <span class="keywd">repeat</span>
        root := nextIteration;
        nextIteration := (root + number <span class="op">div</span> root) <span class="op">mdiv</span> 2_;
      <span class="keywd">until</span> root &lt;= nextIteration;
    <span class="keywd">elsif</span> number &lt;> 0_ <span class="keywd">then</span>
      raise NUMERIC_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Compute the modular multiplicative inverse of a modulo b.
 *  @return the modular multiplicative inverse when a and b are
 *          coprime (gcd(a, b) = 1).
 *  @exception RANGE_ERROR If a and b are not coprime (gcd(a, b) &lt;> 1).
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: modInverse (<span class="op">in</span> <span class="keywd">var</span> <span class="type">bigInteger</span>: a,
    <span class="op">in</span> <span class="keywd">var</span> <span class="type">bigInteger</span>: b) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">bigInteger</span>: modularInverse <span class="keywd">is</span> 0_;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">bigInteger</span>: b_bak <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <span class="type">bigInteger</span>: x <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <span class="type">bigInteger</span>: y <span class="keywd">is</span> 1_;
    <span class="keywd">var</span> <span class="type">bigInteger</span>: lastx <span class="keywd">is</span> 1_;
    <span class="keywd">var</span> <span class="type">bigInteger</span>: lasty <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <span class="type">bigInteger</span>: temp <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <span class="type">bigInteger</span>: quotient <span class="keywd">is</span> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> b &lt; 0_ <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> a &lt; 0_ <span class="op">and</span> b &lt;> 0_ <span class="keywd">then</span>
      a := a <span class="op">mod</span> b;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    b_bak := b;
    <span class="keywd">while</span> b &lt;> 0_ <span class="keywd">do</span>
      temp := b;
      quotient := a <span class="op">div</span> b;
      b := a <span class="op">rem</span> b;
      a := temp;

      temp := x;
      x := lastx - quotient * x;
      lastx := temp;

      temp := y;
      y := lasty - quotient * y;
      lasty := temp;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> a = 1_ <span class="keywd">then</span>
      modularInverse := lastx;
      <span class="keywd">if</span> modularInverse &lt; 0_ <span class="keywd">then</span>
        modularInverse +:= b_bak;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Compute the modular exponentiation of base ** exponent.
 *  @return base ** exponent mod modulus
 *  @exception RANGE_ERROR If exponent or modulus are negative.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: modPow (<span class="op">in</span> <span class="keywd">var</span> <span class="type">bigInteger</span>: base,
    <span class="op">in</span> <span class="keywd">var</span> <span class="type">bigInteger</span>: exponent, <span class="op">in</span> <span class="type">bigInteger</span>: modulus) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">bigInteger</span>: power <span class="keywd">is</span> 1_;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> exponent &lt; 0_ <span class="op">or</span> modulus &lt; 0_ <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">while</span> exponent > 0_ <span class="keywd">do</span>
        <span class="keywd">if</span> odd(exponent) <span class="keywd">then</span>
          power := (power * base) <span class="op">mod</span> modulus;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        exponent >>:= 1;
        base := base ** 2 <span class="op">mod</span> modulus;
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the minimum of two ''bigInteger'' numbers.
 *  @return the minimum of the two numbers.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: min (<span class="op">in</span> <span class="type">bigInteger</span>: value1, <span class="op">in</span> <span class="type">bigInteger</span>: value2) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">bigInteger</span>: minimum <span class="keywd">is</span> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> value1 &lt; value2 <span class="keywd">then</span>
      minimum := value1;
    <span class="keywd">else</span>
      minimum := value2;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the maximum of two ''bigInteger'' numbers.
 *  @return the maximum of the two numbers.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: max (<span class="op">in</span> <span class="type">bigInteger</span>: value1, <span class="op">in</span> <span class="type">bigInteger</span>: value2) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">bigInteger</span>: maximum <span class="keywd">is</span> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> value1 > value2 <span class="keywd">then</span>
      maximum := value1;
    <span class="keywd">else</span>
      maximum := value2;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment"># Allows 'array bigInteger' everywhere without extra type definition.</span>
<span class="keywd">const</span> <span class="type">type</span>: _bigIntegerArray <span class="keywd">is</span> <span class="type">array</span> <span class="type">bigInteger</span>;


DECLARE_TERNARY(bigInteger);
</pre>
</body>
</html>
