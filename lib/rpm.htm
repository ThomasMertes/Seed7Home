<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style1.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  rpm.s7i       Rpm archive library                               *)</span>
<span class="comment">(*  Copyright (C) 2020 - 2023  Thomas Mertes                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/stdio.htm">stdio.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/time.htm">time.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/filesys.htm">filesys.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/filebits.htm">filebits.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bytedata.htm">bytedata.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/msgdigest.htm">msgdigest.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/strifile.htm">strifile.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/gzip.htm">gzip.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/lzma.htm">lzma.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/xz.htm">xz.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/zstd.htm">zstd.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/cpio.htm">cpio.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/archive_base.htm">archive_base.s7i</a>"</span>;


<span class="keywd">const</span> <span class="type">string</span>: RPM_LEAD_MAGIC <span class="keywd">is</span> <span class="stri">"\16#ed;\16#ab;\16#ee;\16#db;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: RPM_HEADER_MAGIC <span class="keywd">is</span> <span class="stri">"\16#8e;\16#ad;\16#e8;"</span>;

<span class="keywd">const</span> <span class="type">integer</span>: RPM_LEAD_SIZE <span class="keywd">is</span> 96;
<span class="keywd">const</span> <span class="type">integer</span>: RPM_HEADER_SIZE <span class="keywd">is</span> 16;
<span class="keywd">const</span> <span class="type">integer</span>: RPM_INDEX_ENTRY_SIZE <span class="keywd">is</span> 16;


<span class="keywd">const</span> <span class="type">type</span>: rpmLead <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">string</span>: magic <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: majorVersion <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: minorVersion <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: fileType <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: arch <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: os <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: sig <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: rpmHeader <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">string</span>: magic <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: version <span class="keywd">is</span> 0;
    <span class="comment"># 4 reserved bytes are currently unused.</span>
    <span class="keywd">var</span> <span class="type">string</span>: reservedBytes <span class="keywd">is</span> <span class="stri">"\0;"</span> <span class="op">mult</span> 4;
    <span class="keywd">var</span> <span class="type">integer</span>: indexCount <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: storeSize <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: rpmIndexEntry <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: tag <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: dataType <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: offset <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: count <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: striValue <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: arrayValue <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: rpmTagMap <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">integer</span><span class="type">]</span> <span class="type">rpmIndexEntry</span>;

<span class="keywd">const</span> <span class="type">integer</span>: RPM_NULL_TYPE         <span class="keywd">is</span> 0;  <span class="comment"># No size</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPM_CHAR_TYPE         <span class="keywd">is</span> 1;  <span class="comment"># Size 1</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPM_INT8_TYPE         <span class="keywd">is</span> 2;  <span class="comment"># Size 1</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPM_INT16_TYPE        <span class="keywd">is</span> 3;  <span class="comment"># Size 2</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPM_INT32_TYPE        <span class="keywd">is</span> 4;  <span class="comment"># Size 4</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPM_INT64_TYPE        <span class="keywd">is</span> 5;  <span class="comment"># Size 8</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPM_STRING_TYPE       <span class="keywd">is</span> 6;  <span class="comment"># Variable number of bytes, terminated by a NULL</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPM_BIN_TYPE          <span class="keywd">is</span> 7;  <span class="comment"># Size 1</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPM_STRING_ARRAY_TYPE <span class="keywd">is</span> 8;  <span class="comment"># Variable, vector of NULL-terminated strings</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPM_I18NSTRING_TYPE   <span class="keywd">is</span> 9;  <span class="comment"># Variable, vector of NULL-terminated strings</span>

<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_HEADERIMMUTABLE    <span class="keywd">is</span>   63;  <span class="comment"># BIN          Optional</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_HEADERI18NTABLE    <span class="keywd">is</span>  100;  <span class="comment"># STRING_ARRAY Required  Contains a list of locales for which strings are provided</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_NAME               <span class="keywd">is</span> 1000;  <span class="comment"># STRING       Required  Name of package</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_VERSION            <span class="keywd">is</span> 1001;  <span class="comment"># STRING       Required  Version of package</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_RELEASE            <span class="keywd">is</span> 1002;  <span class="comment"># STRING       Required  Release of package</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_EPOCH              <span class="keywd">is</span> 1003;  <span class="comment">#                        Epoch of package</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_SUMMARY            <span class="keywd">is</span> 1004;  <span class="comment"># I18NSTRING   Required  Summary description of the package</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_DESCRIPTION        <span class="keywd">is</span> 1005;  <span class="comment"># I18NSTRING   Required  Full description of the package</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BUILDTIME          <span class="keywd">is</span> 1006;  <span class="comment"># INT32        Optional  Seconds since epoch when pkg built</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BUILDHOST          <span class="keywd">is</span> 1007;  <span class="comment"># STRING       Optional  Host package was built on</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_INSTALLTIME        <span class="keywd">is</span> 1008;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_SIZE               <span class="keywd">is</span> 1009;  <span class="comment"># INT32        Required  Sum of sizes of regular files in archive</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_DISTRIBUTION       <span class="keywd">is</span> 1010;  <span class="comment"># STRING</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_VENDOR             <span class="keywd">is</span> 1011;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_GIF                <span class="keywd">is</span> 1012;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_XPM                <span class="keywd">is</span> 1013;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_LICENSE            <span class="keywd">is</span> 1014;  <span class="comment"># STRING       Required  Package license</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PACKAGER           <span class="keywd">is</span> 1015;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_GROUP              <span class="keywd">is</span> 1016;  <span class="comment"># I18NSTRING   Required  Package group</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_CHANGELOG          <span class="keywd">is</span> 1017;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_SOURCE             <span class="keywd">is</span> 1018;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PATCH              <span class="keywd">is</span> 1019;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_URL                <span class="keywd">is</span> 1020;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_OS                 <span class="keywd">is</span> 1021;  <span class="comment"># STRING       Required</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_ARCH               <span class="keywd">is</span> 1022;  <span class="comment"># STRING       Required  Architecture of package</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PREIN              <span class="keywd">is</span> 1023;  <span class="comment"># STRING</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_POSTIN             <span class="keywd">is</span> 1024;  <span class="comment"># STRING</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PREUN              <span class="keywd">is</span> 1025;  <span class="comment"># STRING</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_POSTUN             <span class="keywd">is</span> 1026;  <span class="comment"># STRING</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_OLDFILENAMES       <span class="keywd">is</span> 1027;  <span class="comment"># STRING_ARRAY Optional  Filenames when not in "compressed format"</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILESIZES          <span class="keywd">is</span> 1028;  <span class="comment"># INT32      Size of each file [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILESTATES         <span class="keywd">is</span> 1029;  <span class="comment"># CHAR       (only after installed)</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILEMODES          <span class="keywd">is</span> 1030;  <span class="comment"># INT16      Mode of each file [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILEUIDS           <span class="keywd">is</span> 1031;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILEGIDS           <span class="keywd">is</span> 1032;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILERDEVS          <span class="keywd">is</span> 1033;  <span class="comment"># INT16      Device number from which the file was copied [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILEMTIMES         <span class="keywd">is</span> 1034;  <span class="comment"># INT32      Modification time seconds since epoch [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILEMD5S           <span class="keywd">is</span> 1035;  <span class="comment"># STRING_ARRAY  MD5 sum of each file [indexed] (blank if not regular file)</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILELINKTOS        <span class="keywd">is</span> 1036;  <span class="comment"># STRING_ARRAY  Target for symlink [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILEFLAGS          <span class="keywd">is</span> 1037;  <span class="comment"># INT32 (bits)  Bits that classify and control how files installed [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_ROOT               <span class="keywd">is</span> 1038;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILEUSERNAME       <span class="keywd">is</span> 1039;  <span class="comment"># STRING_ARRAY  Owner name of file [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILEGROUPNAME      <span class="keywd">is</span> 1040;  <span class="comment"># STRING_ARRAY  Group name of file [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_EXCLUDE            <span class="keywd">is</span> 1041;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_EXCLUSIVE          <span class="keywd">is</span> 1042;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_ICON               <span class="keywd">is</span> 1043;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_SOURCERPM          <span class="keywd">is</span> 1044;  <span class="comment"># STRING       Optional  Name of associated source rpm</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILEVERIFYFLAGS    <span class="keywd">is</span> 1045;  <span class="comment"># INT32 (bits) Optional  Bits that control how files are to be verified after install [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_ARCHIVESIZE        <span class="keywd">is</span> 1046;  <span class="comment"># INT32        Optional  Uncompressed size of the payload archive</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PROVIDENAME        <span class="keywd">is</span> 1047;  <span class="comment"># STRING_ARRAY  List of dependency names [index]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_REQUIREFLAGS       <span class="keywd">is</span> 1048;  <span class="comment"># INT32 (bits)  Bits to specify the dependency range and context [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_REQUIRENAME        <span class="keywd">is</span> 1049;  <span class="comment"># STRING_ARRAY  List of requirement names [index]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_REQUIREVERSION     <span class="keywd">is</span> 1050;  <span class="comment"># STRING_ARRAY  Version associated with Requirename [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_NOSOURCE           <span class="keywd">is</span> 1051;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_NOPATCH            <span class="keywd">is</span> 1052;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_CONFLICTFLAGS      <span class="keywd">is</span> 1053;  <span class="comment"># INT32 (bits)  Bits to specify the conflict range and context [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_CONFLICTNAME       <span class="keywd">is</span> 1054;  <span class="comment"># STRING_ARRAY  List of conflict names [index]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_CONFLICTVERSION    <span class="keywd">is</span> 1055;  <span class="comment"># STRING_ARRAY  Version associated with Versioname [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_DEFAULTPREFIX      <span class="keywd">is</span> 1056;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BUILDROOT          <span class="keywd">is</span> 1057;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_INSTALLPREFIX      <span class="keywd">is</span> 1058;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_EXCLUDEARCH        <span class="keywd">is</span> 1059;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_EXCLUDEOS          <span class="keywd">is</span> 1060;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_EXCLUSIVEARCH      <span class="keywd">is</span> 1061;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_EXCLUSIVEOS        <span class="keywd">is</span> 1062;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_AUTOREQPROV        <span class="keywd">is</span> 1063;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_RPMVERSION         <span class="keywd">is</span> 1064;  <span class="comment"># STRING       Optional  Version of the RPM tool used to build package</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRIGGERSCRIPTS     <span class="keywd">is</span> 1065;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRIGGERNAME        <span class="keywd">is</span> 1066;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRIGGERVERSION     <span class="keywd">is</span> 1067;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRIGGERFLAGS       <span class="keywd">is</span> 1068;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRIGGERINDEX       <span class="keywd">is</span> 1069;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_VERIFYSCRIPT       <span class="keywd">is</span> 1079;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_CHANGELOGTIME      <span class="keywd">is</span> 1080;  <span class="comment"># INT32        Optional  Seconds since epoch for changelog entry</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_CHANGELOGNAME      <span class="keywd">is</span> 1081;  <span class="comment"># STRING_ARRAY Optional  Name line of changelog entry</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_CHANGELOGTEXT      <span class="keywd">is</span> 1082;  <span class="comment"># STRING_ARRAY Optional  Text of changelog entry</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BROKENMD5          <span class="keywd">is</span> 1083;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PREREQ             <span class="keywd">is</span> 1084;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PREINPROG          <span class="keywd">is</span> 1085;  <span class="comment"># STRING  Interpreter for prein scripts</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_POSTINPROG         <span class="keywd">is</span> 1086;  <span class="comment"># STRING  Interpreter for postin scripts</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PREUNPROG          <span class="keywd">is</span> 1087;  <span class="comment"># STRING  Interpreter for preun scripts</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_POSTUNPROG         <span class="keywd">is</span> 1088;  <span class="comment"># STRING  Interpreter for postun scripts</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BUILDARCHS         <span class="keywd">is</span> 1089;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_OBSOLETENAME       <span class="keywd">is</span> 1090;  <span class="comment"># STRING_ARRAY  List of obsoleted dependency names [index]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_VERIFYSCRIPTPROG   <span class="keywd">is</span> 1091;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRIGGERSCRIPTPROG  <span class="keywd">is</span> 1092;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_DOCDIR             <span class="keywd">is</span> 1093;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_COOKIE             <span class="keywd">is</span> 1094;  <span class="comment"># STRING       Optional</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILEDEVICES        <span class="keywd">is</span> 1095;  <span class="comment"># INT32  16-bit device number from which the file was copied [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILEINODES         <span class="keywd">is</span> 1096;  <span class="comment"># INT32  Inode value from the original file on build host [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILELANGS          <span class="keywd">is</span> 1097;  <span class="comment"># STRING_ARRAY  Per-file locale marker [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PREFIXES           <span class="keywd">is</span> 1098;  <span class="comment"># STRING_ARRAY  Relocation prefixes</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_INSTPREFIXES       <span class="keywd">is</span> 1099;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRIGGERIN          <span class="keywd">is</span> 1100;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRIGGERUN          <span class="keywd">is</span> 1101;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRIGGERPOSTUN      <span class="keywd">is</span> 1102;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_AUTOREQ            <span class="keywd">is</span> 1103;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_AUTOPROV           <span class="keywd">is</span> 1104;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_CAPABILITY         <span class="keywd">is</span> 1105;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_SOURCEPACKAGE      <span class="keywd">is</span> 1106;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_OLDORIGFILENAMES   <span class="keywd">is</span> 1107;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BUILDPREREQ        <span class="keywd">is</span> 1108;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BUILDREQUIRES      <span class="keywd">is</span> 1109;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BUILDCONFLICTS     <span class="keywd">is</span> 1110;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BUILDMACROS        <span class="keywd">is</span> 1111;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PROVIDEFLAGS       <span class="keywd">is</span> 1112;  <span class="comment"># INT32 (bits)  Bits to specify the provide range and context [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PROVIDEVERSION     <span class="keywd">is</span> 1113;  <span class="comment"># STRING_ARRAY  Version associated with provide names [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_OBSOLETEFLAGS      <span class="keywd">is</span> 1114;  <span class="comment"># INT32 (bits)  Bits to specify the obsolete range and context [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_OBSOLETEVERSION    <span class="keywd">is</span> 1115;  <span class="comment"># STRING_ARRAY  Version associated with the obsolete names [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_DIRINDEXES         <span class="keywd">is</span> 1116;  <span class="comment"># INT32        Optional  Specifies the index for the file into the dirnames array [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BASENAMES          <span class="keywd">is</span> 1117;  <span class="comment"># STRING_ARRAY Optional  Specified the base portion of the filename [index]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_DIRNAMES           <span class="keywd">is</span> 1118;  <span class="comment"># STRING_ARRAY Optional  The directory portion of the filename [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_ORIGDIRINDEXES     <span class="keywd">is</span> 1119;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_ORIGBASENAMES      <span class="keywd">is</span> 1120;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_ORIGDIRNAMES       <span class="keywd">is</span> 1121;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_OPTFLAGS           <span class="keywd">is</span> 1122;  <span class="comment"># STRING       Optional  Additional flags passed when compiling the package</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_DISTURL            <span class="keywd">is</span> 1123;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PAYLOADFORMAT      <span class="keywd">is</span> 1124;  <span class="comment"># STRING       Required  Format of the archive section. E.g.: "cpio"</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PAYLOADCOMPRESSOR  <span class="keywd">is</span> 1125;  <span class="comment"># STRING       Required  Format of the compression of the archive. E.g.: "gzip"</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PAYLOADFLAGS       <span class="keywd">is</span> 1126;  <span class="comment"># STRING       Required  Specifies the compression level of package "9"</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_INSTALLCOLOR       <span class="keywd">is</span> 1127;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_INSTALLTID         <span class="keywd">is</span> 1128;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_REMOVETID          <span class="keywd">is</span> 1129;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_SHA1RHN            <span class="keywd">is</span> 1130;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_RHNPLATFORM        <span class="keywd">is</span> 1131;  <span class="comment"># STRING       Deprecated</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PLATFORM           <span class="keywd">is</span> 1132;  <span class="comment"># STRING       Optional</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PATCHESNAME        <span class="keywd">is</span> 1133;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PATCHESFLAGS       <span class="keywd">is</span> 1134;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PATCHESVERSION     <span class="keywd">is</span> 1135;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_CACHECTIME         <span class="keywd">is</span> 1136;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_CACHEPKGPATH       <span class="keywd">is</span> 1137;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_CACHEPKGSIZE       <span class="keywd">is</span> 1138;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_CACHEPKGMTIME      <span class="keywd">is</span> 1139;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILECOLORS         <span class="keywd">is</span> 1140;  <span class="comment"># INT32 (bits)  "color" (type) of the file [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILECLASS          <span class="keywd">is</span> 1141;  <span class="comment"># INT  Index into class dictionary [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_CLASSDICT          <span class="keywd">is</span> 1142;  <span class="comment"># STRING_ARRAY  List of file classes (output of the "file" command)</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILEDEPENDSX       <span class="keywd">is</span> 1143;  <span class="comment"># INT  Size of the entries in DependsDict [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILEDEPENDSN       <span class="keywd">is</span> 1144;  <span class="comment"># INT  Index into the entries in DependsDict [indexed]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_DEPENDSDICT        <span class="keywd">is</span> 1145;  <span class="comment"># INT32  Type/Index into Requires/Provides/Conflicts/Obsoletes</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_SOURCEPKGID        <span class="keywd">is</span> 1146;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILECONTEXTS       <span class="keywd">is</span> 1147;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FSCONTEXTS         <span class="keywd">is</span> 1148;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_RECONTEXTS         <span class="keywd">is</span> 1149;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_POLICIES           <span class="keywd">is</span> 1150;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PRETRANS           <span class="keywd">is</span> 1151;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_POSTTRANS          <span class="keywd">is</span> 1152;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PRETRANSPROG       <span class="keywd">is</span> 1153;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_POSTTRANSPROG      <span class="keywd">is</span> 1154;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_DISTTAG            <span class="keywd">is</span> 1155;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_OLDSUGGESTSNAME    <span class="keywd">is</span> 1156;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_OLDSUGGESTSVERSION <span class="keywd">is</span> 1157;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_OLDSUGGESTSFLAGS   <span class="keywd">is</span> 1158;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_OLDENHANCESNAME    <span class="keywd">is</span> 1159;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_OLDENHANCESVERSION <span class="keywd">is</span> 1160;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_OLDENHANCESFLAGS   <span class="keywd">is</span> 1161;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PRIORITY           <span class="keywd">is</span> 1162;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_CVSID              <span class="keywd">is</span> 1163;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BLINKPKGID         <span class="keywd">is</span> 1164;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BLINKHDRID         <span class="keywd">is</span> 1165;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BLINKNEVRA         <span class="keywd">is</span> 1166;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FLINKPKGID         <span class="keywd">is</span> 1167;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FLINKHDRID         <span class="keywd">is</span> 1168;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FLINKNEVRA         <span class="keywd">is</span> 1169;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PACKAGEORIGIN      <span class="keywd">is</span> 1170;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRIGGERPREIN       <span class="keywd">is</span> 1171;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BUILDSUGGESTS      <span class="keywd">is</span> 1172;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BUILDENHANCES      <span class="keywd">is</span> 1173;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_SCRIPTSTATES       <span class="keywd">is</span> 1174;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_SCRIPTMETRICS      <span class="keywd">is</span> 1175;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BUILDCPUCLOCK      <span class="keywd">is</span> 1176;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILEDIGESTALGOS    <span class="keywd">is</span> 1177;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_VARIANTS           <span class="keywd">is</span> 1178;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_XMAJOR             <span class="keywd">is</span> 1179;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_XMINOR             <span class="keywd">is</span> 1180;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_REPOTAG            <span class="keywd">is</span> 1181;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_KEYWORDS           <span class="keywd">is</span> 1182;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BUILDPLATFORMS     <span class="keywd">is</span> 1183;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PACKAGECOLOR       <span class="keywd">is</span> 1184;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PACKAGEPREFCOLOR   <span class="keywd">is</span> 1185;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_XATTRSDICT         <span class="keywd">is</span> 1186;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILEXATTRSX        <span class="keywd">is</span> 1187;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_DEPATTRSDICT       <span class="keywd">is</span> 1188;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_CONFLICTATTRSX     <span class="keywd">is</span> 1189;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_OBSOLETEATTRSX     <span class="keywd">is</span> 1190;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PROVIDEATTRSX      <span class="keywd">is</span> 1191;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_REQUIREATTRSX      <span class="keywd">is</span> 1192;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BUILDPROVIDES      <span class="keywd">is</span> 1193;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BUILDOBSOLETES     <span class="keywd">is</span> 1194;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_DBINSTANCE         <span class="keywd">is</span> 1195;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_NVRA               <span class="keywd">is</span> 1196;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILENAMES          <span class="keywd">is</span> 5000;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILEPROVIDE        <span class="keywd">is</span> 5001;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILEREQUIRE        <span class="keywd">is</span> 5002;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FSNAMES            <span class="keywd">is</span> 5003;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FSSIZES            <span class="keywd">is</span> 5004;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRIGGERCONDS       <span class="keywd">is</span> 5005;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRIGGERTYPE        <span class="keywd">is</span> 5006;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_ORIGFILENAMES      <span class="keywd">is</span> 5007;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_LONGFILESIZES      <span class="keywd">is</span> 5008;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_LONGSIZE           <span class="keywd">is</span> 5009;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILECAPS           <span class="keywd">is</span> 5010;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILEDIGESTALGO     <span class="keywd">is</span> 5011;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_BUGURL             <span class="keywd">is</span> 5012;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_EVR                <span class="keywd">is</span> 5013;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_NVR                <span class="keywd">is</span> 5014;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_NEVR               <span class="keywd">is</span> 5015;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_NEVRA              <span class="keywd">is</span> 5016;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_HEADERCOLOR        <span class="keywd">is</span> 5017;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_VERBOSE            <span class="keywd">is</span> 5018;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_EPOCHNUM           <span class="keywd">is</span> 5019;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PREINFLAGS         <span class="keywd">is</span> 5020;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_POSTINFLAGS        <span class="keywd">is</span> 5021;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PREUNFLAGS         <span class="keywd">is</span> 5022;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_POSTUNFLAGS        <span class="keywd">is</span> 5023;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PRETRANSFLAGS      <span class="keywd">is</span> 5024;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_POSTTRANSFLAGS     <span class="keywd">is</span> 5025;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_VERIFYSCRIPTFLAGS  <span class="keywd">is</span> 5026;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRIGGERSCRIPTFLAGS <span class="keywd">is</span> 5027;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_COLLECTIONS        <span class="keywd">is</span> 5029;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_POLICYNAMES        <span class="keywd">is</span> 5030;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_POLICYTYPES        <span class="keywd">is</span> 5031;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_POLICYTYPESINDEXES <span class="keywd">is</span> 5032;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_POLICYFLAGS        <span class="keywd">is</span> 5033;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_VCS                <span class="keywd">is</span> 5034;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_ORDERNAME          <span class="keywd">is</span> 5035;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_ORDERVERSION       <span class="keywd">is</span> 5036;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_ORDERFLAGS         <span class="keywd">is</span> 5037;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_MSSFMANIFEST       <span class="keywd">is</span> 5038;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_MSSFDOMAIN         <span class="keywd">is</span> 5039;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_INSTFILENAMES      <span class="keywd">is</span> 5040;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_REQUIRENEVRS       <span class="keywd">is</span> 5041;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PROVIDENEVRS       <span class="keywd">is</span> 5042;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_OBSOLETENEVRS      <span class="keywd">is</span> 5043;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_CONFLICTNEVRS      <span class="keywd">is</span> 5044;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILENLINKS         <span class="keywd">is</span> 5045;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_RECOMMENDNAME      <span class="keywd">is</span> 5046;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_RECOMMENDVERSION   <span class="keywd">is</span> 5047;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_RECOMMENDFLAGS     <span class="keywd">is</span> 5048;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_SUGGESTNAME        <span class="keywd">is</span> 5049;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_SUGGESTVERSION     <span class="keywd">is</span> 5050;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_SUGGESTFLAGS       <span class="keywd">is</span> 5051;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_SUPPLEMENTNAME     <span class="keywd">is</span> 5052;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_SUPPLEMENTVERSION  <span class="keywd">is</span> 5053;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_SUPPLEMENTFLAGS    <span class="keywd">is</span> 5054;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_ENHANCENAME        <span class="keywd">is</span> 5055;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_ENHANCEVERSION     <span class="keywd">is</span> 5056;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_ENHANCEFLAGS       <span class="keywd">is</span> 5057;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_RECOMMENDNEVRS     <span class="keywd">is</span> 5058;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_SUGGESTNEVRS       <span class="keywd">is</span> 5059;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_SUPPLEMENTNEVRS    <span class="keywd">is</span> 5060;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_ENHANCENEVRS       <span class="keywd">is</span> 5061;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_ENCODING           <span class="keywd">is</span> 5062;
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILETRIGGERIN               <span class="keywd">is</span> 5063;  <span class="comment"># internal</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILETRIGGERUN               <span class="keywd">is</span> 5064;  <span class="comment"># internal</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILETRIGGERPOSTUN           <span class="keywd">is</span> 5065;  <span class="comment"># internal</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILETRIGGERSCRIPTS          <span class="keywd">is</span> 5066;  <span class="comment"># s[]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILETRIGGERSCRIPTPROG       <span class="keywd">is</span> 5067;  <span class="comment"># s[]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILETRIGGERSCRIPTFLAGS      <span class="keywd">is</span> 5068;  <span class="comment"># i[]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILETRIGGERNAME             <span class="keywd">is</span> 5069;  <span class="comment"># s[]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILETRIGGERINDEX            <span class="keywd">is</span> 5070;  <span class="comment"># i[]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILETRIGGERVERSION          <span class="keywd">is</span> 5071;  <span class="comment"># s[]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILETRIGGERFLAGS            <span class="keywd">is</span> 5072;  <span class="comment"># i[]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRANSFILETRIGGERIN          <span class="keywd">is</span> 5073;  <span class="comment"># internal</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRANSFILETRIGGERUN          <span class="keywd">is</span> 5074;  <span class="comment"># internal</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRANSFILETRIGGERPOSTUN      <span class="keywd">is</span> 5075;  <span class="comment"># internal</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRANSFILETRIGGERSCRIPTS     <span class="keywd">is</span> 5076;  <span class="comment"># s[]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRANSFILETRIGGERSCRIPTPROG  <span class="keywd">is</span> 5077;  <span class="comment"># s[]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRANSFILETRIGGERSCRIPTFLAGS <span class="keywd">is</span> 5078;  <span class="comment"># i[]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRANSFILETRIGGERNAME        <span class="keywd">is</span> 5079;  <span class="comment"># s[]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRANSFILETRIGGERINDEX       <span class="keywd">is</span> 5080;  <span class="comment"># i[]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRANSFILETRIGGERVERSION     <span class="keywd">is</span> 5081;  <span class="comment"># s[]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRANSFILETRIGGERFLAGS       <span class="keywd">is</span> 5082;  <span class="comment"># i[]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_REMOVEPATHPOSTFIXES         <span class="keywd">is</span> 5083;  <span class="comment"># s internal</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILETRIGGERPRIORITIES       <span class="keywd">is</span> 5084;  <span class="comment"># i[]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRANSFILETRIGGERPRIORITIES  <span class="keywd">is</span> 5085;  <span class="comment"># i[]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILETRIGGERCONDS            <span class="keywd">is</span> 5086;  <span class="comment"># s[] extension</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILETRIGGERTYPE             <span class="keywd">is</span> 5087;  <span class="comment"># s[] extension</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRANSFILETRIGGERCONDS       <span class="keywd">is</span> 5088;  <span class="comment"># s[] extension</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_TRANSFILETRIGGERTYPE        <span class="keywd">is</span> 5089;  <span class="comment"># s[] extension</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILESIGNATURES              <span class="keywd">is</span> 5090;  <span class="comment"># s[]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_FILESIGNATURELENGTH         <span class="keywd">is</span> 5091;  <span class="comment"># i</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PAYLOADDIGEST               <span class="keywd">is</span> 5092;  <span class="comment"># s[]</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PAYLOADDIGESTALGO           <span class="keywd">is</span> 5093;  <span class="comment"># i</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_AUTOINSTALLED               <span class="keywd">is</span> 5094;  <span class="comment"># i reservation (unimplemented)</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_IDENTITY                    <span class="keywd">is</span> 5095;  <span class="comment"># s reservation (unimplemented)</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_MODULARITYLABEL             <span class="keywd">is</span> 5096;  <span class="comment"># s</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMTAG_PAYLOADDIGESTALT            <span class="keywd">is</span> 5097;  <span class="comment"># s[]</span>

<span class="keywd">const</span> <span class="type">integer</span>: RPMSIGTAG_HEADERSIGNATURES <span class="keywd">is</span>   62;  <span class="comment"># BIN    Optional</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSIGTAG_SIZE             <span class="keywd">is</span> 1000;  <span class="comment"># INT32  Required  Byte count for the header section plus the compressed payload.</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSIGTAG_PGP              <span class="keywd">is</span> 1002;  <span class="comment"># BIN    Optional</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSIGTAG_MD5              <span class="keywd">is</span> 1004;  <span class="comment"># BIN    Required  MD5 checksum over the header section plus the payload.</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSIGTAG_GPG              <span class="keywd">is</span> 1005;  <span class="comment"># BIN    Optional</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSIGTAG_PAYLOADSIZE      <span class="keywd">is</span> 1007;  <span class="comment"># INT32  Optional  Byte count for the uncompressed payload.</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSIGTAG_RESERVEDSPACE    <span class="keywd">is</span> 1008;  <span class="comment"># BIN</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSIGTAG_SHA1             <span class="keywd">is</span>  269;  <span class="comment"># STRING</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSIGTAG_SHA256           <span class="keywd">is</span>  273;  <span class="comment"># STRING Optional</span>

<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_ANY           <span class="keywd">is</span> 0;
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_LESS          <span class="keywd">is</span> 1 &lt;&lt;  1;
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_GREATER       <span class="keywd">is</span> 1 &lt;&lt;  2;
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_EQUAL         <span class="keywd">is</span> 1 &lt;&lt;  3;
<span class="comment"># bit 4 unused</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_POSTTRANS     <span class="keywd">is</span> 1 &lt;&lt;  5;  <span class="comment"># %posttrans dependency</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_PREREQ        <span class="keywd">is</span> 1 &lt;&lt;  6;  <span class="comment"># legacy prereq dependency</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_PRETRANS      <span class="keywd">is</span> 1 &lt;&lt;  7;  <span class="comment"># Pre-transaction dependency</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_INTERP        <span class="keywd">is</span> 1 &lt;&lt;  8;  <span class="comment"># Interpreter used by scriptlet</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_SCRIPT_PRE    <span class="keywd">is</span> 1 &lt;&lt;  9;  <span class="comment"># %pre dependency</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_SCRIPT_POST   <span class="keywd">is</span> 1 &lt;&lt; 10;  <span class="comment"># %post dependency</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_SCRIPT_PREUN  <span class="keywd">is</span> 1 &lt;&lt; 11;  <span class="comment"># %preun dependency</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_SCRIPT_POSTUN <span class="keywd">is</span> 1 &lt;&lt; 12;  <span class="comment"># %postun dependency</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_SCRIPT_VERIFY <span class="keywd">is</span> 1 &lt;&lt; 13;  <span class="comment"># %verify dependency</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_FIND_REQUIRES <span class="keywd">is</span> 1 &lt;&lt; 14;  <span class="comment"># find-requires generated dependency</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_FIND_PROVIDES <span class="keywd">is</span> 1 &lt;&lt; 15;  <span class="comment"># find-provides generated dependency</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_TRIGGERIN     <span class="keywd">is</span> 1 &lt;&lt; 16;  <span class="comment"># %triggerin dependency</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_TRIGGERUN     <span class="keywd">is</span> 1 &lt;&lt; 17;  <span class="comment"># %triggerun dependency</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_TRIGGERPOSTUN <span class="keywd">is</span> 1 &lt;&lt; 18;  <span class="comment"># %triggerpostun dependency</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_MISSINGOK     <span class="keywd">is</span> 1 &lt;&lt; 19;  <span class="comment"># suggests/enhances hint</span>
<span class="comment"># bits 20-23 unused</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_RPMLIB        <span class="keywd">is</span> 1 &lt;&lt; 24;  <span class="comment"># rpmlib(feature) dependency</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_TRIGGERPREIN  <span class="keywd">is</span> 1 &lt;&lt; 25;  <span class="comment"># %triggerprein dependency</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_KEYRING       <span class="keywd">is</span> 1 &lt;&lt; 26;
<span class="comment"># bit 27 unused</span>
<span class="keywd">const</span> <span class="type">integer</span>: RPMSENSE_CONFIG        <span class="keywd">is</span> 1 &lt;&lt; 28;

<span class="keywd">const</span> <span class="type">integer</span>: RPM_DIGESTALGO_MD5         <span class="keywd">is</span>  1;
<span class="keywd">const</span> <span class="type">integer</span>: RPM_DIGESTALGO_SHA1        <span class="keywd">is</span>  2;
<span class="keywd">const</span> <span class="type">integer</span>: RPM_DIGESTALGO_RIPEMD160   <span class="keywd">is</span>  3;
<span class="keywd">const</span> <span class="type">integer</span>: RPM_DIGESTALGO_MD2         <span class="keywd">is</span>  5;
<span class="keywd">const</span> <span class="type">integer</span>: RPM_DIGESTALGO_TIGER192    <span class="keywd">is</span>  6;
<span class="keywd">const</span> <span class="type">integer</span>: RPM_DIGESTALGO_HAVAL_5_160 <span class="keywd">is</span>  7;
<span class="keywd">const</span> <span class="type">integer</span>: RPM_DIGESTALGO_SHA256      <span class="keywd">is</span>  8;
<span class="keywd">const</span> <span class="type">integer</span>: RPM_DIGESTALGO_SHA384      <span class="keywd">is</span>  9;
<span class="keywd">const</span> <span class="type">integer</span>: RPM_DIGESTALGO_SHA512      <span class="keywd">is</span> 10;
<span class="keywd">const</span> <span class="type">integer</span>: RPM_DIGESTALGO_SHA224      <span class="keywd">is</span> 11;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: sigtagName (<span class="op">in</span> <span class="type">integer</span>: tag) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> tag <span class="keywd">of</span>
      <span class="keywd">when</span> {  62}: name := <span class="stri">"HEADERSIGNATURES"</span>;
      <span class="keywd">when</span> {1000}: name := <span class="stri">"SIZE"</span>;
      <span class="keywd">when</span> {1001}: name := <span class="stri">"LEMD5_1"</span>;
      <span class="keywd">when</span> {1002}: name := <span class="stri">"PGP"</span>;
      <span class="keywd">when</span> {1003}: name := <span class="stri">"LEMD5_2"</span>;
      <span class="keywd">when</span> {1004}: name := <span class="stri">"MD5"</span>;
      <span class="keywd">when</span> {1005}: name := <span class="stri">"GPG"</span>;
      <span class="keywd">when</span> {1006}: name := <span class="stri">"PGP5"</span>;
      <span class="keywd">when</span> {1007}: name := <span class="stri">"PAYLOADSIZE"</span>;
      <span class="keywd">when</span> {1008}: name := <span class="stri">"RESERVEDSPACE"</span>;
      <span class="keywd">when</span> { 257}: name := <span class="stri">"SIGSIZE"</span>;
      <span class="keywd">when</span> { 258}: name := <span class="stri">"SIGLEMD5_1"</span>;
      <span class="keywd">when</span> { 259}: name := <span class="stri">"SIGPGP"</span>;
      <span class="keywd">when</span> { 260}: name := <span class="stri">"SIGLEMD5_2"</span>;
      <span class="keywd">when</span> { 261}: name := <span class="stri">"SIGMD5"</span>;
      <span class="keywd">when</span> { 262}: name := <span class="stri">"SIGGPG"</span>;
      <span class="keywd">when</span> { 263}: name := <span class="stri">"SIGPGP5"</span>;
      <span class="keywd">when</span> { 264}: name := <span class="stri">"BADSHA1_1"</span>;
      <span class="keywd">when</span> { 265}: name := <span class="stri">"BADSHA1_2"</span>;
      <span class="keywd">when</span> { 267}: name := <span class="stri">"DSA"</span>;
      <span class="keywd">when</span> { 268}: name := <span class="stri">"RSA"</span>;
      <span class="keywd">when</span> { 269}: name := <span class="stri">"SHA1"</span>;
      <span class="keywd">when</span> { 270}: name := <span class="stri">"LONGSIZE"</span>;
      <span class="keywd">when</span> { 271}: name := <span class="stri">"LONGARCHIVESIZE"</span>;
      <span class="keywd">when</span> { 273}: name := <span class="stri">"SHA256"</span>;
      <span class="keywd">otherwise</span>: name := <span class="stri">"tag "</span> &lt;&amp; tag;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: rpmtagName (<span class="op">in</span> <span class="type">integer</span>: tag) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> tag <span class="keywd">of</span>
      <span class="keywd">when</span> {RPMTAG_HEADERIMMUTABLE}:             name := <span class="stri">"HEADERIMMUTABLE"</span>;
      <span class="keywd">when</span> {RPMTAG_HEADERI18NTABLE}:             name := <span class="stri">"HEADERI18NTABLE"</span>;
      <span class="keywd">when</span> {RPMTAG_NAME}:                        name := <span class="stri">"NAME"</span>;
      <span class="keywd">when</span> {RPMTAG_VERSION}:                     name := <span class="stri">"VERSION"</span>;
      <span class="keywd">when</span> {RPMTAG_RELEASE}:                     name := <span class="stri">"RELEASE"</span>;
      <span class="keywd">when</span> {RPMTAG_EPOCH}:                       name := <span class="stri">"EPOCH"</span>;
      <span class="keywd">when</span> {RPMTAG_SUMMARY}:                     name := <span class="stri">"SUMMARY"</span>;
      <span class="keywd">when</span> {RPMTAG_DESCRIPTION}:                 name := <span class="stri">"DESCRIPTION"</span>;
      <span class="keywd">when</span> {RPMTAG_BUILDTIME}:                   name := <span class="stri">"BUILDTIME"</span>;
      <span class="keywd">when</span> {RPMTAG_BUILDHOST}:                   name := <span class="stri">"BUILDHOST"</span>;
      <span class="keywd">when</span> {RPMTAG_INSTALLTIME}:                 name := <span class="stri">"INSTALLTIME"</span>;
      <span class="keywd">when</span> {RPMTAG_SIZE}:                        name := <span class="stri">"SIZE"</span>;
      <span class="keywd">when</span> {RPMTAG_DISTRIBUTION}:                name := <span class="stri">"DISTRIBUTION"</span>;
      <span class="keywd">when</span> {RPMTAG_VENDOR}:                      name := <span class="stri">"VENDOR"</span>;
      <span class="keywd">when</span> {RPMTAG_GIF}:                         name := <span class="stri">"GIF"</span>;
      <span class="keywd">when</span> {RPMTAG_XPM}:                         name := <span class="stri">"XPM"</span>;
      <span class="keywd">when</span> {RPMTAG_LICENSE}:                     name := <span class="stri">"LICENSE"</span>;
      <span class="keywd">when</span> {RPMTAG_PACKAGER}:                    name := <span class="stri">"PACKAGER"</span>;
      <span class="keywd">when</span> {RPMTAG_GROUP}:                       name := <span class="stri">"GROUP"</span>;
      <span class="keywd">when</span> {RPMTAG_CHANGELOG}:                   name := <span class="stri">"CHANGELOG"</span>;
      <span class="keywd">when</span> {RPMTAG_SOURCE}:                      name := <span class="stri">"SOURCE"</span>;
      <span class="keywd">when</span> {RPMTAG_PATCH}:                       name := <span class="stri">"PATCH"</span>;
      <span class="keywd">when</span> {RPMTAG_URL}:                         name := <span class="stri">"URL"</span>;
      <span class="keywd">when</span> {RPMTAG_OS}:                          name := <span class="stri">"OS"</span>;
      <span class="keywd">when</span> {RPMTAG_ARCH}:                        name := <span class="stri">"ARCH"</span>;
      <span class="keywd">when</span> {RPMTAG_PREIN}:                       name := <span class="stri">"PREIN"</span>;
      <span class="keywd">when</span> {RPMTAG_POSTIN}:                      name := <span class="stri">"POSTIN"</span>;
      <span class="keywd">when</span> {RPMTAG_PREUN}:                       name := <span class="stri">"PREUN"</span>;
      <span class="keywd">when</span> {RPMTAG_POSTUN}:                      name := <span class="stri">"POSTUN"</span>;
      <span class="keywd">when</span> {RPMTAG_OLDFILENAMES}:                name := <span class="stri">"OLDFILENAMES"</span>;
      <span class="keywd">when</span> {RPMTAG_FILESIZES}:                   name := <span class="stri">"FILESIZES"</span>;
      <span class="keywd">when</span> {RPMTAG_FILESTATES}:                  name := <span class="stri">"FILESTATES"</span>;
      <span class="keywd">when</span> {RPMTAG_FILEMODES}:                   name := <span class="stri">"FILEMODES"</span>;
      <span class="keywd">when</span> {RPMTAG_FILEUIDS}:                    name := <span class="stri">"FILEUIDS"</span>;
      <span class="keywd">when</span> {RPMTAG_FILEGIDS}:                    name := <span class="stri">"FILEGIDS"</span>;
      <span class="keywd">when</span> {RPMTAG_FILERDEVS}:                   name := <span class="stri">"FILERDEVS"</span>;
      <span class="keywd">when</span> {RPMTAG_FILEMTIMES}:                  name := <span class="stri">"FILEMTIMES"</span>;
      <span class="keywd">when</span> {RPMTAG_FILEMD5S}:                    name := <span class="stri">"FILEMD5S"</span>;
      <span class="keywd">when</span> {RPMTAG_FILELINKTOS}:                 name := <span class="stri">"FILELINKTOS"</span>;
      <span class="keywd">when</span> {RPMTAG_FILEFLAGS}:                   name := <span class="stri">"FILEFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_ROOT}:                        name := <span class="stri">"ROOT"</span>;
      <span class="keywd">when</span> {RPMTAG_FILEUSERNAME}:                name := <span class="stri">"FILEUSERNAME"</span>;
      <span class="keywd">when</span> {RPMTAG_FILEGROUPNAME}:               name := <span class="stri">"FILEGROUPNAME"</span>;
      <span class="keywd">when</span> {RPMTAG_EXCLUDE}:                     name := <span class="stri">"EXCLUDE"</span>;
      <span class="keywd">when</span> {RPMTAG_EXCLUSIVE}:                   name := <span class="stri">"EXCLUSIVE"</span>;
      <span class="keywd">when</span> {RPMTAG_ICON}:                        name := <span class="stri">"ICON"</span>;
      <span class="keywd">when</span> {RPMTAG_SOURCERPM}:                   name := <span class="stri">"SOURCERPM"</span>;
      <span class="keywd">when</span> {RPMTAG_FILEVERIFYFLAGS}:             name := <span class="stri">"FILEVERIFYFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_ARCHIVESIZE}:                 name := <span class="stri">"ARCHIVESIZE"</span>;
      <span class="keywd">when</span> {RPMTAG_PROVIDENAME}:                 name := <span class="stri">"PROVIDENAME"</span>;
      <span class="keywd">when</span> {RPMTAG_REQUIREFLAGS}:                name := <span class="stri">"REQUIREFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_REQUIRENAME}:                 name := <span class="stri">"REQUIRENAME"</span>;
      <span class="keywd">when</span> {RPMTAG_REQUIREVERSION}:              name := <span class="stri">"REQUIREVERSION"</span>;
      <span class="keywd">when</span> {RPMTAG_NOSOURCE}:                    name := <span class="stri">"NOSOURCE"</span>;
      <span class="keywd">when</span> {RPMTAG_NOPATCH}:                     name := <span class="stri">"NOPATCH"</span>;
      <span class="keywd">when</span> {RPMTAG_CONFLICTFLAGS}:               name := <span class="stri">"CONFLICTFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_CONFLICTNAME}:                name := <span class="stri">"CONFLICTNAME"</span>;
      <span class="keywd">when</span> {RPMTAG_CONFLICTVERSION}:             name := <span class="stri">"CONFLICTVERSION"</span>;
      <span class="keywd">when</span> {RPMTAG_DEFAULTPREFIX}:               name := <span class="stri">"DEFAULTPREFIX"</span>;
      <span class="keywd">when</span> {RPMTAG_BUILDROOT}:                   name := <span class="stri">"BUILDROOT"</span>;
      <span class="keywd">when</span> {RPMTAG_INSTALLPREFIX}:               name := <span class="stri">"INSTALLPREFIX"</span>;
      <span class="keywd">when</span> {RPMTAG_EXCLUDEARCH}:                 name := <span class="stri">"EXCLUDEARCH"</span>;
      <span class="keywd">when</span> {RPMTAG_EXCLUDEOS}:                   name := <span class="stri">"EXCLUDEOS"</span>;
      <span class="keywd">when</span> {RPMTAG_EXCLUSIVEARCH}:               name := <span class="stri">"EXCLUSIVEARCH"</span>;
      <span class="keywd">when</span> {RPMTAG_EXCLUSIVEOS}:                 name := <span class="stri">"EXCLUSIVEOS"</span>;
      <span class="keywd">when</span> {RPMTAG_AUTOREQPROV}:                 name := <span class="stri">"AUTOREQPROV"</span>;
      <span class="keywd">when</span> {RPMTAG_RPMVERSION}:                  name := <span class="stri">"RPMVERSION"</span>;
      <span class="keywd">when</span> {RPMTAG_TRIGGERSCRIPTS}:              name := <span class="stri">"TRIGGERSCRIPTS"</span>;
      <span class="keywd">when</span> {RPMTAG_TRIGGERNAME}:                 name := <span class="stri">"TRIGGERNAME"</span>;
      <span class="keywd">when</span> {RPMTAG_TRIGGERVERSION}:              name := <span class="stri">"TRIGGERVERSION"</span>;
      <span class="keywd">when</span> {RPMTAG_TRIGGERFLAGS}:                name := <span class="stri">"TRIGGERFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_TRIGGERINDEX}:                name := <span class="stri">"TRIGGERINDEX"</span>;
      <span class="keywd">when</span> {RPMTAG_VERIFYSCRIPT}:                name := <span class="stri">"VERIFYSCRIPT"</span>;
      <span class="keywd">when</span> {RPMTAG_CHANGELOGTIME}:               name := <span class="stri">"CHANGELOGTIME"</span>;
      <span class="keywd">when</span> {RPMTAG_CHANGELOGNAME}:               name := <span class="stri">"CHANGELOGNAME"</span>;
      <span class="keywd">when</span> {RPMTAG_CHANGELOGTEXT}:               name := <span class="stri">"CHANGELOGTEXT"</span>;
      <span class="keywd">when</span> {RPMTAG_BROKENMD5}:                   name := <span class="stri">"BROKENMD5"</span>;
      <span class="keywd">when</span> {RPMTAG_PREREQ}:                      name := <span class="stri">"PREREQ"</span>;
      <span class="keywd">when</span> {RPMTAG_PREINPROG}:                   name := <span class="stri">"PREINPROG"</span>;
      <span class="keywd">when</span> {RPMTAG_POSTINPROG}:                  name := <span class="stri">"POSTINPROG"</span>;
      <span class="keywd">when</span> {RPMTAG_PREUNPROG}:                   name := <span class="stri">"PREUNPROG"</span>;
      <span class="keywd">when</span> {RPMTAG_POSTUNPROG}:                  name := <span class="stri">"POSTUNPROG"</span>;
      <span class="keywd">when</span> {RPMTAG_BUILDARCHS}:                  name := <span class="stri">"BUILDARCHS"</span>;
      <span class="keywd">when</span> {RPMTAG_OBSOLETENAME}:                name := <span class="stri">"OBSOLETENAME"</span>;
      <span class="keywd">when</span> {RPMTAG_VERIFYSCRIPTPROG}:            name := <span class="stri">"VERIFYSCRIPTPROG"</span>;
      <span class="keywd">when</span> {RPMTAG_TRIGGERSCRIPTPROG}:           name := <span class="stri">"TRIGGERSCRIPTPROG"</span>;
      <span class="keywd">when</span> {RPMTAG_DOCDIR}:                      name := <span class="stri">"DOCDIR"</span>;
      <span class="keywd">when</span> {RPMTAG_COOKIE}:                      name := <span class="stri">"COOKIE"</span>;
      <span class="keywd">when</span> {RPMTAG_FILEDEVICES}:                 name := <span class="stri">"FILEDEVICES"</span>;
      <span class="keywd">when</span> {RPMTAG_FILEINODES}:                  name := <span class="stri">"FILEINODES"</span>;
      <span class="keywd">when</span> {RPMTAG_FILELANGS}:                   name := <span class="stri">"FILELANGS"</span>;
      <span class="keywd">when</span> {RPMTAG_PREFIXES}:                    name := <span class="stri">"PREFIXES"</span>;
      <span class="keywd">when</span> {RPMTAG_INSTPREFIXES}:                name := <span class="stri">"INSTPREFIXES"</span>;
      <span class="keywd">when</span> {RPMTAG_TRIGGERIN}:                   name := <span class="stri">"TRIGGERIN"</span>;
      <span class="keywd">when</span> {RPMTAG_TRIGGERUN}:                   name := <span class="stri">"TRIGGERUN"</span>;
      <span class="keywd">when</span> {RPMTAG_TRIGGERPOSTUN}:               name := <span class="stri">"TRIGGERPOSTUN"</span>;
      <span class="keywd">when</span> {RPMTAG_AUTOREQ}:                     name := <span class="stri">"AUTOREQ"</span>;
      <span class="keywd">when</span> {RPMTAG_AUTOPROV}:                    name := <span class="stri">"AUTOPROV"</span>;
      <span class="keywd">when</span> {RPMTAG_CAPABILITY}:                  name := <span class="stri">"CAPABILITY"</span>;
      <span class="keywd">when</span> {RPMTAG_SOURCEPACKAGE}:               name := <span class="stri">"SOURCEPACKAGE"</span>;
      <span class="keywd">when</span> {RPMTAG_OLDORIGFILENAMES}:            name := <span class="stri">"OLDORIGFILENAMES"</span>;
      <span class="keywd">when</span> {RPMTAG_BUILDPREREQ}:                 name := <span class="stri">"BUILDPREREQ"</span>;
      <span class="keywd">when</span> {RPMTAG_BUILDREQUIRES}:               name := <span class="stri">"BUILDREQUIRES"</span>;
      <span class="keywd">when</span> {RPMTAG_BUILDCONFLICTS}:              name := <span class="stri">"BUILDCONFLICTS"</span>;
      <span class="keywd">when</span> {RPMTAG_BUILDMACROS}:                 name := <span class="stri">"BUILDMACROS"</span>;
      <span class="keywd">when</span> {RPMTAG_PROVIDEFLAGS}:                name := <span class="stri">"PROVIDEFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_PROVIDEVERSION}:              name := <span class="stri">"PROVIDEVERSION"</span>;
      <span class="keywd">when</span> {RPMTAG_OBSOLETEFLAGS}:               name := <span class="stri">"OBSOLETEFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_OBSOLETEVERSION}:             name := <span class="stri">"OBSOLETEVERSION"</span>;
      <span class="keywd">when</span> {RPMTAG_DIRINDEXES}:                  name := <span class="stri">"DIRINDEXES"</span>;
      <span class="keywd">when</span> {RPMTAG_BASENAMES}:                   name := <span class="stri">"BASENAMES"</span>;
      <span class="keywd">when</span> {RPMTAG_DIRNAMES}:                    name := <span class="stri">"DIRNAMES"</span>;
      <span class="keywd">when</span> {RPMTAG_ORIGDIRINDEXES}:              name := <span class="stri">"ORIGDIRINDEXES"</span>;
      <span class="keywd">when</span> {RPMTAG_ORIGBASENAMES}:               name := <span class="stri">"ORIGBASENAMES"</span>;
      <span class="keywd">when</span> {RPMTAG_ORIGDIRNAMES}:                name := <span class="stri">"ORIGDIRNAMES"</span>;
      <span class="keywd">when</span> {RPMTAG_OPTFLAGS}:                    name := <span class="stri">"OPTFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_DISTURL}:                     name := <span class="stri">"DISTURL"</span>;
      <span class="keywd">when</span> {RPMTAG_PAYLOADFORMAT}:               name := <span class="stri">"PAYLOADFORMAT"</span>;
      <span class="keywd">when</span> {RPMTAG_PAYLOADCOMPRESSOR}:           name := <span class="stri">"PAYLOADCOMPRESSOR"</span>;
      <span class="keywd">when</span> {RPMTAG_PAYLOADFLAGS}:                name := <span class="stri">"PAYLOADFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_INSTALLCOLOR}:                name := <span class="stri">"INSTALLCOLOR"</span>;
      <span class="keywd">when</span> {RPMTAG_INSTALLTID}:                  name := <span class="stri">"INSTALLTID"</span>;
      <span class="keywd">when</span> {RPMTAG_REMOVETID}:                   name := <span class="stri">"REMOVETID"</span>;
      <span class="keywd">when</span> {RPMTAG_SHA1RHN}:                     name := <span class="stri">"SHA1RHN"</span>;
      <span class="keywd">when</span> {RPMTAG_RHNPLATFORM}:                 name := <span class="stri">"RHNPLATFORM"</span>;
      <span class="keywd">when</span> {RPMTAG_PLATFORM}:                    name := <span class="stri">"PLATFORM"</span>;
      <span class="keywd">when</span> {RPMTAG_PATCHESNAME}:                 name := <span class="stri">"PATCHESNAME"</span>;
      <span class="keywd">when</span> {RPMTAG_PATCHESFLAGS}:                name := <span class="stri">"PATCHESFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_PATCHESVERSION}:              name := <span class="stri">"PATCHESVERSION"</span>;
      <span class="keywd">when</span> {RPMTAG_CACHECTIME}:                  name := <span class="stri">"CACHECTIME"</span>;
      <span class="keywd">when</span> {RPMTAG_CACHEPKGPATH}:                name := <span class="stri">"CACHEPKGPATH"</span>;
      <span class="keywd">when</span> {RPMTAG_CACHEPKGSIZE}:                name := <span class="stri">"CACHEPKGSIZE"</span>;
      <span class="keywd">when</span> {RPMTAG_CACHEPKGMTIME}:               name := <span class="stri">"CACHEPKGMTIME"</span>;
      <span class="keywd">when</span> {RPMTAG_FILECOLORS}:                  name := <span class="stri">"FILECOLORS"</span>;
      <span class="keywd">when</span> {RPMTAG_FILECLASS}:                   name := <span class="stri">"FILECLASS"</span>;
      <span class="keywd">when</span> {RPMTAG_CLASSDICT}:                   name := <span class="stri">"CLASSDICT"</span>;
      <span class="keywd">when</span> {RPMTAG_FILEDEPENDSX}:                name := <span class="stri">"FILEDEPENDSX"</span>;
      <span class="keywd">when</span> {RPMTAG_FILEDEPENDSN}:                name := <span class="stri">"FILEDEPENDSN"</span>;
      <span class="keywd">when</span> {RPMTAG_DEPENDSDICT}:                 name := <span class="stri">"DEPENDSDICT"</span>;
      <span class="keywd">when</span> {RPMTAG_SOURCEPKGID}:                 name := <span class="stri">"SOURCEPKGID"</span>;
      <span class="keywd">when</span> {RPMTAG_FILECONTEXTS}:                name := <span class="stri">"FILECONTEXTS"</span>;
      <span class="keywd">when</span> {RPMTAG_FSCONTEXTS}:                  name := <span class="stri">"FSCONTEXTS"</span>;
      <span class="keywd">when</span> {RPMTAG_RECONTEXTS}:                  name := <span class="stri">"RECONTEXTS"</span>;
      <span class="keywd">when</span> {RPMTAG_POLICIES}:                    name := <span class="stri">"POLICIES"</span>;
      <span class="keywd">when</span> {RPMTAG_PRETRANS}:                    name := <span class="stri">"PRETRANS"</span>;
      <span class="keywd">when</span> {RPMTAG_POSTTRANS}:                   name := <span class="stri">"POSTTRANS"</span>;
      <span class="keywd">when</span> {RPMTAG_PRETRANSPROG}:                name := <span class="stri">"PRETRANSPROG"</span>;
      <span class="keywd">when</span> {RPMTAG_POSTTRANSPROG}:               name := <span class="stri">"POSTTRANSPROG"</span>;
      <span class="keywd">when</span> {RPMTAG_DISTTAG}:                     name := <span class="stri">"DISTTAG"</span>;
      <span class="keywd">when</span> {RPMTAG_OLDSUGGESTSNAME}:             name := <span class="stri">"OLDSUGGESTSNAME"</span>;
      <span class="keywd">when</span> {RPMTAG_OLDSUGGESTSVERSION}:          name := <span class="stri">"OLDSUGGESTSVERSION"</span>;
      <span class="keywd">when</span> {RPMTAG_OLDSUGGESTSFLAGS}:            name := <span class="stri">"OLDSUGGESTSFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_OLDENHANCESNAME}:             name := <span class="stri">"OLDENHANCESNAME"</span>;
      <span class="keywd">when</span> {RPMTAG_OLDENHANCESVERSION}:          name := <span class="stri">"OLDENHANCESVERSION"</span>;
      <span class="keywd">when</span> {RPMTAG_OLDENHANCESFLAGS}:            name := <span class="stri">"OLDENHANCESFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_PRIORITY}:                    name := <span class="stri">"PRIORITY"</span>;
      <span class="keywd">when</span> {RPMTAG_CVSID}:                       name := <span class="stri">"CVSID"</span>;
      <span class="keywd">when</span> {RPMTAG_BLINKPKGID}:                  name := <span class="stri">"BLINKPKGID"</span>;
      <span class="keywd">when</span> {RPMTAG_BLINKHDRID}:                  name := <span class="stri">"BLINKHDRID"</span>;
      <span class="keywd">when</span> {RPMTAG_BLINKNEVRA}:                  name := <span class="stri">"BLINKNEVRA"</span>;
      <span class="keywd">when</span> {RPMTAG_FLINKPKGID}:                  name := <span class="stri">"FLINKPKGID"</span>;
      <span class="keywd">when</span> {RPMTAG_FLINKHDRID}:                  name := <span class="stri">"FLINKHDRID"</span>;
      <span class="keywd">when</span> {RPMTAG_FLINKNEVRA}:                  name := <span class="stri">"FLINKNEVRA"</span>;
      <span class="keywd">when</span> {RPMTAG_PACKAGEORIGIN}:               name := <span class="stri">"PACKAGEORIGIN"</span>;
      <span class="keywd">when</span> {RPMTAG_TRIGGERPREIN}:                name := <span class="stri">"TRIGGERPREIN"</span>;
      <span class="keywd">when</span> {RPMTAG_BUILDSUGGESTS}:               name := <span class="stri">"BUILDSUGGESTS"</span>;
      <span class="keywd">when</span> {RPMTAG_BUILDENHANCES}:               name := <span class="stri">"BUILDENHANCES"</span>;
      <span class="keywd">when</span> {RPMTAG_SCRIPTSTATES}:                name := <span class="stri">"SCRIPTSTATES"</span>;
      <span class="keywd">when</span> {RPMTAG_SCRIPTMETRICS}:               name := <span class="stri">"SCRIPTMETRICS"</span>;
      <span class="keywd">when</span> {RPMTAG_BUILDCPUCLOCK}:               name := <span class="stri">"BUILDCPUCLOCK"</span>;
      <span class="keywd">when</span> {RPMTAG_FILEDIGESTALGOS}:             name := <span class="stri">"FILEDIGESTALGOS"</span>;
      <span class="keywd">when</span> {RPMTAG_VARIANTS}:                    name := <span class="stri">"VARIANTS"</span>;
      <span class="keywd">when</span> {RPMTAG_XMAJOR}:                      name := <span class="stri">"XMAJOR"</span>;
      <span class="keywd">when</span> {RPMTAG_XMINOR}:                      name := <span class="stri">"XMINOR"</span>;
      <span class="keywd">when</span> {RPMTAG_REPOTAG}:                     name := <span class="stri">"REPOTAG"</span>;
      <span class="keywd">when</span> {RPMTAG_KEYWORDS}:                    name := <span class="stri">"KEYWORDS"</span>;
      <span class="keywd">when</span> {RPMTAG_BUILDPLATFORMS}:              name := <span class="stri">"BUILDPLATFORMS"</span>;
      <span class="keywd">when</span> {RPMTAG_PACKAGECOLOR}:                name := <span class="stri">"PACKAGECOLOR"</span>;
      <span class="keywd">when</span> {RPMTAG_PACKAGEPREFCOLOR}:            name := <span class="stri">"PACKAGEPREFCOLOR"</span>;
      <span class="keywd">when</span> {RPMTAG_XATTRSDICT}:                  name := <span class="stri">"XATTRSDICT"</span>;
      <span class="keywd">when</span> {RPMTAG_FILEXATTRSX}:                 name := <span class="stri">"FILEXATTRSX"</span>;
      <span class="keywd">when</span> {RPMTAG_DEPATTRSDICT}:                name := <span class="stri">"DEPATTRSDICT"</span>;
      <span class="keywd">when</span> {RPMTAG_CONFLICTATTRSX}:              name := <span class="stri">"CONFLICTATTRSX"</span>;
      <span class="keywd">when</span> {RPMTAG_OBSOLETEATTRSX}:              name := <span class="stri">"OBSOLETEATTRSX"</span>;
      <span class="keywd">when</span> {RPMTAG_PROVIDEATTRSX}:               name := <span class="stri">"PROVIDEATTRSX"</span>;
      <span class="keywd">when</span> {RPMTAG_REQUIREATTRSX}:               name := <span class="stri">"REQUIREATTRSX"</span>;
      <span class="keywd">when</span> {RPMTAG_BUILDPROVIDES}:               name := <span class="stri">"BUILDPROVIDES"</span>;
      <span class="keywd">when</span> {RPMTAG_BUILDOBSOLETES}:              name := <span class="stri">"BUILDOBSOLETES"</span>;
      <span class="keywd">when</span> {RPMTAG_DBINSTANCE}:                  name := <span class="stri">"DBINSTANCE"</span>;
      <span class="keywd">when</span> {RPMTAG_NVRA}:                        name := <span class="stri">"NVRA"</span>;
      <span class="keywd">when</span> {RPMTAG_FILENAMES}:                   name := <span class="stri">"FILENAMES"</span>;
      <span class="keywd">when</span> {RPMTAG_FILEPROVIDE}:                 name := <span class="stri">"FILEPROVIDE"</span>;
      <span class="keywd">when</span> {RPMTAG_FILEREQUIRE}:                 name := <span class="stri">"FILEREQUIRE"</span>;
      <span class="keywd">when</span> {RPMTAG_FSNAMES}:                     name := <span class="stri">"FSNAMES"</span>;
      <span class="keywd">when</span> {RPMTAG_FSSIZES}:                     name := <span class="stri">"FSSIZES"</span>;
      <span class="keywd">when</span> {RPMTAG_TRIGGERCONDS}:                name := <span class="stri">"TRIGGERCONDS"</span>;
      <span class="keywd">when</span> {RPMTAG_TRIGGERTYPE}:                 name := <span class="stri">"TRIGGERTYPE"</span>;
      <span class="keywd">when</span> {RPMTAG_ORIGFILENAMES}:               name := <span class="stri">"ORIGFILENAMES"</span>;
      <span class="keywd">when</span> {RPMTAG_LONGFILESIZES}:               name := <span class="stri">"LONGFILESIZES"</span>;
      <span class="keywd">when</span> {RPMTAG_LONGSIZE}:                    name := <span class="stri">"LONGSIZE"</span>;
      <span class="keywd">when</span> {RPMTAG_FILECAPS}:                    name := <span class="stri">"FILECAPS"</span>;
      <span class="keywd">when</span> {RPMTAG_FILEDIGESTALGO}:              name := <span class="stri">"FILEDIGESTALGO"</span>;
      <span class="keywd">when</span> {RPMTAG_BUGURL}:                      name := <span class="stri">"BUGURL"</span>;
      <span class="keywd">when</span> {RPMTAG_EVR}:                         name := <span class="stri">"EVR"</span>;
      <span class="keywd">when</span> {RPMTAG_NVR}:                         name := <span class="stri">"NVR"</span>;
      <span class="keywd">when</span> {RPMTAG_NEVR}:                        name := <span class="stri">"NEVR"</span>;
      <span class="keywd">when</span> {RPMTAG_NEVRA}:                       name := <span class="stri">"NEVRA"</span>;
      <span class="keywd">when</span> {RPMTAG_HEADERCOLOR}:                 name := <span class="stri">"HEADERCOLOR"</span>;
      <span class="keywd">when</span> {RPMTAG_VERBOSE}:                     name := <span class="stri">"VERBOSE"</span>;
      <span class="keywd">when</span> {RPMTAG_EPOCHNUM}:                    name := <span class="stri">"EPOCHNUM"</span>;
      <span class="keywd">when</span> {RPMTAG_PREINFLAGS}:                  name := <span class="stri">"PREINFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_POSTINFLAGS}:                 name := <span class="stri">"POSTINFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_PREUNFLAGS}:                  name := <span class="stri">"PREUNFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_POSTUNFLAGS}:                 name := <span class="stri">"POSTUNFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_PRETRANSFLAGS}:               name := <span class="stri">"PRETRANSFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_POSTTRANSFLAGS}:              name := <span class="stri">"POSTTRANSFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_VERIFYSCRIPTFLAGS}:           name := <span class="stri">"VERIFYSCRIPTFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_TRIGGERSCRIPTFLAGS}:          name := <span class="stri">"TRIGGERSCRIPTFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_COLLECTIONS}:                 name := <span class="stri">"COLLECTIONS"</span>;
      <span class="keywd">when</span> {RPMTAG_POLICYNAMES}:                 name := <span class="stri">"POLICYNAMES"</span>;
      <span class="keywd">when</span> {RPMTAG_POLICYTYPES}:                 name := <span class="stri">"POLICYTYPES"</span>;
      <span class="keywd">when</span> {RPMTAG_POLICYTYPESINDEXES}:          name := <span class="stri">"POLICYTYPESINDEXES"</span>;
      <span class="keywd">when</span> {RPMTAG_POLICYFLAGS}:                 name := <span class="stri">"POLICYFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_VCS}:                         name := <span class="stri">"VCS"</span>;
      <span class="keywd">when</span> {RPMTAG_ORDERNAME}:                   name := <span class="stri">"ORDERNAME"</span>;
      <span class="keywd">when</span> {RPMTAG_ORDERVERSION}:                name := <span class="stri">"ORDERVERSION"</span>;
      <span class="keywd">when</span> {RPMTAG_ORDERFLAGS}:                  name := <span class="stri">"ORDERFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_MSSFMANIFEST}:                name := <span class="stri">"MSSFMANIFEST"</span>;
      <span class="keywd">when</span> {RPMTAG_MSSFDOMAIN}:                  name := <span class="stri">"MSSFDOMAIN"</span>;
      <span class="keywd">when</span> {RPMTAG_INSTFILENAMES}:               name := <span class="stri">"INSTFILENAMES"</span>;
      <span class="keywd">when</span> {RPMTAG_REQUIRENEVRS}:                name := <span class="stri">"REQUIRENEVRS"</span>;
      <span class="keywd">when</span> {RPMTAG_PROVIDENEVRS}:                name := <span class="stri">"PROVIDENEVRS"</span>;
      <span class="keywd">when</span> {RPMTAG_OBSOLETENEVRS}:               name := <span class="stri">"OBSOLETENEVRS"</span>;
      <span class="keywd">when</span> {RPMTAG_CONFLICTNEVRS}:               name := <span class="stri">"CONFLICTNEVRS"</span>;
      <span class="keywd">when</span> {RPMTAG_FILENLINKS}:                  name := <span class="stri">"FILENLINKS"</span>;
      <span class="keywd">when</span> {RPMTAG_RECOMMENDNAME}:               name := <span class="stri">"RECOMMENDNAME"</span>;
      <span class="keywd">when</span> {RPMTAG_RECOMMENDVERSION}:            name := <span class="stri">"RECOMMENDVERSION"</span>;
      <span class="keywd">when</span> {RPMTAG_RECOMMENDFLAGS}:              name := <span class="stri">"RECOMMENDFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_SUGGESTNAME}:                 name := <span class="stri">"SUGGESTNAME"</span>;
      <span class="keywd">when</span> {RPMTAG_SUGGESTVERSION}:              name := <span class="stri">"SUGGESTVERSION"</span>;
      <span class="keywd">when</span> {RPMTAG_SUGGESTFLAGS}:                name := <span class="stri">"SUGGESTFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_SUPPLEMENTNAME}:              name := <span class="stri">"SUPPLEMENTNAME"</span>;
      <span class="keywd">when</span> {RPMTAG_SUPPLEMENTVERSION}:           name := <span class="stri">"SUPPLEMENTVERSION"</span>;
      <span class="keywd">when</span> {RPMTAG_SUPPLEMENTFLAGS}:             name := <span class="stri">"SUPPLEMENTFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_ENHANCENAME}:                 name := <span class="stri">"ENHANCENAME"</span>;
      <span class="keywd">when</span> {RPMTAG_ENHANCEVERSION}:              name := <span class="stri">"ENHANCEVERSION"</span>;
      <span class="keywd">when</span> {RPMTAG_ENHANCEFLAGS}:                name := <span class="stri">"ENHANCEFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_RECOMMENDNEVRS}:              name := <span class="stri">"RECOMMENDNEVRS"</span>;
      <span class="keywd">when</span> {RPMTAG_SUGGESTNEVRS}:                name := <span class="stri">"SUGGESTNEVRS"</span>;
      <span class="keywd">when</span> {RPMTAG_SUPPLEMENTNEVRS}:             name := <span class="stri">"SUPPLEMENTNEVRS"</span>;
      <span class="keywd">when</span> {RPMTAG_ENHANCENEVRS}:                name := <span class="stri">"ENHANCENEVRS"</span>;
      <span class="keywd">when</span> {RPMTAG_ENCODING}:                    name := <span class="stri">"ENCODING"</span>;
      <span class="keywd">when</span> {RPMTAG_FILETRIGGERIN}:               name := <span class="stri">"FILETRIGGERIN"</span>;
      <span class="keywd">when</span> {RPMTAG_FILETRIGGERUN}:               name := <span class="stri">"FILETRIGGERUN"</span>;
      <span class="keywd">when</span> {RPMTAG_FILETRIGGERPOSTUN}:           name := <span class="stri">"FILETRIGGERPOSTUN"</span>;
      <span class="keywd">when</span> {RPMTAG_FILETRIGGERSCRIPTS}:          name := <span class="stri">"FILETRIGGERSCRIPTS"</span>;
      <span class="keywd">when</span> {RPMTAG_FILETRIGGERSCRIPTPROG}:       name := <span class="stri">"FILETRIGGERSCRIPTPROG"</span>;
      <span class="keywd">when</span> {RPMTAG_FILETRIGGERSCRIPTFLAGS}:      name := <span class="stri">"FILETRIGGERSCRIPTFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_FILETRIGGERNAME}:             name := <span class="stri">"FILETRIGGERNAME"</span>;
      <span class="keywd">when</span> {RPMTAG_FILETRIGGERINDEX}:            name := <span class="stri">"FILETRIGGERINDEX"</span>;
      <span class="keywd">when</span> {RPMTAG_FILETRIGGERVERSION}:          name := <span class="stri">"FILETRIGGERVERSION"</span>;
      <span class="keywd">when</span> {RPMTAG_FILETRIGGERFLAGS}:            name := <span class="stri">"FILETRIGGERFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_TRANSFILETRIGGERIN}:          name := <span class="stri">"TRANSFILETRIGGERIN"</span>;
      <span class="keywd">when</span> {RPMTAG_TRANSFILETRIGGERUN}:          name := <span class="stri">"TRANSFILETRIGGERUN"</span>;
      <span class="keywd">when</span> {RPMTAG_TRANSFILETRIGGERPOSTUN}:      name := <span class="stri">"TRANSFILETRIGGERPOSTUN"</span>;
      <span class="keywd">when</span> {RPMTAG_TRANSFILETRIGGERSCRIPTS}:     name := <span class="stri">"TRANSFILETRIGGERSCRIPTS"</span>;
      <span class="keywd">when</span> {RPMTAG_TRANSFILETRIGGERSCRIPTPROG}:  name := <span class="stri">"TRANSFILETRIGGERSCRIPTPROG"</span>;
      <span class="keywd">when</span> {RPMTAG_TRANSFILETRIGGERSCRIPTFLAGS}: name := <span class="stri">"TRANSFILETRIGGERSCRIPTFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_TRANSFILETRIGGERNAME}:        name := <span class="stri">"TRANSFILETRIGGERNAME"</span>;
      <span class="keywd">when</span> {RPMTAG_TRANSFILETRIGGERINDEX}:       name := <span class="stri">"TRANSFILETRIGGERINDEX"</span>;
      <span class="keywd">when</span> {RPMTAG_TRANSFILETRIGGERVERSION}:     name := <span class="stri">"TRANSFILETRIGGERVERSION"</span>;
      <span class="keywd">when</span> {RPMTAG_TRANSFILETRIGGERFLAGS}:       name := <span class="stri">"TRANSFILETRIGGERFLAGS"</span>;
      <span class="keywd">when</span> {RPMTAG_REMOVEPATHPOSTFIXES}:         name := <span class="stri">"REMOVEPATHPOSTFIXES"</span>;
      <span class="keywd">when</span> {RPMTAG_FILETRIGGERPRIORITIES}:       name := <span class="stri">"FILETRIGGERPRIORITIES"</span>;
      <span class="keywd">when</span> {RPMTAG_TRANSFILETRIGGERPRIORITIES}:  name := <span class="stri">"TRANSFILETRIGGERPRIORITIES"</span>;
      <span class="keywd">when</span> {RPMTAG_FILETRIGGERCONDS}:            name := <span class="stri">"FILETRIGGERCONDS"</span>;
      <span class="keywd">when</span> {RPMTAG_FILETRIGGERTYPE}:             name := <span class="stri">"FILETRIGGERTYPE"</span>;
      <span class="keywd">when</span> {RPMTAG_TRANSFILETRIGGERCONDS}:       name := <span class="stri">"TRANSFILETRIGGERCONDS"</span>;
      <span class="keywd">when</span> {RPMTAG_TRANSFILETRIGGERTYPE}:        name := <span class="stri">"TRANSFILETRIGGERTYPE"</span>;
      <span class="keywd">when</span> {RPMTAG_FILESIGNATURES}:              name := <span class="stri">"FILESIGNATURES"</span>;
      <span class="keywd">when</span> {RPMTAG_FILESIGNATURELENGTH}:         name := <span class="stri">"FILESIGNATURELENGTH"</span>;
      <span class="keywd">when</span> {RPMTAG_PAYLOADDIGEST}:               name := <span class="stri">"PAYLOADDIGEST"</span>;
      <span class="keywd">when</span> {RPMTAG_PAYLOADDIGESTALGO}:           name := <span class="stri">"PAYLOADDIGESTALGO"</span>;
      <span class="keywd">when</span> {RPMTAG_AUTOINSTALLED}:               name := <span class="stri">"AUTOINSTALLED"</span>;
      <span class="keywd">when</span> {RPMTAG_IDENTITY}:                    name := <span class="stri">"IDENTITY"</span>;
      <span class="keywd">when</span> {RPMTAG_MODULARITYLABEL}:             name := <span class="stri">"MODULARITYLABEL"</span>;
      <span class="keywd">when</span> {RPMTAG_PAYLOADDIGESTALT}:            name := <span class="stri">"PAYLOADDIGESTALT"</span>;
      <span class="keywd">otherwise</span>: name := <span class="stri">"tag "</span> &lt;&amp; tag;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: rpmDependencyFlagsString (<span class="op">in</span> <span class="type">integer</span>: flags) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: flagsString <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: bitNum <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> bitNum <span class="keywd">range</span> 0 <span class="keywd">to</span> 28 <span class="keywd">do</span>
      <span class="comment"># writeln(bin32(flags) radix 16 &lt;&amp; " " &lt;&amp; bin32(1) &lt;&lt; bitNum radix 16 &lt;&amp; " " &lt;&amp; bin32(flags) &amp; (bin32(1) &lt;&lt; bitNum) &lt;&amp; " " &lt;&amp; bin32(flags) &amp; (bin32(1) &lt;&lt; bitNum) &lt;> bin32(0) &lt;&amp; " " &lt;&amp; bitNum);</span>
      <span class="keywd">if</span> bin32(flags) &amp; (bin32(1) &lt;&lt; bitNum) &lt;> bin32(0) <span class="keywd">then</span>
        <span class="keywd">if</span> flagsString &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          flagsString &amp;:= <span class="stri">", "</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">case</span> integer(bin32(1) &lt;&lt; bitNum) <span class="keywd">of</span>
          <span class="keywd">when</span> {1 &lt;&lt; 0}:                 flagsString &amp;:= <span class="stri">"UNUSED_0"</span>;
          <span class="keywd">when</span> {RPMSENSE_LESS}:          flagsString &amp;:= <span class="stri">"LESS"</span>;
          <span class="keywd">when</span> {RPMSENSE_GREATER}:       flagsString &amp;:= <span class="stri">"GREATER"</span>;
          <span class="keywd">when</span> {RPMSENSE_EQUAL}:         flagsString &amp;:= <span class="stri">"EQUAL"</span>;
          <span class="keywd">when</span> {1 &lt;&lt; 4}:                 flagsString &amp;:= <span class="stri">"UNUSED_4"</span>;
          <span class="keywd">when</span> {RPMSENSE_POSTTRANS}:     flagsString &amp;:= <span class="stri">"POSTTRANS"</span>;
          <span class="keywd">when</span> {RPMSENSE_PREREQ}:        flagsString &amp;:= <span class="stri">"PREREQ"</span>;
          <span class="keywd">when</span> {RPMSENSE_PRETRANS}:      flagsString &amp;:= <span class="stri">"PRETRANS"</span>;
          <span class="keywd">when</span> {RPMSENSE_INTERP}:        flagsString &amp;:= <span class="stri">"INTERP"</span>;
          <span class="keywd">when</span> {RPMSENSE_SCRIPT_PRE}:    flagsString &amp;:= <span class="stri">"SCRIPT_PRE"</span>;
          <span class="keywd">when</span> {RPMSENSE_SCRIPT_POST}:   flagsString &amp;:= <span class="stri">"SCRIPT_POST"</span>;
          <span class="keywd">when</span> {RPMSENSE_SCRIPT_PREUN}:  flagsString &amp;:= <span class="stri">"SCRIPT_PREUN"</span>;
          <span class="keywd">when</span> {RPMSENSE_SCRIPT_POSTUN}: flagsString &amp;:= <span class="stri">"SCRIPT_POSTUN"</span>;
          <span class="keywd">when</span> {RPMSENSE_SCRIPT_VERIFY}: flagsString &amp;:= <span class="stri">"SCRIPT_VERIFY"</span>;
          <span class="keywd">when</span> {RPMSENSE_FIND_REQUIRES}: flagsString &amp;:= <span class="stri">"FIND_REQUIRES"</span>;
          <span class="keywd">when</span> {RPMSENSE_FIND_PROVIDES}: flagsString &amp;:= <span class="stri">"FIND_PROVIDES"</span>;
          <span class="keywd">when</span> {RPMSENSE_TRIGGERIN}:     flagsString &amp;:= <span class="stri">"TRIGGERIN"</span>;
          <span class="keywd">when</span> {RPMSENSE_TRIGGERUN}:     flagsString &amp;:= <span class="stri">"TRIGGERUN"</span>;
          <span class="keywd">when</span> {RPMSENSE_TRIGGERPOSTUN}: flagsString &amp;:= <span class="stri">"TRIGGERPOSTUN"</span>;
          <span class="keywd">when</span> {RPMSENSE_MISSINGOK}:     flagsString &amp;:= <span class="stri">"MISSINGOK"</span>;
          <span class="keywd">when</span> {1 &lt;&lt; 20}:                flagsString &amp;:= <span class="stri">"UNUSED_20"</span>;
          <span class="keywd">when</span> {1 &lt;&lt; 21}:                flagsString &amp;:= <span class="stri">"UNUSED_21"</span>;
          <span class="keywd">when</span> {1 &lt;&lt; 22}:                flagsString &amp;:= <span class="stri">"UNUSED_22"</span>;
          <span class="keywd">when</span> {1 &lt;&lt; 23}:                flagsString &amp;:= <span class="stri">"UNUSED_23"</span>;
          <span class="keywd">when</span> {RPMSENSE_RPMLIB}:        flagsString &amp;:= <span class="stri">"RPMLIB"</span>;
          <span class="keywd">when</span> {RPMSENSE_TRIGGERPREIN}:  flagsString &amp;:= <span class="stri">"TRIGGERPREIN"</span>;
          <span class="keywd">when</span> {RPMSENSE_KEYRING}:       flagsString &amp;:= <span class="stri">"KEYRING"</span>;
          <span class="keywd">when</span> {1 &lt;&lt; 27}:                flagsString &amp;:= <span class="stri">"UNUSED_27"</span>;
          <span class="keywd">when</span> {RPMSENSE_CONFIG}:        flagsString &amp;:= <span class="stri">"CONFIG"</span>;
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    flagsString &amp;:= <span class="stri">" "</span> &lt;&amp; flags radix 16;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: show (<span class="op">in</span> <span class="type">rpmLead</span>: lead) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> lead.magic = RPM_LEAD_MAGIC <span class="keywd">then</span>
      writeln(<span class="stri">"Version "</span> &lt;&amp; lead.majorVersion &lt;&amp; <span class="stri">"."</span> &lt;&amp; lead.minorVersion);
      writeln(<span class="stri">"Type: "</span> &lt;&amp; lead.fileType);
      writeln(<span class="stri">"Arch: "</span> &lt;&amp; lead.arch);
      writeln(<span class="stri">"Name: "</span> &lt;&amp; literal(lead.name));
      writeln(<span class="stri">"Os: "</span> &lt;&amp; lead.os);
      writeln(<span class="stri">"Signature version: "</span> &lt;&amp; lead.sig);
    <span class="keywd">else</span>
      writeln(<span class="stri">" *** Rpm lead magic not okay."</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: show (<span class="op">in</span> <span class="type">rpmHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: idx <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> header.magic = RPM_HEADER_MAGIC <span class="keywd">then</span>
      writeln(<span class="stri">"Header version: "</span> &lt;&amp; header.version);
      writeln(<span class="stri">"IndexCount: "</span> &lt;&amp; header.indexCount);
      writeln(<span class="stri">"StoreSize: "</span> &lt;&amp; header.storeSize);
    <span class="keywd">else</span>
      writeln(<span class="stri">" *** Rpm header magic not okay."</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getStriValue (<span class="op">in</span> <span class="type">string</span>: store,
    <span class="op">in</span> <span class="type">rpmIndexEntry</span>: indexEntry) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: data <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: currPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> indexEntry.dataType <span class="keywd">of</span>
      <span class="keywd">when</span> {RPM_NULL_TYPE}:
        data := <span class="stri">""</span>;
      <span class="keywd">when</span> {RPM_CHAR_TYPE}:
        data := store[succ(indexEntry.offset) fixLen indexEntry.count];
      <span class="keywd">when</span> {RPM_INT8_TYPE}:
        data := store[succ(indexEntry.offset) fixLen indexEntry.count];
      <span class="keywd">when</span> {RPM_INT16_TYPE}:
        data := store[succ(indexEntry.offset) fixLen 2 * indexEntry.count];
      <span class="keywd">when</span> {RPM_INT32_TYPE}:
        data := store[succ(indexEntry.offset) fixLen 4 * indexEntry.count];
      <span class="keywd">when</span> {RPM_INT64_TYPE}:
        data := store[succ(indexEntry.offset) fixLen 8 * indexEntry.count];
      <span class="keywd">when</span> {RPM_STRING_TYPE}:
        currPos := succ(indexEntry.offset);
        data := getAsciiz(store, currPos);
      <span class="keywd">when</span> {RPM_BIN_TYPE}:
        data := store[succ(indexEntry.offset) fixLen indexEntry.count];
      <span class="keywd">when</span> {RPM_STRING_ARRAY_TYPE, RPM_I18NSTRING_TYPE}:
        currPos := succ(indexEntry.offset);
        <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> indexEntry.count <span class="keywd">do</span>
          data &amp;:= getAsciiz(store, currPos) &amp; <span class="stri">"\0;"</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: getArrayValue (<span class="op">in</span> <span class="type">string</span>: store,
    <span class="op">in</span> <span class="type">rpmIndexEntry</span>: indexEntry) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: arrayValue <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: currPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> indexEntry.dataType <span class="keywd">of</span>
      <span class="keywd">when</span> {RPM_STRING_ARRAY_TYPE, RPM_I18NSTRING_TYPE}:
        currPos := succ(indexEntry.offset);
        <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> indexEntry.count <span class="keywd">do</span>
          arrayValue &amp;:= getAsciiz(store, currPos);
        <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getIntValue (<span class="op">in</span> <span class="type">string</span>: store,
    <span class="op">in</span> <span class="type">rpmIndexEntry</span>: indexEntry) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> indexEntry.dataType <span class="keywd">of</span>
      <span class="keywd">when</span> {RPM_INT8_TYPE}:
        number := bytes2Int(store[succ(indexEntry.offset) fixLen 1], UNSIGNED, BE);
      <span class="keywd">when</span> {RPM_INT16_TYPE}:
        number := bytes2Int(store[succ(indexEntry.offset) fixLen 2], UNSIGNED, BE);
      <span class="keywd">when</span> {RPM_INT32_TYPE}:
        number := bytes2Int(store[succ(indexEntry.offset) fixLen 4], UNSIGNED, BE);
      <span class="keywd">when</span> {RPM_INT64_TYPE}:
        number := bytes2Int(store[succ(indexEntry.offset) fixLen 8], UNSIGNED, BE);
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readLead (<span class="keywd">inout</span> <span class="type">file</span>: rpmFile, <span class="keywd">inout</span> <span class="type">rpmLead</span>: lead) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: leadStri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    leadStri := gets(rpmFile, RPM_LEAD_SIZE);
    <span class="keywd">if</span> length(leadStri) = RPM_LEAD_SIZE <span class="keywd">then</span>
      lead.magic        :=           leadStri[ 1 fixLen  4];
      lead.majorVersion := bytes2Int(leadStri[ 5 fixLen  1], UNSIGNED, BE);
      lead.minorVersion := bytes2Int(leadStri[ 6 fixLen  1], UNSIGNED, BE);
      lead.fileType     := bytes2Int(leadStri[ 7 fixLen  2], UNSIGNED, BE);
      lead.arch         := bytes2Int(leadStri[ 9 fixLen  2], UNSIGNED, BE);
      lead.name         :=           leadStri[11 fixLen 66];
      lead.os           := bytes2Int(leadStri[77 fixLen  2], UNSIGNED, BE);
      lead.sig          := bytes2Int(leadStri[79 fixLen  2], UNSIGNED, BE);
      <span class="comment"># 16 reserved bytes are currently unused.</span>
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">rpmLead</span>: lead) <span class="keywd">is</span>
  <span class="keywd">return</span> lead.magic &lt;&amp;
         bytes(lead.majorVersion, UNSIGNED, BE, 1) &lt;&amp;
         bytes(lead.minorVersion, UNSIGNED, BE, 1) &lt;&amp;
         bytes(lead.fileType,     UNSIGNED, BE, 2) &lt;&amp;
         bytes(lead.arch,         UNSIGNED, BE, 2) &lt;&amp;
               lead.name <span class="op">rpad</span> 66                   &lt;&amp;
         bytes(lead.os,           UNSIGNED, BE, 2) &lt;&amp;
         bytes(lead.sig,          UNSIGNED, BE, 2) &lt;&amp;
         <span class="stri">"\0;"</span> <span class="op">mult</span> 16;   <span class="comment"># 16 reserved bytes</span>


<span class="keywd">const</span> <span class="type">proc</span>: writeLead (<span class="keywd">inout</span> <span class="type">file</span>: outFile, <span class="keywd">inout</span> <span class="type">rpmLead</span>: lead) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    lead.magic := RPM_LEAD_MAGIC;
    lead.majorVersion := 3;
    lead.minorVersion := 0;
    lead.fileType := 1;
    lead.arch := 1;
    lead.name := <span class="stri">""</span>;
    lead.os := 1;
    lead.sig := 5;
    write(outFile, str(lead));
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readHeader (<span class="keywd">inout</span> <span class="type">file</span>: rpmFile, <span class="keywd">inout</span> <span class="type">rpmHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: headerStri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    headerStri := gets(rpmFile, RPM_HEADER_SIZE);
    <span class="keywd">if</span> length(headerStri) = RPM_HEADER_SIZE <span class="keywd">then</span>
      header.magic         :=           headerStri[ 1 fixLen 3];
      header.version       := bytes2Int(headerStri[ 4 fixLen 1], UNSIGNED, BE);
      header.reservedBytes :=           headerStri[ 5 fixLen 4];
      header.indexCount    := bytes2Int(headerStri[ 9 fixLen 4], UNSIGNED, BE);
      header.storeSize     := bytes2Int(headerStri[13 fixLen 4], UNSIGNED, BE);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">rpmHeader</span>: header) <span class="keywd">is</span>
  <span class="keywd">return</span>       header.magic &lt;&amp;
         bytes(header.version,    UNSIGNED, BE, 1) &lt;&amp;
               header.reservedBytes &lt;&amp;
         bytes(header.indexCount, UNSIGNED, BE, 4) &lt;&amp;
         bytes(header.storeSize,  UNSIGNED, BE, 4);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">rpmIndexEntry</span>: indexEntry) <span class="keywd">is</span>
  <span class="keywd">return</span> bytes(indexEntry.tag,      UNSIGNED, BE, 4) &lt;&amp;
         bytes(indexEntry.dataType, UNSIGNED, BE, 4) &lt;&amp;
         bytes(indexEntry.offset,   SIGNED,   BE, 4) &lt;&amp;
         bytes(indexEntry.count,    UNSIGNED, BE, 4);


<span class="keywd">const</span> <span class="type">type</span>: rpmCatalogEntry <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: fileSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: mode <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: uid <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: gid <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: rdev <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: mtime <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: digest <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: linkTo <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: flags <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: userName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: groupName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: verifyFlags <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: device <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: inode <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: lang <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: dirIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: baseName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: color <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: fileClass <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: dependX <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: dependN <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: allDataPresent <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">string</span>: filePath <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: fileNumber <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: dirty <span class="keywd">is</span> FALSE;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: write (<span class="op">in</span> <span class="type">rpmCatalogEntry</span>: catalogEntry) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"fileSize: "</span> &lt;&amp; catalogEntry.fileSize);
    writeln(<span class="stri">"mode: "</span> &lt;&amp; catalogEntry.mode);
    writeln(<span class="stri">"uid: "</span> &lt;&amp; catalogEntry.uid);
    writeln(<span class="stri">"gid: "</span> &lt;&amp; catalogEntry.gid);
    writeln(<span class="stri">"rdev: "</span> &lt;&amp; catalogEntry.rdev);
    writeln(<span class="stri">"mtime: "</span> &lt;&amp; catalogEntry.mtime);
    writeln(<span class="stri">"digest: "</span> &lt;&amp; catalogEntry.digest);
    writeln(<span class="stri">"linkTo: "</span> &lt;&amp; catalogEntry.linkTo);
    writeln(<span class="stri">"flags: "</span> &lt;&amp; catalogEntry.flags);
    writeln(<span class="stri">"userName: "</span> &lt;&amp; catalogEntry.userName);
    writeln(<span class="stri">"groupName: "</span> &lt;&amp; catalogEntry.groupName);
    writeln(<span class="stri">"verifyFlags: "</span> &lt;&amp; catalogEntry.verifyFlags);
    writeln(<span class="stri">"device: "</span> &lt;&amp; catalogEntry.device);
    writeln(<span class="stri">"inode: "</span> &lt;&amp; catalogEntry.inode);
    writeln(<span class="stri">"lang: "</span> &lt;&amp; catalogEntry.lang);
    writeln(<span class="stri">"dirIndex: "</span> &lt;&amp; catalogEntry.dirIndex);
    writeln(<span class="stri">"baseName: "</span> &lt;&amp; catalogEntry.baseName);
    writeln(<span class="stri">"color: "</span> &lt;&amp; catalogEntry.color);
    writeln(<span class="stri">"fileClass: "</span> &lt;&amp; catalogEntry.fileClass);
    writeln(<span class="stri">"dependX: "</span> &lt;&amp; catalogEntry.dependX);
    writeln(<span class="stri">"dependN: "</span> &lt;&amp; catalogEntry.dependN);
    writeln(<span class="stri">"allDataPresent: "</span> &lt;&amp; catalogEntry.allDataPresent);
    writeln(<span class="stri">"filePath: "</span> &lt;&amp; catalogEntry.filePath);
    writeln(<span class="stri">"fileNumber: "</span> &lt;&amp; catalogEntry.fileNumber);
    writeln(<span class="stri">"dirty: "</span> &lt;&amp; catalogEntry.dirty);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: rpmDependency <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: flags <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: version <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: rpmCatalogType <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">string</span><span class="type">]</span> <span class="type">rpmCatalogEntry</span>;

<span class="keywd">const</span> <span class="type">type</span>: rpmSection <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">rpmHeader</span>: head <span class="keywd">is</span> rpmHeader.value;
    <span class="keywd">var</span> <span class="type">rpmTagMap</span>: tagMap <span class="keywd">is</span> rpmTagMap.value;
    <span class="keywd">var</span> <span class="type">string</span>: indexData <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: store <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="comment">(**
 *  [[filesys#fileSys|FileSys]] implementation type to access a RPM archive.
 *  File paths in a rpm archive can be absolute (they start with a slash)
 *  or relative (they do not start with a slash). The rpm file system does
 *  not support the concept of a current working directory. The functions
 *  chdir and getcwd are not supported by the rpm file system. Absolute
 *  and relative paths in a rpm archive can be accessed directly.
 *  Since "/" is just a normal path in a rpm archive the root path of a
 *  rpm file system is "". Possible usages of rpm file system functions are:
 *    getMTime(aRpmFile, "src/drivers")   # Relative path in the archive.
 *    fileType(aRpmFile, "/usr/include")  # Absolute path in the archive.
 *    fileSize(aRpmFile, "/image")        # Absolute path in the archive.
 *    readDir(aRpmFile, "")               # Return e.g.: "src" and "/"
 *    readDir(aRpmFile, "/")              # Return e.g.: "usr" and "image"
 *)</span>
<span class="keywd">const</span> <span class="type">type</span>: rpmArchive <span class="keywd">is</span> sub emptyFileSys <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">file</span>: rpmFile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">rpmLead</span>: lead <span class="keywd">is</span> rpmLead.value;
    <span class="keywd">var</span> <span class="type">rpmSection</span>: signature <span class="keywd">is</span> rpmSection.value;
    <span class="keywd">var</span> <span class="type">rpmSection</span>: header <span class="keywd">is</span> rpmSection.value;
    <span class="keywd">var</span> <span class="type">integer</span>: payloadPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">archiveRegisterType</span>: register <span class="keywd">is</span> archiveRegisterType.value;
    <span class="keywd">var</span> <span class="type">rpmCatalogType</span>: catalog <span class="keywd">is</span> rpmCatalogType.value;
    <span class="keywd">var</span> <span class="type">integer</span>: fileDigestAlgo <span class="keywd">is</span> RPM_DIGESTALGO_MD5;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: dirNameList <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: classDict <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">rpmDependency</span>: provided <span class="keywd">is</span> 0 <span class="op">times</span> rpmDependency.value;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">rpmDependency</span>: required <span class="keywd">is</span> 0 <span class="op">times</span> rpmDependency.value;
    <span class="keywd">var</span> <span class="type">file</span>: payloadFile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">fileSys</span>: archive <span class="keywd">is</span> fileSys.value;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: getStringArray (<span class="op">in</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">integer</span>: tag) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: stringArray <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmIndexEntry</span>: stringArrayIndex <span class="keywd">is</span> rpmIndexEntry.value;
    <span class="keywd">var</span> <span class="type">integer</span>: stringPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> tag <span class="op">in</span> rpm.header.tagMap <span class="keywd">then</span>
      stringArrayIndex := rpm.header.tagMap[tag];
      stringPos := succ(stringArrayIndex.offset);
      stringArray := stringArrayIndex.count <span class="op">times</span> <span class="stri">""</span>;
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> stringArrayIndex.count <span class="keywd">do</span>
        stringArray[index] := getAsciiz(rpm.header.store, stringPos);
        <span class="comment"># writeln(rpmtagName(tag) &lt;&amp; "[" &lt;&amp; index &lt;&amp; "]: " &lt;&amp; stringArray[index]);</span>
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: createMinimumOfCatalog (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: oldFileNamePos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: dirIndexPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: baseNamePos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: digestPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: linkToPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: userNamePos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: groupNamePos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: langPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: numberOfFiles <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: filePath8 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">rpmCatalogEntry</span>: catalogEntry <span class="keywd">is</span> rpmCatalogEntry.value;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> RPMTAG_OLDFILENAMES <span class="op">in</span> rpm.header.tagMap <span class="keywd">then</span>
      oldFileNamePos := succ(rpm.header.tagMap[RPMTAG_OLDFILENAMES].offset);
    <span class="keywd">else</span>
      rpm.dirNameList := getStringArray(rpm, RPMTAG_DIRNAMES);
      dirIndexPos := succ(rpm.header.tagMap[RPMTAG_DIRINDEXES].offset);
      baseNamePos := succ(rpm.header.tagMap[RPMTAG_BASENAMES].offset);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    digestPos := succ(rpm.header.tagMap[RPMTAG_FILEMD5S].offset);
    linkToPos := succ(rpm.header.tagMap[RPMTAG_FILELINKTOS].offset);
    userNamePos := succ(rpm.header.tagMap[RPMTAG_FILEUSERNAME].offset);
    groupNamePos := succ(rpm.header.tagMap[RPMTAG_FILEGROUPNAME].offset);
    langPos := succ(rpm.header.tagMap[RPMTAG_FILELANGS].offset);
    numberOfFiles := rpm.header.tagMap[RPMTAG_FILESIZES].count;
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> numberOfFiles <span class="keywd">do</span>
      <span class="keywd">if</span> oldFileNamePos &lt;> 0 <span class="keywd">then</span>
        filePath8 := getAsciiz(rpm.header.store, oldFileNamePos);
      <span class="keywd">else</span>
        catalogEntry.dirIndex := succ(bytes2Int(
            rpm.header.store[dirIndexPos fixLen 4], SIGNED, BE));
        dirIndexPos +:= 4;
        catalogEntry.baseName := getAsciiz(rpm.header.store, baseNamePos);
        filePath8 := rpm.dirNameList[catalogEntry.dirIndex];
        <span class="comment"># writeln("dirName[" &lt;&amp; index &lt;&amp; "]: " &lt;&amp; filePath8);</span>
        filePath8 &amp;:= catalogEntry.baseName;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">block</span>
        catalogEntry.filePath := fromUtf8(filePath8);
      exception
        catch RANGE_ERROR:
          catalogEntry.filePath := filePath8;
      <span class="keywd">end</span> <span class="keywd">block</span>;
      catalogEntry.digest := getAsciiz(rpm.header.store, digestPos);
      catalogEntry.linkTo := getAsciiz(rpm.header.store, linkToPos);
      catalogEntry.userName  := getAsciiz(rpm.header.store, userNamePos);
      catalogEntry.groupName := getAsciiz(rpm.header.store, groupNamePos);
      catalogEntry.lang := getAsciiz(rpm.header.store, langPos);
      catalogEntry.fileNumber := index;
      rpm.catalog @:= [catalogEntry.filePath] catalogEntry;
      rpm.register @:= [catalogEntry.filePath] index;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getInt (<span class="op">in</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">integer</span>: tag, <span class="op">in</span> <span class="type">integer</span>: index) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmIndexEntry</span>: indexEntry <span class="keywd">is</span> rpmIndexEntry.value;
    <span class="keywd">var</span> <span class="type">integer</span>: offset <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> tag <span class="op">in</span> rpm.header.tagMap <span class="keywd">then</span>
      indexEntry := rpm.header.tagMap[tag];
      <span class="keywd">if</span> index &lt;= indexEntry.count <span class="keywd">then</span>
        offset := succ(indexEntry.offset);
        <span class="keywd">case</span> indexEntry.dataType <span class="keywd">of</span>
          <span class="keywd">when</span> {RPM_INT8_TYPE}:
            pos := offset + pred(index);
            number := bytes2Int(rpm.header.store[pos fixLen 1], UNSIGNED, BE);
          <span class="keywd">when</span> {RPM_INT16_TYPE}:
            pos := offset + pred(index) * 2;
            number := bytes2Int(rpm.header.store[pos fixLen 2], UNSIGNED, BE);
          <span class="keywd">when</span> {RPM_INT32_TYPE}:
            pos := offset + pred(index) * 4;
            number := bytes2Int(rpm.header.store[pos fixLen 4], UNSIGNED, BE);
          <span class="keywd">when</span> {RPM_INT64_TYPE}:
            pos := offset + pred(index) * 8;
            number := bytes2Int(rpm.header.store[pos fixLen 8], UNSIGNED, BE);
          <span class="keywd">otherwise</span>:
            raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">else</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readCatalogEntry (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="keywd">inout</span> <span class="type">rpmCatalogEntry</span>: catalogEntry) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: fileNumber <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    fileNumber := catalogEntry.fileNumber;
    <span class="keywd">if</span> fileNumber = 0 <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      catalogEntry.fileSize    := getInt(rpm, RPMTAG_FILESIZES,       fileNumber);
      catalogEntry.mode        := getInt(rpm, RPMTAG_FILEMODES,       fileNumber);
      catalogEntry.uid         := getInt(rpm, RPMTAG_FILEUIDS,        fileNumber);
      catalogEntry.gid         := getInt(rpm, RPMTAG_FILEGIDS,        fileNumber);
      catalogEntry.rdev        := getInt(rpm, RPMTAG_FILERDEVS,       fileNumber);
      catalogEntry.mtime       := getInt(rpm, RPMTAG_FILEMTIMES,      fileNumber);
      catalogEntry.flags       := getInt(rpm, RPMTAG_FILEFLAGS,       fileNumber);
      catalogEntry.verifyFlags := getInt(rpm, RPMTAG_FILEVERIFYFLAGS, fileNumber);
      catalogEntry.device      := getInt(rpm, RPMTAG_FILEDEVICES,     fileNumber);
      catalogEntry.inode       := getInt(rpm, RPMTAG_FILEINODES,      fileNumber);
      catalogEntry.color       := getInt(rpm, RPMTAG_FILECOLORS,      fileNumber);
      catalogEntry.fileClass   := getInt(rpm, RPMTAG_FILECLASS,       fileNumber);
      catalogEntry.dependX     := getInt(rpm, RPMTAG_FILEDEPENDSX,    fileNumber);
      catalogEntry.dependN     := getInt(rpm, RPMTAG_FILEDEPENDSN,    fileNumber);
      catalogEntry.allDataPresent := TRUE;
      rpm.catalog @:= [catalogEntry.filePath] catalogEntry;
      <span class="comment"># write(catalogEntry);</span>
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: updateIndexEntry (<span class="keywd">inout</span> <span class="type">rpmSection</span>: section, <span class="op">in</span> <span class="type">integer</span>: tag,
    <span class="op">in</span> <span class="type">integer</span>: dataType, <span class="op">in</span> <span class="type">integer</span>: value) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmIndexEntry</span>: indexEntry <span class="keywd">is</span> rpmIndexEntry.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> tag <span class="op">in</span> section.tagMap <span class="keywd">then</span>
      indexEntry := section.tagMap[tag];
    <span class="keywd">else</span>
      indexEntry.tag := tag;
      indexEntry.dataType := dataType;
      indexEntry.count := 1;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">case</span> indexEntry.dataType <span class="keywd">of</span>
      <span class="keywd">when</span> {RPM_INT8_TYPE}:
        indexEntry.striValue := bytes(value, UNSIGNED, BE, 1);
      <span class="keywd">when</span> {RPM_INT16_TYPE}:
        indexEntry.striValue := bytes(value, UNSIGNED, BE, 2);
      <span class="keywd">when</span> {RPM_INT32_TYPE}:
        indexEntry.striValue := bytes(value, UNSIGNED, BE, 4);
      <span class="keywd">when</span> {RPM_INT64_TYPE}:
        indexEntry.striValue := bytes(value, UNSIGNED, BE, 8);
      <span class="keywd">otherwise</span>:
        raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">case</span>;
    section.tagMap @:= [tag] indexEntry;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: updateIndexEntry (<span class="keywd">inout</span> <span class="type">rpmSection</span>: section, <span class="op">in</span> <span class="type">integer</span>: tag,
    <span class="op">in</span> <span class="type">integer</span>: dataType, <span class="op">in</span> <span class="type">string</span>: value) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmIndexEntry</span>: indexEntry <span class="keywd">is</span> rpmIndexEntry.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> tag <span class="op">in</span> section.tagMap <span class="keywd">then</span>
      indexEntry := section.tagMap[tag];
    <span class="keywd">else</span>
      indexEntry.tag := tag;
      indexEntry.dataType := dataType;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">case</span> indexEntry.dataType <span class="keywd">of</span>
      <span class="keywd">when</span> {RPM_STRING_TYPE}:
        indexEntry.count := 1;
        indexEntry.striValue := value;
      <span class="keywd">when</span> {RPM_BIN_TYPE}:
        indexEntry.count := length(value);
        indexEntry.striValue := value;
      <span class="keywd">otherwise</span>:
        raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">case</span>;
    section.tagMap @:= [tag] indexEntry;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: updateIndexEntry (<span class="keywd">inout</span> <span class="type">rpmSection</span>: section, <span class="op">in</span> <span class="type">integer</span>: tag,
    <span class="op">in</span> <span class="type">integer</span>: dataType, <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: value) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmIndexEntry</span>: indexEntry <span class="keywd">is</span> rpmIndexEntry.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> tag <span class="op">in</span> section.tagMap <span class="keywd">then</span>
      indexEntry := section.tagMap[tag];
    <span class="keywd">else</span>
      indexEntry.tag := tag;
      indexEntry.dataType := dataType;
      indexEntry.count := length(value);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    indexEntry.arrayValue := value;
    section.tagMap @:= [tag] indexEntry;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: updateIndexEntry (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">integer</span>: tag,
    <span class="op">in</span> <span class="type">integer</span>: dataType, <span class="op">in</span> <span class="type">integer</span>: fileNumber, <span class="op">in</span> <span class="type">integer</span>: value) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmIndexEntry</span>: indexEntry <span class="keywd">is</span> rpmIndexEntry.value;
    <span class="keywd">var</span> <span class="type">integer</span>: dataSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: data <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> tag <span class="op">in</span> rpm.header.tagMap <span class="keywd">then</span>
      indexEntry := rpm.header.tagMap[tag];
    <span class="keywd">else</span>
      indexEntry.tag := tag;
      indexEntry.dataType := dataType;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">case</span> indexEntry.dataType <span class="keywd">of</span>
      <span class="keywd">when</span> {RPM_INT8_TYPE}:
        dataSize := 1;
        data := bytes(value, UNSIGNED, BE, 1);
      <span class="keywd">when</span> {RPM_INT16_TYPE}:
        dataSize := 2;
        data := bytes(value, UNSIGNED, BE, 2);
      <span class="keywd">when</span> {RPM_INT32_TYPE}:
        dataSize := 4;
        data := bytes(value, UNSIGNED, BE, 4);
      <span class="keywd">when</span> {RPM_INT64_TYPE}:
        dataSize := 8;
        data := bytes(value, UNSIGNED, BE, 8);
      <span class="keywd">otherwise</span>:
        raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">if</span> fileNumber > indexEntry.count <span class="keywd">then</span>
      indexEntry.striValue &amp;:= <span class="stri">"\0;"</span> <span class="op">mult</span> (fileNumber - indexEntry.count) * dataSize;
      indexEntry.count := fileNumber;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    indexEntry.striValue @:= [succ(pred(fileNumber) * dataSize)] data;
    rpm.header.tagMap @:= [tag] indexEntry;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: updateIndexEntry (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">integer</span>: tag,
    <span class="op">in</span> <span class="type">integer</span>: dataType, <span class="op">in</span> <span class="type">integer</span>: fileNumber, <span class="op">in</span> <span class="type">string</span>: value) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmIndexEntry</span>: indexEntry <span class="keywd">is</span> rpmIndexEntry.value;
    <span class="keywd">var</span> <span class="type">string</span>: data <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> tag <span class="op">in</span> rpm.header.tagMap <span class="keywd">then</span>
      indexEntry := rpm.header.tagMap[tag];
    <span class="keywd">else</span>
      indexEntry.tag := tag;
      indexEntry.dataType := dataType;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">case</span> indexEntry.dataType <span class="keywd">of</span>
      <span class="keywd">when</span> {RPM_STRING_ARRAY_TYPE, RPM_I18NSTRING_TYPE}:
        data := value;
      <span class="keywd">otherwise</span>:
        raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">if</span> fileNumber > indexEntry.count <span class="keywd">then</span>
      indexEntry.arrayValue &amp;:= (fileNumber - indexEntry.count) <span class="op">times</span> <span class="stri">""</span>;
      indexEntry.count := fileNumber;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    indexEntry.arrayValue[fileNumber] := data;
    rpm.header.tagMap @:= [tag] indexEntry;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: updateHeader (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">rpmCatalogEntry</span>: catalogEntry) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    updateIndexEntry(rpm, RPMTAG_FILESIZES, RPM_INT32_TYPE,
                     catalogEntry.fileNumber, catalogEntry.fileSize);
    updateIndexEntry(rpm, RPMTAG_FILEMODES, RPM_INT16_TYPE,
                     catalogEntry.fileNumber, catalogEntry.mode);
    <span class="comment"># RPMTAG_FILEUIDS</span>
    <span class="comment"># RPMTAG_FILEGIDS</span>
    updateIndexEntry(rpm, RPMTAG_FILERDEVS, RPM_INT16_TYPE,
                     catalogEntry.fileNumber, catalogEntry.rdev);
    updateIndexEntry(rpm, RPMTAG_FILEMTIMES, RPM_INT32_TYPE,
                     catalogEntry.fileNumber, catalogEntry.mtime);
    updateIndexEntry(rpm, RPMTAG_FILEMD5S, RPM_STRING_ARRAY_TYPE,
                     catalogEntry.fileNumber, catalogEntry.digest);
    updateIndexEntry(rpm, RPMTAG_FILELINKTOS, RPM_STRING_ARRAY_TYPE,
                     catalogEntry.fileNumber, catalogEntry.linkTo);
    updateIndexEntry(rpm, RPMTAG_FILEFLAGS, RPM_INT32_TYPE,
                     catalogEntry.fileNumber, catalogEntry.flags);
    updateIndexEntry(rpm, RPMTAG_FILEUSERNAME, RPM_STRING_ARRAY_TYPE,
                     catalogEntry.fileNumber, catalogEntry.userName);
    updateIndexEntry(rpm, RPMTAG_FILEGROUPNAME, RPM_STRING_ARRAY_TYPE,
                     catalogEntry.fileNumber, catalogEntry.groupName);
    updateIndexEntry(rpm, RPMTAG_FILEVERIFYFLAGS, RPM_INT32_TYPE,
                     catalogEntry.fileNumber, catalogEntry.verifyFlags);
    updateIndexEntry(rpm, RPMTAG_FILEDEVICES, RPM_INT32_TYPE,
                     catalogEntry.fileNumber, catalogEntry.device);
    updateIndexEntry(rpm, RPMTAG_FILEINODES, RPM_INT32_TYPE,
                     catalogEntry.fileNumber, catalogEntry.inode);
    updateIndexEntry(rpm, RPMTAG_FILELANGS, RPM_STRING_ARRAY_TYPE,
                     catalogEntry.fileNumber, catalogEntry.lang);
    updateIndexEntry(rpm, RPMTAG_DIRINDEXES, RPM_INT32_TYPE,
                     catalogEntry.fileNumber, pred(catalogEntry.dirIndex));
    updateIndexEntry(rpm, RPMTAG_BASENAMES, RPM_STRING_ARRAY_TYPE,
                     catalogEntry.fileNumber, catalogEntry.baseName);
    updateIndexEntry(rpm, RPMTAG_FILECOLORS, RPM_INT32_TYPE,
                     catalogEntry.fileNumber, catalogEntry.color);
    updateIndexEntry(rpm, RPMTAG_FILECLASS, RPM_INT32_TYPE,
                     catalogEntry.fileNumber, catalogEntry.fileClass);
    updateIndexEntry(rpm, RPMTAG_FILEDEPENDSX, RPM_INT32_TYPE,
                     catalogEntry.fileNumber, catalogEntry.dependX);
    updateIndexEntry(rpm, RPMTAG_FILEDEPENDSN, RPM_INT32_TYPE,
                     catalogEntry.fileNumber, catalogEntry.dependN);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: findDirIndex (<span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: dirNameList, <span class="op">in</span> <span class="type">string</span>: dirName) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: dirIndex <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> <span class="keywd">key</span> index <span class="keywd">range</span> dirNameList <span class="keywd">until</span> dirIndex &lt;> 0 <span class="keywd">do</span>
      <span class="keywd">if</span> dirNameList[index] = dirName <span class="keywd">then</span>
        dirIndex := index;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: updateHeader (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmCatalogEntry</span>: catalogEntry <span class="keywd">is</span> rpmCatalogEntry.value;
    <span class="keywd">var</span> <span class="type">integer</span>: slashPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: dirName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: dirIndex <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> catalogEntry <span class="keywd">range</span> rpm.catalog <span class="keywd">do</span>
      <span class="keywd">if</span> catalogEntry.dirty <span class="keywd">then</span>
        <span class="comment"># writeln("updateHeader " &lt;&amp; catalogEntry.filePath);</span>
        slashPos := rpos(catalogEntry.filePath, <span class="stri">"/"</span>);
        <span class="keywd">if</span> slashPos &lt;> 0 <span class="keywd">then</span>
          dirName := catalogEntry.filePath[.. slashPos];
          catalogEntry.baseName := catalogEntry.filePath[succ(slashPos) ..];
        <span class="keywd">else</span>
          dirName := <span class="stri">""</span>;
          catalogEntry.baseName := catalogEntry.filePath;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        dirIndex := findDirIndex(rpm.dirNameList, dirName);
        <span class="keywd">if</span> dirIndex = 0 <span class="keywd">then</span>
          rpm.dirNameList &amp;:= dirName;
          dirIndex := length(rpm.dirNameList);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        catalogEntry.dirIndex := dirIndex;
        rpm.catalog @:= [catalogEntry.filePath] catalogEntry;
        updateHeader(rpm, catalogEntry);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isDirty (<span class="op">in</span> <span class="type">rpmArchive</span>: rpm) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: isDirty <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmCatalogEntry</span>: catalogEntry <span class="keywd">is</span> rpmCatalogEntry.value;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> catalogEntry <span class="keywd">range</span> rpm.catalog <span class="keywd">do</span>
      <span class="keywd">if</span> catalogEntry.dirty <span class="keywd">then</span>
        isDirty := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: fillTagMap (<span class="op">in</span> <span class="type">string</span>: indexData, <span class="keywd">inout</span> <span class="type">rpmTagMap</span>: tagMap) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">rpmIndexEntry</span>: indexEntry <span class="keywd">is</span> rpmIndexEntry.value;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> pos <span class="keywd">range</span> 1 <span class="keywd">to</span> length(indexData) step 16 <span class="keywd">do</span>
      indexEntry.tag      := bytes2Int(indexData[pos      fixLen 4], UNSIGNED, BE);
      indexEntry.dataType := bytes2Int(indexData[pos +  4 fixLen 4], UNSIGNED, BE);
      indexEntry.offset   := bytes2Int(indexData[pos +  8 fixLen 4], SIGNED,   BE);
      indexEntry.count    := bytes2Int(indexData[pos + 12 fixLen 4], UNSIGNED, BE);
      tagMap @:= [indexEntry.tag] indexEntry;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readSection (<span class="keywd">inout</span> <span class="type">file</span>: rpmFile, <span class="keywd">inout</span> <span class="type">rpmSection</span>: section) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    readHeader(rpmFile, section.head);
    <span class="keywd">if</span> section.head.magic = RPM_HEADER_MAGIC <span class="keywd">then</span>
      <span class="comment"># show(section.head);</span>
      section.indexData := gets(rpmFile, section.head.indexCount * RPM_INDEX_ENTRY_SIZE);
      fillTagMap(section.indexData, section.tagMap);
      <span class="comment"># sectionStorePos := tell(rpmFile);</span>
      section.store := gets(rpmFile, section.head.storeSize);
      <span class="comment"># writeln("length(section.store): " &lt;&amp; length(section.store));</span>
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: sectionStri (<span class="keywd">inout</span> <span class="type">rpmSection</span>: section, <span class="op">in</span> <span class="type">integer</span>: sectionTag) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: sectionStri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmIndexEntry</span>: sectionIndexEntry <span class="keywd">is</span> rpmIndexEntry.value;
    <span class="keywd">var</span> <span class="type">rpmIndexEntry</span>: indexEntry <span class="keywd">is</span> rpmIndexEntry.value;
  <span class="keywd">begin</span>
    section.head.magic := RPM_HEADER_MAGIC;
    section.head.version := 1;
    section.head.indexCount := succ(length(section.tagMap));
    section.head.storeSize := length(section.store) + 16;
    sectionStri := str(section.head);
    <span class="comment"># The first entry in the index array must be the sectionTag (regionTag) entry.</span>
    sectionIndexEntry.tag := sectionTag;
    sectionIndexEntry.dataType := RPM_BIN_TYPE;
    <span class="comment"># The data of the sectionTag must be after all other data in the section store.</span>
    sectionIndexEntry.offset := length(section.store);
    sectionIndexEntry.count := 16;
    sectionStri &amp;:= str(sectionIndexEntry);
    <span class="keywd">for</span> indexEntry <span class="keywd">range</span> section.tagMap <span class="keywd">do</span>
      <span class="comment"># writeln("indexEntry: " &lt;&amp; literal(str(indexEntry)));</span>
      sectionStri &amp;:= str(indexEntry);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="comment"># section.store does not contain the data of the sectionTag index entry.</span>
    sectionStri &amp;:= section.store;
    <span class="comment"># The data of the sectionTag entry is itself an index entry with the sectionTag.</span>
    <span class="comment"># The negative offset of this index entry refers back to the original sectionTag index entry.</span>
    sectionIndexEntry.offset := -succ(length(section.tagMap)) * 16;
    sectionStri &amp;:= str(sectionIndexEntry);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: assignIndexValues (<span class="keywd">inout</span> <span class="type">rpmSection</span>: section) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmIndexEntry</span>: indexEntry <span class="keywd">is</span> rpmIndexEntry.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> section.store &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      <span class="keywd">for</span> indexEntry <span class="keywd">range</span> section.tagMap <span class="keywd">do</span>
        <span class="keywd">case</span> indexEntry.dataType <span class="keywd">of</span>
          <span class="keywd">when</span> {RPM_INT8_TYPE, RPM_INT16_TYPE, RPM_INT32_TYPE, RPM_INT64_TYPE,
                RPM_STRING_TYPE, RPM_BIN_TYPE}:
            <span class="keywd">if</span> indexEntry.striValue = <span class="stri">""</span> <span class="keywd">then</span>
              indexEntry.striValue := getStriValue(section.store, indexEntry);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">when</span> {RPM_STRING_ARRAY_TYPE, RPM_I18NSTRING_TYPE}:
            <span class="keywd">if</span> length(indexEntry.arrayValue) = 0 <span class="keywd">then</span>
              indexEntry.arrayValue := getArrayValue(section.store, indexEntry);
            <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: updateStore (<span class="keywd">inout</span> <span class="type">rpmSection</span>: section) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmIndexEntry</span>: indexEntry <span class="keywd">is</span> rpmIndexEntry.value;
    <span class="keywd">var</span> <span class="type">string</span>: store <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> indexEntry <span class="keywd">range</span> section.tagMap <span class="keywd">do</span>
      indexEntry.offset := length(store);
      <span class="keywd">case</span> indexEntry.dataType <span class="keywd">of</span>
        <span class="keywd">when</span> {RPM_INT8_TYPE}:
          store &amp;:= indexEntry.striValue;
        <span class="keywd">when</span> {RPM_INT16_TYPE}:
          <span class="comment"># Align to 2 bytes</span>
          <span class="keywd">if</span> odd(length(store)) <span class="keywd">then</span>
            store &amp;:= <span class="stri">"\0;"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          indexEntry.offset := length(store);
          store &amp;:= indexEntry.striValue;
        <span class="keywd">when</span> {RPM_INT32_TYPE}:
          <span class="comment"># Align to 4 bytes</span>
          <span class="keywd">if</span> length(store) <span class="op">mod</span> 4 &lt;> 0 <span class="keywd">then</span>
            store &amp;:= <span class="stri">"\0;"</span> <span class="op">mult</span> (4 - length(store) <span class="op">mod</span> 4);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          indexEntry.offset := length(store);
          store &amp;:= indexEntry.striValue;
        <span class="keywd">when</span> {RPM_INT64_TYPE}:
          <span class="comment"># Align to 8 bytes</span>
          <span class="keywd">if</span> length(store) <span class="op">mod</span> 8 &lt;> 0 <span class="keywd">then</span>
            store &amp;:= <span class="stri">"\0;"</span> <span class="op">mult</span> (8 - length(store) <span class="op">mod</span> 4);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          indexEntry.offset := length(store);
          store &amp;:= indexEntry.striValue;
        <span class="keywd">when</span> {RPM_STRING_TYPE}:
          store &amp;:= indexEntry.striValue &amp; <span class="stri">"\0;"</span>;
        <span class="keywd">when</span> {RPM_BIN_TYPE}:
          store &amp;:= indexEntry.striValue;
        <span class="keywd">when</span> {RPM_STRING_ARRAY_TYPE, RPM_I18NSTRING_TYPE}:
          store &amp;:= join(indexEntry.arrayValue, <span class="stri">"\0;"</span>) &amp; <span class="stri">"\0;"</span>;
      <span class="keywd">end</span> <span class="keywd">case</span>;
      section.tagMap @:= [indexEntry.tag] indexEntry;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    section.store := store;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: checkHeaderDigest (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> TRUE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: referenceDigest <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: computedDigest <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> RPMSIGTAG_SHA1 <span class="op">in</span> rpm.signature.tagMap <span class="keywd">then</span>
      referenceDigest := getStriValue(rpm.signature.store, rpm.signature.tagMap[RPMSIGTAG_SHA1]);
      computedDigest := hex(sha1(str(rpm.header.head) &amp; rpm.header.indexData &amp; rpm.header.store));
      <span class="keywd">if</span> referenceDigest &lt;> computedDigest <span class="keywd">then</span>
        okay := FALSE;
        <span class="comment"># writeln("reference sha1 digest: " &lt;&amp; literal(referenceDigest));</span>
        <span class="comment"># writeln("computed sha1 digest:  " &lt;&amp; literal(computedDigest));</span>
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> RPMSIGTAG_SHA256 <span class="op">in</span> rpm.signature.tagMap <span class="keywd">then</span>
      referenceDigest := getStriValue(rpm.signature.store, rpm.signature.tagMap[RPMSIGTAG_SHA256]);
      computedDigest := hex(sha256(str(rpm.header.head) &amp; rpm.header.indexData &amp; rpm.header.store));
      <span class="keywd">if</span> referenceDigest &lt;> computedDigest <span class="keywd">then</span>
        okay := FALSE;
        <span class="comment"># writeln("reference sha256 digest: " &lt;&amp; literal(referenceDigest));</span>
        <span class="comment"># writeln("computed sha256 digest:  " &lt;&amp; literal(computedDigest));</span>
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: doSettings (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmIndexEntry</span>: fileDigestAlgo <span class="keywd">is</span> rpmIndexEntry.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> rpm.fileDigestAlgo = RPM_DIGESTALGO_MD5 <span class="op">and</span>
        RPMTAG_FILEDIGESTALGO <span class="op">in</span> rpm.header.tagMap <span class="keywd">then</span>
      fileDigestAlgo := rpm.header.tagMap[RPMTAG_FILEDIGESTALGO];
      rpm.fileDigestAlgo := bytes2Int(
          rpm.header.store[succ(fileDigestAlgo.offset) fixLen 4], SIGNED, BE);
      <span class="comment"># writeln("fileDigestAlgo: " &lt;&amp; rpm.fileDigestAlgo);</span>
    <span class="keywd">end</span> <span class="keywd">if</span>;
    rpm.classDict := getStringArray(rpm, RPMTAG_CLASSDICT);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readDependencies (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: flagsPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: namePos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: versionPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: count <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> RPMTAG_PROVIDEFLAGS <span class="op">in</span> rpm.header.tagMap <span class="op">and</span>
        RPMTAG_PROVIDENAME <span class="op">in</span> rpm.header.tagMap <span class="op">and</span>
        RPMTAG_PROVIDEVERSION <span class="op">in</span> rpm.header.tagMap <span class="keywd">then</span>
      flagsPos := succ(rpm.header.tagMap[RPMTAG_PROVIDEFLAGS].offset);
      namePos := succ(rpm.header.tagMap[RPMTAG_PROVIDENAME].offset);
      versionPos := succ(rpm.header.tagMap[RPMTAG_PROVIDEVERSION].offset);
      count := rpm.header.tagMap[RPMTAG_PROVIDEFLAGS].count;
      rpm.provided := count <span class="op">times</span> rpmDependency.value;
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> count <span class="keywd">do</span>
        rpm.provided[index].flags := bytes2Int(
            rpm.header.store[flagsPos fixLen 4], UNSIGNED, BE);
        flagsPos +:= 4;
        rpm.provided[index].name := getAsciiz(rpm.header.store, namePos);
        rpm.provided[index].version := getAsciiz(rpm.header.store, versionPos);
        <span class="comment"># writeln("provided: " &lt;&amp; rpmDependencyFlagsString(rpm.provided[index].flags) &lt;&amp;</span>
        <span class="comment">#         " " &lt;&amp; rpm.provided[index].name &lt;&amp; " " &lt;&amp; rpm.provided[index].version);</span>
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> RPMTAG_REQUIREFLAGS <span class="op">in</span> rpm.header.tagMap <span class="op">and</span>
        RPMTAG_REQUIRENAME <span class="op">in</span> rpm.header.tagMap <span class="op">and</span>
        RPMTAG_REQUIREVERSION <span class="op">in</span> rpm.header.tagMap <span class="keywd">then</span>
      flagsPos := succ(rpm.header.tagMap[RPMTAG_REQUIREFLAGS].offset);
      namePos := succ(rpm.header.tagMap[RPMTAG_REQUIRENAME].offset);
      versionPos := succ(rpm.header.tagMap[RPMTAG_REQUIREVERSION].offset);
      count := rpm.header.tagMap[RPMTAG_REQUIREFLAGS].count;
      rpm.required := count <span class="op">times</span> rpmDependency.value;
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> count <span class="keywd">do</span>
        rpm.required[index].flags := bytes2Int(
            rpm.header.store[flagsPos fixLen 4], UNSIGNED, BE);
        flagsPos +:= 4;
        rpm.required[index].name := getAsciiz(rpm.header.store, namePos);
        rpm.required[index].version := getAsciiz(rpm.header.store, versionPos);
        <span class="comment"># writeln("required: " &lt;&amp; rpmDependencyFlagsString(rpm.required[index].flags) &lt;&amp;</span>
        <span class="comment">#         " " &lt;&amp; rpm.required[index].name &lt;&amp; " " &lt;&amp; rpm.required[index].version);</span>
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getDigest (<span class="op">in</span> <span class="type">string</span>: content, <span class="op">in</span> <span class="type">integer</span>: digestAlgo) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: digest <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> digestAlgo <span class="keywd">of</span>
      <span class="keywd">when</span> {RPM_DIGESTALGO_MD5}:         digest := md5(content);
      <span class="keywd">when</span> {RPM_DIGESTALGO_SHA1}:        digest := sha1(content);
      <span class="keywd">when</span> {RPM_DIGESTALGO_RIPEMD160}:   digest := ripemd160(content);
      <span class="keywd">when</span> {RPM_DIGESTALGO_MD2}:         noop;
      <span class="keywd">when</span> {RPM_DIGESTALGO_TIGER192}:    noop;
      <span class="keywd">when</span> {RPM_DIGESTALGO_HAVAL_5_160}: noop;
      <span class="keywd">when</span> {RPM_DIGESTALGO_SHA256}:      digest := sha256(content);
      <span class="keywd">when</span> {RPM_DIGESTALGO_SHA384}:      digest := sha384(content);
      <span class="keywd">when</span> {RPM_DIGESTALGO_SHA512}:      digest := sha512(content);
      <span class="keywd">when</span> {RPM_DIGESTALGO_SHA224}:      digest := sha224(content);
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: checkPayloadDigest (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: payloadContent <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: digestPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: referenceDigest <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: computedDigest <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: digestAlgo <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> RPMTAG_PAYLOADDIGEST <span class="op">in</span> rpm.header.tagMap <span class="op">and</span>
        RPMTAG_PAYLOADDIGESTALGO <span class="op">in</span> rpm.header.tagMap <span class="keywd">then</span>
      seek(rpm.rpmFile, rpm.payloadPos);
      payloadContent := gets(rpm.rpmFile, integer.last);
      digestPos := succ(rpm.header.tagMap[RPMTAG_PAYLOADDIGEST].offset);
      referenceDigest := getAsciiz(rpm.header.store, digestPos);
      digestAlgo := getIntValue(rpm.header.store, rpm.header.tagMap[RPMTAG_PAYLOADDIGESTALGO]);
      <span class="comment"># writeln("length(payloadContent): " &lt;&amp; length(payloadContent));</span>
      computedDigest := hex(getDigest(payloadContent, digestAlgo));
      <span class="keywd">if</span> referenceDigest &lt;> computedDigest <span class="keywd">then</span>
        <span class="comment"># writeln("digestAlgo: " &lt;&amp; digestAlgo);</span>
        <span class="comment"># writeln("reference digest: " &lt;&amp; literal(referenceDigest));</span>
        <span class="comment"># writeln("computed digest:  " &lt;&amp; literal(computedDigest));</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> RPMSIGTAG_MD5 <span class="op">in</span> rpm.signature.tagMap <span class="keywd">then</span>
      <span class="keywd">if</span> payloadContent = <span class="stri">""</span> <span class="keywd">then</span>
        seek(rpm.rpmFile, rpm.payloadPos);
        payloadContent := gets(rpm.rpmFile, integer.last);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      referenceDigest := getStriValue(rpm.signature.store, rpm.signature.tagMap[RPMSIGTAG_MD5]);
      computedDigest := md5(str(rpm.header.head) &amp; rpm.header.indexData &amp; rpm.header.store &amp; payloadContent);
      <span class="keywd">if</span> referenceDigest &lt;> computedDigest <span class="keywd">then</span>
        <span class="comment"># writeln("reference md5 digest: " &lt;&amp; literal(referenceDigest));</span>
        <span class="comment"># writeln("computed md5 digest:  " &lt;&amp; literal(computedDigest));</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getArchive (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: compressor <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: format <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">file</span>: payload <span class="keywd">is</span> STD_NULL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> rpm.payloadPos = 0 <span class="keywd">then</span>
      rpm.payloadFile := openStriFile();
    <span class="keywd">else</span>
      checkPayloadDigest(rpm);
      seek(rpm.rpmFile, rpm.payloadPos);
      <span class="keywd">if</span> RPMTAG_PAYLOADCOMPRESSOR <span class="op">in</span> rpm.header.tagMap <span class="keywd">then</span>
        compressor := getStriValue(rpm.header.store, rpm.header.tagMap[RPMTAG_PAYLOADCOMPRESSOR]);
        <span class="comment"># writeln("compressor: " &lt;&amp; compressor);</span>
        <span class="keywd">case</span> compressor <span class="keywd">of</span>
          <span class="keywd">when</span> {<span class="stri">"gzip"</span>}: payload := openGzipFile(rpm.rpmFile, READ);
          <span class="keywd">when</span> {<span class="stri">"lzma"</span>}: payload := openLzmaFile(rpm.rpmFile);
          <span class="keywd">when</span> {<span class="stri">"xz"</span>}:   payload := openXzFile(rpm.rpmFile);
          <span class="keywd">when</span> {<span class="stri">"zstd"</span>}: payload := openZstdFile(rpm.rpmFile);
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> payload &lt;> STD_NULL <span class="keywd">then</span>
        <span class="comment"># writeln("length uncompressed: " &lt;&amp; length(payload));</span>
        rpm.payloadFile := openStriFile(gets(payload, integer.last));
        close(payload);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> rpm.payloadFile &lt;> STD_NULL <span class="keywd">then</span>
      <span class="keywd">if</span> RPMTAG_PAYLOADFORMAT <span class="op">in</span> rpm.header.tagMap <span class="keywd">then</span>
        format := getStriValue(rpm.header.store, rpm.header.tagMap[RPMTAG_PAYLOADFORMAT]);
        <span class="comment"># writeln("format: " &lt;&amp; format);</span>
        <span class="keywd">case</span> format <span class="keywd">of</span>
          <span class="keywd">when</span> {<span class="stri">"cpio"</span>}: rpm.archive := openCpio(rpm.payloadFile);
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">elsif</span> rpm.payloadPos = 0 <span class="keywd">then</span>
        rpm.archive := openCpio(rpm.payloadFile);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: archiveFilePath (<span class="keywd">inout</span> <span class="type">fileSys</span>: archive, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: archiveFilePath <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> startsWith(filePath, <span class="stri">"/"</span>) <span class="op">and</span>
        fileTypeSL(archive, filePath) = FILE_ABSENT <span class="keywd">then</span>
      archiveFilePath := <span class="stri">"."</span> &amp; filePath;
    <span class="keywd">else</span>
      archiveFilePath := filePath;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Open a RPM archive with the given rpmFile.
 *  @param rpmFile File that contains a RPM archive.
 *  @return a file system that accesses the RPM archive, or
 *          fileSys.value if it could not be opened.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">fileSys</span>: openRpm (<span class="keywd">inout</span> <span class="type">file</span>: rpmFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fileSys</span>: newFileSys <span class="keywd">is</span> fileSys.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmArchive</span>: rpm <span class="keywd">is</span> rpmArchive.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(rpmFile) = 0 <span class="keywd">then</span>
      rpm.rpmFile := rpmFile;
      newFileSys := toInterface(rpm);
    <span class="keywd">else</span>
      seek(rpmFile, 1);
      readLead(rpmFile, rpm.lead);
      <span class="keywd">if</span> rpm.lead.magic = RPM_LEAD_MAGIC <span class="keywd">then</span>
        rpm.rpmFile := rpmFile;
        readSection(rpmFile, rpm.signature);
        <span class="keywd">if</span> rpm.signature.head.magic = RPM_HEADER_MAGIC <span class="keywd">then</span>
          ignore(gets(rpmFile, 7 - pred(rpm.signature.head.storeSize) <span class="op">mod</span> 8));
          readSection(rpmFile, rpm.header);
          <span class="keywd">if</span> rpm.header.head.magic = RPM_HEADER_MAGIC <span class="keywd">then</span>
            <span class="comment"># ignore(gets(rpmFile, 7 - pred(rpm.header.head.storeSize) mod 8));</span>
            rpm.payloadPos := tell(rpmFile);
            <span class="keywd">if</span> checkHeaderDigest(rpm) <span class="keywd">then</span>
              doSettings(rpm);
              createMinimumOfCatalog(rpm);
              readDependencies(rpm);
              newFileSys := toInterface(rpm);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Open a RPM archive with the given rpmFileName.
 *  @param rpmFileName Name of the RPM archive to be opened.
 *  @return a file system that accesses the RPM archive, or
 *          fileSys.value if it could not be opened.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">fileSys</span>: openRpm (<span class="op">in</span> <span class="type">string</span>: rpmFileName) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fileSys</span>: rpm <span class="keywd">is</span> fileSys.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">file</span>: rpmFile <span class="keywd">is</span> STD_NULL;
  <span class="keywd">begin</span>
    rpmFile := open(rpmFileName, <span class="stri">"r"</span>);
    rpm := openRpm(rpmFile);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Close a RPM archive. The RPM file below stays open.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: close (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: signatureSection <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: headerSection <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: payload <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isDirty(rpm) <span class="keywd">then</span>
      writeln(<span class="stri">"in close"</span>);
      <span class="keywd">if</span> length(rpm.rpmFile) = 0 <span class="keywd">then</span>
        writeLead(rpm.rpmFile, rpm.lead);
      <span class="keywd">end</span> <span class="keywd">if</span>;

      <span class="comment"># writeln("prepare payload:");</span>
      <span class="keywd">if</span> rpm.archive &lt;> fileSys.value <span class="keywd">then</span>
        <span class="comment"># writeln("size payloadFile: " &lt;&amp; length(rpm.payloadFile));</span>
        seek(rpm.payloadFile, 1);
        payload := gzip(gets(rpm.payloadFile, integer.last));
        <span class="comment"># writeln("size payload: " &lt;&amp; length(payload));</span>
      <span class="keywd">end</span> <span class="keywd">if</span>;

      <span class="comment"># writeln("prepare header:");</span>
      assignIndexValues(rpm.header);
      updateHeader(rpm);
      updateIndexEntry(rpm.header, RPMTAG_ARCHIVESIZE, RPM_INT32_TYPE,
                       length(rpm.payloadFile));
      updateIndexEntry(rpm.header, RPMTAG_DIRNAMES, RPM_STRING_ARRAY_TYPE, rpm.dirNameList);
      updateIndexEntry(rpm.header, RPMTAG_PAYLOADCOMPRESSOR, RPM_STRING_TYPE, <span class="stri">"gzip"</span>);
      updateIndexEntry(rpm.header, RPMTAG_PAYLOADFORMAT, RPM_STRING_TYPE, <span class="stri">"cpio"</span>);
      updateStore(rpm.header);
      headerSection := sectionStri(rpm.header, RPMTAG_HEADERIMMUTABLE);

      writeln(<span class="stri">"prepare signature:"</span>);
      updateIndexEntry(rpm.signature, RPMSIGTAG_SIZE, RPM_INT32_TYPE,
                       length(headerSection) + length(payload));
      updateIndexEntry(rpm.signature, RPMSIGTAG_PAYLOADSIZE, RPM_INT32_TYPE,
                       length(rpm.payloadFile));
      updateIndexEntry(rpm.signature, RPMSIGTAG_SHA1, RPM_STRING_TYPE,
                       hex(sha1(headerSection)));
      updateIndexEntry(rpm.signature, RPMSIGTAG_SHA256, RPM_STRING_TYPE,
                       hex(sha256(headerSection)));
      updateIndexEntry(rpm.signature, RPMSIGTAG_MD5, RPM_BIN_TYPE,
                       md5(headerSection &amp; payload));

      assignIndexValues(rpm.signature);
      updateStore(rpm.signature);
      signatureSection := sectionStri(rpm.signature, RPMSIGTAG_HEADERSIGNATURES);
      writeln(length(signatureSection));

      writeln(4505 - length(signatureSection) -
          (7 - pred(length(signatureSection)) <span class="op">mod</span> 8) -
          RPM_LEAD_SIZE - RPM_INDEX_ENTRY_SIZE);
      updateIndexEntry(rpm.signature, RPMSIGTAG_RESERVEDSPACE, RPM_BIN_TYPE,
                       <span class="stri">"\0;"</span> <span class="op">mult</span> 4505 - length(signatureSection) -
                       (7 - pred(length(signatureSection)) <span class="op">mod</span> 8) -
                       RPM_LEAD_SIZE - RPM_INDEX_ENTRY_SIZE);

      rpm.signature.tagMap[RPMSIGTAG_RESERVEDSPACE].offset := length(rpm.signature.store);
      rpm.signature.store &amp;:= rpm.signature.tagMap[RPMSIGTAG_RESERVEDSPACE].striValue;
      signatureSection := sectionStri(rpm.signature, RPMSIGTAG_HEADERSIGNATURES);
      writeln(length(signatureSection));

      write(rpm.rpmFile, signatureSection);
      write(rpm.rpmFile, <span class="stri">"\0;"</span> <span class="op">mult</span> (7 - pred(length(signatureSection)) <span class="op">mod</span> 8));
      write(rpm.rpmFile, headerSection);
      write(rpm.rpmFile, payload);
      truncate(rpm.rpmFile, pred(tell(rpm.rpmFile)));
      <span class="comment"># close(rpm.rpmFile);</span>
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> rpm.archive &lt;> fileSys.value <span class="keywd">then</span>
      close(rpm.archive);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    rpm.rpmFile := STD_NULL;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: implicitDir (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">string</span>: dirPath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: implicitDir <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: filePath <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> dirPath &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      <span class="keywd">for</span> <span class="keywd">key</span> filePath <span class="keywd">range</span> rpm.register <span class="keywd">do</span>
        <span class="keywd">if</span> startsWith(filePath, dirPath) <span class="op">and</span>
            length(filePath) > length(dirPath) <span class="op">and</span>
            (filePath[succ(length(dirPath))] = <span class="stri">'/'</span> <span class="op">or</span> dirPath = <span class="stri">"/"</span>) <span class="keywd">then</span>
          implicitDir := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">rpmCatalogEntry</span>: addImplicitDir (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm,
    <span class="op">in</span> <span class="type">string</span>: dirPath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">rpmCatalogEntry</span>: catalogEntry <span class="keywd">is</span> rpmCatalogEntry.value;
  <span class="keywd">begin</span>
    catalogEntry.filePath := dirPath;
    catalogEntry.mode := ord(MODE_FILE_DIR) + 8#775;
    catalogEntry.allDataPresent := TRUE;
    rpm.catalog @:= [dirPath] catalogEntry;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: followSymlink (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: filePath,
    <span class="keywd">inout</span> <span class="type">rpmCatalogEntry</span>: catalogEntry) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: missingPath <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: offset <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: modeValue <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: symlinkCount <span class="keywd">is</span> MAX_SYMLINKS;
    <span class="keywd">var</span> <span class="type">boolean</span>: isSymlink <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> rpm.catalog <span class="keywd">then</span>
        catalogEntry := rpm.catalog[filePath];
      <span class="keywd">elsif</span> implicitDir(rpm, filePath) <span class="keywd">then</span>
        catalogEntry := addImplicitDir(rpm, filePath);
      <span class="keywd">else</span>
        missingPath := filePath;
        isSymlink := FALSE;
        <span class="comment"># writeln("missing: " &lt;&amp; missingPath);</span>
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> missingPath = <span class="stri">""</span> <span class="keywd">then</span>
        <span class="keywd">if</span> <span class="op">not</span> catalogEntry.allDataPresent <span class="keywd">then</span>
          readCatalogEntry(rpm, catalogEntry);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> bin32(catalogEntry.mode) &amp; MODE_FILE_TYPE_MASK = MODE_FILE_SYMLINK <span class="keywd">then</span>
          filePath := catalogEntry.linkTo;
        <span class="keywd">else</span>
          isSymlink := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      decr(symlinkCount);
    <span class="keywd">until</span> <span class="op">not</span> isSymlink <span class="op">or</span> symlinkCount = 0;
    <span class="keywd">if</span> isSymlink <span class="keywd">then</span>
      <span class="comment"># Too many symbolic links.</span>
      raise FILE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">rpmCatalogEntry</span>: followSymlink (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">rpmCatalogEntry</span>: catalogEntry <span class="keywd">is</span> rpmCatalogEntry.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: missingPath <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    missingPath := followSymlink(rpm, filePath, catalogEntry);
    <span class="keywd">if</span> missingPath &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      <span class="comment"># The file does not exist.</span>
      raise FILE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the file names in a directory inside a RPM archive.
 *  Note that the function returns only the file names.
 *  Additional information must be obtained with other calls.
 *  @param rpm Open RPM archive.
 *  @param dirPath Path of a directory in the RPM archive.
 *  @return an array with the file names.
 *  @exception RANGE_ERROR ''dirPath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''dirPath'' is not present in the RPM archive.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: readDir (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">string</span>: dirPath) <span class="keywd">is</span>
  <span class="keywd">return</span> readDir(rpm.register, dirPath);


<span class="comment">(**
 *  Determine the file paths in a RPM archive.
 *  Note that the function returns only the file paths.
 *  Additional information must be obtained with other calls.
 *  @param rpm Open RPM archive.
 *  @return an array with the file paths.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: readDir (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, RECURSIVE) <span class="keywd">is</span>
  <span class="keywd">return</span> sort(keys(rpm.register));


<span class="comment">(**
 *  Determine the type of a file in a RPM archive.
 *  The function follows symbolic links. If the chain of
 *  symbolic links is too long the function returns ''FILE_SYMLINK''.
 *  If a symbolic link refers to a place where the permission
 *  is denied the function returns ''FILE_SYMLINK''.
 *  A return value of ''FILE_ABSENT'' does not imply that a file
 *  with this name can be created, since missing directories and
 *  invalid file names cause also ''FILE_ABSENT''.
 *  @return the type of the file.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">fileType</span>: fileType (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fileType</span>: aFileType <span class="keywd">is</span> FILE_UNKNOWN;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmCatalogEntry</span>: catalogEntry <span class="keywd">is</span> rpmCatalogEntry.value;
    <span class="keywd">var</span> <span class="type">integer</span>: symlinkCount <span class="keywd">is</span> MAX_SYMLINKS;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("fileType: " &lt;&amp; filePath);</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath = <span class="stri">""</span> <span class="keywd">then</span>
      aFileType := FILE_DIR;
    <span class="keywd">else</span>
      <span class="keywd">repeat</span>
        <span class="keywd">if</span> filePath <span class="op">in</span> rpm.catalog <span class="keywd">then</span>
          catalogEntry := rpm.catalog[filePath];
        <span class="keywd">elsif</span> implicitDir(rpm, filePath) <span class="keywd">then</span>
          catalogEntry := addImplicitDir(rpm, filePath);
        <span class="keywd">else</span>
          aFileType := FILE_ABSENT;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> aFileType = FILE_UNKNOWN <span class="keywd">then</span>
          <span class="keywd">if</span> <span class="op">not</span> catalogEntry.allDataPresent <span class="keywd">then</span>
            readCatalogEntry(rpm, catalogEntry);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">case</span> bin32(catalogEntry.mode) &amp; MODE_FILE_TYPE_MASK <span class="keywd">of</span>
            <span class="keywd">when</span> {MODE_FILE_REGULAR}: aFileType := FILE_REGULAR;
            <span class="keywd">when</span> {MODE_FILE_DIR}:     aFileType := FILE_DIR;
            <span class="keywd">when</span> {MODE_FILE_CHAR}:    aFileType := FILE_CHAR;
            <span class="keywd">when</span> {MODE_FILE_BLOCK}:   aFileType := FILE_BLOCK;
            <span class="keywd">when</span> {MODE_FILE_FIFO}:    aFileType := FILE_FIFO;
            <span class="keywd">when</span> {MODE_FILE_SOCKET}:  aFileType := FILE_SOCKET;
            <span class="keywd">when</span> {MODE_FILE_SYMLINK}:
              filePath := catalogEntry.linkTo;
            <span class="keywd">otherwise</span>:
              raise RANGE_ERROR;
          <span class="keywd">end</span> <span class="keywd">case</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        decr(symlinkCount);
      <span class="keywd">until</span> aFileType &lt;> FILE_UNKNOWN <span class="op">or</span> symlinkCount = 0;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the type of a file in a RPM archive.
 *  The function does not follow symbolic links. Therefore it may
 *  return ''FILE_SYMLINK''. A return value of ''FILE_ABSENT'' does
 *  not imply that a file with this name can be created, since missing
 *  directories and invalid file names cause also ''FILE_ABSENT''.
 *  @return the type of the file.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">fileType</span>: fileTypeSL (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fileType</span>: aFileType <span class="keywd">is</span> FILE_UNKNOWN;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmCatalogEntry</span>: catalogEntry <span class="keywd">is</span> rpmCatalogEntry.value;
    <span class="keywd">var</span> <span class="type">integer</span>: offset <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: modeValue <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("fileTypeSL: " &lt;&amp; filePath);</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath = <span class="stri">""</span> <span class="keywd">then</span>
      aFileType := FILE_DIR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> rpm.catalog <span class="keywd">then</span>
        catalogEntry := rpm.catalog[filePath];
      <span class="keywd">elsif</span> implicitDir(rpm, filePath) <span class="keywd">then</span>
        catalogEntry := addImplicitDir(rpm, filePath);
      <span class="keywd">else</span>
        aFileType := FILE_ABSENT;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> aFileType = FILE_UNKNOWN <span class="keywd">then</span>
        <span class="keywd">if</span> <span class="op">not</span> catalogEntry.allDataPresent <span class="keywd">then</span>
          readCatalogEntry(rpm, catalogEntry);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">case</span> bin32(catalogEntry.mode) &amp; MODE_FILE_TYPE_MASK <span class="keywd">of</span>
          <span class="keywd">when</span> {MODE_FILE_REGULAR}: aFileType := FILE_REGULAR;
          <span class="keywd">when</span> {MODE_FILE_DIR}:     aFileType := FILE_DIR;
          <span class="keywd">when</span> {MODE_FILE_CHAR}:    aFileType := FILE_CHAR;
          <span class="keywd">when</span> {MODE_FILE_BLOCK}:   aFileType := FILE_BLOCK;
          <span class="keywd">when</span> {MODE_FILE_FIFO}:    aFileType := FILE_FIFO;
          <span class="keywd">when</span> {MODE_FILE_SOCKET}:  aFileType := FILE_SOCKET;
          <span class="keywd">when</span> {MODE_FILE_SYMLINK}: aFileType := FILE_SYMLINK;
          <span class="keywd">otherwise</span>:
            raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the file mode (permissions) of a file in a RPM archive.
 *  The function follows symbolic links.
 *  @return the file mode.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the RPM archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">fileMode</span>: fileMode (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fileMode</span>: mode <span class="keywd">is</span> fileMode.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      mode := fileMode(followSymlink(rpm, filePath).mode);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Change the file mode (permissions) of a file in a RPM archive.
 *  The function follows symbolic links.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the RPM archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: setFileMode (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">fileMode</span>: mode) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmCatalogEntry</span>: catalogEntry <span class="keywd">is</span> rpmCatalogEntry.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      catalogEntry := followSymlink(rpm, filePath);
      <span class="keywd">if</span> catalogEntry.fileNumber &lt;> 0 <span class="keywd">then</span>
        catalogEntry.mode := (catalogEntry.mode >> 9 &lt;&lt; 9) + integer(mode);
        catalogEntry.dirty := TRUE;
        rpm.catalog @:= [catalogEntry.filePath] catalogEntry;
        <span class="keywd">if</span> rpm.archive = fileSys.value <span class="keywd">then</span>
          getArchive(rpm);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        setFileMode(rpm.archive,
            archiveFilePath(rpm.archive, catalogEntry.filePath), mode);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the size of a file in a RPM archive.
 *  The file size is measured in bytes.
 *  For directories a size of 0 is returned.
 *  The function follows symbolic links.
 *  @return the size of the file.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the RPM archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: fileSize (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: size <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      size := followSymlink(rpm, filePath).fileSize;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the modification time of a file in a RPM archive.
 *  The function follows symbolic links.
 *  @return the modification time of the file.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the RPM archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: getMTime (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: modificationTime <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      modificationTime := timestamp1970ToTime(
          followSymlink(rpm, filePath).mtime);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Set the modification time of a file in a RPM archive.
 *  The function follows symbolic links.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception RANGE_ERROR ''aTime'' is invalid or cannot be
 *             converted to the system file time.
 *  @exception FILE_ERROR ''filePath'' is not present in the RPM archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: setMTime (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">time</span>: modificationTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmCatalogEntry</span>: catalogEntry <span class="keywd">is</span> rpmCatalogEntry.value;
    <span class="keywd">var</span> <span class="type">integer</span>: mtime <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    mtime := timestamp1970(modificationTime);
    <span class="keywd">if</span> mtime &lt; 0 <span class="op">or</span> mtime >= 2 ** 31 <span class="op">or</span>
        (filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>)) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      catalogEntry := followSymlink(rpm, filePath);
      <span class="keywd">if</span> catalogEntry.fileNumber &lt;> 0 <span class="keywd">then</span>
        catalogEntry.mtime := mtime;
        catalogEntry.dirty := TRUE;
        rpm.catalog @:= [catalogEntry.filePath] catalogEntry;
        <span class="keywd">if</span> rpm.archive = fileSys.value <span class="keywd">then</span>
          getArchive(rpm);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        setMTime(rpm.archive,
                 archiveFilePath(rpm.archive, catalogEntry.filePath),
                 modificationTime);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the name of the owner (UID) of a file in a RPM archive.
 *  The function follows symbolic links.
 *  @return the name of the file owner.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the RPM archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getOwner (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: owner <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmCatalogEntry</span>: catalogEntry <span class="keywd">is</span> rpmCatalogEntry.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      catalogEntry := followSymlink(rpm, filePath);
      <span class="keywd">if</span> catalogEntry.userName &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        owner := catalogEntry.userName;
      <span class="keywd">else</span>
        owner := str(catalogEntry.uid);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: setOwner (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">string</span>: owner) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmCatalogEntry</span>: catalogEntry <span class="keywd">is</span> rpmCatalogEntry.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      catalogEntry := followSymlink(rpm, filePath);
      <span class="keywd">if</span> catalogEntry.fileNumber &lt;> 0 <span class="keywd">then</span>
        <span class="keywd">if</span> isDigitString(owner) <span class="keywd">then</span>
          catalogEntry.uid := integer(owner);
          catalogEntry.userName := <span class="stri">""</span>;
        <span class="keywd">else</span>
          catalogEntry.uid := 0;
          catalogEntry.userName := owner;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        catalogEntry.dirty := TRUE;
        rpm.catalog @:= [catalogEntry.filePath] catalogEntry;
        <span class="keywd">if</span> rpm.archive = fileSys.value <span class="keywd">then</span>
          getArchive(rpm);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        setOwner(rpm.archive,
                 archiveFilePath(rpm.archive, catalogEntry.filePath),
                 owner);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the name of the group (GID) of a file in a RPM archive.
 *  The function follows symbolic links.
 *  @return the name of the file group.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the RPM archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getGroup (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: group <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmCatalogEntry</span>: catalogEntry <span class="keywd">is</span> rpmCatalogEntry.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      catalogEntry := followSymlink(rpm, filePath);
      <span class="keywd">if</span> catalogEntry.groupName &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        group := catalogEntry.groupName;
      <span class="keywd">else</span>
        group := str(catalogEntry.gid);
      <span class="keywd">end</span> <span class="keywd">if</span>;
     <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: setGroup (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">string</span>: group) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmCatalogEntry</span>: catalogEntry <span class="keywd">is</span> rpmCatalogEntry.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      catalogEntry := followSymlink(rpm, filePath);
      <span class="keywd">if</span> catalogEntry.fileNumber &lt;> 0 <span class="keywd">then</span>
        <span class="keywd">if</span> isDigitString(group) <span class="keywd">then</span>
          catalogEntry.gid := integer(group);
          catalogEntry.groupName := <span class="stri">""</span>;
        <span class="keywd">else</span>
          catalogEntry.gid := 0;
          catalogEntry.groupName := group;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        catalogEntry.dirty := TRUE;
        rpm.catalog @:= [catalogEntry.filePath] catalogEntry;
        <span class="keywd">if</span> rpm.archive = fileSys.value <span class="keywd">then</span>
          getArchive(rpm);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        setGroup(rpm.archive,
                 archiveFilePath(rpm.archive, catalogEntry.filePath),
                 group);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads the destination of a symbolic link in a RPM archive.
 *  @return The destination referred by the symbolic link.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the RPM archive,
 *             or is not a symbolic link.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: readLink (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: linkPath <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmCatalogEntry</span>: catalogEntry <span class="keywd">is</span> rpmCatalogEntry.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath <span class="op">in</span> rpm.catalog <span class="keywd">then</span>
      catalogEntry := rpm.catalog[filePath];
    <span class="keywd">else</span>
      raise FILE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="op">not</span> catalogEntry.allDataPresent <span class="keywd">then</span>
      readCatalogEntry(rpm, catalogEntry);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> bin32(catalogEntry.mode) &amp; MODE_FILE_TYPE_MASK = MODE_FILE_SYMLINK <span class="keywd">then</span>
      linkPath := catalogEntry.linkTo;
    <span class="keywd">else</span>
      raise FILE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get the contents of a file in a RPM archive.
 *  The function follows symbolic links.
 *  @return the specified file as string.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the RPM archive,
 *             or is not a regular file, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getFile (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: content <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmCatalogEntry</span>: catalogEntry <span class="keywd">is</span> rpmCatalogEntry.value;
    <span class="keywd">var</span> <span class="type">string</span>: digest <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      catalogEntry := followSymlink(rpm, filePath);
      <span class="keywd">if</span> bin32(catalogEntry.mode) &amp; MODE_FILE_TYPE_MASK = MODE_FILE_REGULAR <span class="keywd">then</span>
        <span class="keywd">if</span> rpm.archive = fileSys.value <span class="keywd">then</span>
          getArchive(rpm);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        content := getFile(rpm.archive, archiveFilePath(rpm.archive, catalogEntry.filePath));
        digest := hex(getDigest(content, rpm.fileDigestAlgo));
        <span class="keywd">if</span> catalogEntry.digest &lt;> digest <span class="keywd">then</span>
          <span class="comment"># writeln("fileDigestAlgo: " &lt;&amp; rpm.fileDigestAlgo);</span>
          <span class="comment"># writeln("digest: " &lt;&amp; rpm.catalog[fileNumber].digest &lt;&amp;</span>
          <span class="comment">#         " computed digest: " &lt;&amp; digest);</span>
          raise FILE_ERROR;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Write ''data'' to a RPM archive with the given ''filePath''.
 *  If the file exists already, it is overwritten.
 *  The function follows symbolic links.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR The file exists, but it is not a regular file.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: putFile (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">string</span>: data) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmCatalogEntry</span>: catalogEntry <span class="keywd">is</span> rpmCatalogEntry.value;
    <span class="keywd">var</span> <span class="type">string</span>: missingPath <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath = <span class="stri">""</span> <span class="op">or</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      missingPath := followSymlink(rpm, filePath, catalogEntry);
      <span class="keywd">if</span> missingPath = <span class="stri">""</span> <span class="keywd">then</span>
        <span class="comment"># The file does exist.</span>
        <span class="keywd">if</span> bin32(catalogEntry.mode) &amp; MODE_FILE_TYPE_MASK &lt;> MODE_FILE_REGULAR <span class="keywd">then</span>
          raise FILE_ERROR;
        <span class="keywd">else</span>
          <span class="keywd">if</span> rpm.archive = fileSys.value <span class="keywd">then</span>
            getArchive(rpm);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          catalogEntry.fileSize := length(data);
          catalogEntry.digest := hex(getDigest(data, rpm.fileDigestAlgo));
          catalogEntry.dirty := TRUE;
          rpm.catalog @:= [catalogEntry.filePath] catalogEntry;
          putFile(rpm.archive, catalogEntry.filePath, data);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        <span class="keywd">if</span> rpm.archive = fileSys.value <span class="keywd">then</span>
          getArchive(rpm);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        catalogEntry.fileSize := length(data);
        catalogEntry.mode := ord(MODE_FILE_REGULAR) + 8#664;
        catalogEntry.uid := 100;
        catalogEntry.gid := 100;
        catalogEntry.rdev := 0;
        catalogEntry.mtime := timestamp1970(time(NOW));
        catalogEntry.digest := hex(getDigest(data, rpm.fileDigestAlgo));
        catalogEntry.linkTo := <span class="stri">""</span>;
        catalogEntry.flags := 0;
        catalogEntry.userName := <span class="stri">""</span>;
        catalogEntry.groupName := <span class="stri">""</span>;
        catalogEntry.verifyFlags := 0;
        catalogEntry.device := 0;
        catalogEntry.inode := succ(length(rpm.register));
        catalogEntry.lang := <span class="stri">""</span>;
        catalogEntry.dirIndex := 0;
        catalogEntry.baseName := <span class="stri">""</span>;
        catalogEntry.color := 0;
        catalogEntry.fileClass := 0;
        catalogEntry.dependX := 0;
        catalogEntry.dependN := 0;
        catalogEntry.allDataPresent := TRUE;
        catalogEntry.filePath := missingPath;
        catalogEntry.fileNumber := succ(length(rpm.register));
        catalogEntry.dirty := TRUE;
        rpm.catalog @:= [missingPath] catalogEntry;
        rpm.register @:= [missingPath] catalogEntry.fileNumber;
        putFile(rpm.archive, missingPath, data);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Creates a new directory in a RPM archive.
 *  The function does not follow symbolic links.
 *  @exception RANGE_ERROR ''dirPath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR A system function returns an error.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: mkdir (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">rpmCatalogEntry</span>: catalogEntry <span class="keywd">is</span> rpmCatalogEntry.value;
    <span class="keywd">var</span> <span class="type">boolean</span>: fileExists <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">integer</span>: fileNumber <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: filePath8 <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath = <span class="stri">""</span> <span class="op">or</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath <span class="op">in</span> rpm.catalog <span class="keywd">then</span>
      fileNumber := rpm.catalog[filePath].fileNumber;
    <span class="keywd">elsif</span> implicitDir(rpm, filePath) <span class="keywd">then</span>
      fileNumber := addImplicitDir(rpm, filePath).fileNumber;
    <span class="keywd">else</span>
      fileExists := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> fileExists <span class="op">and</span> fileNumber &lt;> 0 <span class="keywd">then</span>
      <span class="comment"># The file exists and it is not an implicit directory.</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> rpm.archive = fileSys.value <span class="keywd">then</span>
        getArchive(rpm);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      catalogEntry.fileSize := 0;
      catalogEntry.mode := ord(MODE_FILE_DIR) + 8#775;
      catalogEntry.uid := 100;
      catalogEntry.gid := 100;
      catalogEntry.rdev := 0;
      catalogEntry.mtime := timestamp1970(time(NOW));
      catalogEntry.digest := <span class="stri">""</span>;
      catalogEntry.linkTo := <span class="stri">""</span>;
      catalogEntry.flags := 0;
      catalogEntry.userName := <span class="stri">""</span>;
      catalogEntry.groupName := <span class="stri">""</span>;
      catalogEntry.verifyFlags := 0;
      catalogEntry.device := 0;
      catalogEntry.inode := succ(length(rpm.register));
      catalogEntry.lang := <span class="stri">""</span>;
      catalogEntry.dirIndex := 0;
      catalogEntry.baseName := <span class="stri">""</span>;
      catalogEntry.color := 0;
      catalogEntry.fileClass := 0;
      catalogEntry.dependX := 0;
      catalogEntry.dependN := 0;
      catalogEntry.allDataPresent := TRUE;
      catalogEntry.filePath := filePath;
      catalogEntry.fileNumber := succ(length(rpm.register));
      catalogEntry.dirty := TRUE;
      rpm.catalog @:= [filePath] catalogEntry;
      rpm.register @:= [filePath] catalogEntry.fileNumber;
      mkdir(rpm.archive, filePath);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  For-loop which loops recursively over the paths in a RPM archive.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">for</span> (<span class="keywd">inout</span> <span class="type">string</span>: filePath) <span class="keywd">range</span> (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm) <span class="keywd">do</span>
              (<span class="op">in</span> <span class="type">proc</span>: statements)
            <span class="keywd">end</span> <span class="keywd">for</span> <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">for</span> <span class="keywd">key</span> filePath <span class="keywd">range</span> rpm.register <span class="keywd">do</span>
      statements;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">file</span>: openFileInRpm (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">string</span>: mode) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">file</span>: newFile <span class="keywd">is</span> STD_NULL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> mode = <span class="stri">"r"</span> <span class="keywd">then</span>
      <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
        raise RANGE_ERROR;
      <span class="keywd">elsif</span> filePath <span class="op">in</span> rpm.catalog <span class="keywd">then</span>
        <span class="keywd">if</span> rpm.archive = fileSys.value <span class="keywd">then</span>
          getArchive(rpm);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        newFile := open(rpm.archive, filePath, mode);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Open a file with ''filePath'' and ''mode'' in in a RPM archive.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">file</span>: open (<span class="keywd">inout</span> <span class="type">rpmArchive</span>: rpm, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">string</span>: mode) <span class="keywd">is</span>
  <span class="keywd">return</span> openFileInRpm(rpm, filePath, mode);
</pre>
</body>
</html>
