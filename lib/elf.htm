<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  elf.s7i       Support for the ELF executable and link format    *)</span>
<span class="comment">(*  Copyright (C) 2024  Thomas Mertes                               *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bytedata.htm">bytedata.s7i</a>"</span>;


<span class="keywd">const</span> <span class="type">string</span>: ELF_MAGIC <span class="keywd">is</span> <span class="stri">"\127;ELF"</span>;

<span class="keywd">const</span> <span class="type">integer</span>: ELF_IDENT_SIZE <span class="keywd">is</span> 16;
<span class="keywd">const</span> <span class="type">integer</span>: ELF_HEADER32_SIZE <span class="keywd">is</span> 52;
<span class="keywd">const</span> <span class="type">integer</span>: ELF_HEADER64_SIZE <span class="keywd">is</span> 64;

<span class="keywd">const</span> <span class="type">integer</span>: ELF_PROGRAM_HEADER32_SIZE <span class="keywd">is</span> 32;
<span class="keywd">const</span> <span class="type">integer</span>: ELF_PROGRAM_HEADER64_SIZE <span class="keywd">is</span> 56;

<span class="keywd">const</span> <span class="type">integer</span>: ELF_SECTION_HEADER32_SIZE <span class="keywd">is</span> 40;
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SECTION_HEADER64_SIZE <span class="keywd">is</span> 64;

<span class="keywd">const</span> <span class="type">integer</span>: ELF_NOTE_HEADER_SIZE <span class="keywd">is</span> 12;

<span class="keywd">const</span> <span class="type">integer</span>: ELF_SYM32_SIZE <span class="keywd">is</span> 16;
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SYM64_SIZE <span class="keywd">is</span> 24;

<span class="keywd">const</span> <span class="type">integer</span>: ELF_DYN32_SIZE <span class="keywd">is</span>  8;
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DYN64_SIZE <span class="keywd">is</span> 16;

<span class="keywd">const</span> <span class="type">integer</span>: ELF_VER_D_AUX_SIZE <span class="keywd">is</span>  8;
<span class="keywd">const</span> <span class="type">integer</span>: ELF_VER_N_AUX_SIZE <span class="keywd">is</span> 16;
<span class="keywd">const</span> <span class="type">integer</span>: ELF_VER_NEED_SIZE  <span class="keywd">is</span> 16;

<span class="keywd">const</span> <span class="type">integer</span>: ELF_TARGET_OS_SYSTEM_V       <span class="keywd">is</span> 16#00;  <span class="comment"># System V</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_TARGET_OS_HP_UX          <span class="keywd">is</span> 16#01;  <span class="comment"># HP-UX</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_TARGET_OS_NET_BSD        <span class="keywd">is</span> 16#02;  <span class="comment"># NetBSD</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_TARGET_OS_LINUX          <span class="keywd">is</span> 16#03;  <span class="comment"># Linux</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_TARGET_OS_GNU_HURD       <span class="keywd">is</span> 16#04;  <span class="comment"># GNU Hurd</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_TARGET_OS_SOLARIS        <span class="keywd">is</span> 16#06;  <span class="comment"># Solaris</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_TARGET_OS_AIX            <span class="keywd">is</span> 16#07;  <span class="comment"># AIX (Monterey)</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_TARGET_OS_IRIX           <span class="keywd">is</span> 16#08;  <span class="comment"># IRIX</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_TARGET_OS_FREE_BSD       <span class="keywd">is</span> 16#09;  <span class="comment"># FreeBSD</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_TARGET_OS_TRU64          <span class="keywd">is</span> 16#0a;  <span class="comment"># Tru64</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_TARGET_OS_NOVELL_MODESTO <span class="keywd">is</span> 16#0b;  <span class="comment"># Novell Modesto</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_TARGET_OS_OPEN_BSD       <span class="keywd">is</span> 16#0c;  <span class="comment"># OpenBSD</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_TARGET_OS_OPEN_VMS       <span class="keywd">is</span> 16#0d;  <span class="comment"># OpenVMS</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_TARGET_OS_NONSTOP_KERNEL <span class="keywd">is</span> 16#0e;  <span class="comment"># NonStop Kernel</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_TARGET_OS_AROS           <span class="keywd">is</span> 16#0f;  <span class="comment"># AROS</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_TARGET_OS_FENIX_OS       <span class="keywd">is</span> 16#10;  <span class="comment"># FenixOS</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_TARGET_OS_NUXI           <span class="keywd">is</span> 16#11;  <span class="comment"># Nuxi CloudABI</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_TARGET_OS_OPEN_VOS       <span class="keywd">is</span> 16#12;  <span class="comment"># Stratus Technologies OpenVOS</span>

<span class="keywd">const</span> <span class="type">integer</span>: ELF_OBJECT_FILE_TYPE_NONE   <span class="keywd">is</span> 16#00;    <span class="comment"># Unknown.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_OBJECT_FILE_TYPE_REL    <span class="keywd">is</span> 16#01;    <span class="comment"># Relocatable file.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_OBJECT_FILE_TYPE_EXEC   <span class="keywd">is</span> 16#02;    <span class="comment"># Executable file.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_OBJECT_FILE_TYPE_DYN    <span class="keywd">is</span> 16#03;    <span class="comment"># Shared object.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_OBJECT_FILE_TYPE_CORE   <span class="keywd">is</span> 16#04;    <span class="comment"># Core file.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_OBJECT_FILE_TYPE_LOOS   <span class="keywd">is</span> 16#fE00;  <span class="comment"># Reserved inclusive range. Operating system specific.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_OBJECT_FILE_TYPE_HIOS   <span class="keywd">is</span> 16#fEff;
<span class="keywd">const</span> <span class="type">integer</span>: ELF_OBJECT_FILE_TYPE_LOPROC <span class="keywd">is</span> 16#ff00;  <span class="comment"># Reserved inclusive range. Processor specific.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_OBJECT_FILE_TYPE_HIPROC <span class="keywd">is</span> 16#ffff;

<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_NO_SPECIFIC            <span class="keywd">is</span> 16#00;   <span class="comment"># No specific instruction set</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_AT_AND_T_WE            <span class="keywd">is</span> 16#01;   <span class="comment"># AT&amp;T WE 32100</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_SPARC                  <span class="keywd">is</span> 16#02;   <span class="comment"># SPARC</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_X86                    <span class="keywd">is</span> 16#03;   <span class="comment"># x86</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_MOTOROLA_68000         <span class="keywd">is</span> 16#04;   <span class="comment"># Motorola 68000 (M68k)</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_MOTOROLA_88000         <span class="keywd">is</span> 16#05;   <span class="comment"># Motorola 88000 (M88k)</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_INTEL_MCU              <span class="keywd">is</span> 16#06;   <span class="comment"># Intel MCU</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_INTEL_80860            <span class="keywd">is</span> 16#07;   <span class="comment"># Intel 80860</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_MIPS                   <span class="keywd">is</span> 16#08;   <span class="comment"># MIPS</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_IBM_SYSTEM_370         <span class="keywd">is</span> 16#09;   <span class="comment"># IBM System/370</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_MIPS_RS3000_LE         <span class="keywd">is</span> 16#0a;   <span class="comment"># MIPS RS3000 Little-endian</span>
<span class="comment">#                                            16#0b - 16#0e    # Reserved for future use</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_HP_PA_RISC             <span class="keywd">is</span> 16#0f;   <span class="comment"># Hewlett-Packard PA-RISC</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_INTEL_80960            <span class="keywd">is</span> 16#13;   <span class="comment"># Intel 80960</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_POWER_PC               <span class="keywd">is</span> 16#14;   <span class="comment"># PowerPC</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_POWER_PC_64_BIT        <span class="keywd">is</span> 16#15;   <span class="comment"># PowerPC (64-bit)</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_S390                   <span class="keywd">is</span> 16#16;   <span class="comment"># S390, including S3916#</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_IBM_SPU_SPC            <span class="keywd">is</span> 16#17;   <span class="comment"># IBM SPU/SPC</span>
<span class="comment">#                                            16#18 - 16#23    # Reserved for future use</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_NEC_V800               <span class="keywd">is</span> 16#24;   <span class="comment"># NEC V800</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_FUJITSU_FR20           <span class="keywd">is</span> 16#25;   <span class="comment"># Fujitsu FR20</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_TRW_RH_22              <span class="keywd">is</span> 16#26;   <span class="comment"># TRW RH-32</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_MOTOROLA_RCE           <span class="keywd">is</span> 16#27;   <span class="comment"># Motorola RCE</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_ARM                    <span class="keywd">is</span> 16#28;   <span class="comment"># Arm (up to Armv7/AArch32)</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_DIGITAL_ALPHA          <span class="keywd">is</span> 16#29;   <span class="comment"># Digital Alpha</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_SUPER_H                <span class="keywd">is</span> 16#2a;   <span class="comment"># SuperH</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_SPARC_VERSION_9        <span class="keywd">is</span> 16#2b;   <span class="comment"># SPARC Version 9</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_SIEMENS_TRI_CORE       <span class="keywd">is</span> 16#2c;   <span class="comment"># Siemens TriCore embedded processor</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_ARGONAUT_RISC          <span class="keywd">is</span> 16#2d;   <span class="comment"># Argonaut RISC Core</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_HITACHI_H8_300         <span class="keywd">is</span> 16#2e;   <span class="comment"># Hitachi H8/300</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_HITACHI_H8_300H        <span class="keywd">is</span> 16#2f;   <span class="comment"># Hitachi H8/300H</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_HITACHI_H8S            <span class="keywd">is</span> 16#30;   <span class="comment"># Hitachi H8S</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_HITACHI_H8_500         <span class="keywd">is</span> 16#31;   <span class="comment"># Hitachi H8/500</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_IA_64                  <span class="keywd">is</span> 16#32;   <span class="comment"># IA-64</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_STANFORD_MIPS_X        <span class="keywd">is</span> 16#33;   <span class="comment"># Stanford MIPS-X</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_MOTOROLA_COLD_FIRE     <span class="keywd">is</span> 16#34;   <span class="comment"># Motorola ColdFire</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_MOTOROLA_M68HC12       <span class="keywd">is</span> 16#35;   <span class="comment"># Motorola M68HC12</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_FUJITSU_MMA            <span class="keywd">is</span> 16#36;   <span class="comment"># Fujitsu MMA Multimedia Accelerator</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_SIEMENS_PCP            <span class="keywd">is</span> 16#37;   <span class="comment"># Siemens PCP</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_SONY_N_CPU             <span class="keywd">is</span> 16#38;   <span class="comment"># Sony nCPU embedded RISC processor</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_DENSO_NDR1             <span class="keywd">is</span> 16#39;   <span class="comment"># Denso NDR1 microprocessor</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_MOTOROLA_STAR_CORE     <span class="keywd">is</span> 16#3a;   <span class="comment"># Motorola Star*Core processor</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_TOYOTA_ME16            <span class="keywd">is</span> 16#3b;   <span class="comment"># Toyota ME16 processor</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_ST100                  <span class="keywd">is</span> 16#3c;   <span class="comment"># STMicroelectronics ST100 processor</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_TINY_J                 <span class="keywd">is</span> 16#3d;   <span class="comment"># Advanced Logic Corp. TinyJ embedded processor family</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_AMD_X86_64             <span class="keywd">is</span> 16#3e;   <span class="comment"># AMD x86-64</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_SONY_DSP               <span class="keywd">is</span> 16#3f;   <span class="comment"># Sony DSP Processor</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_DEC_PDP_10             <span class="keywd">is</span> 16#40;   <span class="comment"># Digital Equipment Corp. PDP-10</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_DEC_PDP_11             <span class="keywd">is</span> 16#41;   <span class="comment"># Digital Equipment Corp. PDP-11</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_SIEMENS_FX66           <span class="keywd">is</span> 16#42;   <span class="comment"># Siemens FX66 microcontroller</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_ST9                    <span class="keywd">is</span> 16#43;   <span class="comment"># STMicroelectronics ST9+ 8/16 bit microcontroller</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_ST7                    <span class="keywd">is</span> 16#44;   <span class="comment"># STMicroelectronics ST7 8-bit microcontroller</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_MOTOROLA_MC68HC16      <span class="keywd">is</span> 16#45;   <span class="comment"># Motorola MC68HC16 Microcontroller</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_MOTOROLA_MC68HC11      <span class="keywd">is</span> 16#46;   <span class="comment"># Motorola MC68HC11 Microcontroller</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_MOTOROLA_MC68HC08      <span class="keywd">is</span> 16#47;   <span class="comment"># Motorola MC68HC08 Microcontroller</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_MOTOROLA_MC68HC05      <span class="keywd">is</span> 16#48;   <span class="comment"># Motorola MC68HC05 Microcontroller</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_SILICON_GRAPHICS_SV_X  <span class="keywd">is</span> 16#49;   <span class="comment"># Silicon Graphics SVx</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_ST19                   <span class="keywd">is</span> 16#4a;   <span class="comment"># STMicroelectronics ST19 8-bit microcontroller</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_DIGITAL_VAX            <span class="keywd">is</span> 16#4b;   <span class="comment"># Digital VAX</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_AXIS                   <span class="keywd">is</span> 16#4c;   <span class="comment"># Axis Communications 32-bit embedded processor</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_INFINEON               <span class="keywd">is</span> 16#4d;   <span class="comment"># Infineon Technologies 32-bit embedded processor</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_ELEMENT_14             <span class="keywd">is</span> 16#4e;   <span class="comment"># Element 14 64-bit DSP Processor</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_LSI_LOGIC              <span class="keywd">is</span> 16#4f;   <span class="comment"># LSI Logic 16-bit DSP Processor</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_TMS320C6000            <span class="keywd">is</span> 16#8c;   <span class="comment"># TMS320C6000 Family</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_MCST_ELBRUS_E2K        <span class="keywd">is</span> 16#af;   <span class="comment"># MCST Elbrus e2k</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_ARM_64                 <span class="keywd">is</span> 16#b7;   <span class="comment"># Arm 64-bits (Armv8/AArch64)</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_ZILOG_Z80              <span class="keywd">is</span> 16#dc;   <span class="comment"># Zilog Z80</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_RISC_V                 <span class="keywd">is</span> 16#f3;   <span class="comment"># RISC-V</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_BERKELEY_PACKET_FILTER <span class="keywd">is</span> 16#f7;   <span class="comment"># Berkeley Packet Filter</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_WDC_65C816             <span class="keywd">is</span> 16#101;  <span class="comment"># WDC 65C816</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_MACHINE_LOONG_ARCH             <span class="keywd">is</span> 16#102;  <span class="comment"># LoongArch</span>

<span class="keywd">const</span> <span class="type">integer</span>: ELF_PT_NULL    <span class="keywd">is</span> 16#00000000;  <span class="comment"># Program header table entry unused.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_PT_LOAD    <span class="keywd">is</span> 16#00000001;  <span class="comment"># Loadable segment.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_PT_DYNAMIC <span class="keywd">is</span> 16#00000002;  <span class="comment"># Dynamic linking information.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_PT_INTERP  <span class="keywd">is</span> 16#00000003;  <span class="comment"># Interpreter information.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_PT_NOTE    <span class="keywd">is</span> 16#00000004;  <span class="comment"># Auxiliary information.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_PT_SHLIB   <span class="keywd">is</span> 16#00000005;  <span class="comment"># Reserved.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_PT_PHDR    <span class="keywd">is</span> 16#00000006;  <span class="comment"># Segment containing program header table itself.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_PT_TLS     <span class="keywd">is</span> 16#00000007;  <span class="comment"># Thread-Local Storage template.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_PT_LOOS    <span class="keywd">is</span> 16#60000000;  <span class="comment"># Reserved inclusive range. Operating system specific.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_PT_HIOS    <span class="keywd">is</span> 16#6fffffff;
<span class="keywd">const</span> <span class="type">integer</span>: ELF_PT_LOPROC  <span class="keywd">is</span> 16#70000000;  <span class="comment"># Reserved inclusive range. Processor specific.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_PT_HIPROC  <span class="keywd">is</span> 16#7fffffff;

<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_NULL           <span class="keywd">is</span> 16#0;         <span class="comment"># Section header table entry unused</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_PROGBITS       <span class="keywd">is</span> 16#1;         <span class="comment"># Program data</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_SYMTAB         <span class="keywd">is</span> 16#2;         <span class="comment"># Symbol table</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_STRTAB         <span class="keywd">is</span> 16#3;         <span class="comment"># String table</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_RELA           <span class="keywd">is</span> 16#4;         <span class="comment"># Relocation entries with addends</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_HASH           <span class="keywd">is</span> 16#5;         <span class="comment"># Symbol hash table</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_DYNAMIC        <span class="keywd">is</span> 16#6;         <span class="comment"># Dynamic linking information</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_NOTE           <span class="keywd">is</span> 16#7;         <span class="comment"># Notes</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_NOBITS         <span class="keywd">is</span> 16#8;         <span class="comment"># Program space with no data (bss)</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_REL            <span class="keywd">is</span> 16#9;         <span class="comment"># Relocation entries, no addends</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_SHLIB          <span class="keywd">is</span> 16#a;         <span class="comment"># Reserved</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_DYNSYM         <span class="keywd">is</span> 16#b;         <span class="comment"># Dynamic linker symbol table</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_INIT_ARRAY     <span class="keywd">is</span> 16#e;         <span class="comment"># Array of constructors</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_FINI_ARRAY     <span class="keywd">is</span> 16#f;         <span class="comment"># Array of destructors</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_PREINIT_ARRAY  <span class="keywd">is</span> 16#10;        <span class="comment"># Array of pre-constructors</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_GROUP          <span class="keywd">is</span> 16#11;        <span class="comment"># Section group</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_SYMTAB_SHNDX   <span class="keywd">is</span> 16#12;        <span class="comment"># Extended section indices</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_NUM            <span class="keywd">is</span> 16#13;        <span class="comment"># Number of defined types.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_LOOS           <span class="keywd">is</span> 16#60000000;  <span class="comment"># Start OS-specific.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_GNU_ATTRIBUTES <span class="keywd">is</span> 16#6ffffff5;  <span class="comment"># Object attributes.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_GNU_HASH       <span class="keywd">is</span> 16#6ffffff6;  <span class="comment"># GNU-style hash table.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_GNU_LIBLIST    <span class="keywd">is</span> 16#6ffffff7;  <span class="comment"># Prelink library list</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_CHECKSUM       <span class="keywd">is</span> 16#6ffffff8;  <span class="comment"># Checksum for DSO content.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_LOSUNW         <span class="keywd">is</span> 16#6ffffffa;  <span class="comment"># Sun-specific low bound.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_SUNW_move      <span class="keywd">is</span> 16#6ffffffa;
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_SUNW_COMDAT    <span class="keywd">is</span> 16#6ffffffb;
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_SUNW_syminfo   <span class="keywd">is</span> 16#6ffffffc;
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_GNU_verdef     <span class="keywd">is</span> 16#6ffffffd;  <span class="comment"># Version definition section.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_GNU_verneed    <span class="keywd">is</span> 16#6ffffffe;  <span class="comment"># Version needs section.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHT_GNU_versym     <span class="keywd">is</span> 16#6fffffff;  <span class="comment"># Version symbol table.</span>

<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHF_WRITE            <span class="keywd">is</span> 16#1;         <span class="comment"># Writable</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHF_ALLOC            <span class="keywd">is</span> 16#2;         <span class="comment"># Occupies memory during execution</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHF_EXECINSTR        <span class="keywd">is</span> 16#4;         <span class="comment"># Executable</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHF_MERGE            <span class="keywd">is</span> 16#10;        <span class="comment"># Might be merged</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHF_STRINGS          <span class="keywd">is</span> 16#20;        <span class="comment"># Contains null-terminated strings</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHF_INFO_LINK        <span class="keywd">is</span> 16#40;        <span class="comment"># 'sh_info' contains SHT index</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHF_LINK_ORDER       <span class="keywd">is</span> 16#80;        <span class="comment"># Preserve order after combining</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHF_OS_NONCONFORMING <span class="keywd">is</span> 16#100;       <span class="comment"># Non-standard OS specific handling required</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHF_GROUP            <span class="keywd">is</span> 16#200;       <span class="comment"># Section is member of a group</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHF_TLS              <span class="keywd">is</span> 16#400;       <span class="comment"># Section hold thread-local data</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHF_MASKOS           <span class="keywd">is</span> 16#0ff00000;  <span class="comment"># OS-specific</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHF_MASKPROC         <span class="keywd">is</span> 16#f0000000;  <span class="comment"># Processor-specific</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHF_ORDERED          <span class="keywd">is</span> 16#4000000;   <span class="comment"># Special ordering requirement (Solaris)</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_SHF_EXCLUDE          <span class="keywd">is</span> 16#8000000;   <span class="comment"># Section is excluded unless referenced or allocated (Solaris)</span>

<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_NULL            <span class="keywd">is</span>  0;  <span class="comment"># Marks end of dynamic section</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_NEEDED          <span class="keywd">is</span>  1;  <span class="comment"># Name of needed library</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_PLTRELSZ        <span class="keywd">is</span>  2;  <span class="comment"># Size in bytes of PLT relocs</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_PLTGOT          <span class="keywd">is</span>  3;  <span class="comment"># Processor defined value</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_HASH            <span class="keywd">is</span>  4;  <span class="comment"># Address of symbol hash table</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_STRTAB          <span class="keywd">is</span>  5;  <span class="comment"># Address of string table</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_SYMTAB          <span class="keywd">is</span>  6;  <span class="comment"># Address of symbol table</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_RELA            <span class="keywd">is</span>  7;  <span class="comment"># Address of Rela relocs</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_RELASZ          <span class="keywd">is</span>  8;  <span class="comment"># Total size of Rela relocs</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_RELAENT         <span class="keywd">is</span>  9;  <span class="comment"># Size of one Rela reloc</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_STRSZ           <span class="keywd">is</span> 10;  <span class="comment"># Size of string table</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_SYMENT          <span class="keywd">is</span> 11;  <span class="comment"># Size of one symbol table entry</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_INIT            <span class="keywd">is</span> 12;  <span class="comment"># Address of init function</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_FINI            <span class="keywd">is</span> 13;  <span class="comment"># Address of termination function</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_SONAME          <span class="keywd">is</span> 14;  <span class="comment"># Name of shared object</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_RPATH           <span class="keywd">is</span> 15;  <span class="comment"># Library search path (deprecated)</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_SYMBOLIC        <span class="keywd">is</span> 16;  <span class="comment"># Start symbol search here</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_REL             <span class="keywd">is</span> 17;  <span class="comment"># Address of Rel relocs</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_RELSZ           <span class="keywd">is</span> 18;  <span class="comment"># Total size of Rel relocs</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_RELENT          <span class="keywd">is</span> 19;  <span class="comment"># Size of one Rel reloc</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_PLTREL          <span class="keywd">is</span> 20;  <span class="comment"># Type of reloc in PLT</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_DEBUG           <span class="keywd">is</span> 21;  <span class="comment"># For debugging; unspecified</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_TEXTREL         <span class="keywd">is</span> 22;  <span class="comment"># Reloc might modify .text</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_JMPREL          <span class="keywd">is</span> 23;  <span class="comment"># Address of PLT relocs</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_BIND_NOW        <span class="keywd">is</span> 24;  <span class="comment"># Process relocations of object</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_INIT_ARRAY      <span class="keywd">is</span> 25;  <span class="comment"># Array with addresses of init fct</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_FINI_ARRAY      <span class="keywd">is</span> 26;  <span class="comment"># Array with addresses of fini fct</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_INIT_ARRAYSZ    <span class="keywd">is</span> 27;  <span class="comment"># Size in bytes of DT_INIT_ARRAY</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_FINI_ARRAYSZ    <span class="keywd">is</span> 28;  <span class="comment"># Size in bytes of DT_FINI_ARRAY</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_RUNPATH         <span class="keywd">is</span> 29;  <span class="comment"># Library search path</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_FLAGS           <span class="keywd">is</span> 30;  <span class="comment"># Flags for the object being loaded</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_ENCODING        <span class="keywd">is</span> 32;  <span class="comment"># Start of encoded range</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_PREINIT_ARRAY   <span class="keywd">is</span> 32;  <span class="comment"># Array with addresses of preinit fct*/</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_PREINIT_ARRAYSZ <span class="keywd">is</span> 33;  <span class="comment"># size in bytes of DT_PREINIT_ARRAY</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_SYMTAB_SHNDX    <span class="keywd">is</span> 34;  <span class="comment"># Address of SYMTAB_SHNDX section</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_RELRSZ          <span class="keywd">is</span> 35;  <span class="comment"># Total size of RELR relative relocations</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_RELR            <span class="keywd">is</span> 36;  <span class="comment"># Address of RELR relative relocations</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_RELRENT         <span class="keywd">is</span> 37;  <span class="comment"># Size of one RELR relative relocaction</span>
<span class="keywd">const</span> <span class="type">integer</span>: ELF_DT_NUM             <span class="keywd">is</span> 38;  <span class="comment"># Number used</span>


<span class="keywd">const</span> <span class="type">type</span>: elfHeader <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">string</span>: magic <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: addressSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: isLittleEndian <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">integer</span>: elfVersion <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: targetOs <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: abiVersion <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: objectFileType <span class="keywd">is</span> 0;       <span class="comment"># Object file type</span>
    <span class="keywd">var</span> <span class="type">integer</span>: machine <span class="keywd">is</span> 0;              <span class="comment"># Architecture</span>
    <span class="keywd">var</span> <span class="type">integer</span>: version <span class="keywd">is</span> 0;              <span class="comment"># Object file version</span>
    <span class="keywd">var</span> <span class="type">integer</span>: entry <span class="keywd">is</span> 0;                <span class="comment"># Entry point virtual address</span>
    <span class="keywd">var</span> <span class="type">integer</span>: programHeaderOffset <span class="keywd">is</span> 0;  <span class="comment"># Program header table file offset</span>
    <span class="keywd">var</span> <span class="type">integer</span>: sectionHeaderOffset <span class="keywd">is</span> 0;  <span class="comment"># Section header table file offset</span>
    <span class="keywd">var</span> <span class="type">integer</span>: flags <span class="keywd">is</span> 0;                <span class="comment"># Processor-specific flags</span>
    <span class="keywd">var</span> <span class="type">integer</span>: headerSize <span class="keywd">is</span> 0;           <span class="comment"># ELF header size in bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: programHeaderSize <span class="keywd">is</span> 0;    <span class="comment"># Program header table entry size</span>
    <span class="keywd">var</span> <span class="type">integer</span>: programHeaderNum <span class="keywd">is</span> 0;     <span class="comment"># Program header table entry count</span>
    <span class="keywd">var</span> <span class="type">integer</span>: sectionHeaderSize <span class="keywd">is</span> 0;    <span class="comment"># Section header table entry size</span>
    <span class="keywd">var</span> <span class="type">integer</span>: sectionHeaderNum <span class="keywd">is</span> 0;     <span class="comment"># Section header table entry count</span>
    <span class="keywd">var</span> <span class="type">integer</span>: nameSectionIndex <span class="keywd">is</span> 0;     <span class="comment"># Section header string table index</span>
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: show (<span class="op">in</span> <span class="type">elfHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"magic: "</span> &lt;&amp; literal(header.magic));
    writeln(<span class="stri">"addressSize: "</span> &lt;&amp; header.addressSize);
    writeln(<span class="stri">"isLittleEndian: "</span> &lt;&amp; header.isLittleEndian);
    writeln(<span class="stri">"elfVersion: "</span> &lt;&amp; header.elfVersion);
    writeln(<span class="stri">"targetOs: "</span> &lt;&amp; header.targetOs);
    writeln(<span class="stri">"abiVersion: "</span> &lt;&amp; header.abiVersion);
    writeln(<span class="stri">"objectFileType: "</span> &lt;&amp; header.objectFileType);
    writeln(<span class="stri">"machine: 16#"</span> &lt;&amp; header.machine radix 16);
    writeln(<span class="stri">"version: "</span> &lt;&amp; header.version);
    writeln(<span class="stri">"entry: "</span> &lt;&amp; header.entry);
    writeln(<span class="stri">"programHeaderOffset: "</span> &lt;&amp; header.programHeaderOffset);
    writeln(<span class="stri">"sectionHeaderOffset: "</span> &lt;&amp; header.sectionHeaderOffset);
    writeln(<span class="stri">"flags: "</span> &lt;&amp; header.flags);
    writeln(<span class="stri">"headerSize: "</span> &lt;&amp; header.headerSize);
    writeln(<span class="stri">"programHeaderSize: "</span> &lt;&amp; header.programHeaderSize);
    writeln(<span class="stri">"programHeaderNum: "</span> &lt;&amp; header.programHeaderNum);
    writeln(<span class="stri">"sectionHeaderSize: "</span> &lt;&amp; header.sectionHeaderSize);
    writeln(<span class="stri">"sectionHeaderNum: "</span> &lt;&amp; header.sectionHeaderNum);
    writeln(<span class="stri">"nameSectionIndex: "</span> &lt;&amp; header.nameSectionIndex);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readHeader32Le (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    header.objectFileType      := bytes2Int(stri[17 fixLen  2], UNSIGNED, LE);
    header.machine             := bytes2Int(stri[19 fixLen  2], UNSIGNED, LE);
    header.version             := bytes2Int(stri[21 fixLen  4], UNSIGNED, LE);
    header.entry               := bytes2Int(stri[25 fixLen  4], UNSIGNED, LE);
    header.programHeaderOffset := bytes2Int(stri[29 fixLen  4], UNSIGNED, LE);
    header.sectionHeaderOffset := bytes2Int(stri[33 fixLen  4], UNSIGNED, LE);
    header.flags               := bytes2Int(stri[37 fixLen  4], UNSIGNED, LE);
    header.headerSize          := bytes2Int(stri[41 fixLen  2], UNSIGNED, LE);
    header.programHeaderSize   := bytes2Int(stri[43 fixLen  2], UNSIGNED, LE);
    header.programHeaderNum    := bytes2Int(stri[45 fixLen  2], UNSIGNED, LE);
    header.sectionHeaderSize   := bytes2Int(stri[47 fixLen  2], UNSIGNED, LE);
    header.sectionHeaderNum    := bytes2Int(stri[49 fixLen  2], UNSIGNED, LE);
    header.nameSectionIndex    := bytes2Int(stri[51 fixLen  2], UNSIGNED, LE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readHeader32Be (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    header.objectFileType      := bytes2Int(stri[17 fixLen  2], UNSIGNED, BE);
    header.machine             := bytes2Int(stri[19 fixLen  2], UNSIGNED, BE);
    header.version             := bytes2Int(stri[21 fixLen  4], UNSIGNED, BE);
    header.entry               := bytes2Int(stri[25 fixLen  4], UNSIGNED, BE);
    header.programHeaderOffset := bytes2Int(stri[29 fixLen  4], UNSIGNED, BE);
    header.sectionHeaderOffset := bytes2Int(stri[33 fixLen  4], UNSIGNED, BE);
    header.flags               := bytes2Int(stri[37 fixLen  4], UNSIGNED, BE);
    header.headerSize          := bytes2Int(stri[41 fixLen  2], UNSIGNED, BE);
    header.programHeaderSize   := bytes2Int(stri[43 fixLen  2], UNSIGNED, BE);
    header.programHeaderNum    := bytes2Int(stri[45 fixLen  2], UNSIGNED, BE);
    header.sectionHeaderSize   := bytes2Int(stri[47 fixLen  2], UNSIGNED, BE);
    header.sectionHeaderNum    := bytes2Int(stri[49 fixLen  2], UNSIGNED, BE);
    header.nameSectionIndex    := bytes2Int(stri[51 fixLen  2], UNSIGNED, BE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readHeader64Le (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    header.objectFileType      := bytes2Int(stri[17 fixLen  2], UNSIGNED, LE);
    header.machine             := bytes2Int(stri[19 fixLen  2], UNSIGNED, LE);
    header.version             := bytes2Int(stri[21 fixLen  4], UNSIGNED, LE);
    header.entry               := bytes2Int(stri[25 fixLen  8], UNSIGNED, LE);
    header.programHeaderOffset := bytes2Int(stri[33 fixLen  8], UNSIGNED, LE);
    header.sectionHeaderOffset := bytes2Int(stri[41 fixLen  8], UNSIGNED, LE);
    header.flags               := bytes2Int(stri[49 fixLen  4], UNSIGNED, LE);
    header.headerSize          := bytes2Int(stri[53 fixLen  2], UNSIGNED, LE);
    header.programHeaderSize   := bytes2Int(stri[55 fixLen  2], UNSIGNED, LE);
    header.programHeaderNum    := bytes2Int(stri[57 fixLen  2], UNSIGNED, LE);
    header.sectionHeaderSize   := bytes2Int(stri[59 fixLen  2], UNSIGNED, LE);
    header.sectionHeaderNum    := bytes2Int(stri[61 fixLen  2], UNSIGNED, LE);
    header.nameSectionIndex    := bytes2Int(stri[63 fixLen  2], UNSIGNED, LE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readHeader64Be (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    header.objectFileType      := bytes2Int(stri[17 fixLen  2], UNSIGNED, BE);
    header.machine             := bytes2Int(stri[19 fixLen  2], UNSIGNED, BE);
    header.version             := bytes2Int(stri[21 fixLen  4], UNSIGNED, BE);
    header.entry               := bytes2Int(stri[25 fixLen  8], UNSIGNED, BE);
    header.programHeaderOffset := bytes2Int(stri[33 fixLen  8], UNSIGNED, BE);
    header.sectionHeaderOffset := bytes2Int(stri[41 fixLen  8], UNSIGNED, BE);
    header.flags               := bytes2Int(stri[49 fixLen  4], UNSIGNED, BE);
    header.headerSize          := bytes2Int(stri[53 fixLen  2], UNSIGNED, BE);
    header.programHeaderSize   := bytes2Int(stri[55 fixLen  2], UNSIGNED, BE);
    header.programHeaderNum    := bytes2Int(stri[57 fixLen  2], UNSIGNED, BE);
    header.sectionHeaderSize   := bytes2Int(stri[59 fixLen  2], UNSIGNED, BE);
    header.sectionHeaderNum    := bytes2Int(stri[61 fixLen  2], UNSIGNED, BE);
    header.nameSectionIndex    := bytes2Int(stri[63 fixLen  2], UNSIGNED, BE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readHeader (<span class="keywd">inout</span> <span class="type">file</span>: inFile, <span class="keywd">inout</span> <span class="type">elfHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: addressFormat <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: endianess <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    stri := gets(inFile, ELF_IDENT_SIZE);
    <span class="keywd">if</span> length(stri) = ELF_IDENT_SIZE <span class="keywd">then</span>
      header.magic             :=           stri[ 1 fixLen  4];
      addressFormat            := bytes2Int(stri[ 5 fixLen  1], UNSIGNED, LE);
      endianess                := bytes2Int(stri[ 6 fixLen  1], UNSIGNED, LE);
      header.elfVersion        := bytes2Int(stri[ 7 fixLen  1], UNSIGNED, LE);
      header.targetOs          := bytes2Int(stri[ 8 fixLen  1], UNSIGNED, LE);
      header.abiVersion        := bytes2Int(stri[ 9 fixLen  1], UNSIGNED, LE);
      <span class="comment"># 7 reserved padding bytes are currently unused.</span>
      <span class="keywd">if</span> header.magic =  ELF_MAGIC <span class="keywd">then</span>
        <span class="keywd">if</span> addressFormat = 1 <span class="keywd">then</span>
          stri &amp;:= gets(inFile, ELF_HEADER32_SIZE - ELF_IDENT_SIZE);
          <span class="keywd">if</span> length(stri) = ELF_HEADER32_SIZE <span class="keywd">then</span>
            header.addressSize := 32;
            <span class="keywd">if</span> endianess = 1 <span class="keywd">then</span>
              header.isLittleEndian := TRUE;
              readHeader32Le(stri, header);
            <span class="keywd">elsif</span> endianess = 2 <span class="keywd">then</span>
              header.isLittleEndian := FALSE;
              readHeader32Be(stri, header);
            <span class="keywd">else</span>
              raise RANGE_ERROR;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            raise RANGE_ERROR;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> addressFormat = 2 <span class="keywd">then</span>
          stri &amp;:= gets(inFile, ELF_HEADER64_SIZE - ELF_IDENT_SIZE);
          <span class="keywd">if</span> length(stri) = ELF_HEADER64_SIZE <span class="keywd">then</span>
            header.addressSize := 64;
            <span class="keywd">if</span> endianess = 1 <span class="keywd">then</span>
              header.isLittleEndian := TRUE;
              readHeader64Le(stri, header);
            <span class="keywd">elsif</span> endianess = 2 <span class="keywd">then</span>
              header.isLittleEndian := FALSE;
              readHeader64Be(stri, header);
            <span class="keywd">else</span>
              raise RANGE_ERROR;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            raise RANGE_ERROR;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: elfProgramHeader <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: segmentType <span class="keywd">is</span> 0;   <span class="comment"># Segment type</span>
    <span class="keywd">var</span> <span class="type">integer</span>: offset <span class="keywd">is</span> 0;        <span class="comment"># Segment file offset</span>
    <span class="keywd">var</span> <span class="type">integer</span>: virtualAddr <span class="keywd">is</span> 0;   <span class="comment"># Segment virtual address</span>
    <span class="keywd">var</span> <span class="type">integer</span>: physicalAddr <span class="keywd">is</span> 0;  <span class="comment"># Segment physical address</span>
    <span class="keywd">var</span> <span class="type">integer</span>: fileSize <span class="keywd">is</span> 0;      <span class="comment"># Segment size in file</span>
    <span class="keywd">var</span> <span class="type">integer</span>: memorySize <span class="keywd">is</span> 0;    <span class="comment"># Segment size in memory</span>
    <span class="keywd">var</span> <span class="type">integer</span>: flags <span class="keywd">is</span> 0;         <span class="comment"># Segment flags</span>
    <span class="keywd">var</span> <span class="type">integer</span>: alignment <span class="keywd">is</span> 0;     <span class="comment"># Segment alignment</span>
    <span class="keywd">var</span> <span class="type">integer</span>: addressSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: isLittleEndian <span class="keywd">is</span> TRUE;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: show (<span class="op">in</span> <span class="type">elfProgramHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"segmentType: "</span> &lt;&amp; header.segmentType);
    writeln(<span class="stri">"flags: "</span> &lt;&amp; header.flags);
    writeln(<span class="stri">"offset: "</span> &lt;&amp; header.offset);
    writeln(<span class="stri">"virtualAddr: "</span> &lt;&amp; header.virtualAddr);
    writeln(<span class="stri">"physicalAddr: "</span> &lt;&amp; header.physicalAddr);
    writeln(<span class="stri">"fileSize: "</span> &lt;&amp; header.fileSize);
    writeln(<span class="stri">"memorySize: "</span> &lt;&amp; header.memorySize);
    writeln(<span class="stri">"alignment: "</span> &lt;&amp; header.alignment);
    writeln(<span class="stri">"addressSize: "</span> &lt;&amp; header.addressSize);
    writeln(<span class="stri">"isLittleEndian: "</span> &lt;&amp; header.isLittleEndian);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readProgramHeader32Le (<span class="op">in</span> <span class="type">string</span>: stri,
    <span class="keywd">inout</span> <span class="type">elfProgramHeader</span>: programHeader) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    programHeader.segmentType  := bytes2Int(stri[ 1 fixLen 4], UNSIGNED, LE);
    programHeader.offset       := bytes2Int(stri[ 5 fixLen 4], UNSIGNED, LE);
    programHeader.virtualAddr  := bytes2Int(stri[ 9 fixLen 4], UNSIGNED, LE);
    programHeader.physicalAddr := bytes2Int(stri[13 fixLen 4], UNSIGNED, LE);
    programHeader.fileSize     := bytes2Int(stri[17 fixLen 4], UNSIGNED, LE);
    programHeader.memorySize   := bytes2Int(stri[21 fixLen 4], UNSIGNED, LE);
    programHeader.flags        := bytes2Int(stri[25 fixLen 4], UNSIGNED, LE);
    programHeader.alignment    := bytes2Int(stri[29 fixLen 4], UNSIGNED, LE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readProgramHeader32Be (<span class="op">in</span> <span class="type">string</span>: stri,
    <span class="keywd">inout</span> <span class="type">elfProgramHeader</span>: programHeader) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    programHeader.segmentType  := bytes2Int(stri[ 1 fixLen 4], UNSIGNED, BE);
    programHeader.offset       := bytes2Int(stri[ 5 fixLen 4], UNSIGNED, BE);
    programHeader.virtualAddr  := bytes2Int(stri[ 9 fixLen 4], UNSIGNED, BE);
    programHeader.physicalAddr := bytes2Int(stri[13 fixLen 4], UNSIGNED, BE);
    programHeader.fileSize     := bytes2Int(stri[17 fixLen 4], UNSIGNED, BE);
    programHeader.memorySize   := bytes2Int(stri[21 fixLen 4], UNSIGNED, BE);
    programHeader.flags        := bytes2Int(stri[25 fixLen 4], UNSIGNED, BE);
    programHeader.alignment    := bytes2Int(stri[29 fixLen 4], UNSIGNED, BE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readProgramHeader64Le (<span class="op">in</span> <span class="type">string</span>: stri,
    <span class="keywd">inout</span> <span class="type">elfProgramHeader</span>: programHeader) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    programHeader.segmentType  := bytes2Int(stri[ 1 fixLen 4], UNSIGNED, LE);
    programHeader.flags        := bytes2Int(stri[ 5 fixLen 4], UNSIGNED, LE);
    programHeader.offset       := bytes2Int(stri[ 9 fixLen 8], UNSIGNED, LE);
    programHeader.virtualAddr  := bytes2Int(stri[17 fixLen 8], UNSIGNED, LE);
    programHeader.physicalAddr := bytes2Int(stri[25 fixLen 8], UNSIGNED, LE);
    programHeader.fileSize     := bytes2Int(stri[33 fixLen 8], UNSIGNED, LE);
    programHeader.memorySize   := bytes2Int(stri[41 fixLen 8], UNSIGNED, LE);
    programHeader.alignment    := bytes2Int(stri[49 fixLen 8], UNSIGNED, LE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readProgramHeader64Be (<span class="op">in</span> <span class="type">string</span>: stri,
    <span class="keywd">inout</span> <span class="type">elfProgramHeader</span>: programHeader) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    programHeader.segmentType  := bytes2Int(stri[ 1 fixLen 4], UNSIGNED, BE);
    programHeader.flags        := bytes2Int(stri[ 5 fixLen 4], UNSIGNED, BE);
    programHeader.offset       := bytes2Int(stri[ 9 fixLen 8], UNSIGNED, BE);
    programHeader.virtualAddr  := bytes2Int(stri[17 fixLen 8], UNSIGNED, BE);
    programHeader.physicalAddr := bytes2Int(stri[25 fixLen 8], UNSIGNED, BE);
    programHeader.fileSize     := bytes2Int(stri[33 fixLen 8], UNSIGNED, BE);
    programHeader.memorySize   := bytes2Int(stri[41 fixLen 8], UNSIGNED, BE);
    programHeader.alignment    := bytes2Int(stri[49 fixLen 8], UNSIGNED, BE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readProgramHeader (<span class="keywd">inout</span> <span class="type">file</span>: inFile, <span class="op">in</span> <span class="type">elfHeader</span>: header,
    <span class="keywd">inout</span> <span class="type">elfProgramHeader</span>: programHeader) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := gets(inFile, header.programHeaderSize);
    <span class="keywd">if</span> length(stri) = header.programHeaderSize <span class="keywd">then</span>
      <span class="keywd">if</span> header.addressSize = 32 <span class="keywd">then</span>
        <span class="keywd">if</span> length(stri) >= ELF_PROGRAM_HEADER32_SIZE <span class="keywd">then</span>
          <span class="keywd">if</span> header.isLittleEndian <span class="keywd">then</span>
            readProgramHeader32Le(stri, programHeader);
          <span class="keywd">else</span>
            readProgramHeader32Be(stri, programHeader);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> header.addressSize = 64 <span class="keywd">then</span>
        <span class="keywd">if</span> length(stri) >= ELF_PROGRAM_HEADER64_SIZE <span class="keywd">then</span>
          <span class="keywd">if</span> header.isLittleEndian <span class="keywd">then</span>
            readProgramHeader64Le(stri, programHeader);
          <span class="keywd">else</span>
            readProgramHeader64Be(stri, programHeader);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      programHeader.addressSize := header.addressSize;
      programHeader.isLittleEndian := header.isLittleEndian;
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: elfSectionHeader <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: nameOffset <span class="keywd">is</span> 0;     <span class="comment"># Section name (string tbl index)</span>
    <span class="keywd">var</span> <span class="type">integer</span>: sectionType <span class="keywd">is</span> 0;    <span class="comment"># Section type</span>
    <span class="keywd">var</span> <span class="type">integer</span>: flags <span class="keywd">is</span> 0;          <span class="comment"># Section flags</span>
    <span class="keywd">var</span> <span class="type">integer</span>: address <span class="keywd">is</span> 0;        <span class="comment"># Section virtual addr at execution</span>
    <span class="keywd">var</span> <span class="type">integer</span>: offset <span class="keywd">is</span> 0;         <span class="comment"># Section file offset</span>
    <span class="keywd">var</span> <span class="type">integer</span>: size <span class="keywd">is</span> 0;           <span class="comment"># Section size in bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: link <span class="keywd">is</span> 0;           <span class="comment"># Link to another section</span>
    <span class="keywd">var</span> <span class="type">integer</span>: info <span class="keywd">is</span> 0;           <span class="comment"># Additional section information</span>
    <span class="keywd">var</span> <span class="type">integer</span>: addrAlignment <span class="keywd">is</span> 0;  <span class="comment"># Section alignment</span>
    <span class="keywd">var</span> <span class="type">integer</span>: entrySize <span class="keywd">is</span> 0;      <span class="comment"># Entry size if section holds table</span>
    <span class="keywd">var</span> <span class="type">string</span>: name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: addressSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: isLittleEndian <span class="keywd">is</span> TRUE;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: sectionTypeName (<span class="op">in</span> <span class="type">integer</span>: sectionType) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: typeName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> sectionType <span class="keywd">of</span>
      <span class="keywd">when</span> {ELF_SHT_NULL}:           typeName := <span class="stri">"SHT_NULL"</span>;
      <span class="keywd">when</span> {ELF_SHT_PROGBITS}:       typeName := <span class="stri">"SHT_PROGBITS"</span>;
      <span class="keywd">when</span> {ELF_SHT_SYMTAB}:         typeName := <span class="stri">"SHT_SYMTAB"</span>;
      <span class="keywd">when</span> {ELF_SHT_STRTAB}:         typeName := <span class="stri">"SHT_STRTAB"</span>;
      <span class="keywd">when</span> {ELF_SHT_RELA}:           typeName := <span class="stri">"SHT_RELA"</span>;
      <span class="keywd">when</span> {ELF_SHT_HASH}:           typeName := <span class="stri">"SHT_HASH"</span>;
      <span class="keywd">when</span> {ELF_SHT_DYNAMIC}:        typeName := <span class="stri">"SHT_DYNAMIC"</span>;
      <span class="keywd">when</span> {ELF_SHT_NOTE}:           typeName := <span class="stri">"SHT_NOTE"</span>;
      <span class="keywd">when</span> {ELF_SHT_NOBITS}:         typeName := <span class="stri">"SHT_NOBITS"</span>;
      <span class="keywd">when</span> {ELF_SHT_REL}:            typeName := <span class="stri">"SHT_REL"</span>;
      <span class="keywd">when</span> {ELF_SHT_SHLIB}:          typeName := <span class="stri">"SHT_SHLIB"</span>;
      <span class="keywd">when</span> {ELF_SHT_DYNSYM}:         typeName := <span class="stri">"SHT_DYNSYM"</span>;
      <span class="keywd">when</span> {ELF_SHT_INIT_ARRAY}:     typeName := <span class="stri">"SHT_INIT_ARRAY"</span>;
      <span class="keywd">when</span> {ELF_SHT_FINI_ARRAY}:     typeName := <span class="stri">"SHT_FINI_ARRAY"</span>;
      <span class="keywd">when</span> {ELF_SHT_PREINIT_ARRAY}:  typeName := <span class="stri">"SHT_PREINIT_ARRAY"</span>;
      <span class="keywd">when</span> {ELF_SHT_GROUP}:          typeName := <span class="stri">"SHT_GROUP"</span>;
      <span class="keywd">when</span> {ELF_SHT_SYMTAB_SHNDX}:   typeName := <span class="stri">"SHT_SYMTAB_SHNDX"</span>;
      <span class="keywd">when</span> {ELF_SHT_NUM}:            typeName := <span class="stri">"SHT_NUM"</span>;
      <span class="keywd">when</span> {ELF_SHT_GNU_ATTRIBUTES}: typeName := <span class="stri">"SHT_GNU_ATTRIBUTES"</span>;
      <span class="keywd">when</span> {ELF_SHT_GNU_HASH}:       typeName := <span class="stri">"SHT_GNU_HASH"</span>;
      <span class="keywd">when</span> {ELF_SHT_GNU_LIBLIST}:    typeName := <span class="stri">"SHT_GNU_LIBLIST"</span>;
      <span class="keywd">when</span> {ELF_SHT_CHECKSUM}:       typeName := <span class="stri">"SHT_CHECKSUM"</span>;
      <span class="keywd">when</span> {ELF_SHT_SUNW_move}:      typeName := <span class="stri">"SHT_SUNW_move"</span>;
      <span class="keywd">when</span> {ELF_SHT_SUNW_COMDAT}:    typeName := <span class="stri">"SHT_SUNW_COMDAT"</span>;
      <span class="keywd">when</span> {ELF_SHT_SUNW_syminfo}:   typeName := <span class="stri">"SHT_SUNW_syminfo"</span>;
      <span class="keywd">when</span> {ELF_SHT_GNU_verdef}:     typeName := <span class="stri">"SHT_GNU_verdef"</span>;
      <span class="keywd">when</span> {ELF_SHT_GNU_verneed}:    typeName := <span class="stri">"SHT_GNU_verneed"</span>;
      <span class="keywd">when</span> {ELF_SHT_GNU_versym}:     typeName := <span class="stri">"SHT_GNU_versym"</span>;
      <span class="keywd">otherwise</span>:                     typeName := sectionType radix 16;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: show (<span class="op">in</span> <span class="type">elfSectionHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"nameOffset: "</span> &lt;&amp; header.nameOffset);
    writeln(<span class="stri">"sectionType: "</span> &lt;&amp; header.sectionType &lt;&amp; <span class="stri">" "</span> &lt;&amp; sectionTypeName(header.sectionType));
    writeln(<span class="stri">"flags: "</span> &lt;&amp; header.flags);
    writeln(<span class="stri">"address: "</span> &lt;&amp; header.address);
    writeln(<span class="stri">"offset: "</span> &lt;&amp; header.offset);
    writeln(<span class="stri">"size: "</span> &lt;&amp; header.size);
    writeln(<span class="stri">"link: "</span> &lt;&amp; header.link);
    writeln(<span class="stri">"info: "</span> &lt;&amp; header.info);
    writeln(<span class="stri">"addrAlignment: "</span> &lt;&amp; header.addrAlignment);
    writeln(<span class="stri">"entrySize: "</span> &lt;&amp; header.entrySize);
    writeln(<span class="stri">"name: "</span> &lt;&amp; header.name);
    writeln(<span class="stri">"addressSize: "</span> &lt;&amp; header.addressSize);
    writeln(<span class="stri">"isLittleEndian: "</span> &lt;&amp; header.isLittleEndian);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readSectionHeader32Le (<span class="op">in</span> <span class="type">string</span>: stri,
    <span class="keywd">inout</span> <span class="type">elfSectionHeader</span>: sectionHeader) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    sectionHeader.nameOffset    := bytes2Int(stri[ 1 fixLen 4], UNSIGNED, LE);
    sectionHeader.sectionType   := bytes2Int(stri[ 5 fixLen 4], UNSIGNED, LE);
    sectionHeader.flags         := bytes2Int(stri[ 9 fixLen 4], UNSIGNED, LE);
    sectionHeader.address       := bytes2Int(stri[13 fixLen 4], UNSIGNED, LE);
    sectionHeader.offset        := bytes2Int(stri[17 fixLen 4], UNSIGNED, LE);
    sectionHeader.size          := bytes2Int(stri[21 fixLen 4], UNSIGNED, LE);
    sectionHeader.link          := bytes2Int(stri[25 fixLen 4], UNSIGNED, LE);
    sectionHeader.info          := bytes2Int(stri[29 fixLen 4], UNSIGNED, LE);
    sectionHeader.addrAlignment := bytes2Int(stri[33 fixLen 4], UNSIGNED, LE);
    sectionHeader.entrySize     := bytes2Int(stri[37 fixLen 4], UNSIGNED, LE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readSectionHeader32Be (<span class="op">in</span> <span class="type">string</span>: stri,
    <span class="keywd">inout</span> <span class="type">elfSectionHeader</span>: sectionHeader) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    sectionHeader.nameOffset    := bytes2Int(stri[ 1 fixLen 4], UNSIGNED, BE);
    sectionHeader.sectionType   := bytes2Int(stri[ 5 fixLen 4], UNSIGNED, BE);
    sectionHeader.flags         := bytes2Int(stri[ 9 fixLen 4], UNSIGNED, BE);
    sectionHeader.address       := bytes2Int(stri[13 fixLen 4], UNSIGNED, BE);
    sectionHeader.offset        := bytes2Int(stri[17 fixLen 4], UNSIGNED, BE);
    sectionHeader.size          := bytes2Int(stri[21 fixLen 4], UNSIGNED, BE);
    sectionHeader.link          := bytes2Int(stri[25 fixLen 4], UNSIGNED, BE);
    sectionHeader.info          := bytes2Int(stri[29 fixLen 4], UNSIGNED, BE);
    sectionHeader.addrAlignment := bytes2Int(stri[33 fixLen 4], UNSIGNED, BE);
    sectionHeader.entrySize     := bytes2Int(stri[37 fixLen 4], UNSIGNED, BE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readSectionHeader64Le (<span class="op">in</span> <span class="type">string</span>: stri,
    <span class="keywd">inout</span> <span class="type">elfSectionHeader</span>: sectionHeader) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    sectionHeader.nameOffset    := bytes2Int(stri[ 1 fixLen 4], UNSIGNED, LE);
    sectionHeader.sectionType   := bytes2Int(stri[ 5 fixLen 4], UNSIGNED, LE);
    sectionHeader.flags         := bytes2Int(stri[ 9 fixLen 8], UNSIGNED, LE);
    sectionHeader.address       := bytes2Int(stri[17 fixLen 8], UNSIGNED, LE);
    sectionHeader.offset        := bytes2Int(stri[25 fixLen 8], UNSIGNED, LE);
    sectionHeader.size          := bytes2Int(stri[33 fixLen 8], UNSIGNED, LE);
    sectionHeader.link          := bytes2Int(stri[41 fixLen 4], UNSIGNED, LE);
    sectionHeader.info          := bytes2Int(stri[45 fixLen 4], UNSIGNED, LE);
    sectionHeader.addrAlignment := bytes2Int(stri[49 fixLen 8], UNSIGNED, LE);
    sectionHeader.entrySize     := bytes2Int(stri[57 fixLen 8], UNSIGNED, LE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readSectionHeader64Be (<span class="op">in</span> <span class="type">string</span>: stri,
    <span class="keywd">inout</span> <span class="type">elfSectionHeader</span>: sectionHeader) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    sectionHeader.nameOffset    := bytes2Int(stri[ 1 fixLen 4], UNSIGNED, BE);
    sectionHeader.sectionType   := bytes2Int(stri[ 5 fixLen 4], UNSIGNED, BE);
    sectionHeader.flags         := bytes2Int(stri[ 9 fixLen 8], UNSIGNED, BE);
    sectionHeader.address       := bytes2Int(stri[17 fixLen 8], UNSIGNED, BE);
    sectionHeader.offset        := bytes2Int(stri[25 fixLen 8], UNSIGNED, BE);
    sectionHeader.size          := bytes2Int(stri[33 fixLen 8], UNSIGNED, BE);
    sectionHeader.link          := bytes2Int(stri[41 fixLen 4], UNSIGNED, BE);
    sectionHeader.info          := bytes2Int(stri[45 fixLen 4], UNSIGNED, BE);
    sectionHeader.addrAlignment := bytes2Int(stri[49 fixLen 8], UNSIGNED, BE);
    sectionHeader.entrySize     := bytes2Int(stri[57 fixLen 8], UNSIGNED, BE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readSectionHeader (<span class="keywd">inout</span> <span class="type">file</span>: inFile, <span class="op">in</span> <span class="type">elfHeader</span>: header,
    <span class="keywd">inout</span> <span class="type">elfSectionHeader</span>: sectionHeader) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := gets(inFile, header.sectionHeaderSize);
    <span class="keywd">if</span> length(stri) = header.sectionHeaderSize <span class="keywd">then</span>
      <span class="keywd">if</span> header.addressSize = 32 <span class="keywd">then</span>
        <span class="keywd">if</span> length(stri) >= ELF_SECTION_HEADER32_SIZE <span class="keywd">then</span>
          <span class="keywd">if</span> header.isLittleEndian <span class="keywd">then</span>
            readSectionHeader32Le(stri, sectionHeader);
          <span class="keywd">else</span>
            readSectionHeader32Be(stri, sectionHeader);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> header.addressSize = 64 <span class="keywd">then</span>
        <span class="keywd">if</span> length(stri) >= ELF_SECTION_HEADER64_SIZE <span class="keywd">then</span>
          <span class="keywd">if</span> header.isLittleEndian <span class="keywd">then</span>
            readSectionHeader64Le(stri, sectionHeader);
          <span class="keywd">else</span>
            readSectionHeader64Be(stri, sectionHeader);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      sectionHeader.addressSize := header.addressSize;
      sectionHeader.isLittleEndian := header.isLittleEndian;
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: elfSectionNameHash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">string</span><span class="type">]</span> <span class="type">integer</span>;

<span class="keywd">const</span> <span class="type">type</span>: elfData <span class="keywd">is</span> <span class="keywd">sub</span> emptyFileSys <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">file</span>: elfFile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">elfHeader</span>: header <span class="keywd">is</span> elfHeader.value;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">elfProgramHeader</span>: programHeaders <span class="keywd">is</span> 0 <span class="op">times</span> elfProgramHeader.value;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">elfSectionHeader</span>: sectionHeaders <span class="keywd">is</span> 0 <span class="op">times</span> elfSectionHeader.value;
    <span class="keywd">var</span> <span class="type">string</span>: sectionNameTable <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">elfSectionNameHash</span>: sectionNameHash <span class="keywd">is</span> elfSectionNameHash.value;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="comment">(**
 *  Open an ELF file.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">elfData</span>: openElf (<span class="keywd">inout</span> <span class="type">file</span>: elfFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">elfData</span>: data <span class="keywd">is</span> elfData.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">elfSectionHeader</span>: sectionHeader0 <span class="keywd">is</span> elfSectionHeader.value;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    readHeader(elfFile, data.header);
    <span class="keywd">if</span> data.header.magic = ELF_MAGIC <span class="keywd">then</span>
      <span class="comment"># show(data.header);</span>
      <span class="keywd">if</span> data.header.sectionHeaderNum = 0 <span class="op">and</span>
          data.header.sectionHeaderOffset &lt;> 0 <span class="keywd">then</span>
        seek(elfFile, succ(data.header.sectionHeaderOffset));
        readSectionHeader(elfFile, data.header, sectionHeader0);
        data.header.sectionHeaderNum := sectionHeader0.size;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      data.elfFile := elfFile;
      data.programHeaders := data.header.programHeaderNum <span class="op">times</span> elfProgramHeader.value;
      seek(elfFile, succ(data.header.programHeaderOffset));
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> data.header.programHeaderNum <span class="keywd">do</span>
        readProgramHeader(elfFile, data.header, data.programHeaders[index]);
        <span class="comment"># show(data.programHeaders[index]);</span>
      <span class="keywd">end</span> <span class="keywd">for</span>;
      data.sectionHeaders := data.header.sectionHeaderNum <span class="op">times</span> elfSectionHeader.value;
      seek(elfFile, succ(data.header.sectionHeaderOffset));
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> data.header.sectionHeaderNum <span class="keywd">do</span>
        readSectionHeader(elfFile, data.header, data.sectionHeaders[index]);
        <span class="comment"># show(data.sectionHeaders[index]);</span>
      <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="comment"># writeln("------------");</span>
      index := succ(data.header.nameSectionIndex);
      <span class="comment"># show(data.sectionHeaders[index]);</span>
      seek(elfFile, succ(data.sectionHeaders[index].offset));
      data.sectionNameTable := gets(elfFile, data.sectionHeaders[index].size);
      <span class="comment"># writeln(literal(data.sectionNameTable));</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> data.header.sectionHeaderNum <span class="keywd">do</span>
        data.sectionHeaders[index].name :=
            fromAsciiz(data.sectionNameTable, succ(data.sectionHeaders[index].nameOffset));
        <span class="comment"># writeln(data.sectionHeaders[index].name);</span>
        data.sectionNameHash @:= [data.sectionHeaders[index].name] index;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Return the list of section names from the given ELF ''data''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: readSectionNames (<span class="op">in</span> <span class="type">elfData</span>: data) <span class="keywd">is</span>
  <span class="keywd">return</span> keys(data.sectionNameHash);


<span class="comment">(**
 *  Get the section with the with the specified ''sectionName''.
 *  @return the section with the name ''sectionName'', or
 *          an empty section if no section with this name exists.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">elfSectionHeader</span>: getSection (<span class="op">in</span> <span class="type">elfData</span>: data, <span class="op">in</span> <span class="type">string</span>: sectionName) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">elfSectionHeader</span>: sectionHeader <span class="keywd">is</span> elfSectionHeader.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> sectionName <span class="op">in</span> data.sectionNameHash <span class="keywd">then</span>
      sectionHeader := data.sectionHeaders[data.sectionNameHash[sectionName]];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get the section data of the section ''sectionName''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getSectionData (<span class="keywd">inout</span> <span class="type">elfData</span>: data, <span class="op">in</span> <span class="type">string</span>: sectionName) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: sectionData <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">elfSectionHeader</span>: sectionHeader <span class="keywd">is</span> elfSectionHeader.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> sectionName <span class="op">in</span> data.sectionNameHash <span class="keywd">then</span>
      sectionHeader := data.sectionHeaders[data.sectionNameHash[sectionName]];
      seek(data.elfFile, succ(sectionHeader.offset));
      sectionData := gets(data.elfFile, sectionHeader.size);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: elfGnuHashHeader <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: nbuckets <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: symndx <span class="keywd">is</span> 0;    <span class="comment"># Index of the first accessible symbol in .dynsym</span>
    <span class="keywd">var</span> <span class="type">integer</span>: maskwords <span class="keywd">is</span> 0; <span class="comment"># Nyumber of elements in the Bloom Filter</span>
    <span class="keywd">var</span> <span class="type">integer</span>: shift2 <span class="keywd">is</span> 0;    <span class="comment"># Shift count for the Bloom Filter</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: bloom_filter <span class="keywd">is</span> 0 <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: buckets <span class="keywd">is</span> 0 <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: values <span class="keywd">is</span> 0 <span class="op">times</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: show (<span class="op">in</span> <span class="type">elfGnuHashHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"nbuckets: "</span> &lt;&amp; header.nbuckets);
    writeln(<span class="stri">"symndx: "</span> &lt;&amp; header.symndx);
    writeln(<span class="stri">"maskwords: "</span> &lt;&amp; header.maskwords);
    writeln(<span class="stri">"shift2: "</span> &lt;&amp; header.shift2);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readGnuHashHeaderLe (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfGnuHashHeader</span>: hashHeader) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    hashHeader.nbuckets     := bytes2Int(stri[ 1 fixLen 4], UNSIGNED, LE);
    hashHeader.symndx       := bytes2Int(stri[ 5 fixLen 4], UNSIGNED, LE);
    hashHeader.maskwords    := bytes2Int(stri[ 9 fixLen 4], UNSIGNED, LE);
    hashHeader.shift2       := bytes2Int(stri[13 fixLen 4], UNSIGNED, LE);
    hashHeader.bloom_filter := hashHeader.maskwords <span class="op">times</span> 0;
    hashHeader.buckets      := hashHeader.nbuckets <span class="op">times</span> 0;
    <span class="comment">(*
    uintXX_t bloom_filter[maskwords];
    uint32_t buckets[nbuckets];
    uint32_t values[dynsymcount - symndx];
    *)</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readGnuHashHeaderBe (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfGnuHashHeader</span>: hashHeader) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    hashHeader.nbuckets     := bytes2Int(stri[ 1 fixLen 4], UNSIGNED, BE);
    hashHeader.symndx       := bytes2Int(stri[ 5 fixLen 4], UNSIGNED, BE);
    hashHeader.maskwords    := bytes2Int(stri[ 9 fixLen 4], UNSIGNED, BE);
    hashHeader.shift2       := bytes2Int(stri[13 fixLen 4], UNSIGNED, BE);
    hashHeader.bloom_filter := hashHeader.maskwords <span class="op">times</span> 0;
    hashHeader.buckets      := hashHeader.nbuckets <span class="op">times</span> 0;
    <span class="comment">(*
    uintXX_t bloom_filter[maskwords];
    uint32_t buckets[nbuckets];
    uint32_t values[dynsymcount - symndx];
    *)</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">elfGnuHashHeader</span>: readGnuHashHeader (<span class="op">in</span> <span class="type">string</span>: sectionData, <span class="keywd">inout</span> <span class="type">integer</span>: pos,
    <span class="op">in</span> <span class="type">boolean</span>: isLittleEndian) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">elfGnuHashHeader</span>: hashHeader <span class="keywd">is</span> elfGnuHashHeader.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := sectionData[pos ..];
    <span class="keywd">if</span> length(stri) >= ELF_NOTE_HEADER_SIZE <span class="keywd">then</span>
      <span class="keywd">if</span> isLittleEndian <span class="keywd">then</span>
        readGnuHashHeaderLe(stri, hashHeader);
      <span class="keywd">else</span>
        readGnuHashHeaderBe(stri, hashHeader);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: elfNoteHeader <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: nameSize <span class="keywd">is</span> 0;         <span class="comment"># Length of the note's name.</span>
    <span class="keywd">var</span> <span class="type">integer</span>: descriptionSize <span class="keywd">is</span> 0;  <span class="comment"># Length of the note's descriptor.</span>
    <span class="keywd">var</span> <span class="type">integer</span>: noteType <span class="keywd">is</span> 0;         <span class="comment"># Type of the note.</span>
    <span class="keywd">var</span> <span class="type">string</span>: name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: description <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: show (<span class="op">in</span> <span class="type">elfNoteHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"nameSize: "</span> &lt;&amp; header.nameSize);
    writeln(<span class="stri">"descriptionSize: "</span> &lt;&amp; header.descriptionSize);
    writeln(<span class="stri">"noteType: "</span> &lt;&amp; header.noteType);
    writeln(<span class="stri">"name: "</span> &lt;&amp; header.name);
    writeln(<span class="stri">"description: "</span> &lt;&amp; literal(header.description));
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readNoteHeaderLe (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfNoteHeader</span>: noteHeader) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    noteHeader.nameSize        := bytes2Int(stri[1 fixLen 4], UNSIGNED, LE);
    noteHeader.descriptionSize := bytes2Int(stri[5 fixLen 4], UNSIGNED, LE);
    noteHeader.noteType        := bytes2Int(stri[9 fixLen 4], UNSIGNED, LE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readNoteHeaderBe (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfNoteHeader</span>: noteHeader) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    noteHeader.nameSize        := bytes2Int(stri[1 fixLen 4], UNSIGNED, BE);
    noteHeader.descriptionSize := bytes2Int(stri[5 fixLen 4], UNSIGNED, BE);
    noteHeader.noteType        := bytes2Int(stri[9 fixLen 4], UNSIGNED, BE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">elfNoteHeader</span>: readNoteHeader (<span class="op">in</span> <span class="type">string</span>: sectionData, <span class="keywd">inout</span> <span class="type">integer</span>: pos,
    <span class="op">in</span> <span class="type">boolean</span>: isLittleEndian) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">elfNoteHeader</span>: noteHeader <span class="keywd">is</span> elfNoteHeader.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: alignedNameSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: alignedDescriptionSize <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    stri := sectionData[pos ..];
    <span class="keywd">if</span> length(stri) >= ELF_NOTE_HEADER_SIZE <span class="keywd">then</span>
      <span class="keywd">if</span> isLittleEndian <span class="keywd">then</span>
        readNoteHeaderLe(stri, noteHeader);
      <span class="keywd">else</span>
        readNoteHeaderBe(stri, noteHeader);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      alignedNameSize        := succ(pred(noteHeader.nameSize       ) <span class="op">mdiv</span> 4) * 4;
      alignedDescriptionSize := succ(pred(noteHeader.descriptionSize) <span class="op">mdiv</span> 4) * 4;
      <span class="keywd">if</span> length(stri) >= alignedNameSize + noteHeader.descriptionSize <span class="keywd">then</span>
        <span class="keywd">if</span> noteHeader.nameSize > 0 <span class="keywd">then</span>
          noteHeader.name :=      stri[13                   fixLen pred(noteHeader.nameSize)];
          <span class="keywd">if</span> stri[12 + noteHeader.nameSize] &lt;> <span class="stri">'\0;'</span> <span class="keywd">then</span>
            raise RANGE_ERROR;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        noteHeader.description := stri[13 + alignedNameSize fixLen noteHeader.descriptionSize];
        pos +:= ELF_NOTE_HEADER_SIZE + alignedNameSize + alignedDescriptionSize;
      <span class="keywd">else</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> stri &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get the note ''noteName'' from section ''sectionName'' in ELF ''data''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getNote (<span class="keywd">inout</span> <span class="type">elfData</span>: data, <span class="op">in</span> <span class="type">string</span>: sectionName,
    <span class="op">in</span> <span class="type">string</span>: noteName) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: note <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">elfSectionHeader</span>: sectionHeader <span class="keywd">is</span> elfSectionHeader.value;
    <span class="keywd">var</span> <span class="type">string</span>: sectionData <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">elfNoteHeader</span>: noteHeader <span class="keywd">is</span> elfNoteHeader.value;
  <span class="keywd">begin</span>
    sectionHeader := getSection(data, sectionName);
    <span class="keywd">if</span> sectionHeader.sectionType = ELF_SHT_NOTE <span class="keywd">then</span>
      seek(data.elfFile, succ(sectionHeader.offset));
      sectionData := gets(data.elfFile, sectionHeader.size);
      <span class="keywd">repeat</span>
        noteHeader := readNoteHeader(sectionData, pos, sectionHeader.isLittleEndian);
        <span class="comment"># show(noteHeader);</span>
        <span class="comment"># writeln(literal(noteHeader.name) &lt;&amp; " = " &lt;&amp; literal(noteName) &lt;&amp; ": " &lt;&amp; noteHeader.name = noteName);</span>
      <span class="keywd">until</span> noteHeader.name = noteName;
      note := noteHeader.description;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get the build ID from the given ELF ''data''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getBuildId (<span class="keywd">inout</span> <span class="type">elfData</span>: data) <span class="keywd">is</span>
  <span class="keywd">return</span> getNote(data, <span class="stri">".note.gnu.build-id"</span>, <span class="stri">"GNU"</span>);


<span class="keywd">const</span> <span class="type">type</span>: noteHash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">string</span><span class="type">]</span> <span class="type">string</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">noteHash</span>: getNotes (<span class="keywd">inout</span> <span class="type">elfData</span>: data, <span class="op">in</span> <span class="type">string</span>: sectionName) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">noteHash</span>: notes <span class="keywd">is</span> noteHash.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">elfSectionHeader</span>: sectionHeader <span class="keywd">is</span> elfSectionHeader.value;
    <span class="keywd">var</span> <span class="type">string</span>: sectionData <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">elfNoteHeader</span>: noteHeader <span class="keywd">is</span> elfNoteHeader.value;
  <span class="keywd">begin</span>
    sectionHeader := getSection(data, sectionName);
    <span class="keywd">if</span> sectionHeader.sectionType = ELF_SHT_NOTE <span class="keywd">then</span>
      seek(data.elfFile, succ(sectionHeader.offset));
      sectionData := gets(data.elfFile, sectionHeader.size);
      <span class="keywd">repeat</span>
        noteHeader := readNoteHeader(sectionData, pos, sectionHeader.isLittleEndian);
        show(noteHeader);
        <span class="keywd">if</span> noteHeader.name &lt;> <span class="stri">""</span> <span class="op">or</span> noteHeader.description &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          notes @:= [noteHeader.name] noteHeader.description;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> noteHeader.name = <span class="stri">""</span> <span class="op">and</span> noteHeader.description = <span class="stri">""</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: elfSym <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: nameIndex <span class="keywd">is</span> 0;  <span class="comment"># Symbol name (string tbl index)</span>
    <span class="keywd">var</span> <span class="type">integer</span>: value <span class="keywd">is</span> 0;      <span class="comment"># Symbol value</span>
    <span class="keywd">var</span> <span class="type">integer</span>: size <span class="keywd">is</span> 0;       <span class="comment"># Symbol size</span>
    <span class="keywd">var</span> <span class="type">integer</span>: info <span class="keywd">is</span> 0;       <span class="comment"># Symbol type and binding</span>
    <span class="keywd">var</span> <span class="type">integer</span>: other <span class="keywd">is</span> 0;      <span class="comment"># Symbol visibility</span>
    <span class="keywd">var</span> <span class="type">integer</span>: shndx <span class="keywd">is</span> 0;      <span class="comment"># Section index</span>
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: show (<span class="op">in</span> <span class="type">elfSym</span>: sym) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"nameIndex: "</span> &lt;&amp; sym.nameIndex);
    writeln(<span class="stri">"value: "</span> &lt;&amp; sym.value);
    writeln(<span class="stri">"size: "</span> &lt;&amp; sym.size);
    writeln(<span class="stri">"info: "</span> &lt;&amp; sym.info);
    writeln(<span class="stri">"other: "</span> &lt;&amp; sym.other);
    writeln(<span class="stri">"shndx: "</span> &lt;&amp; sym.shndx);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readSym32Le (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfSym</span>: sym) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    sym.nameIndex := bytes2Int(stri[ 1 fixLen 4], UNSIGNED, LE);
    sym.value     := bytes2Int(stri[ 5 fixLen 4], UNSIGNED, LE);
    sym.size      := bytes2Int(stri[ 9 fixLen 4], UNSIGNED, LE);
    sym.info      := bytes2Int(stri[13 fixLen 1], UNSIGNED, LE);
    sym.other     := bytes2Int(stri[14 fixLen 1], UNSIGNED, LE);
    sym.shndx     := bytes2Int(stri[15 fixLen 2], UNSIGNED, LE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readSym32Be (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfSym</span>: sym) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    sym.nameIndex := bytes2Int(stri[ 1 fixLen 4], UNSIGNED, BE);
    sym.value     := bytes2Int(stri[ 5 fixLen 4], UNSIGNED, BE);
    sym.size      := bytes2Int(stri[ 9 fixLen 4], UNSIGNED, BE);
    sym.info      := bytes2Int(stri[13 fixLen 1], UNSIGNED, BE);
    sym.other     := bytes2Int(stri[14 fixLen 1], UNSIGNED, BE);
    sym.shndx     := bytes2Int(stri[15 fixLen 2], UNSIGNED, BE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readSym64Le (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfSym</span>: sym) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    sym.nameIndex := bytes2Int(stri[ 1 fixLen 4], UNSIGNED, LE);
    sym.info      := bytes2Int(stri[ 5 fixLen 1], UNSIGNED, LE);
    sym.other     := bytes2Int(stri[ 6 fixLen 1], UNSIGNED, LE);
    sym.shndx     := bytes2Int(stri[ 7 fixLen 2], UNSIGNED, LE);
    sym.value     := bytes2Int(stri[ 9 fixLen 8], UNSIGNED, LE);
    sym.size      := bytes2Int(stri[17 fixLen 8], UNSIGNED, LE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readSym64Be (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfSym</span>: sym) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    sym.nameIndex := bytes2Int(stri[ 1 fixLen 4], UNSIGNED, BE);
    sym.info      := bytes2Int(stri[ 5 fixLen 1], UNSIGNED, BE);
    sym.other     := bytes2Int(stri[ 6 fixLen 1], UNSIGNED, BE);
    sym.shndx     := bytes2Int(stri[ 7 fixLen 2], UNSIGNED, BE);
    sym.value     := bytes2Int(stri[ 9 fixLen 8], UNSIGNED, BE);
    sym.size      := bytes2Int(stri[17 fixLen 8], UNSIGNED, BE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">elfSym</span>: readSym (<span class="op">in</span> <span class="type">string</span>: sectionData, <span class="keywd">inout</span> <span class="type">integer</span>: pos,
    <span class="op">in</span> <span class="type">integer</span>: addressSize, <span class="op">in</span> <span class="type">boolean</span>: isLittleEndian) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">elfSym</span>: sym <span class="keywd">is</span> elfSym.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := sectionData[pos ..];
    <span class="keywd">if</span> addressSize = 32 <span class="keywd">then</span>
      <span class="keywd">if</span> length(stri) >= ELF_SYM32_SIZE <span class="keywd">then</span>
        <span class="keywd">if</span> isLittleEndian <span class="keywd">then</span>
          readSym32Le(stri, sym);
        <span class="keywd">else</span>
          readSym32Be(stri, sym);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        pos +:= ELF_SYM32_SIZE;
      <span class="keywd">else</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> addressSize = 64 <span class="keywd">then</span>
      <span class="keywd">if</span> length(stri) >= ELF_SYM64_SIZE <span class="keywd">then</span>
        <span class="keywd">if</span> isLittleEndian <span class="keywd">then</span>
          readSym64Le(stri, sym);
        <span class="keywd">else</span>
          readSym64Le(stri, sym);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        pos +:= ELF_SYM64_SIZE;
      <span class="keywd">else</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get the list of dynamic symbols from ''sectionName'' using ''dynstrSectionName''.
 *   getDynsymNames(data, ".dynsym", ".dynstr")
 *  @param data ELF data.
 *  @param sectionName Name of section in ''data'' with dynamic symbols.
 *  @param dynstrSectionName Name of section with string data.
 *  @return an array with dynamic symbols.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: getDynsymNames (<span class="keywd">inout</span> <span class="type">elfData</span>: data, <span class="op">in</span> <span class="type">string</span>: sectionName,
    <span class="op">in</span> <span class="type">string</span>: dynstrSectionName) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: dynsymNames <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: dynstr <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">elfSectionHeader</span>: sectionHeader <span class="keywd">is</span> elfSectionHeader.value;
    <span class="keywd">var</span> <span class="type">string</span>: sectionData <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">elfSym</span>: sym <span class="keywd">is</span> elfSym.value;
  <span class="keywd">begin</span>
    dynstr := getSectionData(data, dynstrSectionName);
    sectionHeader := getSection(data, sectionName);
    <span class="keywd">if</span> sectionHeader.sectionType = ELF_SHT_DYNSYM <span class="keywd">then</span>
      seek(data.elfFile, succ(sectionHeader.offset));
      sectionData := gets(data.elfFile, sectionHeader.size);
      <span class="keywd">repeat</span>
        sym := readSym(sectionData, pos, sectionHeader.addressSize, sectionHeader.isLittleEndian);
        <span class="comment"># show(sym);</span>
        dynsymNames &amp;:= fromAsciiz(dynstr, succ(sym.nameIndex));
      <span class="keywd">until</span> pos > length(sectionData);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get the list of dynamic symbols from ''sectionName'' in ELF ''data''.
 *   getDynsymNames(data, ".dynsym")
 *  @param data ELF data.
 *  @param sectionName Name of section in ''data'' with dynamic symbols.
 *  @return an array with dynamic symbols.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: getDynsymNames (<span class="keywd">inout</span> <span class="type">elfData</span>: data, <span class="op">in</span> <span class="type">string</span>: sectionName) <span class="keywd">is</span>
  <span class="keywd">return</span> getDynsymNames(data, sectionName, <span class="stri">".dynstr"</span>);


<span class="comment">(**
 *  Get the list of dynamic symbols from ELF ''data''.
 *  @param data ELF data.
 *  @return an array with dynamic symbols.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: getDynsymNames (<span class="keywd">inout</span> <span class="type">elfData</span>: data) <span class="keywd">is</span>
  <span class="keywd">return</span> getDynsymNames(data, <span class="stri">".dynsym"</span>, <span class="stri">".dynstr"</span>);


<span class="keywd">const</span> <span class="type">type</span>: elfDyn <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: tag <span class="keywd">is</span> 0;       <span class="comment"># Dynamic entry type</span>
    <span class="keywd">var</span> <span class="type">integer</span>: valOrPtr <span class="keywd">is</span> 0;  <span class="comment"># Integer value or address value</span>
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: show (<span class="op">in</span> <span class="type">elfDyn</span>: dyn) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"tag: "</span> &lt;&amp; dyn.tag);
    writeln(<span class="stri">"valOrPtr: "</span> &lt;&amp; dyn.valOrPtr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readDyn32Le (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfDyn</span>: dyn) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    dyn.tag      := bytes2Int(stri[1 fixLen 4],   SIGNED, LE);
    dyn.valOrPtr := bytes2Int(stri[5 fixLen 4], UNSIGNED, LE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readDyn32Be (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfDyn</span>: dyn) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    dyn.tag      := bytes2Int(stri[1 fixLen 4],   SIGNED, BE);
    dyn.valOrPtr := bytes2Int(stri[5 fixLen 4], UNSIGNED, BE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readDyn64Le (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfDyn</span>: dyn) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    dyn.tag      := bytes2Int(stri[1 fixLen 8],   SIGNED, LE);
    dyn.valOrPtr := bytes2Int(stri[9 fixLen 8], UNSIGNED, LE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readDyn64Be (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfDyn</span>: dyn) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    dyn.tag      := bytes2Int(stri[1 fixLen 8],   SIGNED, BE);
    dyn.valOrPtr := bytes2Int(stri[9 fixLen 8], UNSIGNED, BE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">elfDyn</span>: readDyn (<span class="op">in</span> <span class="type">string</span>: sectionData, <span class="keywd">inout</span> <span class="type">integer</span>: pos,
    <span class="op">in</span> <span class="type">integer</span>: addressSize, <span class="op">in</span> <span class="type">boolean</span>: isLittleEndian) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">elfDyn</span>: dyn <span class="keywd">is</span> elfDyn.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := sectionData[pos ..];
    <span class="keywd">if</span> addressSize = 32 <span class="keywd">then</span>
      <span class="keywd">if</span> length(stri) >= ELF_DYN32_SIZE <span class="keywd">then</span>
        <span class="keywd">if</span> isLittleEndian <span class="keywd">then</span>
          readDyn32Le(stri, dyn);
        <span class="keywd">else</span>
          readDyn32Be(stri, dyn);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        pos +:= ELF_DYN32_SIZE;
      <span class="keywd">else</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> addressSize = 64 <span class="keywd">then</span>
      <span class="keywd">if</span> length(stri) >= ELF_DYN64_SIZE <span class="keywd">then</span>
        <span class="keywd">if</span> isLittleEndian <span class="keywd">then</span>
          readDyn64Le(stri, dyn);
        <span class="keywd">else</span>
          readDyn64Le(stri, dyn);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        pos +:= ELF_DYN64_SIZE;
      <span class="keywd">else</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get the list of dynamic data from ''sectionName'' using ''dynstrSectionName''.
 *   getDynamicNeeds(elf, ".dynamic", ".dynstr")
 *  @param data ELF data.
 *  @param sectionName Name of section in ''data'' with dynamic data.
 *  @param dynstrSectionName Name of section with string data.
 *  @return an array with the dynamic data.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: getDynamicNeeds (<span class="keywd">inout</span> <span class="type">elfData</span>: data, <span class="op">in</span> <span class="type">string</span>: sectionName,
    <span class="op">in</span> <span class="type">string</span>: dynstrSectionName) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: dynNames <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: dynstr <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">elfSectionHeader</span>: sectionHeader <span class="keywd">is</span> elfSectionHeader.value;
    <span class="keywd">var</span> <span class="type">string</span>: sectionData <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">elfDyn</span>: dyn <span class="keywd">is</span> elfDyn.value;
  <span class="keywd">begin</span>
    dynstr := getSectionData(data, dynstrSectionName);
    sectionHeader := getSection(data, sectionName);
    <span class="keywd">if</span> sectionHeader.sectionType = ELF_SHT_DYNAMIC <span class="keywd">then</span>
      seek(data.elfFile, succ(sectionHeader.offset));
      sectionData := gets(data.elfFile, sectionHeader.size);
      <span class="keywd">repeat</span>
        dyn := readDyn(sectionData, pos, sectionHeader.addressSize, sectionHeader.isLittleEndian);
        <span class="keywd">if</span> dyn.tag = ELF_DT_NEEDED <span class="keywd">then</span>
          dynNames &amp;:= fromAsciiz(dynstr, succ(dyn.valOrPtr));
        <span class="comment"># else</span>
        <span class="comment">#   show(dyn);</span>
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> pos > length(sectionData);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get the list of dynamic data from ''sectionName'' in ELF ''data''.
 *   getDynamicNeeds(elf, ".dynamic")
 *  @param data ELF data.
 *  @param sectionName Name of section in ''data'' with dynamic data.
 *  @return an array with the dynamic data.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: getDynamicNeeds (<span class="keywd">inout</span> <span class="type">elfData</span>: data, <span class="op">in</span> <span class="type">string</span>: sectionName) <span class="keywd">is</span>
  <span class="keywd">return</span> getDynamicNeeds(data, sectionName, <span class="stri">".dynstr"</span>);


<span class="comment">(**
 *  Get the list of dynamic data from ELF ''data''.
 *  @param data ELF data.
 *  @return an array with the dynamic data.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: getDynamicNeeds (<span class="keywd">inout</span> <span class="type">elfData</span>: data) <span class="keywd">is</span>
  <span class="keywd">return</span> getDynamicNeeds(data, <span class="stri">".dynamic"</span>, <span class="stri">".dynstr"</span>);


<span class="keywd">const</span> <span class="type">type</span>: elfVerDAux <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: name <span class="keywd">is</span> 0;  <span class="comment"># Version or dependency names</span>
    <span class="keywd">var</span> <span class="type">integer</span>: next <span class="keywd">is</span> 0;  <span class="comment"># Offset in bytes to next verdaux entry</span>
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: show (<span class="op">in</span> <span class="type">elfVerDAux</span>: verDAux) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"name: "</span> &lt;&amp; verDAux.name);
    writeln(<span class="stri">"next: "</span> &lt;&amp; verDAux.next);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readVerDAuxLe (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfVerDAux</span>: verDAux) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    verDAux.name := bytes2Int(stri[1 fixLen 4], UNSIGNED, LE);
    verDAux.next := bytes2Int(stri[5 fixLen 4], UNSIGNED, LE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readVerDAuxBe (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfVerDAux</span>: verDAux) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    verDAux.name := bytes2Int(stri[1 fixLen 4], UNSIGNED, BE);
    verDAux.next := bytes2Int(stri[5 fixLen 4], UNSIGNED, BE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">elfVerDAux</span>: readVerDAux (<span class="op">in</span> <span class="type">string</span>: sectionData, <span class="keywd">inout</span> <span class="type">integer</span>: pos,
    <span class="op">in</span> <span class="type">boolean</span>: isLittleEndian) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">elfVerDAux</span>: verDAux <span class="keywd">is</span> elfVerDAux.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := sectionData[pos ..];
    <span class="keywd">if</span> length(stri) >= ELF_VER_D_AUX_SIZE <span class="keywd">then</span>
      <span class="keywd">if</span> isLittleEndian <span class="keywd">then</span>
        readVerDAuxLe(stri, verDAux);
      <span class="keywd">else</span>
        readVerDAuxBe(stri, verDAux);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="comment"># pos +:= ELF_VER_D_AUX_SIZE;</span>

      <span class="keywd">if</span> verDAux.next &lt;> 0 <span class="keywd">then</span>
        pos +:= verDAux.next;
      <span class="keywd">else</span>
        pos := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;

    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: elfVerNAux <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: nameHash <span class="keywd">is</span> 0;   <span class="comment"># Hash value of dependency name</span>
    <span class="keywd">var</span> <span class="type">integer</span>: flags <span class="keywd">is</span> 0;      <span class="comment"># Dependency specific information</span>
    <span class="keywd">var</span> <span class="type">integer</span>: other <span class="keywd">is</span> 0;      <span class="comment"># Unused</span>
    <span class="keywd">var</span> <span class="type">integer</span>: nameIndex <span class="keywd">is</span> 0;  <span class="comment"># Dependency name string offset</span>
    <span class="keywd">var</span> <span class="type">integer</span>: next <span class="keywd">is</span> 0;       <span class="comment"># Offset in bytes to next vernaux entry</span>
    <span class="keywd">var</span> <span class="type">string</span>: name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: show (<span class="op">in</span> <span class="type">elfVerNAux</span>: verNAux) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"nameHash: "</span> &lt;&amp; verNAux.nameHash);
    writeln(<span class="stri">"flags: "</span> &lt;&amp; verNAux.flags);
    writeln(<span class="stri">"other: "</span> &lt;&amp; verNAux.other);
    writeln(<span class="stri">"nameIndex: "</span> &lt;&amp; verNAux.nameIndex);
    writeln(<span class="stri">"next: "</span> &lt;&amp; verNAux.next);
    writeln(<span class="stri">"name: "</span> &lt;&amp; verNAux.name);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readVerNAuxLe (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfVerNAux</span>: verNAux) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    verNAux.nameHash  := bytes2Int(stri[ 1 fixLen 4], UNSIGNED, LE);
    verNAux.flags     := bytes2Int(stri[ 5 fixLen 2], UNSIGNED, LE);
    verNAux.other     := bytes2Int(stri[ 7 fixLen 2], UNSIGNED, LE);
    verNAux.nameIndex := bytes2Int(stri[ 9 fixLen 4], UNSIGNED, LE);
    verNAux.next      := bytes2Int(stri[13 fixLen 4], UNSIGNED, LE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readVerNAuxBe (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfVerNAux</span>: verNAux) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    verNAux.nameHash  := bytes2Int(stri[ 1 fixLen 4], UNSIGNED, BE);
    verNAux.flags     := bytes2Int(stri[ 5 fixLen 2], UNSIGNED, BE);
    verNAux.other     := bytes2Int(stri[ 7 fixLen 2], UNSIGNED, BE);
    verNAux.nameIndex := bytes2Int(stri[ 9 fixLen 4], UNSIGNED, BE);
    verNAux.next      := bytes2Int(stri[13 fixLen 4], UNSIGNED, BE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">elfVerNAux</span>: readVerNAux (<span class="op">in</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="type">boolean</span>: isLittleEndian,
    <span class="op">in</span> <span class="type">string</span>: dynstr) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">elfVerNAux</span>: verNAux <span class="keywd">is</span> elfVerNAux.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(stri) >= ELF_VER_N_AUX_SIZE <span class="keywd">then</span>
      <span class="keywd">if</span> isLittleEndian <span class="keywd">then</span>
        readVerNAuxLe(stri, verNAux);
      <span class="keywd">else</span>
        readVerNAuxBe(stri, verNAux);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      verNAux.name := fromAsciiz(dynstr, succ(verNAux.nameIndex));
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: elfVerNeed <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: version <span class="keywd">is</span> 0;        <span class="comment"># Version of structure</span>
    <span class="keywd">var</span> <span class="type">integer</span>: count <span class="keywd">is</span> 0;          <span class="comment"># Number of associated aux entries</span>
    <span class="keywd">var</span> <span class="type">integer</span>: fileNameIndex <span class="keywd">is</span> 0;  <span class="comment"># Offset of filename for this dependency</span>
    <span class="keywd">var</span> <span class="type">integer</span>: aux <span class="keywd">is</span> 0;            <span class="comment"># Offset in bytes to vernaux array</span>
    <span class="keywd">var</span> <span class="type">integer</span>: next <span class="keywd">is</span> 0;           <span class="comment"># Offset in bytes to next verneed entry</span>
    <span class="keywd">var</span> <span class="type">string</span>: fileName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: show (<span class="op">in</span> <span class="type">elfVerNeed</span>: verNeed) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"version: "</span> &lt;&amp; verNeed.version);
    writeln(<span class="stri">"count: "</span> &lt;&amp; verNeed.count);
    writeln(<span class="stri">"fileNameIndex: "</span> &lt;&amp; verNeed.fileNameIndex);
    writeln(<span class="stri">"aux: "</span> &lt;&amp; verNeed.aux);
    writeln(<span class="stri">"next: "</span> &lt;&amp; verNeed.next);
    writeln(<span class="stri">"fileName: "</span> &lt;&amp; verNeed.fileName);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readVerNeedLe (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfVerNeed</span>: verNeed) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    verNeed.version       := bytes2Int(stri[ 1 fixLen 2], UNSIGNED, LE);
    verNeed.count         := bytes2Int(stri[ 3 fixLen 2], UNSIGNED, LE);
    verNeed.fileNameIndex := bytes2Int(stri[ 5 fixLen 4], UNSIGNED, LE);
    verNeed.aux           := bytes2Int(stri[ 9 fixLen 4], UNSIGNED, LE);
    verNeed.next          := bytes2Int(stri[13 fixLen 4], UNSIGNED, LE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readVerNeedBe (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">elfVerNeed</span>: verNeed) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    verNeed.version       := bytes2Int(stri[ 1 fixLen 2], UNSIGNED, BE);
    verNeed.count         := bytes2Int(stri[ 3 fixLen 2], UNSIGNED, BE);
    verNeed.fileNameIndex := bytes2Int(stri[ 5 fixLen 4], UNSIGNED, BE);
    verNeed.aux           := bytes2Int(stri[ 9 fixLen 4], UNSIGNED, BE);
    verNeed.next          := bytes2Int(stri[13 fixLen 4], UNSIGNED, BE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">elfVerNeed</span>: readVerNeed (<span class="op">in</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="type">boolean</span>: isLittleEndian,
    <span class="op">in</span> <span class="type">string</span>: dynstr) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">elfVerNeed</span>: verNeed <span class="keywd">is</span> elfVerNeed.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(stri) >= ELF_VER_NEED_SIZE <span class="keywd">then</span>
      <span class="keywd">if</span> isLittleEndian <span class="keywd">then</span>
        readVerNeedLe(stri, verNeed);
      <span class="keywd">else</span>
        readVerNeedBe(stri, verNeed);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      verNeed.fileName := fromAsciiz(dynstr, succ(verNeed.fileNameIndex));
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get the list of version needs from ''sectionName'' using ''dynstrSectionName''.
 *   getVerNeeds(elf, ".gnu.version_r", ".dynstr")
 *  @param data ELF data.
 *  @param sectionName Name of section in ''data'' with version needs.
 *  @param dynstrSectionName Name of section with string data.
 *  @return an array with the version needs.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: getVerNeeds (<span class="keywd">inout</span> <span class="type">elfData</span>: data, <span class="op">in</span> <span class="type">string</span>: sectionName,
    <span class="op">in</span> <span class="type">string</span>: dynstrSectionName) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: verNeedNames <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: dynstr <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: addressSizeStri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">elfSectionHeader</span>: sectionHeader <span class="keywd">is</span> elfSectionHeader.value;
    <span class="keywd">var</span> <span class="type">string</span>: sectionData <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: verNeedPos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">elfVerNeed</span>: verNeed <span class="keywd">is</span> elfVerNeed.value;
    <span class="keywd">var</span> <span class="type">integer</span>: verNAuxPos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: count <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">elfVerNAux</span>: verNAux <span class="keywd">is</span> elfVerNAux.value;
  <span class="keywd">begin</span>
    dynstr := getSectionData(data, dynstrSectionName);
    addressSizeStri := <span class="stri">"("</span> &lt;&amp; data.header.addressSize &lt;&amp; <span class="stri">"bit)"</span>;
    sectionHeader := getSection(data, sectionName);
    <span class="keywd">if</span> sectionHeader.sectionType = ELF_SHT_GNU_verneed <span class="keywd">then</span>
      seek(data.elfFile, succ(sectionHeader.offset));
      sectionData := gets(data.elfFile, sectionHeader.size);
      <span class="keywd">repeat</span>
        verNeed := readVerNeed(sectionData[verNeedPos ..], sectionHeader.isLittleEndian, dynstr);
        <span class="comment"># show(verNeed);</span>
        <span class="keywd">if</span> verNeed.count &lt;> 0 <span class="keywd">then</span>
          verNAuxPos := verNeedPos + verNeed.aux;
          <span class="keywd">for</span> count <span class="keywd">range</span> 1 <span class="keywd">to</span> verNeed.count <span class="keywd">do</span>
            verNAux := readVerNAux(sectionData[verNAuxPos ..], sectionHeader.isLittleEndian, dynstr);
            <span class="comment"># show(verNAux);</span>
            verNeedNames &amp;:= verNeed.fileName &amp; <span class="stri">"("</span> &amp; verNAux.name &amp; <span class="stri">")"</span> &amp; addressSizeStri;
            <span class="keywd">if</span> verNAux.next &lt;> 0 <span class="keywd">then</span>
              verNAuxPos +:= verNAux.next;
            <span class="keywd">else</span>
              verNAuxPos := 0;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">for</span>;
          <span class="keywd">if</span> verNAuxPos &lt;> 0 <span class="keywd">then</span>
            raise RANGE_ERROR;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> verNeed.next &lt;> 0 <span class="keywd">then</span>
          verNeedPos +:= verNeed.next;
        <span class="keywd">else</span>
          verNeedPos := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> verNeedPos = 0;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get the list of version needs from ''sectionName'' in ELF ''data''.
 *   getVerNeeds(elf, ".gnu.version_r")
 *  @param data ELF data.
 *  @param sectionName Name of section in ''data'' with version needs.
 *  @return an array with the version needs.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: getVerNeeds (<span class="keywd">inout</span> <span class="type">elfData</span>: data, <span class="op">in</span> <span class="type">string</span>: sectionName) <span class="keywd">is</span>
  <span class="keywd">return</span> getVerNeeds(data, sectionName, <span class="stri">".dynstr"</span>);


<span class="comment">(**
 *  Get the list of version needs from ELF ''data''.
 *  @param data ELF data.
 *  @return an array with the version needs.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: getVerNeeds (<span class="keywd">inout</span> <span class="type">elfData</span>: data) <span class="keywd">is</span>
  <span class="keywd">return</span> getVerNeeds(data, <span class="stri">".gnu.version_r"</span>, <span class="stri">".dynstr"</span>);
</pre>
</body>
</html>
