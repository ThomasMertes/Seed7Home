<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  dnafight.sd7  Bacterial dna fight programming game              *)</span>
<span class="comment">(*  Copyright (C) 1985  Thomas Mertes                               *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">directSet</span>: a_set) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">"{"</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">direction</span>: setElement <span class="keywd">is</span> direction.value;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> setElement <span class="keywd">range</span> a_set <span class="keywd">do</span>
      <span class="keywd">if</span> stri &lt;> <span class="stri">"{"</span> <span class="keywd">then</span>
        stri &amp;:= <span class="stri">", "</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      stri &amp;:= str(setElement);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    stri &amp;:= <span class="stri">"}"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">array</span> <span class="type">[</span>direction] <span class="type">array</span> <span class="type">direction</span>: gen2dirs <span class="keywd">is</span> [direction](
    [](HERE,  NORTH, SOUTH, WEST,  EAST),
    [](NORTH, HERE,  NW,    NE),
    [](SOUTH, HERE,  SW,    SE),
    [](WEST,  HERE,  NW,    SW),
    [](EAST,  HERE,  NE,    SE)
  );


<span class="keywd">const</span> <span class="type">proc</span>: dna (RED) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">colorSet</span>: friends <span class="keywd">is</span> {RED};
    <span class="keywd">var</span> <span class="type">colorSet</span>: enemy <span class="keywd">is</span> colorSet.EMPTY_SET;
    <span class="keywd">var</span> <span class="type">direction</span>: direct <span class="keywd">is</span> HERE;
    <span class="keywd">var</span> <span class="type">direction</span>: direct2 <span class="keywd">is</span> HERE;
    <span class="keywd">var</span> <span class="type">directSet</span>: killDirs <span class="keywd">is</span> directSet.EMPTY_SET;
    <span class="keywd">var</span> <span class="type">directSet</span>: eatDirs <span class="keywd">is</span> directSet.EMPTY_SET;
    <span class="keywd">var</span> <span class="type">directSet</span>: splitDirs <span class="keywd">is</span> directSet.EMPTY_SET;
    <span class="keywd">var</span> <span class="type">directSet</span>: helpDirs <span class="keywd">is</span> directSet.EMPTY_SET;
    <span class="keywd">var</span> <span class="type">directSet</span>: gen2eatDirs <span class="keywd">is</span> directSet.EMPTY_SET;
    <span class="keywd">var</span> <span class="type">directSet</span>: gen2splitDirs <span class="keywd">is</span> directSet.EMPTY_SET;
    <span class="keywd">var</span> <span class="type">power</span>: killMeal <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: eatMeal <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: split1Meal <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: split2Meal <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: helpMeal <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: killPow <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: eatPow <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: splitPow <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: helpPow <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: maxNeighbourEnemy <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: split1Pow <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: split2Pow <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: newPow <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: new1SplitPow <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: new2SplitPow <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: meal <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: gen2Meal1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: gen2Meal2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: gen2Meal <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: gen2eatPow <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: gen2splitPow <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: foodSum <span class="keywd">is</span> 0;


    <span class="keywd">const</span> <span class="type">func</span> <span class="type">direction</span>: optimalDir (<span class="op">in</span> <span class="type">directSet</span>: dirs) <span class="keywd">is</span> <span class="keywd">func</span>
      <span class="keywd">result</span>
        <span class="keywd">var</span> <span class="type">direction</span>: optimalDir <span class="keywd">is</span> HERE;

      <span class="keywd">local</span>
        <span class="keywd">var</span> <span class="type">direction</span>: direct <span class="keywd">is</span> HERE;
        <span class="keywd">var</span> <span class="type">power</span>: pow <span class="keywd">is</span> 0;
        <span class="keywd">var</span> <span class="type">power</span>: help <span class="keywd">is</span> 0;
        <span class="keywd">var</span> <span class="type">directSet</span>: directs <span class="keywd">is</span> directSet.EMPTY_SET;

      <span class="keywd">begin</span> <span class="comment">(* optimalDir *)</span>
        <span class="keywd">if</span> dirs = {HERE} <span class="keywd">then</span>
          optimalDir := HERE;
        <span class="keywd">else</span>
          pow := 0;
          directs := directSet.EMPTY_SET;
          <span class="keywd">for</span> direct <span class="keywd">range</span> MAIN_DIRECTIONS <span class="keywd">do</span>
            <span class="keywd">if</span> direct <span class="op">in</span> dirs <span class="keywd">then</span>
              help := food(left[direct]) + food(direct) +
                  food(right[direct]);
              <span class="keywd">if</span> help > pow <span class="keywd">then</span>
                pow := help;
                directs := directSet.EMPTY_SET;
                incl(directs, direct);
              <span class="keywd">elsif</span> help = pow <span class="keywd">then</span>
                incl(directs, direct);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">for</span>;
          optimalDir := ranDir(directs);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">func</span>;


  <span class="keywd">begin</span> <span class="comment">(* dna (RED) *)</span>
    enemy := ALL_COLORS;
    excl(enemy, RED);
    newPow := strength(HERE) - shrinkSize(strength(HERE));
    split1Pow := strength(HERE) - strength(HERE) <span class="op">div</span> 2;
    split2Pow := strength(HERE) <span class="op">div</span> 2;
    new1SplitPow := split1Pow - shrinkSize(split1Pow);
    <span class="keywd">if</span> strength(HERE) > 1 <span class="keywd">then</span>
      new2SplitPow := split2Pow - shrinkSize(split2Pow);
    <span class="keywd">else</span>
      new2SplitPow := 0;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    split1Meal := min(split1Pow, food(HERE));
    <span class="keywd">for</span> direct <span class="keywd">range</span> MAIN_DIRECTIONS <span class="keywd">do</span>
      foodSum +:= food(direct);
      <span class="keywd">if</span> view(direct) = CLEAR <span class="keywd">then</span>
        meal := min(strength(HERE), food(direct));
        <span class="keywd">if</span>  (view(   left [direct]) <span class="op">in</span> enemy <span class="op">and</span>
            strength(left [direct]) >= newPow + meal) <span class="op">or</span>
            (view(   right[direct]) <span class="op">in</span> enemy <span class="op">and</span>
            strength(right[direct]) >= newPow + meal) <span class="keywd">then</span>
          noop;
        <span class="keywd">elsif</span> meal > eatMeal <span class="keywd">then</span>
          eatMeal := meal;
          eatDirs := directSet.EMPTY_SET;
          incl(eatDirs, direct);
        <span class="keywd">elsif</span> meal = eatMeal <span class="keywd">then</span>
          incl(eatDirs, direct);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        meal := min(split2Pow, food(direct));
        <span class="keywd">if</span>  (view(   left [direct]) <span class="op">in</span> enemy <span class="op">and</span>
            strength(left [direct]) >= new2SplitPow + meal) <span class="op">or</span>
            (view(   right[direct]) <span class="op">in</span> enemy <span class="op">and</span>
            strength(right[direct]) >= new2SplitPow + meal) <span class="keywd">then</span>
          noop;
        <span class="keywd">elsif</span> meal > split2Meal <span class="keywd">then</span>
          split2Meal := meal;
          splitDirs := directSet.EMPTY_SET;
          incl(splitDirs, direct);
        <span class="keywd">elsif</span> meal = split2Meal <span class="keywd">then</span>
          incl(splitDirs, direct);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> view(direct) <span class="op">in</span> enemy <span class="keywd">then</span>
        <span class="keywd">if</span> strength(direct) &lt;= strength(HERE) <span class="keywd">then</span>
          <span class="keywd">if</span>  (view(   left [direct]) <span class="op">in</span> enemy <span class="op">and</span>
              strength(left [direct]) >= newPow + strength(direct)) <span class="op">or</span>
              (view(   right[direct]) <span class="op">in</span> enemy <span class="op">and</span>
              strength(right[direct]) >= newPow + strength(direct)) <span class="keywd">then</span>
            noop;
          <span class="keywd">else</span>
            <span class="keywd">if</span> strength(direct) > killMeal <span class="keywd">then</span>
              killMeal := strength(direct);
              killDirs := directSet.EMPTY_SET;
              incl(killDirs, direct);
            <span class="keywd">elsif</span> strength(direct) = killMeal <span class="keywd">then</span>
              incl(killDirs, direct);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> strength(direct) > maxNeighbourEnemy <span class="keywd">then</span>
          maxNeighbourEnemy := strength(direct);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> view(direct) <span class="op">in</span> friends <span class="keywd">then</span>
        <span class="keywd">if</span> (strength(direct) &lt;= strength(HERE)) <span class="keywd">then</span>
          <span class="keywd">if</span>  (view(   left [direct]) <span class="op">in</span> enemy <span class="op">and</span>
              strength(left [direct]) >= strength(direct) <span class="op">and</span>
              strength(left [direct]) &lt; newPow + strength(direct)) <span class="op">or</span>
              (view(   right[direct]) <span class="op">in</span> enemy <span class="op">and</span>
              strength(right[direct]) >= strength(direct) <span class="op">and</span>
              strength(right[direct]) &lt; newPow + strength(direct)) <span class="keywd">then</span>
<span class="comment">(*
            write("Help situation: enemy="); write(view(left[direct]));
            write("["); write(strength(left[direct])); write("]/");
            write(view(right[direct])); write("["); write(strength(right[direct]));
            write("] FRIEND="); write(view(direct)); write("[");
            write(strength(direct)); write("] SELF="); write(view(HERE));
            write("["); write(strength(HERE)); write("] NEWSIZE=");
            writeln(newPow + strength(direct)); readln(KEYBOARD);
*)</span>
            <span class="keywd">if</span> strength(direct) > helpMeal <span class="keywd">then</span>
              helpMeal := 2 * strength(direct);
              <span class="comment">(* 2 * strength(direct) because with other moves the friend would be lost *)</span>
              helpDirs := directSet.EMPTY_SET;
              incl(helpDirs, direct);
            <span class="keywd">elsif</span> strength(direct) = helpMeal <span class="keywd">then</span>
              incl(helpDirs, direct);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> strength(HERE) = 1 <span class="op">or</span>
        maxNeighbourEnemy >= new1SplitPow + split1Meal <span class="keywd">then</span>
      splitPow := 0;
      splitDirs := directSet.EMPTY_SET;
    <span class="keywd">else</span>
      splitPow := new1SplitPow + split1Meal + new2SplitPow + split2Meal;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    foodSum +:= food(HERE);
    meal := min(strength(HERE), food(HERE));
    <span class="keywd">if</span> maxNeighbourEnemy &lt; newPow + meal <span class="keywd">then</span>
      <span class="keywd">if</span> meal > eatMeal <span class="keywd">then</span>
        eatMeal := meal;
        eatDirs := directSet.EMPTY_SET;
        incl(eatDirs, HERE);
      <span class="keywd">elsif</span> meal = eatMeal <span class="keywd">then</span>
        incl(eatDirs, HERE);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    eatPow := newPow + eatMeal;
    killPow := newPow + killMeal;
    helpPow := newPow + helpMeal;
    <span class="keywd">for</span> direct <span class="keywd">range</span> eatDirs <span class="keywd">do</span>
      gen2Meal := 0;
      <span class="keywd">for</span> direct2 <span class="keywd">range</span> gen2dirs[direct] <span class="keywd">do</span>
        <span class="keywd">if</span> direct2 = direct <span class="keywd">then</span>
          meal := min(eatPow, food(direct) - eatMeal);
        <span class="keywd">else</span>
          meal := min(eatPow, food(direct2));
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> meal > gen2Meal <span class="keywd">then</span>
          gen2Meal := meal;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">if</span> gen2Meal > gen2eatPow <span class="keywd">then</span>
        gen2eatPow := gen2Meal;
        gen2eatDirs := directSet.EMPTY_SET;
        incl(gen2eatDirs, direct);
      <span class="keywd">elsif</span> gen2Meal = gen2eatPow <span class="keywd">then</span>
        incl(gen2eatDirs, direct);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> direct <span class="keywd">range</span> splitDirs <span class="keywd">do</span>
      gen2Meal1 := 0;
      <span class="keywd">for</span> direct2 <span class="keywd">range</span> gen2dirs[HERE] <span class="keywd">do</span>
        <span class="keywd">if</span> direct2 &lt;> direct <span class="op">and</span> view(direct2) = CLEAR <span class="keywd">then</span>
          <span class="keywd">if</span> direct2 = HERE <span class="keywd">then</span>
            meal := min(new1SplitPow + split1Meal, food(direct2) - split1Meal);
          <span class="keywd">else</span>
            meal := min(new1SplitPow + split1Meal, food(direct2));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> meal > gen2Meal1 <span class="keywd">then</span>
            gen2Meal1 := meal;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      gen2Meal2 := 0;
      <span class="keywd">for</span> direct2 <span class="keywd">range</span> gen2dirs[direct] <span class="keywd">do</span>
        <span class="keywd">if</span> direct2 &lt;> HERE <span class="op">and</span> view(direct2) = CLEAR <span class="keywd">then</span>
          <span class="keywd">if</span> direct2 = direct <span class="keywd">then</span>
            meal := min(new2SplitPow + split2Meal, food(direct2) - split2Meal);
          <span class="keywd">else</span>
            meal := min(new2SplitPow + split2Meal, food(direct2));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> meal > gen2Meal2 <span class="keywd">then</span>
            gen2Meal2 := meal;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      gen2Meal := gen2Meal1 + gen2Meal2;
      <span class="keywd">if</span> gen2Meal > gen2splitPow <span class="keywd">then</span>
        gen2splitPow := gen2Meal;
        gen2splitDirs := directSet.EMPTY_SET;
        incl(gen2splitDirs, direct);
      <span class="keywd">elsif</span> gen2Meal = gen2splitPow <span class="keywd">then</span>
        incl(gen2splitDirs, direct);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    gen2eatPow +:= eatPow - shrinkSize(eatPow);
    gen2splitPow +:= splitPow -
        shrinkSize(new1SplitPow + split1Meal) - shrinkSize(new2SplitPow + split2Meal);
    <span class="keywd">if</span> killDirs &lt;> directSet.EMPTY_SET <span class="op">and</span>
        killPow >= strength(HERE) - newPow <span class="keywd">then</span>
      kill(optimalDir(killDirs));
    <span class="keywd">elsif</span> helpDirs &lt;> directSet.EMPTY_SET <span class="keywd">then</span>
      kill(optimalDir(helpDirs));
    <span class="keywd">elsif</span> max(eatPow, splitPow) > 0 <span class="keywd">then</span>
      <span class="keywd">if</span> gen2splitPow >= gen2eatPow <span class="op">and</span> gen2splitDirs &lt;> directSet.EMPTY_SET <span class="keywd">then</span>
        split(optimalDir(gen2splitDirs), split1Pow, split2Pow);
      <span class="keywd">else</span>
        eat(optimalDir(gen2eatDirs), strength(HERE));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      noop;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* dna (RED) *)</span>
</pre>
</body>
</html>
