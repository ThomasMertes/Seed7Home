<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  huffman.s7i   Support for Huffman coding.                       *)</span>
<span class="comment">(*  Copyright (C) 2021, 2022, 2024  Thomas Mertes                   *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bitdata.htm">bitdata.s7i</a>"</span>;


<span class="keywd">const</span> <span class="type">type</span>: symbolsWithCodeLengthType <span class="keywd">is</span> <span class="type">array</span> <span class="type">array</span> integer;


<span class="comment">(**
 *  Compute lists of symbols (index of codeLength) ordered by code langth.
 *  The result is a two-dimensional array where the first index is a code length.
 *   symbolsWithCodeLength := computeSymbolsWithCodeLength(codeLengths);
 *   # Now symbolsWithCodeLength[2] is an array of symbols with length 2.
 *  @param codeLengths Array to map the symbols (index) to the number of bits used
 *                     to encode this symbol. Zero means: This symbol is not used.
 *  @return an array of symbol arrays with the code length as first index.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">symbolsWithCodeLengthType</span>: computeSymbolsWithCodeLength (<span class="op">in</span> <span class="type">array</span> <span class="type">integer</span>: codeLengths) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">symbolsWithCodeLengthType</span>: symbolsWithCodeLength <span class="keywd">is</span> 0 <span class="op">times</span> 0 <span class="op">times</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: codeLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: maximumCodeLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: numberOfCodes <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: numberOfCodesWithLength <span class="keywd">is</span> 0 <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: valueIndex <span class="keywd">is</span> 0 <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: symbol <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> codeLength <span class="keywd">range</span> codeLengths <span class="keywd">do</span>
      <span class="keywd">if</span> codeLength > maximumCodeLength <span class="keywd">then</span>
        maximumCodeLength := codeLength;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    numberOfCodesWithLength := [1 .. maximumCodeLength] <span class="op">times</span> 0;
    <span class="keywd">for</span> codeLength <span class="keywd">range</span> codeLengths <span class="keywd">do</span>
      <span class="keywd">if</span> codeLength &lt;> 0 <span class="keywd">then</span>
        incr(numberOfCodesWithLength[codeLength]);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    symbolsWithCodeLength := [1 .. maximumCodeLength] <span class="op">times</span> 0 <span class="op">times</span> 0;
    <span class="keywd">for</span> numberOfCodes <span class="keywd">key</span> codeLength <span class="keywd">range</span> numberOfCodesWithLength <span class="keywd">do</span>
      <span class="keywd">if</span> numberOfCodes &lt;> 0 <span class="keywd">then</span>
        symbolsWithCodeLength[codeLength] := numberOfCodes <span class="op">times</span> 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    valueIndex := [1 .. maximumCodeLength] <span class="op">times</span> 1;
    <span class="keywd">for</span> codeLength <span class="keywd">key</span> symbol <span class="keywd">range</span> codeLengths <span class="keywd">do</span>
      <span class="keywd">if</span> codeLength &lt;> 0 <span class="keywd">then</span>
        symbolsWithCodeLength[codeLength][valueIndex[codeLength]] := symbol;
        incr(valueIndex[codeLength]);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: huffmanSymbolArray <span class="keywd">is</span> <span class="type">array</span> <span class="type">[</span>0 ..] integer;
<span class="keywd">const</span> <span class="type">type</span>: msbHuffmanCodeLengthArray <span class="keywd">is</span> <span class="type">array</span> <span class="type">[</span>0 ..] integer;


<span class="comment">(**
 *  Type to describe Huffman decoding from a [[bitdata#msbInBitStream|msbInBitStream]].
 *  This Huffman encoding is used by [[jpeg|JPEG]] files.
 *)</span>
<span class="keywd">const</span> <span class="type">type</span>: msbHuffmanDecoder <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: maximumCodeLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">huffmanSymbolArray</span>: symbols <span class="keywd">is</span> huffmanSymbolArray.value;
    <span class="keywd">var</span> <span class="type">msbHuffmanCodeLengthArray</span>: codeLengths <span class="keywd">is</span> msbHuffmanCodeLengthArray.value;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="comment">(**
 *  Create a Huffman decoder for reading in MSB-First order.
 *  This Huffman encoding is used by [[jpeg|JPEG]] files. It can happen that
 *  ''huffmanSymbols'' contains the same value twice. In that case
 *  the same symbol is encoded in two ways. This makes absolutely no
 *  sense but it can happen. For that reason it is necessary to use
 *  decoder.codeLengths with the same index as decoder.symbols.
 *  @param maximumCodeLength Maximum Huffman code length used.
 *  @param numberOfCodesWithLength Array to map bit width (index) to the number
 *                                 of symbols encoded with this bit width.
 *  @param huffmanSymbols String with symbols ordered by the bit width.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">msbHuffmanDecoder</span>: createMsbHuffmanDecoder (<span class="op">in</span> <span class="type">integer</span>: maximumCodeLength,
    <span class="op">in</span> <span class="type">array</span> <span class="type">integer</span>: numberOfCodesWithLength, <span class="op">in</span> <span class="type">string</span>: huffmanSymbols) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">msbHuffmanDecoder</span>: decoder <span class="keywd">is</span> msbHuffmanDecoder.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: currentCode <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: codeLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: symbolIndexStart <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: symbolIndexEnd <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: symbolIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: symbol <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: tableIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: repeatCount <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    decoder.maximumCodeLength := maximumCodeLength;
    decoder.symbols := huffmanSymbolArray[.. pred(1 &lt;&lt; maximumCodeLength)] <span class="op">times</span> 0;
    decoder.codeLengths := msbHuffmanCodeLengthArray[.. pred(1 &lt;&lt; maximumCodeLength)] <span class="op">times</span> 0;
    <span class="keywd">for</span> codeLength <span class="keywd">range</span> 1 <span class="keywd">to</span> maximumCodeLength <span class="keywd">do</span>
      repeatCount := 1 &lt;&lt; (maximumCodeLength - codeLength);
      symbolIndexStart := succ(symbolIndexEnd);
      symbolIndexEnd +:= numberOfCodesWithLength[codeLength];
      <span class="keywd">for</span> symbolIndex <span class="keywd">range</span> symbolIndexStart <span class="keywd">to</span> symbolIndexEnd <span class="keywd">do</span>
        symbol := ord(huffmanSymbols[symbolIndex]);
        <span class="keywd">for</span> repeatCount <span class="keywd">do</span>
          decoder.symbols[tableIndex] := symbol;
          decoder.codeLengths[tableIndex] := codeLength;
          incr(tableIndex);
        <span class="keywd">end</span> <span class="keywd">for</span>;
        incr(currentCode);
      <span class="keywd">end</span> <span class="keywd">for</span>;
      currentCode &lt;&lt;:= 1;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    symbol := ord(huffmanSymbols[length(huffmanSymbols)]);
    <span class="keywd">while</span> tableIndex &lt;= pred(1 &lt;&lt; maximumCodeLength) <span class="keywd">do</span>
      decoder.symbols[tableIndex] := symbol;
      decoder.codeLengths[tableIndex] := maximumCodeLength;
      incr(tableIndex);
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment"># The function createHuffmanTableMsb() is deprecated. Use createMsbHuffmanDecoder() instead.</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">msbHuffmanDecoder</span>: createHuffmanTableMsb (<span class="op">in</span> <span class="type">integer</span>: maximumCodeLength,
    <span class="op">in</span> <span class="type">array</span> <span class="type">integer</span>: numberOfCodesWithLength, <span class="op">in</span> <span class="type">string</span>: orderedSymbols) <span class="keywd">is</span>
  <span class="keywd">return</span> createMsbHuffmanDecoder(maximumCodeLength, numberOfCodesWithLength, orderedSymbols);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">msbHuffmanDecoder</span>: createMsbHuffmanDecoder (<span class="op">in</span> <span class="type">symbolsWithCodeLengthType</span>: symbolsWithCodeLength) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">msbHuffmanDecoder</span>: decoder <span class="keywd">is</span> msbHuffmanDecoder.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: currentCode <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: codeLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: symbol <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: tableIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: repeatCount <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    decoder.maximumCodeLength := maxIdx(symbolsWithCodeLength);
    decoder.symbols := huffmanSymbolArray[.. pred(1 &lt;&lt; decoder.maximumCodeLength)] <span class="op">times</span> 0;
    decoder.codeLengths := msbHuffmanCodeLengthArray[.. pred(1 &lt;&lt; decoder.maximumCodeLength)] <span class="op">times</span> 0;
    <span class="keywd">for</span> <span class="keywd">key</span> codeLength <span class="keywd">range</span> symbolsWithCodeLength <span class="keywd">do</span>
      repeatCount := 1 &lt;&lt; (decoder.maximumCodeLength - codeLength);
      <span class="keywd">for</span> symbol <span class="keywd">range</span> symbolsWithCodeLength[codeLength] <span class="keywd">do</span>
        <span class="keywd">for</span> repeatCount <span class="keywd">do</span>
          decoder.symbols[tableIndex] := symbol;
          decoder.codeLengths[tableIndex] := codeLength;
          incr(tableIndex);
        <span class="keywd">end</span> <span class="keywd">for</span>;
        incr(currentCode);
      <span class="keywd">end</span> <span class="keywd">for</span>;
      currentCode &lt;&lt;:= 1;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    symbol := ord(symbolsWithCodeLength[decoder.maximumCodeLength]
                  [length(symbolsWithCodeLength[decoder.maximumCodeLength])]);
    <span class="keywd">while</span> tableIndex &lt;= pred(1 &lt;&lt; decoder.maximumCodeLength) <span class="keywd">do</span>
      decoder.symbols[tableIndex] := symbol;
      decoder.codeLengths[tableIndex] := decoder.maximumCodeLength;
      incr(tableIndex);
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Create a Huffman decoder for reading in MSB-First order.
 *  This Huffman decoding is used by the BZIP2 algorithm.
 *  Non-optimal Huffman encodings, where symbols are encoded with more
 *  bits than necessary, are accepted as well. The decoder is created
 *  as follows:
 *  E.g.: The code lengths (in bits) of
 *   4 0 0 6 5 3 3 3 3 3 4 3 0 0 0 0 5 5 6
 *  describe that 0 is encoded with 4 bits, 3 with 6 bits, etc.
 *  This leads to the following encoding lengths:
 *   length 3: (5, 6, 7, 8, 9, 11)
 *   length 4: (0, 10)
 *   length 5: (4, 16, 17)
 *   length 6: (3, 18)
 *  Beginning with the lowest length the following encodings are generated:
 *   000: 5
 *   001: 6
 *   ...
 *   101: 11
 *  For the next length (4 instead of 3) the value is incremented and shifted:
 *   1100: 0
 *  The decoder should be able fetch the maximum length of bits and to
 *  use it as index. In order to allow that the data must be transformed.
 *  The bits must be left shifted and all variants of lower bits must be added:
 *   000000 encodes 5
 *   ...
 *   000111 encodes 5
 *   001000 encodes 6
 *   ...
 *   101000 encodes 11
 *   ...
 *   101111 encodes 11
 *   110000 encodes 0
 *   ...
 *   110011 encodes 0
 *   ...
 *  @param codeLengths Array to map the symbols (index) to the number of bits used
 *                     to encode this symbol. Zero means: This symbol is not used.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">msbHuffmanDecoder</span>: createMsbHuffmanDecoder (<span class="op">in</span> <span class="type">array</span> <span class="type">integer</span>: codeLengths) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">msbHuffmanDecoder</span>: decoder <span class="keywd">is</span> msbHuffmanDecoder.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">symbolsWithCodeLengthType</span>: symbolsWithCodeLength <span class="keywd">is</span> 0 <span class="op">times</span> 0 <span class="op">times</span> 0;
  <span class="keywd">begin</span>
    symbolsWithCodeLength := computeSymbolsWithCodeLength(codeLengths);
    decoder := createMsbHuffmanDecoder(symbolsWithCodeLength);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get a Huffman symbol from a [[bitdata#msbInBitStream|msbInBitStream]] using the Huffman ''decoder''.
 *  The read direction is from MSB (most significant bit) to LSB (least significant bit).
 *  The function peeks bits from ''inBitStream''. By default ''inBitStream'' appends some
 *  '\16#ff;' bytes to allow that bits can be peeked always.
 *   aSymbol := getHuffmanSymbol(compressedStream, huffmanDecoder);
 *  @param inBitStream MSB orderd bit stream from which the bits are skipped.
 *  @param decoder Huffman decoder defining the bit sequences that encode the symbols.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getHuffmanSymbol (<span class="keywd">inout</span> <span class="type">msbInBitStream</span>: inBitStream,
    <span class="op">in</span> <span class="type">msbHuffmanDecoder</span>: decoder) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: symbol <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    index := peekBits(inBitStream, decoder.maximumCodeLength);
    symbol := decoder.symbols[index];
    skipBits(inBitStream, decoder.codeLengths[index]);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Type to describe Huffman decoding from a [[bitdata#lsbInBitStream|lsbInBitStream]].
 *  This Huffman decoding is used by the inflate (deflate) algorithm.
 *)</span>
<span class="keywd">const</span> <span class="type">type</span>: lsbHuffmanDecoder <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: maximumCodeLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">huffmanSymbolArray</span>: symbols <span class="keywd">is</span> huffmanSymbolArray.value;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: codeLengths <span class="keywd">is</span> 0 <span class="op">times</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">lsbHuffmanDecoder</span>: createLsbHuffmanDecoder (<span class="op">in</span> <span class="type">array</span> <span class="type">integer</span>: codeLengths,
    <span class="op">in</span> <span class="type">integer</span>: maximumCodeLength,
    <span class="op">in</span> <span class="type">symbolsWithCodeLengthType</span>: symbolsWithCodeLength) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">lsbHuffmanDecoder</span>: decoder <span class="keywd">is</span> lsbHuffmanDecoder.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: codeLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: symbol <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: currentCode <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: reversedCode <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: highBits <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    decoder.maximumCodeLength := maximumCodeLength;
    decoder.symbols := huffmanSymbolArray[.. pred(1 &lt;&lt; maximumCodeLength)] <span class="op">times</span> 0;
    decoder.codeLengths := codeLengths;
    <span class="keywd">for</span> codeLength <span class="keywd">range</span> 1 <span class="keywd">to</span> maximumCodeLength <span class="keywd">do</span>
      <span class="keywd">for</span> symbol <span class="keywd">range</span> symbolsWithCodeLength[codeLength] <span class="keywd">do</span>
        reversedCode := reverseBits(codeLength, currentCode);
        <span class="keywd">for</span> highBits <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(1 &lt;&lt; maximumCodeLength) step 1 &lt;&lt; codeLength <span class="keywd">do</span>
          decoder.symbols[highBits + reversedCode] := symbol;
        <span class="keywd">end</span> <span class="keywd">for</span>;
        incr(currentCode);
      <span class="keywd">end</span> <span class="keywd">for</span>;
      currentCode &lt;&lt;:= 1;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Create a Huffman decoder for reading in LSB-First order.
 *  This Huffman decoding is used by the inflate (deflate) algorithm.
 *  Non-optimal Huffman encodings, where symbols are encoded with more
 *  bits than necessary, are accepted as well. The decoder is created
 *  as follows:
 *  E.g.: The code lengths (in bits) of
 *   4 0 0 6 5 3 3 3 3 3 4 3 0 0 0 0 5 5 6
 *  describe that 0 is encoded with 4 bits, 3 with 6 bits, etc.
 *  This leads to the following encoding lengths:
 *   length 3: (5, 6, 7, 8, 9, 11)
 *   length 4: (0, 10)
 *   length 5: (4, 16, 17)
 *   length 6: (3, 18)
 *  Beginning with the lowest length the following encodings are generated:
 *   000: 5
 *   001: 6
 *   ...
 *   101: 11
 *  For the next length (4 instead of 3) the value is incremented and shifted:
 *   1100: 0
 *  The decoder should be able fetch the maximum length of bits and to
 *  use it as index. In order to allow that the data must be transformed.
 *  The bits must be flipped and all variants of higher bits must be added:
 *   000000 encodes 5
 *   000001 encodes 9
 *   000010 encodes 7
 *   000011 encodes 0
 *   000100 encodes 6
 *   ...
 *   001000 encodes 5
 *   001001 encodes 9
 *   001010 encodes 7
 *   ...
 *  @param codeLengths Array to map the symbols (index) to the number of bits used
 *                     to encode this symbol. Zero means: This symbol is not used.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">lsbHuffmanDecoder</span>: createLsbHuffmanDecoder (<span class="op">in</span> <span class="type">array</span> <span class="type">integer</span>: codeLengths) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">lsbHuffmanDecoder</span>: decoder <span class="keywd">is</span> lsbHuffmanDecoder.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">symbolsWithCodeLengthType</span>: symbolsWithCodeLength <span class="keywd">is</span> 0 <span class="op">times</span> 0 <span class="op">times</span> 0;
  <span class="keywd">begin</span>
    symbolsWithCodeLength := computeSymbolsWithCodeLength(codeLengths);
    decoder := createLsbHuffmanDecoder(codeLengths, maxIdx(symbolsWithCodeLength),
                                       symbolsWithCodeLength);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment"># The function createHuffmanTableLsb() is deprecated. use createLsbHuffmanDecoder() instead.</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">lsbHuffmanDecoder</span>: createHuffmanTableLsb (<span class="op">in</span> <span class="type">array</span> <span class="type">integer</span>: codeLengths) <span class="keywd">is</span>
  <span class="keywd">return</span> createLsbHuffmanDecoder(codeLengths);


<span class="comment">(**
 *  Get a Huffman symbol from a [[bitdata#lsbInBitStream|lsbInBitStream]] using the Huffman ''decoder''.
 *  The read direction is from LSB (least significant bit) to MSB (most significant bit).
 *  The function peeks bits from ''inBitStream''. By default ''inBitStream'' appends some
 *  '\16#ff;' bytes to allow that bits can be peeked always.
 *   aSymbol := getHuffmanSymbol(compressedStream, huffmanDecoder);
 *  @param inBitStream LSB orderd bit stream from which the bits are skipped.
 *  @param decoder Huffman decoder defining the bit sequences that encode the symbols.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getHuffmanSymbol (<span class="keywd">inout</span> <span class="type">lsbInBitStream</span>: inBitStream,
    <span class="op">in</span> <span class="type">lsbHuffmanDecoder</span>: decoder) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: symbol <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    index := peekBits(inBitStream, decoder.maximumCodeLength);
    symbol := decoder.symbols[index];
    skipBits(inBitStream, decoder.codeLengths[symbol]);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Type to describe the Huffman encoding of one symbol.
 *)</span>
<span class="keywd">const</span> <span class="type">type</span>: huffmanEncoding <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: huffmanCode <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: codeLength <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="comment">(**
 *  Type to describe a Huffman encoder.
 *  The Huffman encoder can be used for writing in MSB-First or LSB-First order.
 *  This Huffman encoding is used by [[jpeg|JPEG]] files and by the
 *  deflate compression algorithm.
 *)</span>
<span class="keywd">const</span> <span class="type">type</span>: huffmanEncoder <span class="keywd">is</span> <span class="type">array</span> <span class="type">huffmanEncoding</span>;


<span class="comment">(**
 *  Write a huffman symbol to a [[bitdata#lsbOutBitStream|lsbOutBitStream]] using the huffman ''outNode''.
 *  The write direction is from LSB (least significant bit) to MSB (most significant bit).
 *   putHuffmanSymbol(compressedStream, encoder[huffmanSymbol]);
 *  @param outBitStream LSB orderd bit stream to which the bits are written.
 *  @param encoding Huffman encoding which defines the actual huffmanCode and the codeLength.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: putHuffmanSymbol (<span class="keywd">inout</span> <span class="type">lsbOutBitStream</span>: outBitStream, <span class="op">in</span> <span class="type">huffmanEncoding</span>: encoding) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    putBits(outBitStream, encoding.huffmanCode, encoding.codeLength);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Write a huffman symbol to a [[bitdata#msbOutBitStream|msbOutBitStream]] using the huffman ''encoding''.
 *  The write direction is from MSB (most significant bit) to LSB (least significant bit).
 *   putHuffmanSymbol(compressedStream, encoder[huffmanSymbol]);
 *  @param outBitStream MSB orderd bit stream to which the bits are written.
 *  @param encoding Huffman encoding which defines the actual huffmanCode and the codeLength.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: putHuffmanSymbol (<span class="keywd">inout</span> <span class="type">msbOutBitStream</span>: outBitStream, <span class="op">in</span> <span class="type">huffmanEncoding</span>: encoding) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    putBits(outBitStream, encoding.huffmanCode, encoding.codeLength);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: huffmanSymbolNode <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: count <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: symbol <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: fictiveNode <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: compare (<span class="op">in</span> <span class="type">huffmanSymbolNode</span>: node1, <span class="op">in</span> <span class="type">huffmanSymbolNode</span>: node2) <span class="keywd">is</span>
  <span class="keywd">return</span> -compare(node1.count, node2.count);

<span class="keywd">const</span> <span class="type">type</span>: huffmanSymbolNodeArray <span class="keywd">is</span> <span class="type">array</span> <span class="type">huffmanSymbolNode</span>;


<span class="keywd">const</span> <span class="type">type</span>: huffmanTreeNode <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leftTreeNode <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: rightTreeNode <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: leftSymbol <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: rightSymbol <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: huffmanTreeNodeArray <span class="keywd">is</span> <span class="type">array</span> <span class="type">huffmanTreeNode</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">huffmanSymbolNodeArray</span>: getHuffmanSymbolNodes (<span class="op">in</span> <span class="type">array</span> <span class="type">integer</span>: symbolCount) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">huffmanSymbolNodeArray</span>: symbolNodes <span class="keywd">is</span> huffmanSymbolNodeArray.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: count <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: symbol <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    symbolNodes := length(symbolCount) <span class="op">times</span> huffmanSymbolNode.value;
    <span class="keywd">for</span> count <span class="keywd">key</span> symbol <span class="keywd">range</span> symbolCount <span class="keywd">do</span>
      symbolNodes[index].count := count;
      symbolNodes[index].symbol := symbol;
      incr(index);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    symbolNodes := sort(symbolNodes);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getLengthsFromTree (<span class="keywd">inout</span> <span class="type">array</span> <span class="type">integer</span>: codeLengths,
    <span class="op">in</span> <span class="type">huffmanTreeNode</span>: treeNode, <span class="op">in</span> <span class="type">huffmanTreeNodeArray</span>: treeNodes,
    <span class="op">in</span> <span class="type">integer</span>: codeLength) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> treeNode.leftTreeNode &lt;> 0 <span class="keywd">then</span>
      getLengthsFromTree(codeLengths, treeNodes[treeNode.leftTreeNode],
                         treeNodes, succ(codeLength));
    <span class="keywd">else</span>
      codeLengths[treeNode.leftSymbol] := succ(codeLength);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> treeNode.rightTreeNode &lt;> 0 <span class="keywd">then</span>
      getLengthsFromTree(codeLengths, treeNodes[treeNode.rightTreeNode],
                         treeNodes, succ(codeLength));
    <span class="keywd">else</span>
      codeLengths[treeNode.rightSymbol] := succ(codeLength);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getLengthsFromTree (<span class="keywd">inout</span> <span class="type">array</span> <span class="type">integer</span>: codeLengths,
    <span class="op">in</span> <span class="type">huffmanSymbolNode</span>: symbolNode, <span class="op">in</span> <span class="type">huffmanTreeNodeArray</span>: treeNodes,
    <span class="op">in</span> <span class="type">integer</span>: codeLength) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> symbolNode.fictiveNode &lt;> 0 <span class="keywd">then</span>
      getLengthsFromTree(codeLengths, treeNodes[symbolNode.fictiveNode],
                         treeNodes, codeLength);
    <span class="keywd">else</span>
      codeLengths[symbolNode.symbol] := succ(codeLength);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Create an array of code lengths from the array ''symbolCount''.
 *  The indices of the ''symbolCount'' array are the symbols to be huffman encoded.
 *  The indices of the returned code lengths array are the symbols to be huffman encoded.
 *  @param symbolCount Array of occurances of the corresponding symbol (index).
 *  @return an array of code lengths of the corresponding symbol (index).
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">integer</span>: getHuffmanCodeLengths (<span class="op">in</span> <span class="type">array</span> <span class="type">integer</span>: symbolCount) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: codeLengths <span class="keywd">is</span> 0 <span class="op">times</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">huffmanSymbolNodeArray</span>: symbolNodes <span class="keywd">is</span> huffmanSymbolNodeArray.value;
    <span class="keywd">var</span> <span class="type">huffmanTreeNodeArray</span>: treeNodes <span class="keywd">is</span> huffmanTreeNodeArray.value;
    <span class="keywd">var</span> <span class="type">huffmanTreeNode</span>: treeNode <span class="keywd">is</span> huffmanTreeNode.value;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    symbolNodes := getHuffmanSymbolNodes(symbolCount);
    index := length(symbolNodes);
    <span class="keywd">while</span> symbolNodes[index].count = 0 <span class="op">and</span>
        index > minIdx(symbolNodes) <span class="keywd">do</span>
      decr(index);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">while</span> index > 1 <span class="keywd">do</span>
      treeNode := huffmanTreeNode.value;
      <span class="keywd">if</span> symbolNodes[pred(index)].fictiveNode &lt;> 0 <span class="keywd">then</span>
        treeNode.leftTreeNode :=
            symbolNodes[pred(index)].fictiveNode;
      <span class="keywd">else</span>
        treeNode.leftSymbol := symbolNodes[pred(index)].symbol;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbolNodes[index].fictiveNode &lt;> 0 <span class="keywd">then</span>
        treeNode.rightTreeNode :=
            symbolNodes[index].fictiveNode;
      <span class="keywd">else</span>
        treeNode.rightSymbol := symbolNodes[index].symbol;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      treeNodes &amp;:= treeNode;
      symbolNodes[pred(index)].count +:= symbolNodes[index].count;
      symbolNodes[pred(index)].fictiveNode := length(treeNodes);
      symbolNodes[index].count := 0;
      symbolNodes := sort(symbolNodes);
      decr(index);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    codeLengths := [minIdx(symbolCount) .. maxIdx(symbolCount)] <span class="op">times</span> 0;
    getLengthsFromTree(codeLengths, symbolNodes[1], treeNodes, 0);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reduce the maximum code length of an Huffman encoding to ''allowedMaximum''.
 *  The given ''codeLengths'' array is changed to fit to the ''allowedMaximum''.
 *  @param codeLengths Array to map the symbols (index) to the number of bits used
 *                     to encode this symbol. Zero means: This symbol is not used.
 *  @param allowedMaximum Target maximum code length of the Huffman encoding.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: reduceMaximumHuffmanCodeLength (<span class="keywd">inout</span> <span class="type">array</span> <span class="type">integer</span>: codeLengths,
    <span class="op">in</span> <span class="type">integer</span>: allowedMaximum) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">symbolsWithCodeLengthType</span>: symbolsWithCodeLength <span class="keywd">is</span> 0 <span class="op">times</span> 0 <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: maximumCodeLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: shorterCodeLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: longerCodeLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: symbolsMovingUp <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: moveDone <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: symbol <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    symbolsWithCodeLength := computeSymbolsWithCodeLength(codeLengths);
    maximumCodeLength := maxIdx(symbolsWithCodeLength);
    <span class="keywd">repeat</span>
      shorterCodeLength := maximumCodeLength - 2;
      moveDone := FALSE;
      <span class="keywd">repeat</span>
        <span class="keywd">while</span> length(symbolsWithCodeLength[shorterCodeLength]) = 0 <span class="keywd">do</span>
          decr(shorterCodeLength);
        <span class="keywd">end</span> <span class="keywd">while</span>;
        longerCodeLength := shorterCodeLength + 2;
        symbolsMovingUp := 2;
        <span class="keywd">while</span> longerCodeLength &lt;= maximumCodeLength <span class="op">and</span>
            length(symbolsWithCodeLength[longerCodeLength]) &lt; symbolsMovingUp <span class="keywd">do</span>
          incr(longerCodeLength);
          symbolsMovingUp *:= 2;
        <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">if</span> longerCodeLength &lt;= maximumCodeLength <span class="keywd">then</span>
          <span class="comment"># Move one symbol with shorterCodeLength down (code length + 1).</span>
          <span class="comment"># This creates a free place at the level below.</span>
          <span class="comment"># Because of fictive nodes two symbols can move up to this free place.</span>
	  <span class="comment"># Alternatively at lower levels 4, 8, 16 etc. symbols can move up.</span>
          symbol := symbolsWithCodeLength[shorterCodeLength][1];
          symbolsWithCodeLength[succ(shorterCodeLength)] &amp;:= symbol;
          codeLengths[symbol] := succ(shorterCodeLength);
          <span class="comment"># Remove the moved symbol from the shorterCodeLength level.</span>
          symbolsWithCodeLength[shorterCodeLength] :=
              symbolsWithCodeLength[shorterCodeLength][2 ..];
          <span class="comment"># Move symbols with a longerCodeLength up (code length - 1).</span>
          <span class="comment"># Depending on the difference between shorterCodeLength and</span>
          <span class="comment"># longerCodeLength symbolsMovingUp (2, 4, 8, etc.) symbols can move up.</span>
          <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> symbolsMovingUp <span class="keywd">do</span>
            symbol := symbolsWithCodeLength[longerCodeLength][index];
            symbolsWithCodeLength[pred(longerCodeLength)] &amp;:= symbol;
            codeLengths[symbol] := pred(longerCodeLength);
          <span class="keywd">end</span> <span class="keywd">for</span>;
          <span class="comment"># Remove the moved symbols from the longerCodeLength level.</span>
          symbolsWithCodeLength[longerCodeLength] :=
              symbolsWithCodeLength[longerCodeLength][succ(symbolsMovingUp) ..];
          moveDone := TRUE;
        <span class="keywd">else</span>
          decr(shorterCodeLength);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> moveDone;
      <span class="keywd">if</span> length(symbolsWithCodeLength[maximumCodeLength]) = 0 <span class="keywd">then</span>
        decr(maximumCodeLength);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> maximumCodeLength &lt;= allowedMaximum;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">huffmanEncoder</span>: createHuffmanEncoder (<span class="op">in</span> <span class="type">array</span> <span class="type">integer</span>: codeLengths,
    <span class="op">in</span> <span class="type">integer</span>: maximumCodeLength,
    <span class="op">in</span> <span class="type">symbolsWithCodeLengthType</span>: symbolsWithCodeLength) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">huffmanEncoder</span>: encoder <span class="keywd">is</span> huffmanEncoder.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: codeLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: symbol <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: currentCode <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    encoder := [minIdx(codeLengths) .. maxIdx(codeLengths)] <span class="op">times</span> huffmanEncoding.value;
    <span class="keywd">for</span> codeLength <span class="keywd">range</span> 1 <span class="keywd">to</span> maximumCodeLength <span class="keywd">do</span>
      <span class="keywd">for</span> symbol <span class="keywd">range</span> symbolsWithCodeLength[codeLength] <span class="keywd">do</span>
        encoder[symbol].huffmanCode := reverseBits(codeLength, currentCode);
        encoder[symbol].codeLength := codeLength;
        incr(currentCode);
      <span class="keywd">end</span> <span class="keywd">for</span>;
      currentCode &lt;&lt;:= 1;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Create a ''huffmanEncoder'' from the given ''codeLengths'' array.
 *  The Huffman encoder can be used for writing in MSB-First or LSB-First order.
 *  This Huffman encoding is used by [[jpeg|JPEG]] files and by the
 *  deflate compression algorithm.
 *  @param codeLengths Array to map the symbols (index) to the number of bits used
 *                     to encode this symbol. Zero means: This symbol is not used.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">huffmanEncoder</span>: createHuffmanEncoder (<span class="op">in</span> <span class="type">array</span> <span class="type">integer</span>: codeLengths) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">huffmanEncoder</span>: encoder <span class="keywd">is</span> huffmanEncoder.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">symbolsWithCodeLengthType</span>: symbolsWithCodeLength <span class="keywd">is</span> 0 <span class="op">times</span> 0 <span class="op">times</span> 0;
  <span class="keywd">begin</span>
    symbolsWithCodeLength := computeSymbolsWithCodeLength(codeLengths);
    encoder := createHuffmanEncoder(codeLengths, maxIdx(symbolsWithCodeLength),
                                    symbolsWithCodeLength);
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
