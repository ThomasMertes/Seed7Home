<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  bitdata.s7i   Read and write bits to and from strings           *)</span>
<span class="comment">(*  Copyright (C) 2015, 2017, 2019 - 2024  Thomas Mertes            *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bytedata.htm">bytedata.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bin64.htm">bin64.s7i</a>"</span>;


<span class="comment">(**
 *  Array to reverse the bits of small numbers.
 *  The first index is the number of bits to be reversed (between 2 and 9).
 *  The second index is the number for which the bits should be reversed.
 *   reverseBits[2][2#10]      returns  2#1
 *   reverseBits[4][2#1101]    returns  2#1011
 *   reverseBits[6][2#110101]  returns  2#101011
 *)</span>
<span class="keywd">const</span> <span class="type">array</span> <span class="type">array</span> <span class="type">integer</span>: reverseBits <span class="keywd">is</span> [2] (
    <span class="comment">(* 2 *)</span> [0] (0, 2, 1, 3),
    <span class="comment">(* 3 *)</span> [0] (0, 4, 2, 6, 1, 5, 3, 7),
    <span class="comment">(* 4 *)</span> [0] (0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15),
    <span class="comment">(* 5 *)</span> [0] (0, 16, 8, 24, 4, 20, 12, 28, 2, 18, 10, 26, 6, 22, 14, 30,
                 1, 17, 9, 25, 5, 21, 13, 29, 3, 19, 11, 27, 7, 23, 15, 31),
    <span class="comment">(* 6 *)</span> [0] (0, 32, 16, 48,  8, 40, 24, 56, 4, 36, 20, 52, 12, 44, 28, 60,
                 2, 34, 18, 50, 10, 42, 26, 58, 6, 38, 22, 54, 14, 46, 30, 62,
                 1, 33, 17, 49,  9, 41, 25, 57, 5, 37, 21, 53, 13, 45, 29, 61,
                 3, 35, 19, 51, 11, 43, 27, 59, 7, 39, 23, 55, 15, 47, 31, 63),
    <span class="comment">(* 7 *)</span> [0] (0, 64, 32,  96, 16, 80, 48, 112,  8, 72, 40, 104, 24, 88, 56, 120,
                 4, 68, 36, 100, 20, 84, 52, 116, 12, 76, 44, 108, 28, 92, 60, 124,
                 2, 66, 34,  98, 18, 82, 50, 114, 10, 74, 42, 106, 26, 90, 58, 122,
                 6, 70, 38, 102, 22, 86, 54, 118, 14, 78, 46, 110, 30, 94, 62, 126,
                 1, 65, 33,  97, 17, 81, 49, 113 , 9, 73, 41, 105, 25, 89, 57, 121,
                 5, 69, 37, 101, 21, 85, 53, 117, 13, 77, 45, 109, 29, 93, 61, 125,
                 3, 67, 35,  99, 19, 83, 51, 115, 11, 75, 43, 107, 27, 91, 59, 123,
                 7, 71, 39, 103, 23, 87, 55, 119, 15, 79, 47, 111, 31, 95, 63, 127),
    <span class="comment">(* 8 *)</span> [0] ( 0, 128, 64, 192, 32, 160,  96, 224, 16, 144, 80, 208, 48, 176, 112, 240,
                  8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248,
                  4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244,
                 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252,
                  2, 130, 66, 194, 34, 162,  98, 226, 18, 146, 82, 210, 50, 178, 114, 242,
                 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250,
                  6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246,
                 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254,
                  1, 129, 65, 193, 33, 161,  97, 225, 17, 145, 81, 209, 49, 177, 113, 241,
                  9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249,
                  5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245,
                 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253,
                  3, 131, 67, 195, 35, 163,  99, 227, 19, 147, 83, 211, 51, 179, 115, 243,
                 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251,
                  7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247,
                 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255),
    <span class="comment">(* 9 *)</span> [0] ( 0, 256, 128, 384, 64, 320, 192, 448, 32, 288, 160, 416,  96, 352, 224, 480,
                 16, 272, 144, 400, 80, 336, 208, 464, 48, 304, 176, 432, 112, 368, 240, 496,
                  8, 264, 136, 392, 72, 328, 200, 456, 40, 296, 168, 424, 104, 360, 232, 488,
                 24, 280, 152, 408, 88, 344, 216, 472, 56, 312, 184, 440, 120, 376, 248, 504,
                  4, 260, 132, 388, 68, 324, 196, 452, 36, 292, 164, 420, 100, 356, 228, 484,
                 20, 276, 148, 404, 84, 340, 212, 468, 52, 308, 180, 436, 116, 372, 244, 500,
                 12, 268, 140, 396, 76, 332, 204, 460, 44, 300, 172, 428, 108, 364, 236, 492,
                 28, 284, 156, 412, 92, 348, 220, 476, 60, 316, 188, 444, 124, 380, 252, 508,
                  2, 258, 130, 386, 66, 322, 194, 450, 34, 290, 162, 418,  98, 354, 226, 482,
                 18, 274, 146, 402, 82, 338, 210, 466, 50, 306, 178, 434, 114, 370, 242, 498,
                 10, 266, 138, 394, 74, 330, 202, 458, 42, 298, 170, 426, 106, 362, 234, 490,
                 26, 282, 154, 410, 90, 346, 218, 474, 58, 314, 186, 442, 122, 378, 250, 506,
                  6, 262, 134, 390, 70, 326, 198, 454, 38, 294, 166, 422, 102, 358, 230, 486,
                 22, 278, 150, 406, 86, 342, 214, 470, 54, 310, 182, 438, 118, 374, 246, 502,
                 14, 270, 142, 398, 78, 334, 206, 462, 46, 302, 174, 430, 110, 366, 238, 494,
                 30, 286, 158, 414, 94, 350, 222, 478, 62, 318, 190, 446, 126, 382, 254, 510,
                  1, 257, 129, 385, 65, 321, 193, 449, 33, 289, 161, 417,  97, 353, 225, 481,
                 17, 273, 145, 401, 81, 337, 209, 465, 49, 305, 177, 433, 113, 369, 241, 497,
                  9, 265, 137, 393, 73, 329, 201, 457, 41, 297, 169, 425, 105, 361, 233, 489,
                 25, 281, 153, 409, 89, 345, 217, 473, 57, 313, 185, 441, 121, 377, 249, 505,
                  5, 261, 133, 389, 69, 325, 197, 453, 37, 293, 165, 421, 101, 357, 229, 485,
                 21, 277, 149, 405, 85, 341, 213, 469, 53, 309, 181, 437, 117, 373, 245, 501,
                 13, 269, 141, 397, 77, 333, 205, 461, 45, 301, 173, 429, 109, 365, 237, 493,
                 29, 285, 157, 413, 93, 349, 221, 477, 61, 317, 189, 445, 125, 381, 253, 509,
                  3, 259, 131, 387, 67, 323, 195, 451, 35, 291, 163, 419,  99, 355, 227, 483,
                 19, 275, 147, 403, 83, 339, 211, 467, 51, 307, 179, 435, 115, 371, 243, 499,
                 11, 267, 139, 395, 75, 331, 203, 459, 43, 299, 171, 427, 107, 363, 235, 491,
                 27, 283, 155, 411, 91, 347, 219, 475, 59, 315, 187, 443, 123, 379, 251, 507,
                  7, 263, 135, 391, 71, 327, 199, 455, 39, 295, 167, 423, 103, 359, 231, 487,
                 23, 279, 151, 407, 87, 343, 215, 471, 55, 311, 183, 439, 119, 375, 247, 503,
                 15, 271, 143, 399, 79, 335, 207, 463, 47, 303, 175, 431, 111, 367, 239, 495,
                 31, 287, 159, 415, 95, 351, 223, 479, 63, 319, 191, 447, 127, 383, 255, 511));


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: reverseBits (<span class="op">in</span> <span class="type">integer</span>: size, <span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: bits) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: reversed <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: bitPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> bitPos <span class="keywd">range</span> 1 <span class="keywd">to</span> size <span class="keywd">do</span>
      reversed &lt;&lt;:= 1;
      reversed +:= bits <span class="op">mod</span> 2;
      bits >>:= 1;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: reverseByteBits (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: reversed <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: aChar <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    reversed := <span class="stri">"\0;"</span> <span class="op">mult</span> length(stri);
    <span class="keywd">for</span> aChar <span class="keywd">key</span> index <span class="keywd">range</span> stri <span class="keywd">do</span>
      reversed @:= [index] char(reverseBits[8][ord(aChar)]);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Type to read bitwise data starting with the least significant bit.
 *  This is used by the Huffman compression (as part of the deflate
 *  compression) used for ZIP and GZIP files. It is also used by the
 *  Lempel-Ziv-Welch compression used for GIF files.
 *  In a ''lsbInBitStream'' the read direction is from
 *  LSB (least significant bit) to MSB (most significant bit).
 *  For the bit position in a byte holds: 0 = LSB, 7 = MSB.
 *)</span>
<span class="keywd">const</span> <span class="type">type</span>: lsbInBitStream <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: buffer <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bitPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bytePos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: eofBitPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: eofBytePos <span class="keywd">is</span> integer.last;
    <span class="keywd">var</span> <span class="type">integer</span>: eofCheckPos <span class="keywd">is</span> integer.last;
    <span class="keywd">var</span> <span class="type">string</span>: striBuffer <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: striBufferIncrease <span class="keywd">is</span> 4096;
    <span class="keywd">var</span> <span class="type">integer</span>: tailSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: limit <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">file</span>: inFile <span class="keywd">is</span> STD_NULL;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: show (<span class="op">in</span> <span class="type">lsbInBitStream</span>: inBitStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"buffer: "</span> &lt;&amp; inBitStream.buffer radix 2);
    writeln(<span class="stri">"bitPos: "</span> &lt;&amp; inBitStream.bitPos);
    writeln(<span class="stri">"bytePos: "</span> &lt;&amp; inBitStream.bytePos);
    writeln(<span class="stri">"eofBitPos: "</span> &lt;&amp; inBitStream.eofBitPos);
    writeln(<span class="stri">"eofBytePos: "</span> &lt;&amp; inBitStream.eofBytePos);
    writeln(<span class="stri">"eofCheckPos: "</span> &lt;&amp; inBitStream.eofCheckPos);
    writeln(<span class="stri">"striBuffer: "</span> &lt;&amp; literal(inBitStream.striBuffer));
    writeln(<span class="stri">"striBufferIncrease: "</span> &lt;&amp; inBitStream.striBufferIncrease);
    writeln(<span class="stri">"tailSize: "</span> &lt;&amp; inBitStream.tailSize);
    writeln(<span class="stri">"limit: "</span> &lt;&amp; inBitStream.limit);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: fillStriBuffer (<span class="keywd">inout</span> <span class="type">lsbInBitStream</span>: inBitStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    inBitStream.striBuffer := inBitStream.striBuffer[inBitStream.bytePos ..] &amp;
                            gets(inBitStream.inFile, inBitStream.striBufferIncrease);
    <span class="keywd">if</span> <span class="op">not</span> hasNext(inBitStream.inFile) <span class="keywd">then</span>
      <span class="comment"># Append "\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;" to the data.</span>
      <span class="comment"># This allows a peek of 32 bits also at the end of the data.</span>
      inBitStream.striBuffer &amp;:= <span class="stri">"\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;"</span>;
      inBitStream.tailSize +:= 8;
      inBitStream.eofBytePos := succ(length(inBitStream.striBuffer)) -
                                inBitStream.tailSize;
      inBitStream.eofCheckPos := max(1, length(inBitStream.striBuffer) -
                                 inBitStream.tailSize - 6);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    inBitStream.limit := max(0, length(inBitStream.striBuffer) - 7);
    inBitStream.bytePos := 1;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: fillBuffer (<span class="keywd">inout</span> <span class="type">lsbInBitStream</span>: inBitStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> inBitStream.bytePos > inBitStream.limit <span class="keywd">then</span>
      fillStriBuffer(inBitStream);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    inBitStream.buffer := bytes2Int(inBitStream.striBuffer[inBitStream.bytePos fixLen 8], SIGNED, LE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Open an LSB bit stream from the file ''inFile'' for reading.
 *  In a ''lsbInBitStream'' the read direction is from
 *  LSB (least significant bit) to MSB (most significant bit).
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">lsbInBitStream</span>: openLsbInBitStream (<span class="keywd">inout</span> <span class="type">file</span>: inFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">lsbInBitStream</span>: inBitStream <span class="keywd">is</span> lsbInBitStream.value;
  <span class="keywd">begin</span>
    inBitStream.inFile := inFile;
    fillBuffer(inBitStream);
    <span class="comment"># show(inBitStream);</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Open an LSB bit stream from the string ''stri'' for reading.
 *  In a ''lsbInBitStream'' the read direction is from
 *  LSB (least significant bit) to MSB (most significant bit).
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">lsbInBitStream</span>: openLsbInBitStream (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">lsbInBitStream</span>: inBitStream <span class="keywd">is</span> lsbInBitStream.value;
  <span class="keywd">begin</span>
    <span class="comment"># Append "\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;" to the data.</span>
    <span class="comment"># This allows a peek of 32 bits also at the end of the data.</span>
    inBitStream.striBuffer := stri &amp; <span class="stri">"\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;"</span>;
    inBitStream.tailSize := 8;
    inBitStream.eofBytePos := succ(length(inBitStream.striBuffer)) -
                              inBitStream.tailSize;
    inBitStream.eofCheckPos := max(1, length(inBitStream.striBuffer) -
                               inBitStream.tailSize - 6);
    inBitStream.limit := length(inBitStream.striBuffer) - 7;
    fillBuffer(inBitStream);
    <span class="comment"># show(inBitStream);</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Close an LSB bit stream and position the underlying file at the next byte.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: close (<span class="keywd">inout</span> <span class="type">lsbInBitStream</span>: inBitStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> inBitStream.inFile &lt;> STD_NULL <span class="keywd">then</span>
      <span class="keywd">if</span> inBitStream.bitPos &lt;> 0 <span class="keywd">then</span>
        inBitStream.bytePos +:= (inBitStream.bitPos + 7) <span class="op">mdiv</span> 8;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      seek(inBitStream.inFile, tell(inBitStream.inFile) -
           succ(length(inBitStream.striBuffer) -
                inBitStream.bytePos - inBitStream.tailSize));
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get one bit in LSB-First order from ''inBitStream''.
 *  The bit is read at the current byte and bit position. Afterwards
 *  byte and bit position are advanced by one bit. The read
 *  direction is from LSB (least significant bit) to MSB (most significant bit).
 *   aBitStream := openLsbInBitStream("\2#01101011;\2#11001110;");
 *   skipBits(aBitStream, 5);
 *   # Original data:  "\2#01101011;\2#11001110;"
 *   #                       ^
 *   #                    current
 *   #                   position
 *   getBit(aBitStream)  returns  2#1
 *   # Original data:  "\2#01101011;\2#11001110;"
 *   #                       1
 *   #                    bit of
 *   #                  the result
 *   # Now aBitStream is at bytePos=1 and bitPos=6 of the original data.
 *   # Original data:  "\2#01101011;\2#11001110;"
 *   #                      ^
 *   #                   current
 *   #                  position
 *  @param inBitStream LSB orderd bit stream from which the bit is read.
 *  @exception RANGE_ERROR If the end of ''inBitStream'' has been reached.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getBit (<span class="keywd">inout</span> <span class="type">lsbInBitStream</span>: inBitStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: resultBit <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    resultBit := (inBitStream.buffer >> inBitStream.bitPos) <span class="op">mod</span> 2;
    incr(inBitStream.bitPos);
    <span class="keywd">if</span> inBitStream.bitPos >= 32 <span class="keywd">then</span>
      inBitStream.bitPos -:= 32;
      inBitStream.bytePos +:= 4;
      <span class="keywd">if</span> inBitStream.bytePos > inBitStream.limit <span class="keywd">then</span>
        fillStriBuffer(inBitStream);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      inBitStream.buffer := (inBitStream.buffer >> 32) <span class="op">mod</span> 2 ** 32 +
          (bytes2Int(inBitStream.striBuffer[inBitStream.bytePos + 4 fixLen 4], SIGNED, LE) &lt;&lt; 32);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get ''bitWidth'' bits in LSB-First order from ''inBitStream''.
 *  The bits are read at the current byte and bit position. Afterwards
 *  byte and bit position are advanced by ''bitWidth'' bits. The read
 *  direction is from LSB (least significant bit) to MSB (most significant bit).
 *  If bits from the next byte(s) are read a byte order of little-endian
 *  is used.
 *   aBitStream := openLsbInBitStream("\2#01101011;\2#11001110;");
 *   skipBits(aBitStream, 5);
 *   # Original data:  "\2#01101011;\2#11001110;"
 *   #                       ^
 *   #                    current
 *   #                   position
 *   getBits(aBitStream, 5)  returns  2#10011
 *   # Original data:  "\2#01101011;\2#11001110;"
 *   #                     011               10
 *   #                 lower bits        higher bits
 *   #                  of result         of result
 *   # Now aBitStream is at bytePos=2 and bitPos=2 of the original data.
 *   # Original data:  "\2#01101011;\2#11001110;"
 *   #                                      ^
 *   #                                   current
 *   #                                   position
 *  @param inBitStream LSB orderd bit stream from which the bits are read.
 *  @param bitWidth Number of bits requested (between 1 and 32).
 *  @exception RANGE_ERROR If the end of ''inBitStream'' has been reached.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getBits (<span class="keywd">inout</span> <span class="type">lsbInBitStream</span>: inBitStream, <span class="op">in</span> <span class="type">integer</span>: bitWidth) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: resultBits <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: bytePosDelta <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    resultBits := (inBitStream.buffer >> inBitStream.bitPos) <span class="op">mod</span> (1 &lt;&lt; bitWidth);
    inBitStream.bitPos +:= bitWidth;
    <span class="keywd">if</span> inBitStream.bitPos >= 32 <span class="keywd">then</span>
      bytePosDelta := inBitStream.bitPos <span class="op">mdiv</span> 8;
      inBitStream.bitPos -:= 8 * bytePosDelta;
      inBitStream.bytePos +:= bytePosDelta;
      <span class="keywd">if</span> inBitStream.bytePos > inBitStream.limit <span class="keywd">then</span>
        fillStriBuffer(inBitStream);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> bytePosDelta = 4 <span class="keywd">then</span>
        inBitStream.buffer := (inBitStream.buffer >> 32) <span class="op">mod</span> 2 ** 32 +
            (bytes2Int(inBitStream.striBuffer[inBitStream.bytePos + 4 fixLen 4], SIGNED, LE) &lt;&lt; 32);
      <span class="keywd">elsif</span> bytePosDelta = 5 <span class="keywd">then</span>
        inBitStream.buffer := (inBitStream.buffer >> 40) <span class="op">mod</span> 2 ** 24 +
            (bytes2Int(inBitStream.striBuffer[inBitStream.bytePos + 3 fixLen 5], SIGNED, LE) &lt;&lt; 24);
      <span class="keywd">else</span>
        inBitStream.buffer := bytes2Int(inBitStream.striBuffer[inBitStream.bytePos fixLen 8], SIGNED, LE);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Peek ''bitWidth'' bits in LSB-First order from ''inBitStream''.
 *  The bits are read at the current byte and bit position. Byte
 *  and bit position remain unchanged. The read direction is from
 *  LSB (least significant bit) to MSB (most significant bit).
 *  If bits from the next byte(s) are read a byte order of little-endian
 *  is used.
 *   aBitStream := openLsbInBitStream("\2#01101011;\2#10101101;");
 *   skipBits(aBitStream, 5);
 *   # Original data:  "\2#01101011;\2#10101101;"
 *   #                       ^
 *   #                    current
 *   #                   position
 *   peekBits(aBitStream, 6)  returns  2#101011
 *   # Original data:  "\2#01101011;\2#10101101;"
 *   #                     011              101
 *   #                 lower bits        higher bits
 *   #                  of result         of result
 *   # BytePos and bitPos of aBitStream have not changed.
 *  @param inBitStream LSB orderd bit stream from which the bits are peeked.
 *  @param bitWidth Number of bits requested (between 1 and 32).
 *  @exception RANGE_ERROR If the end of ''inBitStream'' has been reached.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: peekBits (<span class="keywd">inout</span> <span class="type">lsbInBitStream</span>: inBitStream, <span class="op">in</span> <span class="type">integer</span>: bitWidth) <span class="keywd">is</span>
  <span class="keywd">return</span> (inBitStream.buffer >> inBitStream.bitPos) <span class="op">mod</span> (1 &lt;&lt; bitWidth);


<span class="comment">(**
 *  Advance the bit position of ''inBitStream'' by ''bitWidth'' bits.
 *   aBitStream := openLsbInBitStream("\2#01101011;\2#11001110;");
 *   # Now aBitStream has bytePos=1 and bitPos=0 of the original data.
 *   # Original data:  "\2#01101011;\2#11001110;"
 *   #                            ^
 *   #                         current
 *   #                        position
 *   skipBits(aBitStream, 5);
 *   # Now aBitStream is at bytePos=1 and bitPos=5 of the original data.
 *   # Original data:  "\2#01101011;\2#11001110;"
 *   #                       ^
 *   #                    current
 *   #                   position
 *  @param inBitStream LSB orderd bit stream from which the bits are skipped.
 *  @param bitWidth Number of bits to be skipped (between 1 and 32).
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: skipBits (<span class="keywd">inout</span> <span class="type">lsbInBitStream</span>: inBitStream, <span class="op">in</span> <span class="type">integer</span>: bitWidth) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: bytePosDelta <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    inBitStream.bitPos +:= bitWidth;
    <span class="keywd">if</span> inBitStream.bitPos >= 32 <span class="keywd">then</span>
      bytePosDelta := inBitStream.bitPos <span class="op">mdiv</span> 8;
      inBitStream.bitPos -:= 8 * bytePosDelta;
      inBitStream.bytePos +:= bytePosDelta;
      <span class="keywd">if</span> inBitStream.bytePos > inBitStream.limit <span class="keywd">then</span>
        fillStriBuffer(inBitStream);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> bytePosDelta = 4 <span class="keywd">then</span>
        inBitStream.buffer := (inBitStream.buffer >> 32) <span class="op">mod</span> 2 ** 32 +
            (bytes2Int(inBitStream.striBuffer[inBitStream.bytePos + 4 fixLen 4], SIGNED, LE) &lt;&lt; 32);
      <span class="keywd">elsif</span> bytePosDelta = 5 <span class="keywd">then</span>
        inBitStream.buffer := (inBitStream.buffer >> 40) <span class="op">mod</span> 2 ** 24 +
            (bytes2Int(inBitStream.striBuffer[inBitStream.bytePos + 3 fixLen 5], SIGNED, LE) &lt;&lt; 24);
      <span class="keywd">else</span>
        inBitStream.buffer := bytes2Int(inBitStream.striBuffer[inBitStream.bytePos fixLen 8], SIGNED, LE);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine if at least one bit beyond the bit stream has been read.
 *  The EOF condition is also met if skipBits() skips at least one bit
 *  beyond the bit stream.
 *  @param inBitStream MSB orderd bit stream which is checked for EOF.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: eof (<span class="op">in</span> <span class="type">lsbInBitStream</span>: inBitStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: eof <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> inBitStream.bytePos >= inBitStream.eofCheckPos <span class="keywd">then</span>
      <span class="keywd">if</span> inBitStream.bytePos > inBitStream.eofBytePos <span class="keywd">then</span>
        eof := TRUE;
      <span class="keywd">else</span>
        eof := inBitStream.bitPos > 8 * (inBitStream.eofBytePos - inBitStream.bytePos);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get up to ''maxLength'' bytes from ''inBitStream''.
 *  The function returns bytes from the original data. If the current byte of
 *  ''inBitStream'' is partially used, it is not considered, and the bytes are
 *  read beginning with the next byte from the original data. After the data is
 *  read, the position of ''inBitStream'' is advanced to the beginning of the
 *  next byte. A ''maxLength'' of 0 sets the position to the beginning of the
 *  next byte and returns an empty string.
 *   aBitStream := openLsbInBitStream("\2#01101011;\2#1001111;\2#1001011;\2#1101;");
 *   skipBits(aBitStream, 5);
 *   # Original data:  "\2#01101011;\2#1001111;\2#1001011;\2#1101;"
 *   #                       ^
 *   #                    current
 *   #                   position
 *   gets(aBitStream, 2)  returns "\2#1001111;\2#1001011;" (="OK")
 *  @param inBitStream LSB orderd bit stream from which the bytes are read.
 *  @param maxLength The maximum number of bytes to be read.
 *  @exception RANGE_ERROR The parameter ''maxLength'' is negative.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: gets (<span class="keywd">inout</span> <span class="type">lsbInBitStream</span>: inBitStream, <span class="op">in</span> <span class="type">integer</span>: maxLength) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: striRead <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> maxLength &lt; 0 <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      <span class="comment"># Go to the next available byte boundary</span>
      <span class="keywd">if</span> inBitStream.bitPos &lt;> 0 <span class="keywd">then</span>
        inBitStream.bytePos +:= (inBitStream.bitPos + 7) <span class="op">mdiv</span> 8;
        inBitStream.bitPos := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> maxLength &lt;> 0 <span class="keywd">then</span>
        <span class="keywd">if</span> maxLength &lt;= succ(length(inBitStream.striBuffer) - inBitStream.bytePos) <span class="keywd">then</span>
          striRead := inBitStream.striBuffer[inBitStream.bytePos fixLen maxLength];
          inBitStream.bytePos +:= maxLength;
        <span class="keywd">else</span>
          striRead := inBitStream.striBuffer[inBitStream.bytePos ..] &amp;
                      gets(inBitStream.inFile, maxLength -
                           succ(length(inBitStream.striBuffer) - inBitStream.bytePos));
          inBitStream.striBuffer := <span class="stri">""</span>;
          inBitStream.limit := 0;
          inBitStream.bytePos := 1;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      fillBuffer(inBitStream);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Type to read bitwise data starting with the most significant bit.
 *  This is used by the Huffman compression used for JPEG files.
 *  In a ''msbInBitStream'' the read direction is from
 *  MSB (most significant bit) to LSB (least significant bit).
 *  For the bit position in a byte holds: 0 = MSB, 7 = LSB.
 *)</span>
<span class="keywd">const</span> <span class="type">type</span>: msbInBitStream <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: buffer <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bitPos <span class="keywd">is</span> 64;
    <span class="keywd">var</span> <span class="type">integer</span>: bytePos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: eofBitPos <span class="keywd">is</span> 64;
    <span class="keywd">var</span> <span class="type">integer</span>: eofBytePos <span class="keywd">is</span> integer.last;
    <span class="keywd">var</span> <span class="type">integer</span>: eofCheckPos <span class="keywd">is</span> integer.last;
    <span class="keywd">var</span> <span class="type">string</span>: striBuffer <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: striBufferIncrease <span class="keywd">is</span> 4096;
    <span class="keywd">var</span> <span class="type">integer</span>: tailSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: limit <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">file</span>: inFile <span class="keywd">is</span> STD_NULL;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: show (<span class="op">in</span> <span class="type">msbInBitStream</span>: inBitStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"buffer: "</span> &lt;&amp; inBitStream.buffer radix 2);
    writeln(<span class="stri">"bitPos: "</span> &lt;&amp; inBitStream.bitPos);
    writeln(<span class="stri">"bytePos: "</span> &lt;&amp; inBitStream.bytePos);
    writeln(<span class="stri">"eofBitPos: "</span> &lt;&amp; inBitStream.eofBitPos);
    writeln(<span class="stri">"eofBytePos: "</span> &lt;&amp; inBitStream.eofBytePos);
    writeln(<span class="stri">"eofCheckPos: "</span> &lt;&amp; inBitStream.eofCheckPos);
    writeln(<span class="stri">"striBuffer: "</span> &lt;&amp; literal(inBitStream.striBuffer));
    writeln(<span class="stri">"striBufferIncrease: "</span> &lt;&amp; inBitStream.striBufferIncrease);
    writeln(<span class="stri">"tailSize: "</span> &lt;&amp; inBitStream.tailSize);
    writeln(<span class="stri">"limit: "</span> &lt;&amp; inBitStream.limit);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: fillStriBuffer (<span class="keywd">inout</span> <span class="type">msbInBitStream</span>: inBitStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    inBitStream.striBuffer := inBitStream.striBuffer[inBitStream.bytePos ..] &amp;
                            gets(inBitStream.inFile, inBitStream.striBufferIncrease);
    <span class="keywd">if</span> <span class="op">not</span> hasNext(inBitStream.inFile) <span class="keywd">then</span>
      <span class="comment"># Append "\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;" to the data.</span>
      <span class="comment"># This allows a peek of 32 bits also at the end of the data.</span>
      inBitStream.striBuffer &amp;:= <span class="stri">"\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;"</span>;
      inBitStream.tailSize +:= 8;
      inBitStream.eofBytePos := succ(length(inBitStream.striBuffer)) -
                                inBitStream.tailSize;
      inBitStream.eofCheckPos := max(1, length(inBitStream.striBuffer) -
                                 inBitStream.tailSize - 6);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    inBitStream.limit := max(0, length(inBitStream.striBuffer) - 7);
    inBitStream.bytePos := 1;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: fillBuffer (<span class="keywd">inout</span> <span class="type">msbInBitStream</span>: inBitStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> inBitStream.bytePos > inBitStream.limit <span class="keywd">then</span>
      fillStriBuffer(inBitStream);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    inBitStream.buffer := bytes2Int(inBitStream.striBuffer[inBitStream.bytePos fixLen 8], SIGNED, BE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Open an MSB bit stream from the file ''inFile'' for reading.
 *  In a ''msbInBitStream'' the read direction is from
 *  MSB (most significant bit) to LSB (least significant bit).
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">msbInBitStream</span>: openMsbInBitStream (<span class="keywd">inout</span> <span class="type">file</span>: inFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">msbInBitStream</span>: inBitStream <span class="keywd">is</span> msbInBitStream.value;
  <span class="keywd">begin</span>
    inBitStream.inFile := inFile;
    fillBuffer(inBitStream);
    <span class="comment"># show(inBitStream);</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Open an MSB bit stream from the string ''stri'' for reading.
 *  In a ''msbInBitStream'' the read direction is from
 *  MSB (most significant bit) to LSB (least significant bit).
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">msbInBitStream</span>: openMsbInBitStream (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">msbInBitStream</span>: inBitStream <span class="keywd">is</span> msbInBitStream.value;
  <span class="keywd">begin</span>
    <span class="comment"># Append "\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;" to the data.</span>
    <span class="comment"># This allows a peek of 32 bits also at the end of the data.</span>
    inBitStream.striBuffer := stri &amp; <span class="stri">"\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;\16#ff;"</span>;
    inBitStream.tailSize := 8;
    inBitStream.eofBytePos := succ(length(inBitStream.striBuffer)) -
                              inBitStream.tailSize;
    inBitStream.eofCheckPos := max(1, length(inBitStream.striBuffer) -
                               inBitStream.tailSize - 6);
    inBitStream.limit := length(inBitStream.striBuffer) - 7;
    fillBuffer(inBitStream);
    <span class="comment"># show(inBitStream);</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Close an MSB bit stream and position the underlying file at the next byte.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: close (<span class="keywd">inout</span> <span class="type">msbInBitStream</span>: inBitStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> inBitStream.inFile &lt;> STD_NULL <span class="keywd">then</span>
      <span class="keywd">if</span> inBitStream.bitPos &lt;> 64 <span class="keywd">then</span>
        inBitStream.bytePos +:= (71 - inBitStream.bitPos) <span class="op">mdiv</span> 8;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      seek(inBitStream.inFile, tell(inBitStream.inFile) -
           succ(length(inBitStream.striBuffer) -
                inBitStream.bytePos - inBitStream.tailSize));
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get one bit in MSB-First order from ''inBitStream''.
 *  The bits are read at the current byte and bit position. Afterwards
 *  byte and bit position are advanced by ''bitWidth'' bits. The read
 *  direction is from MSB (most significant bit) to LSB (least significant bit).
 *  If bits from the next byte(s) are read a byte order of big-endian
 *  is used.
 *   aBitStream := openMsbInBitStream("\2#01011100;\2#11010110;");
 *   skipBits(aBitStream, 5);
 *   # Original data:  "\2#01011100;\2#11010110;";
 *   #                          ^
 *   #                       current
 *   #                      position
 *   getBit(aBitStream)  returns  2#1
 *   # Original data:  "\2#01011100;\2#11010110;";
 *   #                          1
 *   #                       bit of
 *   #                     the result
 *   # Now aBitStream is at bytePos=1 and bitPos=6 of the original data.
 *   # Original data:  "\2#01011100;\2#11010110;";
 *   #                           ^
 *   #                        current
 *   #                       position
 *  @param inBitStream MSB orderd bit stream from which the bits are peeked.
 *  @exception RANGE_ERROR If the end of ''inBitStream'' has been reached.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getBit (<span class="keywd">inout</span> <span class="type">msbInBitStream</span>: inBitStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: resultBit <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    decr(inBitStream.bitPos);
    resultBit := (inBitStream.buffer >> inBitStream.bitPos) <span class="op">mod</span> 2;
    <span class="keywd">if</span> inBitStream.bitPos &lt;= 32 <span class="keywd">then</span>
      inBitStream.bitPos +:= 32;
      inBitStream.bytePos +:= 4;
      <span class="keywd">if</span> inBitStream.bytePos > inBitStream.limit <span class="keywd">then</span>
        fillStriBuffer(inBitStream);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      inBitStream.buffer := integer(bin64(inBitStream.buffer <span class="op">mod</span> 2 ** 32) &lt;&lt; 32 |
            bin64(inBitStream.striBuffer[inBitStream.bytePos + 4 fixLen 4], BE));
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get ''bitWidth'' bits in MSB-First order from ''inBitStream''.
 *  The bits are read at the current byte and bit position. Afterwards
 *  byte and bit position are advanced by ''bitWidth'' bits. The read
 *  direction is from MSB (most significant bit) to LSB (least significant bit).
 *  If bits from the next byte(s) are read a byte order of big-endian
 *  is used.
 *   aBitStream := openMsbInBitStream("\2#01011100;\2#11010110;");
 *   skipBits(aBitStream, 5);
 *   # Original data:  "\2#01011100;\2#11010110;";
 *   #                          ^
 *   #                       current
 *   #                      position
 *   getBits(aBitStream, 5)  returns  2#10011
 *   # Original data:  "\2#01011100;\2#11010110;";
 *   #                          100    11
 *   #                   higher bits  lower bits
 *   #                    of result    of result
 *   # Now aBitStream is at bytePos=2 and bitPos=2 of the original data.
 *   # Original data:  "\2#01011100;\2#11010110;";
 *   #                                   ^
 *   #                                current
 *   #                                position
 *  @param inBitStream MSB orderd bit stream from which the bits are peeked.
 *  @param bitWidth Number of bits requested (between 1 and 32).
 *  @exception RANGE_ERROR If the end of ''inBitStream'' has been reached.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getBits (<span class="keywd">inout</span> <span class="type">msbInBitStream</span>: inBitStream, <span class="op">in</span> <span class="type">integer</span>: bitWidth) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: resultBits <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: bytePosDelta <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    inBitStream.bitPos -:= bitWidth;
    resultBits := (inBitStream.buffer >> inBitStream.bitPos) <span class="op">mod</span> (1 &lt;&lt; bitWidth);
    <span class="keywd">if</span> inBitStream.bitPos &lt;= 32 <span class="keywd">then</span>
      bytePosDelta := 7 - pred(inBitStream.bitPos) <span class="op">mdiv</span> 8;
      inBitStream.bitPos +:= 8 * bytePosDelta;
      inBitStream.bytePos +:= bytePosDelta;
      <span class="keywd">if</span> inBitStream.bytePos > inBitStream.limit <span class="keywd">then</span>
        fillStriBuffer(inBitStream);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      inBitStream.buffer := bytes2Int(inBitStream.striBuffer[inBitStream.bytePos fixLen 8], SIGNED, BE);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Peek ''bitWidth'' bits in MSB-First order from ''inBitStream''.
 *  The bits are read at the current byte and bit position. Byte
 *  and bit position remain unchanged. The read direction is from
 *  MSB (most significant bit) to LSB (least significant bit).
 *  If bits from the next byte(s) are read a byte order of big-endian
 *  is used.
 *   aBitStream := openMsbInBitStream("\2#01011100;\2#11010110;");
 *   skipBits(aBitStream, 5);
 *   # Original data:  "\2#01011100;\2#11010110;";
 *   #                          ^
 *   #                       current
 *   #                      position
 *   peekBits(aBitStream, 6)  returns  2#100110
 *   # Original data:  "\2#01011100;\2#11010110;";
 *   #                          100    110
 *   #                   higher bits  lower bits
 *   #                    of result    of result
 *   # BytePos and bitPos of aBitStream have not changed.
 *  @param inBitStream MSB orderd bit stream from which the bits are read.
 *  @param bitWidth Number of bits requested (between 1 and 32).
 *  @exception RANGE_ERROR If the end of ''inBitStream'' has been reached.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: peekBits (<span class="keywd">inout</span> <span class="type">msbInBitStream</span>: inBitStream, <span class="op">in</span> <span class="type">integer</span>: bitWidth) <span class="keywd">is</span>
  <span class="keywd">return</span> (inBitStream.buffer >> (inBitStream.bitPos - bitWidth)) <span class="op">mod</span> (1 &lt;&lt; bitWidth);


<span class="comment">(**
 *  Advance the bit position of ''inBitStream'' by ''bitWidth'' bits.
 *   aBitStream := openMsbInBitStream("\2#01101011;\2#11001110;");
 *   # Now aBitStream has bytePos=1 and bitPos=0 of the original data.
 *   # Original data:  "\2#01101011;\2#11001110;"
 *   #                     ^
 *   #                  current
 *   #                 position
 *   skipBits(aBitStream, 5);
 *   # Now aBitStream is at bytePos=1 and bitPos=5 of the original data.
 *   # Original data:  "\2#01101011;\2#11001110;"
 *   #                          ^
 *   #                       current
 *   #                      position
 *  @param inBitStream MSB orderd bit stream from which the bits are skipped.
 *  @param bitWidth Number of bits to be skipped (between 1 and 32).
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: skipBits (<span class="keywd">inout</span> <span class="type">msbInBitStream</span>: inBitStream, <span class="op">in</span> <span class="type">integer</span>: bitWidth) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: bytePosDelta <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    inBitStream.bitPos -:= bitWidth;
    <span class="keywd">if</span> inBitStream.bitPos &lt;= 32 <span class="keywd">then</span>
      bytePosDelta := 7 - pred(inBitStream.bitPos) <span class="op">mdiv</span> 8;
      inBitStream.bitPos +:= 8 * bytePosDelta;
      inBitStream.bytePos +:= bytePosDelta;
      <span class="keywd">if</span> inBitStream.bytePos > inBitStream.limit <span class="keywd">then</span>
        fillStriBuffer(inBitStream);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> bytePosDelta = 4 <span class="keywd">then</span>
        inBitStream.buffer := integer(bin64(inBitStream.buffer <span class="op">mod</span> 2 ** 32) &lt;&lt; 32 |
            bin64(inBitStream.striBuffer[inBitStream.bytePos + 4 fixLen 4], BE));
      <span class="keywd">else</span>
        inBitStream.buffer := bytes2Int(inBitStream.striBuffer[inBitStream.bytePos fixLen 8], SIGNED, BE);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine if at least one bit beyond the bit stream has been read.
 *  The EOF condition is also met if skipBits() skips at least one bit
 *  beyond the bit stream.
 *  @param inBitStream MSB orderd bit stream which is checked for EOF.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: eof (<span class="op">in</span> <span class="type">msbInBitStream</span>: inBitStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: eof <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> inBitStream.bytePos >= inBitStream.eofCheckPos <span class="keywd">then</span>
      <span class="keywd">if</span> inBitStream.bytePos > inBitStream.eofBytePos <span class="keywd">then</span>
        eof := TRUE;
      <span class="keywd">else</span>
        eof := inBitStream.bitPos &lt; 64 - 8 * (inBitStream.eofBytePos - inBitStream.bytePos);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get up to ''maxLength'' bytes from ''inBitStream''.
 *  The function returns bytes from the original data. If the current byte of
 *  ''inBitStream'' is partially used, it is not considered, and the bytes are
 *  read beginning with the next byte from the original data. After the data is
 *  read, the position of ''inBitStream'' is advanced to the beginning of the
 *  next byte. A ''maxLength'' of 0 sets the position to the beginning of the
 *  next byte and returns an empty string.
 *   aBitStream := openMsbInBitStream("\2#01101011;\2#1001111;\2#1001011;\2#1101;");
 *   skipBits(aBitStream, 5);
 *   # Original data:  "\2#01101011;\2#1001111;\2#1001011;\2#1101;"
 *   #                       ^
 *   #                    current
 *   #                   position
 *   gets(aBitStream, 2)  returns "\2#1001111;\2#1001011;" (="OK")
 *  @param inBitStream MSB orderd bit stream from which the bytes are read.
 *  @param maxLength The maximum number of bytes to be read.
 *  @exception RANGE_ERROR The parameter ''maxLength'' is negative.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: gets (<span class="keywd">inout</span> <span class="type">msbInBitStream</span>: inBitStream, <span class="op">in</span> <span class="type">integer</span>: maxLength) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: striRead <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> maxLength &lt; 0 <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      <span class="comment"># Go to the next available byte boundary</span>
      <span class="keywd">if</span> inBitStream.bitPos &lt;> 64 <span class="keywd">then</span>
        inBitStream.bytePos +:= (71 - inBitStream.bitPos) <span class="op">mdiv</span> 8;
        inBitStream.bitPos := 64;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> maxLength &lt;> 0 <span class="keywd">then</span>
        <span class="keywd">if</span> maxLength &lt;= succ(length(inBitStream.striBuffer) - inBitStream.bytePos) <span class="keywd">then</span>
          striRead := inBitStream.striBuffer[inBitStream.bytePos fixLen maxLength];
          inBitStream.bytePos +:= maxLength;
        <span class="keywd">else</span>
          striRead := inBitStream.striBuffer[inBitStream.bytePos ..] &amp;
                      gets(inBitStream.inFile, maxLength -
                           succ(length(inBitStream.striBuffer) - inBitStream.bytePos));
          inBitStream.striBuffer := <span class="stri">""</span>;
          inBitStream.limit := 0;
          inBitStream.bytePos := 1;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      fillBuffer(inBitStream);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Type to write bitwise data starting with the least significant bit.
 *  In a ''lsbOutBitStream'' the write direction is from
 *  LSB (least significant bit) to MSB (most significant bit).
 *  For the bit position in a byte (bitPos) holds: 0 = LSB, 7 = MSB.
 *  The bits are stored in a string of bytes. The byte string can
 *  be obtained with the function getBytes(). The function flush()
 *  can be used to add a partially filled byte to the byte string.
 *  This bit encoding is used by the Huffman compression (as part of
 *  the deflate compression) used for ZIP and GZIP files. It is also
 *  used by the Lempel-Ziv-Welch compression used for GIF files.
 *)</span>
<span class="keywd">const</span> <span class="type">type</span>: lsbOutBitStream <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: buffer <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bitPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: byteString <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="comment">(**
 *  Append one bit in LSB-First order to ''outBitStream''.
 *  The append direction is from LSB (least significant bit) to
 *  MSB (most significant bit).
 *   # Stream data:   "\2#0101011;"  and  bitPos = 7
 *   #                   ^
 *   #                current
 *   #               position
 *   putBit(aBitStream, 2#1)
 *   # Stream data:  "\2#10101011;"  and  bitPos = 0
 *   #                   1
 *   #                appended
 *   #                  bit
 *   putBit(aBitStream, 2#1)
 *   # Stream data:  "\2#10101011;\2#1;"  and  bitPos = 1
 *   #                               1
 *   #                            appended
 *   #                              bit
 *  @param outBitStream Bit stream to which the bit is appended.
 *  @param bit Bit to be appended to ''outBitStream''.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: putBit (<span class="keywd">inout</span> <span class="type">lsbOutBitStream</span>: outBitStream, <span class="op">in</span> <span class="type">integer</span>: bit) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    outBitStream.buffer +:= bit &lt;&lt; outBitStream.bitPos;
    incr(outBitStream.bitPos);
    <span class="keywd">if</span> outBitStream.bitPos = 8 <span class="keywd">then</span>
      outBitStream.byteString &amp;:= char(outBitStream.buffer);
      outBitStream.bitPos := 0;
      outBitStream.buffer := 0;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Append ''bitWidth'' bits in LSB-First order to ''outBitStream''.
 *  The append direction is from LSB (least significant bit) to
 *  MSB (most significant bit). If necessary additional bytes are
 *  added to ''outBitStream''.
 *   # Stream data:     "\2#01011;"  and  bitPos = 5
 *   #                     ^
 *   #                  current
 *   #                 position
 *   putBits(aBitStream, 2#10011, 5);
 *   # Stream data:  "\2#01101011;\2#10;"  and  bitPos = 2
 *   #                   011         10
 *   #                appended    appended
 *   #               lower bits  higher bits
 *  @param outBitStream Bit stream to which the bits are appended.
 *  @param bits Bits to be appended to ''outBitStream''.
 *  @param bitWidth Number of bits to be appended (width of ''bits'').
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: putBits (<span class="keywd">inout</span> <span class="type">lsbOutBitStream</span>: outBitStream, <span class="op">in</span> <span class="type">integer</span>: bits,
    <span class="op">in</span> <span class="type">integer</span>: bitWidth) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    outBitStream.buffer +:= bits &lt;&lt; outBitStream.bitPos;
    outBitStream.bitPos +:= bitWidth;
    <span class="keywd">while</span> outBitStream.bitPos >= 8 <span class="keywd">do</span>
      outBitStream.byteString &amp;:= char(outBitStream.buffer <span class="op">mod</span> 256);
      outBitStream.bitPos -:= 8;
      outBitStream.buffer >>:= 8;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Append the LSB bit stream ''extension'' to ''outBitStream''.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">lsbOutBitStream</span>: outBitStream) &amp;:= (<span class="op">in</span> <span class="type">lsbOutBitStream</span>: extension) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> ch <span class="keywd">range</span> extension.byteString <span class="keywd">do</span>
      putBits(outBitStream, ord(ch), 8);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    putBits(outBitStream, extension.buffer, extension.bitPos);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Obtain the length of the given ''outBitStream''.
 *  The bit stream length is measured in bits.
 *  @param outBitStream Bit stream from which the length is obtained.
 *  @return the length of the bit stream.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: length (<span class="op">in</span> <span class="type">lsbOutBitStream</span>: outBitStream) <span class="keywd">is</span>
  <span class="keywd">return</span> length(outBitStream.byteString) * 8 + outBitStream.bitPos;


<span class="comment">(**
 *  Truncate ''outBitStream'' to the given ''length''.
 *  If the bit stream previously was larger than ''length'', the extra data is lost.
 *  If the bit stream previously was shorter, it is extended, and the extended
 *  part is filled with zero bits.
 *  @param outBitStream Bit stream to be truncated.
 *  @param length Requested length of ''outBitStream'' in bits.
 *  @exception RANGE_ERROR The requested length is negative.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: truncate (<span class="keywd">inout</span> <span class="type">lsbOutBitStream</span>: outBitStream, <span class="op">in</span> <span class="type">integer</span>: length) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: bytePos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bitPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length &lt; 0 <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      bytePos := length <span class="op">mdiv</span> 8;
      bitPos := length <span class="op">mod</span> 8;
      <span class="keywd">if</span> bytePos &lt; length(outBitStream.byteString) <span class="keywd">then</span>
        outBitStream.buffer := ord(outBitStream.byteString[succ(bytePos)]) <span class="op">mod</span> 2 ** bitPos;
        outBitStream.byteString := outBitStream.byteString[.. bytePos];
      <span class="keywd">elsif</span> bytePos = length(outBitStream.byteString) <span class="keywd">then</span>
        <span class="keywd">if</span> bitPos &lt; outBitStream.bitPos <span class="keywd">then</span>
          outBitStream.buffer := outBitStream.buffer <span class="op">mod</span> 2 ** bitPos;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        outBitStream.byteString &amp;:= char(outBitStream.buffer);
        outBitStream.byteString &amp;:= <span class="stri">"\0;"</span> <span class="op">mult</span> bytePos - length(outBitStream.byteString);
        outBitStream.buffer := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      outBitStream.bitPos := bitPos;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Complete a partially filled byte and add it to the byte string.
 *  If ''outBitStream'' has a partially filled byte it is filled with zero
 *  bits and added to the byte string. If ''outBitStream'' has not a
 *  partially filled byte nothing is done.
 *  @param outBitStream Bit stream where the partially filled byte is added.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: flush (<span class="keywd">inout</span> <span class="type">lsbOutBitStream</span>: outBitStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> outBitStream.bitPos &lt;> 0 <span class="keywd">then</span>
      outBitStream.byteString &amp;:= char(outBitStream.buffer);
      outBitStream.bitPos := 0;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    outBitStream.buffer := 0;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Obtain the byte string created from the bits written to ''outBitStream''.
 *  The returned byte string is removed from ''outBitStream''.
 *  A partially filled byte is not part of the returned byte string.
 *  The function flush() can be called in advance to add a
 *  partially filled byte to the byte string.
 *  @param outBitStream Bit stream from which the byte string is obtained.
 *  @return a string of completely filled bytes from ''outBitStream''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getBytes (<span class="keywd">inout</span> <span class="type">lsbOutBitStream</span>: outBitStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: bytes <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    bytes := outBitStream.byteString;
    outBitStream.byteString := <span class="stri">""</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Add the given string ''stri'' to the byte string of ''outBitStream''.
 *  The ''outBitStream'' is flushed before adding ''stri''.
 *  @param outBitStream Bit stream to which ''stri'' is added.
 *  @param stri String to be added to ''outBitStream''.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: write (<span class="keywd">inout</span> <span class="type">lsbOutBitStream</span>: outBitStream, <span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    flush(outBitStream);
    outBitStream.byteString &amp;:= stri;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Type to write bitwise data starting with the most significant bit.
 *  In a ''msbOutBitStream'' the write direction is from
 *  MSB (most significant bit) to LSB (least significant bit).
 *  For the bit position in a byte (bitPos) holds: 0 = MSB, 7 = LSB.
 *  The bits are stored in a string of bytes. The byte string can
 *  be obtained with the function getBytes(). The function flush()
 *  can be used to add a partially filled byte to the byte string.
 *  This bit encoding is used by the Huffman compression used for
 *  JPEG files.
 *)</span>
<span class="keywd">const</span> <span class="type">type</span>: msbOutBitStream <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: buffer <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bitPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: byteString <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="comment">(**
 *  Append one bit in MSB-First order to ''outBitStream''.
 *  The append direction is from MSB (most significant bit) to
 *  LSB (least significant bit).
 *   # Stream data:  "\2#01011100;"  and  bitPos = 7
 *   #                          ^
 *   #                       current
 *   #                       position
 *   putBit(aBitStream, 2#1)
 *   # Stream data:  "\2#01011101;"  and  bitPos = 0
 *   #                          1
 *   #                       appended
 *   #                         bit
 *   putBit(aBitStream, 2#1)
 *   # Stream data:  "\2#01011101;\2#10000000;"  and  bitPos = 1
 *   #                               1
 *   #                            appended
 *   #                              bit
 *  @param outBitStream Bit stream to which the bit is appended.
 *  @param bit Bit to be appended to ''outBitStream''.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: putBit (<span class="keywd">inout</span> <span class="type">msbOutBitStream</span>: outBitStream, <span class="op">in</span> <span class="type">integer</span>: bit) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    outBitStream.buffer &lt;&lt;:= 1;
    outBitStream.buffer +:= bit;
    incr(outBitStream.bitPos);
    <span class="keywd">if</span> outBitStream.bitPos = 8 <span class="keywd">then</span>
      outBitStream.byteString &amp;:= char(outBitStream.buffer);
      outBitStream.bitPos := 0;
      outBitStream.buffer := 0;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Append ''bitWidth'' bits in MSB-First order to ''outBitStream''.
 *  The append direction is from MSB (most significant bit) to
 *  LSB (least significant bit). If necessary additional bytes are
 *  added to ''outBitStream''.
 *   # Stream data:  "\2#01011000;"  and  bitPos = 5
 *   #                        ^
 *   #                     current
 *   #                    position
 *   putBits(aBitStream, 2#10011, 5);
 *   # Stream data:  "\2#01011100;\2#11000000;"  and  bitPos = 2
 *   #                        100    11
 *   #                    appended  appended
 *   #                 higher bits  lower bits
 *  @param outBitStream Bit stream to which the bits are appended.
 *  @param bits Bits to be appended to ''outBitStream''.
 *  @param bitWidth Number of bits to be appended (width of ''bits'').
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: putBits (<span class="keywd">inout</span> <span class="type">msbOutBitStream</span>: outBitStream, <span class="op">in</span> <span class="type">integer</span>: bits,
    <span class="op">in</span> <span class="type">integer</span>: bitWidth) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: bitShift <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    outBitStream.buffer &lt;&lt;:= bitWidth;
    outBitStream.buffer +:= bits;
    outBitStream.bitPos +:= bitWidth;
    <span class="keywd">if</span> outBitStream.bitPos >= 8 <span class="keywd">then</span>
      bitShift := outBitStream.bitPos;
      <span class="keywd">repeat</span>
        bitShift -:= 8;
        outBitStream.byteString &amp;:= char((outBitStream.buffer >> bitShift) <span class="op">mod</span> 256);
      <span class="keywd">until</span> bitShift &lt; 8;
      outBitStream.bitPos := bitShift;
      outBitStream.buffer := outBitStream.buffer <span class="op">mod</span> 2 ** bitShift;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Append the MSB bit stream ''extension'' to ''outBitStream''.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">msbOutBitStream</span>: outBitStream) &amp;:= (<span class="op">in</span> <span class="type">msbOutBitStream</span>: extension) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> ch <span class="keywd">range</span> extension.byteString <span class="keywd">do</span>
      putBits(outBitStream, ord(ch), 8);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    putBits(outBitStream, extension.buffer, extension.bitPos);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Obtain the length of the given ''outBitStream''.
 *  The bit stream length is measured in bits.
 *  @param outBitStream Bit stream from which the length is obtained.
 *  @return the length of the bit stream.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: length (<span class="op">in</span> <span class="type">msbOutBitStream</span>: outBitStream) <span class="keywd">is</span>
  <span class="keywd">return</span> length(outBitStream.byteString) * 8 + outBitStream.bitPos;


<span class="comment">(**
 *  Truncate ''outBitStream'' to the given ''length''.
 *  If the bit stream previously was larger than ''length'', the extra data is lost.
 *  If the bit stream previously was shorter, it is extended, and the extended
 *  part is filled with zero bits.
 *  @param outBitStream Bit stream to be truncated.
 *  @param length Requested length of ''outBitStream'' in bits.
 *  @exception RANGE_ERROR The requested length is negative.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: truncate (<span class="keywd">inout</span> <span class="type">msbOutBitStream</span>: outBitStream, <span class="op">in</span> <span class="type">integer</span>: length) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: bytePos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bitPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length &lt; 0 <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      bytePos := length <span class="op">mdiv</span> 8;
      bitPos := length <span class="op">mod</span> 8;
      <span class="keywd">if</span> bytePos &lt; length(outBitStream.byteString) <span class="keywd">then</span>
        outBitStream.buffer := ord(outBitStream.byteString[succ(bytePos)]) >> (8 - bitPos);
        outBitStream.byteString := outBitStream.byteString[.. bytePos];
      <span class="keywd">elsif</span> bytePos = length(outBitStream.byteString) <span class="keywd">then</span>
        <span class="keywd">if</span> bitPos &lt; outBitStream.bitPos <span class="keywd">then</span>
          outBitStream.buffer >>:= outBitStream.bitPos - bitPos;
        <span class="keywd">elsif</span> bitPos > outBitStream.bitPos <span class="keywd">then</span>
          outBitStream.buffer &lt;&lt;:= bitPos - outBitStream.bitPos;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        outBitStream.byteString &amp;:= char(outBitStream.buffer &lt;&lt; (8 - outBitStream.bitPos));
        outBitStream.byteString &amp;:= <span class="stri">"\0;"</span> <span class="op">mult</span> bytePos - length(outBitStream.byteString);
        outBitStream.buffer := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      outBitStream.bitPos := bitPos;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Complete a partially filled byte and add it to the byte string.
 *  If ''outBitStream'' has a partially filled byte it is filled with zero
 *  bits and added to the byte string. If ''outBitStream'' has not a
 *  partially filled byte nothing is done.
 *  @param outBitStream Bit stream where the partially filled byte is added.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: flush (<span class="keywd">inout</span> <span class="type">msbOutBitStream</span>: outBitStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> outBitStream.bitPos &lt;> 0 <span class="keywd">then</span>
      outBitStream.byteString &amp;:= char(outBitStream.buffer &lt;&lt; (8 - outBitStream.bitPos));
      outBitStream.bitPos := 0;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    outBitStream.buffer := 0;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Obtain the byte string created from the bits written to ''outBitStream''.
 *  The returned byte string is removed from ''outBitStream''.
 *  A partially filled byte is not part of the returned byte string.
 *  The function flush() can be called in advance to add a
 *  partially filled byte to the byte string.
 *  @param outBitStream Bit stream from which the byte string is obtained.
 *  @return a string of completely filled bytes from ''outBitStream''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getBytes (<span class="keywd">inout</span> <span class="type">msbOutBitStream</span>: outBitStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: bytes <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    bytes := outBitStream.byteString;
    outBitStream.byteString := <span class="stri">""</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Add the given string ''stri'' to the byte string of ''outBitStream''.
 *  The ''outBitStream'' is flushed before adding ''stri''.
 *  @param outBitStream Bit stream to which ''stri'' is added.
 *  @param stri String to be added to ''outBitStream''.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: write (<span class="keywd">inout</span> <span class="type">msbOutBitStream</span>: outBitStream, <span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    flush(outBitStream);
    outBitStream.byteString &amp;:= stri;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Type describing a stream of bits that is read backwards.
 *  The bits are read from the most significant bit of the last byte
 *  to the least significant bit of the first byte.
 *)</span>
<span class="keywd">const</span> <span class="type">type</span>: reverseBitStream <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">string</span>: data <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: offset <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="comment">(**
 *  Create a reverse bit stream from ''length'' bytes read from ''inFile''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">reverseBitStream</span>: reverseBitStream (<span class="keywd">inout</span> <span class="type">file</span>: inFile, <span class="op">in</span> <span class="type">integer</span>: length) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">reverseBitStream</span>: inBitStream <span class="keywd">is</span> reverseBitStream.value;
  <span class="keywd">begin</span>
    inBitStream.data := gets(inFile, length);
    inBitStream.offset := pred(length(inBitStream.data) * 8);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Return the number of bits still present in the given reverse ''inBitStream''.
 *  Note that it is possible to read beyond the end fo the stream. In this
 *  case negative values are returned.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: bitsStillInStream (<span class="op">in</span> <span class="type">reverseBitStream</span>: inBitStream) <span class="keywd">is</span>
    <span class="keywd">return</span> succ(inBitStream.offset);


<span class="comment">(**
 *  Return the number of bits read from the given reverse ''inBitStream''.
 *  Note that it is possible to read beyond the end fo the stream.
 *  So the function might return more bits than actually present.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: bitsRead (<span class="op">in</span> <span class="type">reverseBitStream</span>: inBitStream) <span class="keywd">is</span>
    <span class="keywd">return</span> pred(length(inBitStream.data) * 8) - inBitStream.offset;


<span class="comment">(**
 *  Get ''bitWidth'' bits from the given reverse ''inBitStream''.
 *  The bits are read from the most significant bit of the last byte
 *  to the least significant bit of the first byte.
 *  It is possible to read beyond the end of the stream.
 *  In this case the stream is assumed to consist of zero bytes.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getBits (<span class="keywd">inout</span> <span class="type">reverseBitStream</span>: inBitStream, <span class="op">in</span> <span class="type">integer</span>: bitWidth) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: resultBits <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: indexOfHighestByte <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bitsLeftInHighestByte <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: keepBitsInHighestByte <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: valueFromHighestByte <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: spanningFullBytes <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bitsFromLowestByte <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: indexOfLowestByte <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: startIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> bitWidth &lt;> 0 <span class="keywd">then</span>
      <span class="keywd">if</span> inBitStream.offset >= 0 <span class="keywd">then</span>
        indexOfHighestByte    := succ(inBitStream.offset <span class="op">mdiv</span> 8);
        bitsLeftInHighestByte := succ(inBitStream.offset <span class="op">mod</span> 8);

        <span class="keywd">if</span> bitWidth &lt; bitsLeftInHighestByte <span class="keywd">then</span>
          <span class="comment"># Can satisfy with bits from the highest byte</span>
          keepBitsInHighestByte := bitsLeftInHighestByte - bitWidth;  <span class="comment"># Number of bits that are preserved.</span>
          resultBits := (ord(inBitStream.data[indexOfHighestByte]) >> keepBitsInHighestByte) <span class="op">mod</span> (1 &lt;&lt; bitWidth);
        <span class="keywd">else</span>
          <span class="comment"># take bits from highest byte</span>
          valueFromHighestByte := ord(inBitStream.data[indexOfHighestByte]) <span class="op">mod</span> (1 &lt;&lt; bitsLeftInHighestByte);
          <span class="keywd">if</span> bitWidth = bitsLeftInHighestByte <span class="keywd">then</span>
            <span class="comment"># Can satisfy with bits from the highest byte</span>
            resultBits := valueFromHighestByte;
          <span class="keywd">else</span>
            spanningFullBytes  := (bitWidth - bitsLeftInHighestByte) <span class="op">mdiv</span> 8;
            bitsFromLowestByte := (bitWidth - bitsLeftInHighestByte) <span class="op">mod</span> 8;

            indexOfLowestByte := pred(indexOfHighestByte - spanningFullBytes);
            <span class="keywd">if</span> indexOfLowestByte >= 1 <span class="keywd">then</span>
              resultBits := ord(inBitStream.data[indexOfLowestByte]) >> (8 - bitsFromLowestByte);
            <span class="keywd">else</span>
              <span class="comment"># We assume that below the offset 0 there are zero bytes.</span>
              startIndex := -indexOfLowestByte;
            <span class="keywd">end</span> <span class="keywd">if</span>;

            <span class="keywd">for</span> index <span class="keywd">range</span> startIndex <span class="keywd">to</span> pred(spanningFullBytes) <span class="keywd">do</span>
              resultBits +:= ord(inBitStream.data[succ(indexOfLowestByte) + index]) &lt;&lt; (index * 8 + bitsFromLowestByte);
            <span class="keywd">end</span> <span class="keywd">for</span>;

            resultBits +:= valueFromHighestByte &lt;&lt; (spanningFullBytes * 8 + bitsFromLowestByte);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="comment"># Update offset even if we are beyond the end of the stream.</span>
      inBitStream.offset -:= bitWidth;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
