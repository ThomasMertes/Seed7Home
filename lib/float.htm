<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  float.s7i     Floating point support library                    *)</span>
<span class="comment">(*  Copyright (C) 1993, 1994, 2005, 2008  Thomas Mertes             *)</span>
<span class="comment">(*                2011 - 2016, 2018, 2019  Thomas Mertes            *)</span>
<span class="comment">(*                2021 - 2024  Thomas Mertes                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/enable_io.htm">enable_io.s7i</a>"</span>;


<span class="comment">(**
 *  Double precision floating point numbers.
 *)</span>
<span class="keywd">const</span> <span class="type">type</span>: float <span class="keywd">is</span>          subtype object;


$ <span class="keywd">system</span> <span class="stri">"float"</span> <span class="keywd">is</span> float;

<span class="keywd">const</span> <span class="type">proc</span>: destroy (<span class="keywd">ref</span> <span class="type">float</span>: aValue)                        <span class="keywd">is</span> action <span class="stri">"GEN_DESTR"</span>;
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">ref</span> <span class="type">float</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">float</span>: source)          <span class="keywd">is</span> action <span class="stri">"FLT_CREATE"</span>;
IN_PARAM_IS_VALUE(float);


<span class="comment">(**
 *  Default value of ''float'' (0.0).
 *)</span>
<span class="keywd">const</span> <span class="type">float</span>: (attr float) . value <span class="keywd">is</span> 0.0;


<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">float</span>: dest) := (<span class="op">in</span> <span class="type">float</span>: source)          <span class="keywd">is</span> action <span class="stri">"FLT_CPY"</span>;


<span class="comment">(**
 *  Plus sign for ''float'' numbers.
 *  @return its operand unchanged.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: + (<span class="op">in</span> <span class="type">float</span>: number)                         <span class="keywd">is</span> action <span class="stri">"FLT_PLUS"</span>;


<span class="comment">(**
 *  Minus sign, negate a ''float'' number.
 *  @return the negated value of the number.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: - (<span class="op">in</span> <span class="type">float</span>: number)                         <span class="keywd">is</span> action <span class="stri">"FLT_NEGATE"</span>;


<span class="comment">(**
 *  Add two ''float'' numbers.
 *  @return the sum of the two numbers.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: (<span class="op">in</span> <span class="type">float</span>: summand1) + (<span class="op">in</span> <span class="type">float</span>: summand2)  <span class="keywd">is</span> action <span class="stri">"FLT_ADD"</span>;


<span class="comment">(**
 *  Compute the subtraction of two ''float'' numbers.
 *  @return the difference of the two numbers.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: (<span class="op">in</span> <span class="type">float</span>: minuend) - (<span class="op">in</span> <span class="type">float</span>: subtrahend) <span class="keywd">is</span> action <span class="stri">"FLT_SBTR"</span>;


<span class="comment">(**
 *  Multiply two ''float'' numbers.
 *  @return the product of the two numbers.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: (<span class="op">in</span> <span class="type">float</span>: factor1) * (<span class="op">in</span> <span class="type">float</span>: factor2)    <span class="keywd">is</span> action <span class="stri">"FLT_MULT"</span>;


<span class="comment">(**
 *  Compute the division of two ''float'' numbers.
 *   A / 0.0    returns  Infinity  for A > 0.0
 *   A / 0.0    returns -Infinity  for A &lt; 0.0
 *   0.0 / 0.0  returns NaN
 *  @return the quotient of the division.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: (<span class="op">in</span> <span class="type">float</span>: dividend) / (<span class="op">in</span> <span class="type">float</span>: divisor)   <span class="keywd">is</span> action <span class="stri">"FLT_DIV"</span>;


<span class="comment">(**
 *  Compute the floating-point remainder of a division.
 *  The remainder has the same sign as the dividend.
 *  The remainder is dividend - float(trunc(dividend / divisor)) * divisor
 *  The remainder is computed without a conversion to integer.
 *    A        rem NaN       returns NaN
 *    NaN      rem B         returns NaN
 *    A        rem 0.0       returns NaN
 *    Infinity rem B         returns NaN
 *   -Infinity rem B         returns NaN
 *    0.0      rem B         returns 0.0  for B &lt;> 0.0
 *    A        rem Infinity  returns A
 *  @return the floating-point remainder of the division.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: (<span class="op">in</span> <span class="type">float</span>: dividend) <span class="op">rem</span> (<span class="op">in</span> <span class="type">float</span>: divisor) <span class="keywd">is</span> action <span class="stri">"FLT_REM"</span>;


<span class="comment">(**
 *  Compute the floating-point modulo of a division.
 *  The modulo has the same sign as the divisor.
 *  The modulo is dividend - floor(dividend / divisor) * divisor
 *    A        mod  NaN       returns  NaN
 *    NaN      mod  B         returns  NaN
 *    A        mod  0.0       returns  NaN
 *    Infinity mod  B         returns  NaN
 *   -Infinity mod  B         returns  NaN
 *    0.0      mod  B         returns  0.0         for B &lt;> 0.0
 *    A        mod  Infinity  returns  A           for A > 0
 *    A        mod  Infinity  returns  Infinity    for A &lt; 0
 *    A        mod -Infinity  returns  A           for A &lt; 0
 *    A        mod -Infinity  returns -Infinity    for A > 0
 *  @return the floating-point modulo of the division.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: (<span class="op">in</span> <span class="type">float</span>: dividend) <span class="op">mod</span> (<span class="op">in</span> <span class="type">float</span>: divisor) <span class="keywd">is</span> action <span class="stri">"FLT_MOD"</span>;


<span class="comment">(**
 *  Compute the exponentiation of a float ''base'' with an [[integer]] ''exponent''.
 *     A    ** 0  returns 1.0
 *     NaN  ** 0  returns 1.0
 *     NaN  ** B  returns NaN              for B &lt;> 0
 *     0.0  ** B  returns 0.0              for B > 0
 *     0.0  ** 0  returns 1.0
 *     0.0  ** B  returns Infinity         for B &lt; 0
 *   (-0.0) ** B  returns -Infinity        for B &lt; 0 and odd(B)
 *     A    ** B  returns 1.0 / A ** (-B)  for B &lt; 0
 *  @return the result of the exponentiation.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: (<span class="op">in</span> <span class="type">float</span>: base) ** (<span class="op">in</span> <span class="type">integer</span>: exponent)   <span class="keywd">is</span> action <span class="stri">"FLT_IPOW"</span>;


<span class="comment">(**
 *  Compute the exponentiation of a float ''base'' with a float ''exponent''.
 *     A    ** B    returns NaN        for A &lt; 0.0 and B is not integer
 *     A    ** 0.0  returns 1.0
 *     NaN  ** 0.0  returns 1.0
 *     NaN  ** B    returns NaN        for B &lt;> 0.0
 *     0.0  ** B    returns 0.0        for B > 0.0
 *     0.0  ** 0.0  returns 1.0
 *     0.0  ** B    returns Infinity   for B &lt; 0.0
 *   (-0.0) ** B    returns -Infinity  for B &lt; 0.0 and odd(B)
 *     1.0  ** B    returns 1.0
 *     1.0  ** NaN  returns 1.0
 *     A    ** NaN  returns NaN        for A &lt;> 1.0
 *  @return the result of the exponentiation.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: (<span class="op">in</span> <span class="type">float</span>: base) ** (<span class="op">in</span> <span class="type">float</span>: exponent)     <span class="keywd">is</span> action <span class="stri">"FLT_POW"</span>;


<span class="comment">(**
 *  Multiply ''number'' by 2 raised to the power of ''exponent''.
 *  In other words: A &lt;&lt; B is equivalent to A * 2.0 ** B
 *  If the result underflows zero is returned.
 *  If the result overflows Infinity or -Infinity is returned,
 *  depending on the sign of ''number''.
 *  If the argument ''number'' is a [[#NaN|NaN]], Infinity or -Infinity the
 *  unchanged argument is returned.
 *  @return number * 2.0 ** exponent
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: (<span class="op">in</span> <span class="type">float</span>: number) &lt;&lt; (<span class="op">in</span> <span class="type">integer</span>: exponent) <span class="keywd">is</span> action <span class="stri">"FLT_LSHIFT"</span>;


<span class="comment">(**
 *  Divide ''number'' by 2 raised to the power of ''exponent''.
 *  In other words: A >> B is equivalent to A / 2.0 ** B
 *  If the result underflows zero is returned.
 *  If the result overflows Infinity or -Infinity is returned,
 *  depending on the sign of ''number''.
 *  If the argument ''number'' is a [[#NaN|NaN]], Infinity or -Infinity the
 *  unchanged argument is returned.
 *  @return number / 2.0 ** exponent
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: (<span class="op">in</span> <span class="type">float</span>: number) >> (<span class="op">in</span> <span class="type">integer</span>: exponent) <span class="keywd">is</span> action <span class="stri">"FLT_RSHIFT"</span>;


<span class="comment">(**
 *  Increment a float ''number'' by a ''delta''.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">float</span>: number) +:= (<span class="op">in</span> <span class="type">float</span>: delta)        <span class="keywd">is</span> action <span class="stri">"FLT_ADD_ASSIGN"</span>;


<span class="comment">(**
 *  Decrement a float ''number'' by a ''delta''.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">float</span>: number) -:= (<span class="op">in</span> <span class="type">float</span>: delta)        <span class="keywd">is</span> action <span class="stri">"FLT_SBTR_ASSIGN"</span>;


<span class="comment">(**
 *  Multiply a float ''number'' by a ''factor'' and assign the result back to ''number''.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">float</span>: number) *:= (<span class="op">in</span> <span class="type">float</span>: factor)       <span class="keywd">is</span> action <span class="stri">"FLT_MULT_ASSIGN"</span>;


<span class="comment">(**
 *  Divide a float ''number'' by a ''divisor'' and assign the result back to ''number''.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">float</span>: number) /:= (<span class="op">in</span> <span class="type">float</span>: divisor)      <span class="keywd">is</span> action <span class="stri">"FLT_DIV_ASSIGN"</span>;


<span class="comment">(**
 *  Check if two float numbers are equal.
 *  According to IEEE 754 a [[#NaN|NaN]] is not equal to any float value.
 *  Therefore ''NaN = any_value'' and ''any_value = NaN''
 *  always return FALSE. Even ''NaN = NaN'' returns FALSE.
 *  @return TRUE if both numbers are equal, FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">float</span>: number1) = (<span class="op">in</span> <span class="type">float</span>: number2)  <span class="keywd">is</span> action <span class="stri">"FLT_EQ"</span>;


<span class="comment">(**
 *  Check if two float numbers are not equal.
 *  According to IEEE 754 a [[#NaN|NaN]] is not equal to any float value.
 *  Therefore ''NaN &lt;> any_value'' and ''any_value &lt;> NaN''
 *  always return TRUE. Even ''NaN &lt;> NaN'' returns TRUE.
 *  @return FALSE if both numbers are equal, TRUE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">float</span>: number1) &lt;> (<span class="op">in</span> <span class="type">float</span>: number2) <span class="keywd">is</span> action <span class="stri">"FLT_NE"</span>;


<span class="comment">(**
 *  Check if ''number1'' is less than ''number2''.
 *  According to IEEE 754 a [[#NaN|NaN]] is neither less than,
 *  equal to, nor greater than any value, including itself.
 *  If ''number1'' or ''number2'' is NaN, the result
 *  is FALSE;
 *  @return TRUE if ''number1'' is less than ''number2'',
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">float</span>: number1) &lt; (<span class="op">in</span> <span class="type">float</span>: number2)  <span class="keywd">is</span> action <span class="stri">"FLT_LT"</span>;


<span class="comment">(**
 *  Check if ''number1'' is greater than ''number2''.
 *  According to IEEE 754 a [[#NaN|NaN]] is neither less than,
 *  equal to, nor greater than any value, including itself.
 *  If ''number1'' or ''number2'' is NaN, the result
 *  is FALSE;
 *  @return TRUE if ''number1'' is greater than ''number2'',
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">float</span>: number1) > (<span class="op">in</span> <span class="type">float</span>: number2)  <span class="keywd">is</span> action <span class="stri">"FLT_GT"</span>;


<span class="comment">(**
 *  Check if ''number1'' is less than or equal to ''number2''.
 *  According to IEEE 754 a [[#NaN|NaN]] is neither less than,
 *  equal to, nor greater than any value, including itself.
 *  If ''number1'' or ''number2'' is NaN, the result
 *  is FALSE;
 *  @return TRUE if ''number1'' is less than or equal to ''number2'',
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">float</span>: number1) &lt;= (<span class="op">in</span> <span class="type">float</span>: number2) <span class="keywd">is</span> action <span class="stri">"FLT_LE"</span>;


<span class="comment">(**
 *  Check if ''number1'' is greater than or equal to ''number2''.
 *  According to IEEE 754 a [[#NaN|NaN]] is neither less than,
 *  equal to, nor greater than any value, including itself.
 *  If ''number1'' or ''number2'' is NaN, the result
 *  is FALSE;
 *  @return TRUE if ''number1'' is greater than or equal to ''number2'',
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">float</span>: number1) >= (<span class="op">in</span> <span class="type">float</span>: number2) <span class="keywd">is</span> action <span class="stri">"FLT_GE"</span>;


<span class="comment">(**
 *  Positive infinity.
 *  Infinity is the result of 1.0 / 0.0 .
 *)</span>
<span class="keywd">const</span> <span class="type">float</span>: Infinity <span class="keywd">is</span> 1.0 / 0.0;


<span class="comment">(**
 *  Not-a-Number (''NaN'') value.
 *  Represents an undefined or unrepresentable value.
 *  ''NaN'' is the result of 0.0 / 0.0 .
 *  According to IEEE 754 a ''NaN'' is not equal to any float value.
 *  Therefore ''NaN = any_value'' and ''any_value = NaN''
 *  always return FALSE. Even ''NaN = NaN'' returns FALSE.
 *  Checking for NaN is done with the function [[#isNaN(in_float)|isNaN]].
 *)</span>
<span class="keywd">const</span> <span class="type">float</span>: NaN <span class="keywd">is</span> 0.0 / 0.0;


<span class="comment">(**
 *  Compare two float numbers.
 *  Because ''compare'' is used to sort float values, a unique
 *  sort sequence of the values is needed. Therefore ''compare''
 *  considers all [[#NaN|NaN]] values as greater than Infinity.
 *  The NaN values are also considered to be equal to each other.
 *  Negative zero (-0.0) is considered by ''compare'' to be
 *  equal to positive zero (+0.0). This conforms to the behavior
 *  of all other float comparisons with zero.
 *  @return -1, 0 or 1 if the first argument is considered to be
 *          respectively less than, equal to, or greater than the
 *          second.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: compare (<span class="op">in</span> <span class="type">float</span>: number1, <span class="op">in</span> <span class="type">float</span>: number2) <span class="keywd">is</span> action <span class="stri">"FLT_CMP"</span>;


<span class="comment">(**
 *  Compute the hash value of a float number.
 *  @return the hash value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: hashCode (<span class="op">in</span> <span class="type">float</span>: number)                <span class="keywd">is</span> action <span class="stri">"FLT_HASHCODE"</span>;


<span class="comment">(**
 *  Convert a float number to a [[string]].
 *  The number is converted to a string with decimal representation.
 *  The result string has the style [-]ddd.ddd where there is at least
 *  one digit before and after the decimal point. The number of digits
 *  after the decimal point is determined automatically. Except for the
 *  case with only one zero digit after the decimal point the last digit
 *  is never zero. Negative zero (-0.0) and positive zero (+0.0)
 *  are both converted to "0.0".
 *   str(16.125)    returns "16.125"
 *   str(-0.0)      returns "0.0"
 *   str(Infinity)  returns "Infinity"
 *   str(-Infinity) returns "-Infinity"
 *   str(NaN)       returns "NaN"
 *  @return the string result of the conversion.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">float</span>: number)                      <span class="keywd">is</span> action <span class="stri">"FLT_STR"</span>;


<span class="comment">(**
 *  Convert a float number to a [[string]].
 *  The number is converted to a string with decimal representation.
 *  The result string has the style [-]ddd.ddd where there is at least
 *  one digit before and after the decimal point. The number of digits
 *  after the decimal point is determined automatically. Except for the
 *  case with only one zero digit after the decimal point the last digit
 *  is never zero. Negative zero (-0.0) and positive zero (+0.0)
 *  are both converted to "0.0".
 *   string(16.125)    returns "16.125"
 *   string(-0.0)      returns "0.0"
 *   string(Infinity)  returns "Infinity"
 *   string(-Infinity) returns "-Infinity"
 *   string(NaN)       returns "NaN"
 *  @return the string result of the conversion.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: string (<span class="op">in</span> <span class="type">float</span>: number)                   <span class="keywd">is</span> action <span class="stri">"FLT_STR"</span>;


<span class="comment">(**
 *  Convert a ''float'' to a [[string]] in scientific notation.
 *  Scientific notation uses a decimal significand and a decimal exponent.
 *  The significand has an optional sign and exactly one digit before the
 *  decimal point. The decimal point is followed by a fractional part
 *  with at least one digit. Trailing zeros in the fractional part are
 *  omitted except for the digit which follows the decimal point.
 *  The fractional part is followed by the letter e and an exponent,
 *  which is always signed. The value zero is never written with a
 *  negative sign.
 *   str(0.012345,  SCIENTIFIC)  returns "1.2345e-2"
 *   str(1246800.0, SCIENTIFIC)  returns "1.2468e+6"
 *   str(3.1415,    SCIENTIFIC)  returns "3.1415e+0"
 *   str(Infinity,  SCIENTIFIC)  returns "Infinity"
 *   str(-Infinity, SCIENTIFIC)  returns "-Infinity"
 *   str(NaN,       SCIENTIFIC)  returns "NaN"
 *   str(-0.004,    SCIENTIFIC)  returns "-4.0e-3"
 *   str( 0.0,      SCIENTIFIC)  returns "0.0e+0"
 *   str(-0.0,      SCIENTIFIC)  returns "0.0e+0"
 *  @return the string result of the conversion.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">float</span>: number, SCIENTIFIC)          <span class="keywd">is</span> action <span class="stri">"FLT_STR_SCIENTIFIC"</span>;


<span class="comment">(**
 *  Convert a [[string]] to a float number.
 *   float("1.2345")     returns  1.2345
 *   float("1.2345e6")   returns  1234500.0
 *   float("-1.0e-308")  returns -1.0e-308
 *   float("1")          returns  1.0
 *   float("2.")         returns  2.0
 *   float(".5")         returns  0.5
 *   float("-.25")       returns  -0.25
 *   float("Infinity")   returns  Infinity
 *   float("-Infinity")  returns -Infinity
 *   float("NaN")        returns  NaN
 *   float("3.14PI"      raises RANGE_ERROR
 *  @return the float result of the conversion.
 *  @exception RANGE_ERROR If the string contains not a float literal.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: float (<span class="op">in</span> <span class="type">string</span>: stri)                      <span class="keywd">is</span> action <span class="stri">"FLT_PARSE1"</span>;


<span class="comment">(**
 *  Convert a [[string]] to a float number.
 *   float parse "1.2345"     returns  1.2345
 *   float parse "1.2345e6"   returns  1234500.0
 *   float parse "-1.0e-308"  returns -1.0e-308
 *   float parse "1"          returns  1.0
 *   float parse "2."         returns  2.0
 *   float parse ".5"         returns  0.5
 *   float parse "-.25"       returns  -0.25
 *   float parse "Infinity"   returns  Infinity
 *   float parse "-Infinity"  returns -Infinity
 *   float parse "NaN"        returns  NaN
 *   float parse "2.14PI"     raises RANGE_ERROR
 *  @return the float result of the conversion.
 *  @exception RANGE_ERROR If the string contains not a float literal.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: (attr float) <span class="op">parse</span> (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span>
    <span class="keywd">return</span> float(stri);


<span class="comment">(**
 *  Convert a ''float'' to a [[string]] in decimal fixed point notation.
 *  The number is rounded to the specified number of digits (''precision'').
 *  Halfway cases are rounded away from zero. Except for a ''precision'' of
 *  zero the representation has a decimal point and at least one digit
 *  before and after the decimal point. Negative numbers are preceded by
 *  a minus sign (e.g.: "-1.25"). If all digits in the result are 0 a
 *  possible negative sign is omitted.
 *   0.012345  digits 4  returns "0.0123"
 *   1.2468    digits 2  returns "1.25"
 *   3.1415    digits 0  returns "3"
 *   0.125     digits 2  returns "0.12"
 *   0.375     digits 2  returns "0.38"
 *   Infinity  digits 5  returns "Infinity"
 *   -Infinity digits 6  returns "-Infinity"
 *   NaN       digits 7  returns "NaN"
 *   -0.004    digits 2  returns "0.00"
 *  @param precision Number of digits after the decimal point.
 *         If the ''precision'' is zero the decimal point is omitted.
 *  @return the string result of the conversion.
 *  @exception RANGE_ERROR If the ''precision'' is negative.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">float</span>: number) <span class="op">digits</span> (<span class="op">in</span> <span class="type">integer</span>: precision) <span class="keywd">is</span> action <span class="stri">"FLT_DGTS"</span>;


<span class="comment">(**
 *  Convert a ''float'' to a [[string]] in scientific notation.
 *  Scientific notation uses a decimal significand and a decimal exponent.
 *  The significand has an optional sign and exactly one digit before the
 *  decimal point. The fractional part of the significand is rounded
 *  to the specified number of digits (''precision''). Halfway cases are
 *  rounded away from zero. The fractional part is followed by the
 *  letter e and an exponent, which is always signed. The value zero is
 *  never written with a negative sign.
 *   0.012345  sci 4  returns "1.2345e-2"
 *   1.2468    sci 2  returns "1.25e+0"
 *   3.1415    sci 0  returns "3e+0"
 *   0.125     sci 1  returns "1.2e-1"
 *   0.375     sci 1  returns "3.8e-1"
 *   Infinity  sci 5  returns "Infinity"
 *   -Infinity sci 6  returns "-Infinity"
 *   NaN       sci 7  returns "NaN"
 *   -0.004    sci 2  returns "-4.00e-3"
 *   -0.0      sci 2  returns "0.00e+0"
 *  @param precision Number of digits after the decimal point.
 *         If the ''precision'' is zero the decimal point is omitted.
 *  @return the string result of the conversion.
 *  @exception RANGE_ERROR If the ''precision'' is negative.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">float</span>: number) <span class="op">sci</span> (<span class="op">in</span> <span class="type">integer</span>: precision)    <span class="keywd">is</span> action <span class="stri">"FLT_SCI"</span>;


<span class="comment">(**
 *  Set the number of exponent digits in a scientific float notation.
 *  If ''sciNumber'' contains a [[string]] in scientific float notation
 *  the exponent is changed to contain at least ''expDigits'' digits.
 *  If ''sciNumber'' contains not a string in scientific float
 *  notation it is returned unchanged. The ''exp'' operator is
 *  intended to be used together with the ''sci'' operator
 *   0.012345  sci 4 exp 2  returns "1.2345e-02"
 *   1.2468e15 sci 2 exp 1  returns "1.25e+15"
 *   3.1415    sci 0 exp 3  returns "3e+000"
 *   0.125     sci 1 exp 2  returns "1.2e-01"
 *   0.375     sci 1 exp 2  returns "3.8e-01"
 *   Infinity  sci 5 exp 2  returns "Infinity"
 *   -Infinity sci 6 exp 2  returns "-Infinity"
 *   NaN       sci 7 exp 2  returns "NaN"
 *   -0.004    sci 2 exp 2  returns "-4.00e-03"
 *  @return the string result of the conversion.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">string</span>: sciNumber) <span class="op">exp</span> (<span class="op">in</span> <span class="type">integer</span>: expDigits) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: paddedStri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    pos := length(sciNumber);
    <span class="keywd">while</span> pos >= 1 <span class="op">and</span> sciNumber[pos] >= <span class="stri">'0'</span> <span class="op">and</span> sciNumber[pos] &lt;= <span class="stri">'9'</span> <span class="keywd">do</span>
      decr(pos);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> pos >= 2 <span class="op">and</span> sciNumber[pred(pos)] = <span class="stri">'e'</span> <span class="op">and</span>
        (sciNumber[pos] = <span class="stri">'+'</span> <span class="op">or</span> sciNumber[pos] = <span class="stri">'-'</span>) <span class="op">and</span>
        expDigits > length(sciNumber) - pos <span class="keywd">then</span>
      paddedStri := sciNumber[.. pos] &amp; <span class="stri">"0"</span> <span class="op">mult</span> expDigits - length(sciNumber) + pos &amp;
          sciNumber[succ(pos) ..];
    <span class="keywd">else</span>
      paddedStri := sciNumber;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Convert an [[integer]] to a float.
 *  @return the float result of the conversion.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: flt (<span class="op">in</span> <span class="type">integer</span>: number)                     <span class="keywd">is</span> action <span class="stri">"FLT_ICONV1"</span>;


<span class="comment">(**
 *  Convert an [[integer]] to a float.
 *  @return the float result of the conversion.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: float (<span class="op">in</span> <span class="type">integer</span>: number)                   <span class="keywd">is</span> action <span class="stri">"FLT_ICONV1"</span>;


<span class="comment">(**
 *  Convert an [[integer]] to a float.
 *  @return the float result of the conversion.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: (attr float) <span class="op">conv</span> (<span class="op">in</span> <span class="type">integer</span>: number)       <span class="keywd">is</span> action <span class="stri">"FLT_ICONV3"</span>;


<span class="comment">(**
 *  Compute the absolute value of a ''float'' number.
 *  @return the absolute value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: abs (<span class="op">in</span> <span class="type">float</span>: number)                       <span class="keywd">is</span> action <span class="stri">"FLT_ABS"</span>;


<span class="comment">(**
 *  Round down towards negative infinity.
 *  Returns the largest value that is less than or equal to the
 *  argument and is equal to a mathematical integer.
 *  @return the rounded value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: floor (<span class="op">in</span> <span class="type">float</span>: x)                          <span class="keywd">is</span> action <span class="stri">"FLT_FLOOR"</span>;


<span class="comment">(**
 *  Round up towards positive infinity.
 *  Determine the smallest value that is greater than or equal
 *  to the argument and is equal to a mathematical integer.
 *  @return the rounded value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: ceil (<span class="op">in</span> <span class="type">float</span>: x)                           <span class="keywd">is</span> action <span class="stri">"FLT_CEIL"</span>;


<span class="comment">(**
 *  Round a ''float'' to the nearest [[integer]].
 *  Halfway cases are rounded away from zero.
 *   round( 1.4999)  returns  1
 *   round( 0.5)     returns  1
 *   round( 0.4999)  returns  0
 *   round(-0.4999)  returns  0
 *   round(-0.5)     returns -1
 *   round(-1.4999)  returns -1
 *   round(1.0e+19)  raises  RANGE_ERROR
 *  @return the rounded value.
 *  @exception RANGE_ERROR If the number is [[#NaN|NaN]], -Infinity, Infinity,
 *             or does not fit into an integer.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: round (<span class="op">in</span> <span class="type">float</span>: number)                   <span class="keywd">is</span> action <span class="stri">"FLT_ROUND"</span>;


<span class="comment">(**
 *  Round a ''float'' number with a decimal ''precision''.
 *  Halfway cases are rounded away from zero. Note that simple decimal
 *  numbers like 0.1 do not have an exact floating point representation.
 *  So round10(0.099609375, 1) will return an approximation of 0.1.
 *   round10(0.4990234375, 0)  returns 0.0
 *   round10(0.4990234375, 1)  returns 0.5
 *   round10(0.4990234375, 2)  returns 0.5
 *   round10(0.4990234375, 3)  returns 0.499
 *   round10(0.5, 0)           returns 1.0
 *   round10(0.099609375, 1)   returns 0.1
 *   round10(0.099609375, 3)   returns 0.1
 *   round10(0.099609375, 4)   returns 0.0996
 *   round10(-0.099609375, 4)  returns -0.0996
 *  @return the rounded value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: round10 (<span class="op">in</span> <span class="type">float</span>: number, <span class="op">in</span> <span class="type">integer</span>: precision) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: rounded <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">float</span>: factor <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> precision > 0 <span class="keywd">then</span>
      factor := 10.0 ** precision;
      <span class="keywd">if</span> number >= 0.0 <span class="keywd">then</span>
        rounded := floor(number * factor + 0.5) / factor;
      <span class="keywd">else</span>
        rounded := ceil(number * factor - 0.5) / factor;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> precision = 0 <span class="keywd">then</span>
      <span class="keywd">if</span> number >= 0.0 <span class="keywd">then</span>
        rounded := floor(number + 0.5);
      <span class="keywd">else</span>
        rounded := ceil(number - 0.5);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      factor := 10.0 ** (-precision);
      <span class="keywd">if</span> number >= 0.0 <span class="keywd">then</span>
        rounded := floor(number / factor + 0.5) * factor;
      <span class="keywd">else</span>
        rounded := ceil(number / factor - 0.5) * factor;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Truncate towards zero.
 *  The fractional part of a number is discarded.
 *   trunc( 1.9999)  returns  1
 *   trunc( 1.0)     returns  1
 *   trunc( 0.9999)  returns  0
 *   trunc(-0.9999)  returns  0
 *   trunc(-1.0)     returns -1
 *   trunc(-1.9999)  returns -1
 *   trunc(1.0e+19)  raises  RANGE_ERROR
 *  @return the nearest [[integer]] not larger in absolute value
 *          than the argument.
 *  @exception RANGE_ERROR If the number is [[#NaN|NaN]], -Infinity, Infinity,
 *             or does not fit into an integer.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: trunc (<span class="op">in</span> <span class="type">float</span>: number)                   <span class="keywd">is</span> action <span class="stri">"FLT_TRUNC"</span>;


<span class="comment">(**
 *  Determine if a number has a Not-a-Number ([[#NaN|NaN]]) value.
 *  NaN represents an undefined or unrepresentable value.
 *  @return TRUE if the number has a Not-a-Number (NaN) value,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isNaN (<span class="op">in</span> <span class="type">float</span>: number)                   <span class="keywd">is</span> action <span class="stri">"FLT_ISNAN"</span>;


<span class="comment">(**
 *  Determine if a number is negative zero (-0.0).
 *  This function is the only possibility to determine if a number
 *  is -0.0. The comparison operators (=, &lt;>, &lt;, >, &lt;=, >=) and
 *  the function ''compare'' treat 0.0 and -0.0 as equal. The
 *  operators ''digits'' and ''sci'' and the function ''str''
 *  return the same [[string]] for -0.0 and +0.0.
 *  @return TRUE if the number is -0.0,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isNegativeZero (<span class="op">in</span> <span class="type">float</span>: number)          <span class="keywd">is</span> action <span class="stri">"FLT_ISNEGATIVEZERO"</span>;


<span class="comment">(**
 *  Determine if a number is +0.0.
 *  @return TRUE if the number is +0.0,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isPositiveZero (<span class="op">in</span> <span class="type">float</span>: number) <span class="keywd">is</span>
  <span class="keywd">return</span> number = 0.0 <span class="op">and</span> <span class="op">not</span> isNegativeZero(number);


<span class="comment">(**
 *  Convert a float number to a [[string]].
 *  The number is converted to a string with decimal representation.
 *  @return the string result of the conversion.
 *  @exception MEMORY_ERROR Not enough memory to represent the result.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: literal (<span class="op">in</span> <span class="type">float</span>: number)                  <span class="keywd">is</span> action <span class="stri">"FLT_STR"</span>;


<span class="comment">(**
 *  Compute pseudo-random number in the range [low, high).
 *  The random values are uniform distributed.
 *  @return the computed pseudo-random number.
 *  @exception RANGE_ERROR The range is empty (low >= high holds).
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: rand (<span class="op">in</span> <span class="type">float</span>: low, <span class="op">in</span> <span class="type">float</span>: high)         <span class="keywd">is</span> action <span class="stri">"FLT_RAND"</span>;


<span class="keywd">const</span> <span class="type">proc</span>: decompose (<span class="op">in</span> <span class="type">float</span>: number, <span class="keywd">inout</span> <span class="type">float</span>: fraction,
                       <span class="keywd">inout</span> <span class="type">integer</span>: exponent)                <span class="keywd">is</span> action <span class="stri">"FLT_DECOMPOSE"</span>;


<span class="keywd">const</span> <span class="type">type</span>: floatElements <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">float</span>: fraction <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">integer</span>: exponent <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="comment">(**
 *  Decompose float into normalized fraction and integral exponent for 2.
 *  If the argument (number) is 0.0, -0.0, Infinity, -Infinity or [[#NaN|NaN]]
 *  the fraction is set to the argument and the exponent is set to 0.
 *  For all other arguments the fraction is set to an absolute value
 *  between 0.5(included) and 1.0(excluded). For all values of number holds:
 *   number = fraction * 2.0 ** exponent
 *  @param number Number to be decomposed into fraction and exponent.
 *  @return floatElements with fraction and exponent set.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">floatElements</span>: decompose (<span class="op">in</span> <span class="type">float</span>: number) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">floatElements</span>: elements <span class="keywd">is</span> floatElements.value;
  <span class="keywd">begin</span>
    decompose(number, elements.fraction, elements.exponent);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment"># Allows 'array float' everywhere without extra type definition.</span>
<span class="keywd">const</span> <span class="type">type</span>: _floatArray <span class="keywd">is</span> <span class="type">array</span> <span class="type">float</span>;


enable_io(float);
DECLARE_TERNARY(float);
DECLARE_MIN_MAX(float);
</pre>
</body>
</html>
