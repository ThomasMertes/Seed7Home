<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  zip.s7i       Zip compression support library                   *)</span>
<span class="comment">(*  Copyright (C) 2009, 2016, 2017, 2020 - 2025  Thomas Mertes      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/stdio.htm">stdio.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/inflate.htm">inflate.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/deflate.htm">deflate.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/lzw.htm">lzw.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bzip2.htm">bzip2.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/lzma.htm">lzma.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/zstd.htm">zstd.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/xz.htm">xz.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/unicode.htm">unicode.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bytedata.htm">bytedata.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bin32.htm">bin32.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/time.htm">time.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/crc32.htm">crc32.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/filesys.htm">filesys.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/filebits.htm">filebits.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/fileutil.htm">fileutil.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/archive_base.htm">archive_base.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/subfile.htm">subfile.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/msgdigest.htm">msgdigest.s7i</a>"</span>;


<span class="keywd">const</span> <span class="type">string</span>: ZIP_CENTRAL_HEADER_SIGNATURE               <span class="keywd">is</span> <span class="stri">"PK\1;\2;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: ZIP_LOCAL_HEADER_SIGNATURE                 <span class="keywd">is</span> <span class="stri">"PK\3;\4;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: ZIP_END_OF_CENTRAL_DIRECTORY_SIGNATURE     <span class="keywd">is</span> <span class="stri">"PK\5;\6;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: ZIP_DATA_DESCRIPTOR_SIGNATURE              <span class="keywd">is</span> <span class="stri">"PK\7;\8;"</span>;

<span class="keywd">const</span> <span class="type">string</span>: ZIP64_END_OF_CENTRAL_DIRECTORY_SIGNATURE   <span class="keywd">is</span> <span class="stri">"PK\6;\6;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE <span class="keywd">is</span> <span class="stri">"PK\6;\7;"</span>;

<span class="keywd">const</span> <span class="type">integer</span>: ZIP_CENTRAL_HEADER_FIXED_SIZE             <span class="keywd">is</span> 46;
<span class="keywd">const</span> <span class="type">integer</span>: ZIP_LOCAL_HEADER_FIXED_SIZE               <span class="keywd">is</span> 30;
<span class="keywd">const</span> <span class="type">integer</span>: ZIP_END_OF_CENTRAL_DIRECTORY_FIXED_SIZE   <span class="keywd">is</span> 22;

<span class="keywd">const</span> <span class="type">integer</span>: ZIP64_END_OF_CENTRAL_DIRECTORY_FIXED_SIZE <span class="keywd">is</span> 56;
<span class="keywd">const</span> <span class="type">integer</span>: ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE     <span class="keywd">is</span> 20;

<span class="keywd">const</span> <span class="type">integer</span>: ZIP_DATA_DESCRIPTOR_SIZE                  <span class="keywd">is</span> 12;
<span class="keywd">const</span> <span class="type">integer</span>: ZIP64_DATA_DESCRIPTOR_SIZE                <span class="keywd">is</span> 20;

<span class="comment"># Bits of the general_purpose_bit_flag:</span>
<span class="keywd">const</span> <span class="type">bin32</span>: ZIP_HAS_DATA_DESCRIPTOR <span class="keywd">is</span> bin32(16#0008);
<span class="keywd">const</span> <span class="type">bin32</span>: ZIP_FILE_NAME_IS_UTF8   <span class="keywd">is</span> bin32(16#0800);

<span class="keywd">const</span> <span class="type">integer</span>: ZIP_HOST_SYSTEM_MS_DOS <span class="keywd">is</span> 0;
<span class="keywd">const</span> <span class="type">integer</span>: ZIP_HOST_SYSTEM_UNIX   <span class="keywd">is</span> 3;

<span class="comment"># Supported compression_method values:</span>
<span class="keywd">const</span> <span class="type">integer</span>: ZIP_STORE     <span class="keywd">is</span>  0;  <span class="comment"># The file is stored (no compression).</span>
<span class="keywd">const</span> <span class="type">integer</span>: ZIP_SHRINK    <span class="keywd">is</span>  1;  <span class="comment"># The file is shrunk.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ZIP_DEFLATE   <span class="keywd">is</span>  8;  <span class="comment"># The file is deflated.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ZIP_DEFLATE64 <span class="keywd">is</span>  9;  <span class="comment"># The file is compressed with enhanced deflate.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ZIP_BZIP2     <span class="keywd">is</span> 12;  <span class="comment"># The file is compressed with BZIP2.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ZIP_LZMA      <span class="keywd">is</span> 14;  <span class="comment"># The file is compressed with LZMA.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ZIP_REFERENCE <span class="keywd">is</span> 92;  <span class="comment"># Reference to an existing file</span>
<span class="keywd">const</span> <span class="type">integer</span>: ZIP_ZSTD      <span class="keywd">is</span> 93;  <span class="comment"># The file is compressed with Zstandard.</span>
<span class="keywd">const</span> <span class="type">integer</span>: ZIP_XZ        <span class="keywd">is</span> 95;  <span class="comment"># The file is compressed with XZ.</span>

<span class="keywd">const</span> <span class="type">integer</span>: DOS_EPOCH <span class="keywd">is</span> 2#100001;  <span class="comment"># 1980-01-01 in DOS 2 byte date encoding.</span>

<span class="keywd">const</span> <span class="type">integer</span>: ZIP_NTFS_EXTRA_FIELD               <span class="keywd">is</span> 16#000a;  <span class="comment"># NTFS Extra Field</span>
<span class="keywd">const</span> <span class="type">integer</span>: ZIP_UNIX_EXTRA_FIELD               <span class="keywd">is</span> 16#000d;  <span class="comment"># UNIX Extra Field</span>
<span class="keywd">const</span> <span class="type">integer</span>: ZIP_EXTENDED_TIMESTAMP_EXTRA_FIELD <span class="keywd">is</span> 16#5455;  <span class="comment"># Extended Timestamp Extra Field</span>
<span class="keywd">const</span> <span class="type">integer</span>: ZIP_INFO_ZIP_UNIX_EXTRA_FIELD      <span class="keywd">is</span> 16#5855;  <span class="comment"># Info-ZIP Unix Extra Field (type 1)</span>
<span class="keywd">const</span> <span class="type">integer</span>: ZIP_ASI_UNIX_EXTRA_FIELD           <span class="keywd">is</span> 16#756e;  <span class="comment"># ASi Unix Extra Field</span>
<span class="keywd">const</span> <span class="type">integer</span>: ZIP_NEW_UNIX_EXTRA_FIELD           <span class="keywd">is</span> 16#7875;  <span class="comment"># New Unix Extra Field</span>

<span class="keywd">const</span> <span class="type">integer</span>: ZIP64_EXTRA_FIELD <span class="keywd">is</span> 16#0001;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: rposOfMagic (<span class="keywd">inout</span> <span class="type">file</span>: inFile, <span class="op">in</span> <span class="type">string</span>: magic,
    <span class="op">in</span> <span class="type">integer</span>: minRecLen, <span class="op">in</span> <span class="type">integer</span>: maxRecLen) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: posFound <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: data <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: magicPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    pos := length(inFile) - maxRecLen + 1;
    <span class="keywd">if</span> pos &lt;= 0 <span class="keywd">then</span>
      pos := 1;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    seek(inFile, pos);
    data := gets(inFile, maxRecLen);
    magicPos := rpos(data, magic);
    <span class="keywd">if</span> magicPos &lt;> 0 <span class="keywd">then</span>
      posFound := pos + magicPos - 1;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: zipExtraFieldType <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">integer</span><span class="type">]</span> <span class="type">string</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">zipExtraFieldType</span>: getExtraFieldMap (<span class="op">in</span> <span class="type">string</span>: field) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">zipExtraFieldType</span>: extraFieldMap <span class="keywd">is</span> zipExtraFieldType.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: id <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: value <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> pos + 3 &lt;= length(field) <span class="keywd">do</span>
      id     := bytes2Int(field[pos     fixLen 2], UNSIGNED, LE);
      length := bytes2Int(field[pos + 2 fixLen 2], UNSIGNED, LE);
      <span class="keywd">if</span> pos + 3 + length &lt;= length(field) <span class="keywd">then</span>
        <span class="keywd">if</span> length &lt;> 0 <span class="keywd">then</span>
          value := field[pos + 4 fixLen length];
        <span class="keywd">else</span>
          value := <span class="stri">""</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        extraFieldMap @:= [id] value;
        pos +:= 4 + length;
      <span class="keywd">else</span>
        <span class="comment"># Omit corrupt extra field and exit loop</span>
        pos := length(field);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: extraFieldFromMap (<span class="op">in</span> <span class="type">zipExtraFieldType</span>: extraFieldMap) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: field <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: id <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: value <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> id <span class="keywd">range</span> sort(keys(extraFieldMap)) <span class="keywd">do</span>
      value := extraFieldMap[id];
      field &amp;:= bytes(id, UNSIGNED, LE, 2) &amp; bytes(length(value), UNSIGNED, LE, 2) &amp; value;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: writeExtraField (<span class="op">in</span> <span class="type">string</span>: field) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: id <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: value <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> pos + 3 &lt;= length(field) <span class="keywd">do</span>
      id     := bytes2Int(field[pos     fixLen 2], UNSIGNED, LE);
      length := bytes2Int(field[pos + 2 fixLen 2], UNSIGNED, LE);
      <span class="keywd">if</span> pos + 3 + length &lt;= length(field) <span class="keywd">then</span>
        <span class="keywd">if</span> length &lt;> 0 <span class="keywd">then</span>
          value := field[pos + 4 fixLen length];
        <span class="keywd">else</span>
          value := <span class="stri">""</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        value := field[pos + 4 ..];
        write(<span class="stri">"corrupt "</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      writeln(<span class="stri">"field: "</span> &lt;&amp; id radix 16 <span class="op">lpad0</span> 4 &lt;&amp; <span class="stri">" "</span> &lt;&amp; length &lt;&amp; <span class="stri">" "</span> &lt;&amp; literal(value));
      pos +:= 4 + length;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: local_file_header <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">string</span>:  signature                  <span class="keywd">is</span> <span class="stri">""</span>;        <span class="comment"># 4 bytes ("PK\3;\4;")</span>
    <span class="keywd">var</span> <span class="type">integer</span>: version_needed_to_extract  <span class="keywd">is</span> 0;         <span class="comment"># 2 bytes</span>
    <span class="keywd">var</span> <span class="type">bin32</span>:   general_purpose_bit_flag   <span class="keywd">is</span> bin32(0);  <span class="comment"># 2 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: compression_method         <span class="keywd">is</span> ZIP_STORE; <span class="comment"># 2 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: last_mod_file_time         <span class="keywd">is</span> 0;         <span class="comment"># 2 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: last_mod_file_date         <span class="keywd">is</span> DOS_EPOCH; <span class="comment"># 2 bytes</span>
    <span class="keywd">var</span> <span class="type">bin32</span>:   crc_32                     <span class="keywd">is</span> bin32(0);  <span class="comment"># 4 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: compressed_size            <span class="keywd">is</span> 0;         <span class="comment"># 4 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: uncompressed_size          <span class="keywd">is</span> 0;         <span class="comment"># 4 bytes</span>
    <span class="comment">#   integer: file_name_length           is 0;         # 2 bytes</span>
    <span class="comment">#   integer: extra_field_length         is 0;         # 2 bytes</span>
    <span class="keywd">var</span> <span class="type">string</span>:  file_name                  <span class="keywd">is</span> <span class="stri">""</span>;        <span class="comment"># variable size</span>
    <span class="keywd">var</span> <span class="type">string</span>:  extra_field                <span class="keywd">is</span> <span class="stri">""</span>;        <span class="comment"># variable size</span>
    <span class="keywd">var</span> <span class="type">string</span>:  filePath <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">zipExtraFieldType</span>: extraFieldMap <span class="keywd">is</span> zipExtraFieldType.value;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: write (<span class="op">in</span> <span class="type">local_file_header</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"signature: "</span>                 <span class="op">rpad</span> 45 &lt;&amp; literal(header.signature) <span class="op">lpad</span> 16);
    writeln(<span class="stri">"version_needed_to_extract: "</span> <span class="op">rpad</span> 45 &lt;&amp; header.version_needed_to_extract <span class="op">lpad</span> 16);
    writeln(<span class="stri">"general_purpose_bit_flag: "</span>  <span class="op">rpad</span> 45 &lt;&amp; header.general_purpose_bit_flag radix 2 <span class="op">lpad0</span> 16);
    writeln(<span class="stri">"compression_method: "</span>        <span class="op">rpad</span> 45 &lt;&amp; header.compression_method <span class="op">lpad</span> 16);
    writeln(<span class="stri">"last_mod_file_time: "</span>        <span class="op">rpad</span> 45 &lt;&amp; header.last_mod_file_time <span class="op">lpad</span> 16);
    writeln(<span class="stri">"last_mod_file_date: "</span>        <span class="op">rpad</span> 45 &lt;&amp; header.last_mod_file_date <span class="op">lpad</span> 16);
    writeln(<span class="stri">"crc_32: "</span>                    <span class="op">rpad</span> 45 &lt;&amp; header.crc_32 <span class="op">lpad</span> 16);
    writeln(<span class="stri">"compressed_size: "</span>           <span class="op">rpad</span> 45 &lt;&amp; header.compressed_size <span class="op">lpad</span> 16);
    writeln(<span class="stri">"uncompressed_size: "</span>         <span class="op">rpad</span> 45 &lt;&amp; header.uncompressed_size <span class="op">lpad</span> 16);
    writeln(<span class="stri">"file_name_length: "</span>          <span class="op">rpad</span> 45 &lt;&amp; length(header.file_name) <span class="op">lpad</span> 16);
    writeln(<span class="stri">"extra_field_length: "</span>        <span class="op">rpad</span> 45 &lt;&amp; length(header.extra_field) <span class="op">lpad</span> 16);
    writeln(<span class="stri">"file_name: "</span>                 <span class="op">rpad</span> 45 &lt;&amp; literal(header.file_name) <span class="op">lpad</span> 16);
    writeln(<span class="stri">"extra_field: "</span>                       &lt;&amp; literal(header.extra_field) <span class="op">lpad</span> 16);
    writeExtraField(header.extra_field);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: considerZip64ExtraField (<span class="keywd">inout</span> <span class="type">local_file_header</span>: header,
    <span class="op">in</span> <span class="type">string</span>: zip64ExtraField) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> header.uncompressed_size = 16#ffffffff <span class="op">and</span> length(zip64ExtraField) >= pos + 7 <span class="keywd">then</span>
      header.uncompressed_size := bytes2Int(zip64ExtraField[pos fixLen 8], UNSIGNED, LE);
      <span class="comment"># writeln("uncompressed_size: " &lt;&amp; header.uncompressed_size);</span>
      pos +:= 8;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> header.compressed_size = 16#ffffffff <span class="op">and</span> length(zip64ExtraField) >= pos + 7 <span class="keywd">then</span>
      header.compressed_size := bytes2Int(zip64ExtraField[pos fixLen 8], UNSIGNED, LE);
      <span class="comment"># writeln("compressed_size: " &lt;&amp; header.compressed_size);</span>
      pos +:= 8;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">local_file_header</span>: get_local_header (<span class="keywd">inout</span> <span class="type">file</span>: inFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">local_file_header</span>: header <span class="keywd">is</span> local_file_header.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: file_name_length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: extra_field_length <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    stri := gets(inFile, ZIP_LOCAL_HEADER_FIXED_SIZE);
    <span class="keywd">if</span> length(stri) = ZIP_LOCAL_HEADER_FIXED_SIZE <span class="op">and</span>
        stri[.. 4] = ZIP_LOCAL_HEADER_SIGNATURE <span class="keywd">then</span>
      header.signature := ZIP_LOCAL_HEADER_SIGNATURE;
      header.version_needed_to_extract       := bytes2Int(stri[ 5 fixLen 2], UNSIGNED, LE);
      header.general_purpose_bit_flag  := bin32(bytes2Int(stri[ 7 fixLen 2], UNSIGNED, LE));
      header.compression_method              := bytes2Int(stri[ 9 fixLen 2], UNSIGNED, LE);
      header.last_mod_file_time              := bytes2Int(stri[11 fixLen 2], UNSIGNED, LE);
      header.last_mod_file_date              := bytes2Int(stri[13 fixLen 2], UNSIGNED, LE);
      header.crc_32                    := bin32(bytes2Int(stri[15 fixLen 4], UNSIGNED, LE));
      header.compressed_size                 := bytes2Int(stri[19 fixLen 4], UNSIGNED, LE);
      header.uncompressed_size               := bytes2Int(stri[23 fixLen 4], UNSIGNED, LE);
      file_name_length                       := bytes2Int(stri[27 fixLen 2], UNSIGNED, LE);
      extra_field_length                     := bytes2Int(stri[29 fixLen 2], UNSIGNED, LE);
      header.file_name                       := gets(inFile, file_name_length);
      header.extra_field                     := gets(inFile, extra_field_length);
      header.extraFieldMap := getExtraFieldMap(header.extra_field);
      <span class="keywd">if</span> header.general_purpose_bit_flag &amp; ZIP_FILE_NAME_IS_UTF8 &lt;> bin32(0) <span class="keywd">then</span>
        <span class="keywd">block</span>
          header.filePath := fromUtf8(header.file_name);
        exception
          catch RANGE_ERROR:
            header.filePath := header.file_name;
        <span class="keywd">end</span> <span class="keywd">block</span>;
      <span class="keywd">else</span>
        header.filePath := header.file_name;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> header.filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(header.filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
        header.filePath := header.filePath[.. pred(length(header.filePath))];
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> ZIP64_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
        considerZip64ExtraField(header, header.extraFieldMap[ZIP64_EXTRA_FIELD]);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="comment"># write(header);</span>
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">local_file_header</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := ZIP_LOCAL_HEADER_SIGNATURE &amp;
            bytes(       header.version_needed_to_extract, UNSIGNED, LE, 2) &amp;
            bytes(ord(   header.general_purpose_bit_flag), UNSIGNED, LE, 2) &amp;
            bytes(       header.compression_method,        UNSIGNED, LE, 2) &amp;
            bytes(       header.last_mod_file_time,        UNSIGNED, LE, 2) &amp;
            bytes(       header.last_mod_file_date,        UNSIGNED, LE, 2) &amp;
            bytes(ord(   header.crc_32),                   UNSIGNED, LE, 4) &amp;
            bytes(       header.compressed_size,           UNSIGNED, LE, 4) &amp;
            bytes(       header.uncompressed_size,         UNSIGNED, LE, 4) &amp;
            bytes(length(header.file_name),                UNSIGNED, LE, 2) &amp;
            bytes(length(header.extra_field),              UNSIGNED, LE, 2) &amp;
            header.file_name &amp;
            header.extra_field;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: writeHead (<span class="keywd">inout</span> <span class="type">file</span>: outFile, <span class="op">in</span> <span class="type">local_file_header</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    write(outFile, str(header));
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: zip64_end_of_central_dir_locator <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">string</span>:  signature                                        <span class="keywd">is</span> <span class="stri">""</span>;  <span class="comment"># 4 bytes ("PK\6;\7;")</span>
    <span class="keywd">var</span> <span class="type">integer</span>: disk_number_with_zip64_end_of_central_directory  <span class="keywd">is</span> 0;   <span class="comment"># 4 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: offset_of_zip64_end_of_central_directory         <span class="keywd">is</span> 0;   <span class="comment"># 8 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: total_number_of_disks                            <span class="keywd">is</span> 0;   <span class="comment"># 4 bytes</span>
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: write (<span class="op">in</span> <span class="type">zip64_end_of_central_dir_locator</span>: endOfCentDirLocator) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"signature: "</span>                                       <span class="op">rpad</span> 50 &lt;&amp; literal(endOfCentDirLocator.signature) <span class="op">lpad</span> 16);
    writeln(<span class="stri">"disk_number_with_zip64_end_of_central_directory: "</span> <span class="op">rpad</span> 50 &lt;&amp; endOfCentDirLocator.disk_number_with_zip64_end_of_central_directory);
    writeln(<span class="stri">"offset_of_zip64_end_of_central_directory: "</span>        <span class="op">rpad</span> 50 &lt;&amp; endOfCentDirLocator.offset_of_zip64_end_of_central_directory);
    writeln(<span class="stri">"total_number_of_disks: "</span>                           <span class="op">rpad</span> 50 &lt;&amp; endOfCentDirLocator.total_number_of_disks);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">zip64_end_of_central_dir_locator</span>: get_zip64_end_of_central_dir_locator (<span class="keywd">inout</span> <span class="type">file</span>: inFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">zip64_end_of_central_dir_locator</span>: endOfCentDirLocator <span class="keywd">is</span> zip64_end_of_central_dir_locator.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := gets(inFile, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE);
    <span class="keywd">if</span> length(stri) = ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE <span class="op">and</span>
        stri[.. 4] = ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE <span class="keywd">then</span>
      endOfCentDirLocator.signature := ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE;
      endOfCentDirLocator.disk_number_with_zip64_end_of_central_directory := bytes2Int(stri[ 5 fixLen 4], UNSIGNED, LE);
      endOfCentDirLocator.offset_of_zip64_end_of_central_directory        := bytes2Int(stri[ 9 fixLen 8], UNSIGNED, LE);
      endOfCentDirLocator.total_number_of_disks                           := bytes2Int(stri[17 fixLen 4], UNSIGNED, LE);
      <span class="comment"># write(endOfCentDirLocator);</span>
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: zip64_end_of_central_directory <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">string</span>:  signature                                    <span class="keywd">is</span> <span class="stri">""</span>;  <span class="comment"># 4 bytes ("PK\6;\6;")</span>
    <span class="keywd">var</span> <span class="type">integer</span>: size_of_eocd64_minus_12                      <span class="keywd">is</span> 0;   <span class="comment"># 8 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: version_made_by                              <span class="keywd">is</span> 0;   <span class="comment"># 2 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: version_needed_to_extract                    <span class="keywd">is</span> 0;   <span class="comment"># 2 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number_of_this_disk                          <span class="keywd">is</span> 0;   <span class="comment"># 4 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: disk_number_with_start_of_central_directory  <span class="keywd">is</span> 0;   <span class="comment"># 4 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: entries_in_central_directory_on_this_disk    <span class="keywd">is</span> 0;   <span class="comment"># 8 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: entries_in_central_directory                 <span class="keywd">is</span> 0;   <span class="comment"># 8 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: size_of_central_directory                    <span class="keywd">is</span> 0;   <span class="comment"># 8 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: offset_of_start_of_central_directory         <span class="keywd">is</span> 0;   <span class="comment"># 8 bytes</span>
    <span class="keywd">var</span> <span class="type">string</span>:  comment                                      <span class="keywd">is</span> <span class="stri">""</span>;  <span class="comment"># variable size</span>
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: write (<span class="op">in</span> <span class="type">zip64_end_of_central_directory</span>: endOfCentDir) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"signature: "</span>                                   <span class="op">rpad</span> 45 &lt;&amp; literal(endOfCentDir.signature) <span class="op">lpad</span> 16);
    writeln(<span class="stri">"size_of_eocd64_minus_12: "</span>                     <span class="op">rpad</span> 45 &lt;&amp; endOfCentDir.size_of_eocd64_minus_12 <span class="op">lpad</span> 16);
    writeln(<span class="stri">"version_made_by: "</span>                             <span class="op">rpad</span> 45 &lt;&amp; endOfCentDir.version_made_by <span class="op">lpad</span> 16);
    writeln(<span class="stri">"version_needed_to_extract: "</span>                   <span class="op">rpad</span> 45 &lt;&amp; endOfCentDir.version_needed_to_extract <span class="op">lpad</span> 16);
    writeln(<span class="stri">"number_of_this_disk: "</span>                         <span class="op">rpad</span> 45 &lt;&amp; endOfCentDir.number_of_this_disk <span class="op">lpad</span> 16);
    writeln(<span class="stri">"disk_number_with_start_of_central_directory: "</span> <span class="op">rpad</span> 45 &lt;&amp; endOfCentDir.disk_number_with_start_of_central_directory <span class="op">lpad</span> 16);
    writeln(<span class="stri">"entries_in_central_directory_on_this_disk: "</span>   <span class="op">rpad</span> 45 &lt;&amp; endOfCentDir.entries_in_central_directory_on_this_disk <span class="op">lpad</span> 16);
    writeln(<span class="stri">"entries_in_central_directory: "</span>                <span class="op">rpad</span> 45 &lt;&amp; endOfCentDir.entries_in_central_directory <span class="op">lpad</span> 16);
    writeln(<span class="stri">"size_of_central_directory: "</span>                   <span class="op">rpad</span> 45 &lt;&amp; endOfCentDir.size_of_central_directory <span class="op">lpad</span> 16);
    writeln(<span class="stri">"offset_of_start_of_central_directory: "</span>        <span class="op">rpad</span> 45 &lt;&amp; endOfCentDir.offset_of_start_of_central_directory <span class="op">lpad</span> 16);
    writeln(<span class="stri">"comment: "</span>                                     <span class="op">rpad</span> 45 &lt;&amp; literal(endOfCentDir.comment) <span class="op">lpad</span> 16);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">zip64_end_of_central_directory</span>: get_zip64_end_of_central_directory (<span class="keywd">inout</span> <span class="type">file</span>: inFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">zip64_end_of_central_directory</span>: endOfCentDir <span class="keywd">is</span> zip64_end_of_central_directory.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: commentLength <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    stri := gets(inFile, ZIP64_END_OF_CENTRAL_DIRECTORY_FIXED_SIZE);
    <span class="keywd">if</span> length(stri) = ZIP64_END_OF_CENTRAL_DIRECTORY_FIXED_SIZE <span class="op">and</span>
        stri[.. 4] = ZIP64_END_OF_CENTRAL_DIRECTORY_SIGNATURE <span class="keywd">then</span>
      endOfCentDir.signature := ZIP64_END_OF_CENTRAL_DIRECTORY_SIGNATURE;
      endOfCentDir.size_of_eocd64_minus_12                     := bytes2Int(stri[ 5 fixLen 8], UNSIGNED, LE);
      endOfCentDir.version_made_by                             := bytes2Int(stri[13 fixLen 2], UNSIGNED, LE);
      endOfCentDir.version_needed_to_extract                   := bytes2Int(stri[15 fixLen 2], UNSIGNED, LE);
      endOfCentDir.number_of_this_disk                         := bytes2Int(stri[17 fixLen 4], UNSIGNED, LE);
      endOfCentDir.disk_number_with_start_of_central_directory := bytes2Int(stri[21 fixLen 4], UNSIGNED, LE);
      endOfCentDir.entries_in_central_directory_on_this_disk   := bytes2Int(stri[25 fixLen 8], UNSIGNED, LE);
      endOfCentDir.entries_in_central_directory                := bytes2Int(stri[33 fixLen 8], UNSIGNED, LE);
      endOfCentDir.size_of_central_directory                   := bytes2Int(stri[41 fixLen 8], UNSIGNED, LE);
      endOfCentDir.offset_of_start_of_central_directory        := bytes2Int(stri[49 fixLen 8], UNSIGNED, LE);
      commentLength := endOfCentDir.size_of_eocd64_minus_12 + 12 - ZIP64_END_OF_CENTRAL_DIRECTORY_FIXED_SIZE;
      endOfCentDir.comment                                     := gets(inFile, commentLength);
      <span class="comment"># write(endOfCentDir);</span>
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: end_of_central_directory <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">string</span>:  signature                                    <span class="keywd">is</span> <span class="stri">""</span>;  <span class="comment"># 4 bytes ("PK\5;\6;")</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number_of_this_disk                          <span class="keywd">is</span> 0;   <span class="comment"># 2 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: disk_number_with_start_of_central_directory  <span class="keywd">is</span> 0;   <span class="comment"># 2 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: entries_in_central_directory_on_this_disk    <span class="keywd">is</span> 0;   <span class="comment"># 2 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: entries_in_central_directory                 <span class="keywd">is</span> 0;   <span class="comment"># 2 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: size_of_central_directory                    <span class="keywd">is</span> 0;   <span class="comment"># 4 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: offset_of_start_of_central_directory         <span class="keywd">is</span> 0;   <span class="comment"># 4 bytes</span>
    <span class="comment">#   integer: file_comment_length                          is 0;     2 bytes</span>
    <span class="keywd">var</span> <span class="type">string</span>:  file_comment                                 <span class="keywd">is</span> <span class="stri">""</span>;  <span class="comment"># variable size</span>
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: write (<span class="op">in</span> <span class="type">end_of_central_directory</span>: endOfCentDir) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"signature: "</span>                                   <span class="op">rpad</span> 45 &lt;&amp; literal(endOfCentDir.signature) <span class="op">lpad</span> 16);
    writeln(<span class="stri">"number_of_this_disk: "</span>                         <span class="op">rpad</span> 45 &lt;&amp; endOfCentDir.number_of_this_disk <span class="op">lpad</span> 16);
    writeln(<span class="stri">"disk_number_with_start_of_central_directory: "</span> <span class="op">rpad</span> 45 &lt;&amp; endOfCentDir.disk_number_with_start_of_central_directory <span class="op">lpad</span> 16);
    writeln(<span class="stri">"entries_in_central_directory_on_this_disk: "</span>   <span class="op">rpad</span> 45 &lt;&amp; endOfCentDir.entries_in_central_directory_on_this_disk <span class="op">lpad</span> 16);
    writeln(<span class="stri">"entries_in_central_directory: "</span>                <span class="op">rpad</span> 45 &lt;&amp; endOfCentDir.entries_in_central_directory <span class="op">lpad</span> 16);
    writeln(<span class="stri">"size_of_central_directory: "</span>                   <span class="op">rpad</span> 45 &lt;&amp; endOfCentDir.size_of_central_directory <span class="op">lpad</span> 16);
    writeln(<span class="stri">"offset_of_start_of_central_directory: "</span>        <span class="op">rpad</span> 45 &lt;&amp; endOfCentDir.offset_of_start_of_central_directory <span class="op">lpad</span> 16);
    writeln(<span class="stri">"file_comment_length: "</span>                         <span class="op">rpad</span> 45 &lt;&amp; length(endOfCentDir.file_comment) <span class="op">lpad</span> 16);
    writeln(<span class="stri">"file_comment: "</span>                                <span class="op">rpad</span> 45 &lt;&amp; literal(endOfCentDir.file_comment) <span class="op">lpad</span> 16);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">end_of_central_directory</span>: get_end_of_central_directory (<span class="keywd">inout</span> <span class="type">file</span>: inFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">end_of_central_directory</span>: endOfCentDir <span class="keywd">is</span> end_of_central_directory.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: file_comment_length <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    stri := gets(inFile, ZIP_END_OF_CENTRAL_DIRECTORY_FIXED_SIZE);
    <span class="keywd">if</span> length(stri) = ZIP_END_OF_CENTRAL_DIRECTORY_FIXED_SIZE <span class="op">and</span>
        stri[.. 4] = ZIP_END_OF_CENTRAL_DIRECTORY_SIGNATURE <span class="keywd">then</span>
      endOfCentDir.signature := ZIP_END_OF_CENTRAL_DIRECTORY_SIGNATURE;
      endOfCentDir.number_of_this_disk                         := bytes2Int(stri[ 5 fixLen 2], UNSIGNED, LE);
      endOfCentDir.disk_number_with_start_of_central_directory := bytes2Int(stri[ 7 fixLen 2], UNSIGNED, LE);
      endOfCentDir.entries_in_central_directory_on_this_disk   := bytes2Int(stri[ 9 fixLen 2], UNSIGNED, LE);
      endOfCentDir.entries_in_central_directory                := bytes2Int(stri[11 fixLen 2], UNSIGNED, LE);
      endOfCentDir.size_of_central_directory                   := bytes2Int(stri[13 fixLen 4], UNSIGNED, LE);
      endOfCentDir.offset_of_start_of_central_directory        := bytes2Int(stri[17 fixLen 4], UNSIGNED, LE);
      file_comment_length                                      := bytes2Int(stri[21 fixLen 2], UNSIGNED, LE);
      endOfCentDir.file_comment                                := gets(inFile, file_comment_length);
      <span class="comment"># write(endOfCentDir);</span>
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">end_of_central_directory</span>: endOfCentDir) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := ZIP_END_OF_CENTRAL_DIRECTORY_SIGNATURE &amp;
            bytes(       endOfCentDir.number_of_this_disk,                         UNSIGNED, LE, 2) &amp;
            bytes(       endOfCentDir.disk_number_with_start_of_central_directory, UNSIGNED, LE, 2) &amp;
            bytes(       endOfCentDir.entries_in_central_directory_on_this_disk,   UNSIGNED, LE, 2) &amp;
            bytes(       endOfCentDir.entries_in_central_directory,                UNSIGNED, LE, 2) &amp;
            bytes(       endOfCentDir.size_of_central_directory,                   UNSIGNED, LE, 4) &amp;
            bytes(       endOfCentDir.offset_of_start_of_central_directory,        UNSIGNED, LE, 4) &amp;
            bytes(length(endOfCentDir.file_comment),                               UNSIGNED, LE, 2) &amp;
            endOfCentDir.file_comment;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">end_of_central_directory</span>: readEndOfCentralDir (<span class="keywd">inout</span> <span class="type">file</span>: inFile,
    <span class="keywd">inout</span> <span class="type">integer</span>: endOfCentralDirPos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">end_of_central_directory</span>: endOfCentralDir <span class="keywd">is</span> end_of_central_directory.value;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">integer</span>: MIN_RECORD_LEN <span class="keywd">is</span> 22;
    <span class="keywd">const</span> <span class="type">integer</span>: MAX_RECORD_LEN <span class="keywd">is</span> MIN_RECORD_LEN + 2**16 - 1;
    <span class="keywd">var</span> <span class="type">zip64_end_of_central_dir_locator</span>: endOfCentDirLocator <span class="keywd">is</span> zip64_end_of_central_dir_locator.value;
    <span class="keywd">var</span> <span class="type">zip64_end_of_central_directory</span>: endOfCentralDir64 <span class="keywd">is</span> zip64_end_of_central_directory.value;
  <span class="keywd">begin</span>
    endOfCentralDirPos := rposOfMagic(inFile, ZIP_END_OF_CENTRAL_DIRECTORY_SIGNATURE,
                                      MIN_RECORD_LEN, MAX_RECORD_LEN);
    <span class="keywd">if</span> endOfCentralDirPos &lt;> 0 <span class="keywd">then</span>
      <span class="keywd">if</span> endOfCentralDirPos > ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE <span class="keywd">then</span>
        seek(inFile, endOfCentralDirPos - ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE);
        endOfCentDirLocator := get_zip64_end_of_central_dir_locator(inFile);
        <span class="keywd">if</span> endOfCentDirLocator.signature = ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE <span class="keywd">then</span>
          seek(inFile, succ(endOfCentDirLocator.offset_of_zip64_end_of_central_directory));
          endOfCentralDir64 := get_zip64_end_of_central_directory(inFile);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      seek(inFile, endOfCentralDirPos);
      endOfCentralDir := get_end_of_central_directory(inFile);
      <span class="keywd">if</span> endOfCentDirLocator.signature = ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE <span class="keywd">then</span>
        <span class="keywd">if</span> endOfCentralDir64.signature = ZIP64_END_OF_CENTRAL_DIRECTORY_SIGNATURE <span class="keywd">then</span>
          <span class="keywd">if</span> endOfCentralDir.number_of_this_disk = 16#ffff <span class="keywd">then</span>
            endOfCentralDir.number_of_this_disk := endOfCentralDir64.number_of_this_disk;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> endOfCentralDir.disk_number_with_start_of_central_directory = 16#ffff <span class="keywd">then</span>
            endOfCentralDir.disk_number_with_start_of_central_directory :=
                endOfCentralDir64.disk_number_with_start_of_central_directory;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> endOfCentralDir.entries_in_central_directory_on_this_disk = 16#ffff <span class="keywd">then</span>
            endOfCentralDir.entries_in_central_directory_on_this_disk :=
                endOfCentralDir64.entries_in_central_directory_on_this_disk;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> endOfCentralDir.entries_in_central_directory = 16#ffff <span class="keywd">then</span>
            endOfCentralDir.entries_in_central_directory := endOfCentralDir64.entries_in_central_directory;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> endOfCentralDir.size_of_central_directory = 16#ffffffff <span class="keywd">then</span>
            endOfCentralDir.size_of_central_directory := endOfCentralDir64.size_of_central_directory;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> endOfCentralDir.offset_of_start_of_central_directory = 16#ffffffff <span class="keywd">then</span>
            endOfCentralDir.offset_of_start_of_central_directory :=
                endOfCentralDir64.offset_of_start_of_central_directory;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> tell(inFile) &lt;> succ(length(inFile)) <span class="keywd">then</span>
        <span class="comment"># The end_of_central_directory record is not at the end of the file.</span>
        <span class="comment"># writeln("curr pos: " &lt;&amp; tell(inFile) &lt;&amp; " length: " &lt;&amp; length(inFile));</span>
        endOfCentralDir := end_of_central_directory.value;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: central_file_header <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">string</span>: signature                        <span class="keywd">is</span> <span class="stri">""</span>;        <span class="comment"># 4 bytes ("PK\1;\2;")</span>
    <span class="keywd">var</span> <span class="type">integer</span>: version_made_by                 <span class="keywd">is</span> 0;         <span class="comment"># 2 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: version_needed_to_extract       <span class="keywd">is</span> 0;         <span class="comment"># 2 bytes</span>
    <span class="keywd">var</span> <span class="type">bin32</span>:   general_purpose_bit_flag        <span class="keywd">is</span> bin32(0);  <span class="comment"># 2 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: compression_method              <span class="keywd">is</span> ZIP_STORE; <span class="comment"># 2 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: last_mod_file_time              <span class="keywd">is</span> 0;         <span class="comment"># 2 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: last_mod_file_date              <span class="keywd">is</span> DOS_EPOCH; <span class="comment"># 2 bytes</span>
    <span class="keywd">var</span> <span class="type">bin32</span>:   crc_32                          <span class="keywd">is</span> bin32(0);  <span class="comment"># 4 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: compressed_size                 <span class="keywd">is</span> 0;         <span class="comment"># 4 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: uncompressed_size               <span class="keywd">is</span> 0;         <span class="comment"># 4 bytes</span>
    <span class="comment">#   integer: file_name_length                is 0;         # 2 bytes</span>
    <span class="comment">#   integer: extra_field_length              is 0;         # 2 bytes</span>
    <span class="comment">#   integer: file_comment_length             is 0;         # 2 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: disk_number_start               <span class="keywd">is</span> 0;         <span class="comment"># 2 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: internal_file_attributes        <span class="keywd">is</span> 0;         <span class="comment"># 2 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: external_file_attributes        <span class="keywd">is</span> 0;         <span class="comment"># 4 bytes</span>
    <span class="keywd">var</span> <span class="type">integer</span>: relative_offset_of_local_header <span class="keywd">is</span> 0;         <span class="comment"># 4 bytes</span>
    <span class="keywd">var</span> <span class="type">string</span>: file_name                        <span class="keywd">is</span> <span class="stri">""</span>;        <span class="comment"># variable size</span>
    <span class="keywd">var</span> <span class="type">string</span>: extra_field                      <span class="keywd">is</span> <span class="stri">""</span>;        <span class="comment"># variable size</span>
    <span class="keywd">var</span> <span class="type">string</span>: file_comment                     <span class="keywd">is</span> <span class="stri">""</span>;        <span class="comment"># variable size</span>
    <span class="keywd">var</span> <span class="type">string</span>: filePath <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">zipExtraFieldType</span>: extraFieldMap <span class="keywd">is</span> zipExtraFieldType.value;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: write (<span class="op">in</span> <span class="type">central_file_header</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"signature: "</span>                       <span class="op">rpad</span> 45 &lt;&amp; literal(header.signature) <span class="op">lpad</span> 16);
    writeln(<span class="stri">"version_made_by: "</span>                 <span class="op">rpad</span> 45 &lt;&amp; (header.version_made_by radix 16 <span class="op">lpad0</span> 4) <span class="op">lpad</span> 16);
    writeln(<span class="stri">"version_needed_to_extract: "</span>       <span class="op">rpad</span> 45 &lt;&amp; header.version_needed_to_extract <span class="op">lpad</span> 16);
    writeln(<span class="stri">"general_purpose_bit_flag: "</span>        <span class="op">rpad</span> 45 &lt;&amp; header.general_purpose_bit_flag radix 2 <span class="op">lpad0</span> 16);
    writeln(<span class="stri">"compression_method: "</span>              <span class="op">rpad</span> 45 &lt;&amp; header.compression_method <span class="op">lpad</span> 16);
    writeln(<span class="stri">"last_mod_file_time: "</span>              <span class="op">rpad</span> 45 &lt;&amp; header.last_mod_file_time <span class="op">lpad</span> 16);
    writeln(<span class="stri">"last_mod_file_date: "</span>              <span class="op">rpad</span> 45 &lt;&amp; header.last_mod_file_date <span class="op">lpad</span> 16);
    writeln(<span class="stri">"crc_32: "</span>                          <span class="op">rpad</span> 45 &lt;&amp; header.crc_32 <span class="op">lpad</span> 16);
    writeln(<span class="stri">"compressed_size: "</span>                 <span class="op">rpad</span> 45 &lt;&amp; header.compressed_size <span class="op">lpad</span> 16);
    writeln(<span class="stri">"uncompressed_size: "</span>               <span class="op">rpad</span> 45 &lt;&amp; header.uncompressed_size <span class="op">lpad</span> 16);
    writeln(<span class="stri">"file_name_length: "</span>                <span class="op">rpad</span> 45 &lt;&amp; length(header.file_name) <span class="op">lpad</span> 16);
    writeln(<span class="stri">"extra_field_length: "</span>              <span class="op">rpad</span> 45 &lt;&amp; length(header.extra_field) <span class="op">lpad</span> 16);
    writeln(<span class="stri">"file_comment_length: "</span>             <span class="op">rpad</span> 45 &lt;&amp; length(header.file_comment) <span class="op">lpad</span> 16);
    writeln(<span class="stri">"disk_number_start: "</span>               <span class="op">rpad</span> 45 &lt;&amp; header.disk_number_start <span class="op">lpad</span> 16);
    writeln(<span class="stri">"internal_file_attributes: "</span>        <span class="op">rpad</span> 45 &lt;&amp; header.internal_file_attributes <span class="op">lpad</span> 16);
    writeln(<span class="stri">"external_file_attributes: "</span>        <span class="op">rpad</span> 45 &lt;&amp; header.external_file_attributes radix 16 <span class="op">lpad</span> 16);
    writeln(<span class="stri">"relative_offset_of_local_header: "</span> <span class="op">rpad</span> 45 &lt;&amp; header.relative_offset_of_local_header <span class="op">lpad</span> 16);
    writeln(<span class="stri">"file_name: "</span>                       <span class="op">rpad</span> 45 &lt;&amp; literal(header.file_name) <span class="op">lpad</span> 16);
    writeln(<span class="stri">"extra_field: "</span>                     <span class="op">rpad</span> 45 &lt;&amp; literal(header.extra_field) <span class="op">lpad</span> 16);
    writeExtraField(header.extra_field);
    writeln(<span class="stri">"file_comment: "</span>                    <span class="op">rpad</span> 45 &lt;&amp; literal(header.file_comment) <span class="op">lpad</span> 16);
    writeln(<span class="stri">"filePath: "</span>                        <span class="op">rpad</span> 45 &lt;&amp; header.filePath);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: considerZip64ExtraField (<span class="keywd">inout</span> <span class="type">central_file_header</span>: header,
    <span class="op">in</span> <span class="type">string</span>: zip64ExtraField) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> header.uncompressed_size = 16#ffffffff <span class="op">and</span> length(zip64ExtraField) >= pos + 7 <span class="keywd">then</span>
      header.uncompressed_size := bytes2Int(zip64ExtraField[pos fixLen 8], UNSIGNED, LE);
      <span class="comment"># writeln("uncompressed_size: " &lt;&amp; header.uncompressed_size);</span>
      pos +:= 8;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> header.compressed_size = 16#ffffffff <span class="op">and</span> length(zip64ExtraField) >= pos + 7 <span class="keywd">then</span>
      header.compressed_size := bytes2Int(zip64ExtraField[pos fixLen 8], UNSIGNED, LE);
      <span class="comment"># writeln("compressed_size: " &lt;&amp; header.compressed_size);</span>
      pos +:= 8;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> header.relative_offset_of_local_header = 16#ffffffff <span class="op">and</span> length(zip64ExtraField) >= pos + 7 <span class="keywd">then</span>
      header.relative_offset_of_local_header := bytes2Int(zip64ExtraField[pos fixLen 8], UNSIGNED, LE);
      <span class="comment"># writeln("relative_offset_of_local_header: " &lt;&amp; header.relative_offset_of_local_header);</span>
      pos +:= 8;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> header.disk_number_start = 16#ffff <span class="op">and</span> length(zip64ExtraField) >= pos + 3 <span class="keywd">then</span>
      header.disk_number_start := bytes2Int(zip64ExtraField[pos fixLen 4], UNSIGNED, LE);
      <span class="comment"># writeln("disk_number_start: " &lt;&amp; header.disk_number_start);</span>
      pos +:= 4;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">central_file_header</span>: get_central_header (<span class="keywd">inout</span> <span class="type">file</span>: inFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: file_name_length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: extra_field_length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: file_comment_length <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    stri := gets(inFile, ZIP_CENTRAL_HEADER_FIXED_SIZE);
    <span class="keywd">if</span> length(stri) = ZIP_CENTRAL_HEADER_FIXED_SIZE <span class="op">and</span>
        stri[.. 4] = ZIP_CENTRAL_HEADER_SIGNATURE <span class="keywd">then</span>
      header.signature := ZIP_CENTRAL_HEADER_SIGNATURE;
      header.version_made_by                 := bytes2Int(stri[ 5 fixLen 2], UNSIGNED, LE);
      header.version_needed_to_extract       := bytes2Int(stri[ 7 fixLen 2], UNSIGNED, LE);
      header.general_purpose_bit_flag  := bin32(bytes2Int(stri[ 9 fixLen 2], UNSIGNED, LE));
      header.compression_method              := bytes2Int(stri[11 fixLen 2], UNSIGNED, LE);
      header.last_mod_file_time              := bytes2Int(stri[13 fixLen 2], UNSIGNED, LE);
      header.last_mod_file_date              := bytes2Int(stri[15 fixLen 2], UNSIGNED, LE);
      header.crc_32                    := bin32(bytes2Int(stri[17 fixLen 4], UNSIGNED, LE));
      header.compressed_size                 := bytes2Int(stri[21 fixLen 4], UNSIGNED, LE);
      header.uncompressed_size               := bytes2Int(stri[25 fixLen 4], UNSIGNED, LE);
      file_name_length                       := bytes2Int(stri[29 fixLen 2], UNSIGNED, LE);
      extra_field_length                     := bytes2Int(stri[31 fixLen 2], UNSIGNED, LE);
      file_comment_length                    := bytes2Int(stri[33 fixLen 2], UNSIGNED, LE);
      header.disk_number_start               := bytes2Int(stri[35 fixLen 2], UNSIGNED, LE);
      header.internal_file_attributes        := bytes2Int(stri[37 fixLen 2], UNSIGNED, LE);
      header.external_file_attributes        := bytes2Int(stri[39 fixLen 4], UNSIGNED, LE);
      header.relative_offset_of_local_header := bytes2Int(stri[43 fixLen 4], UNSIGNED, LE);
      header.file_name                       := gets(inFile, file_name_length);
      header.extra_field                     := gets(inFile, extra_field_length);
      header.file_comment                    := gets(inFile, file_comment_length);
      header.extraFieldMap := getExtraFieldMap(header.extra_field);
      <span class="keywd">if</span> header.general_purpose_bit_flag &amp; ZIP_FILE_NAME_IS_UTF8 &lt;> bin32(0) <span class="keywd">then</span>
        <span class="keywd">block</span>
          header.filePath:= fromUtf8(header.file_name);
        exception
          catch RANGE_ERROR:
            header.filePath := header.file_name;
        <span class="keywd">end</span> <span class="keywd">block</span>;
      <span class="keywd">else</span>
        header.filePath := header.file_name;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> header.filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(header.filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
        header.filePath := header.filePath[.. pred(length(header.filePath))];
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> ZIP64_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
        considerZip64ExtraField(header, header.extraFieldMap[ZIP64_EXTRA_FIELD]);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="comment"># write(header);</span>
      <span class="comment"># writeExtraField(header.extra_field);</span>
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">central_file_header</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := ZIP_CENTRAL_HEADER_SIGNATURE &amp;
            bytes(       header.version_made_by,                 UNSIGNED, LE, 2) &amp;
            bytes(       header.version_needed_to_extract,       UNSIGNED, LE, 2) &amp;
            bytes(   ord(header.general_purpose_bit_flag),       UNSIGNED, LE, 2) &amp;
            bytes(       header.compression_method,              UNSIGNED, LE, 2) &amp;
            bytes(       header.last_mod_file_time,              UNSIGNED, LE, 2) &amp;
            bytes(       header.last_mod_file_date,              UNSIGNED, LE, 2) &amp;
            bytes(   ord(header.crc_32),                         UNSIGNED, LE, 4) &amp;
            bytes(       header.compressed_size,                 UNSIGNED, LE, 4) &amp;
            bytes(       header.uncompressed_size,               UNSIGNED, LE, 4) &amp;
            bytes(length(header.file_name),                      UNSIGNED, LE, 2) &amp;
            bytes(length(header.extra_field),                    UNSIGNED, LE, 2) &amp;
            bytes(length(header.file_comment),                   UNSIGNED, LE, 2) &amp;
            bytes(       header.disk_number_start,               UNSIGNED, LE, 2) &amp;
            bytes(       header.internal_file_attributes,        UNSIGNED, LE, 2) &amp;
            bytes(       header.external_file_attributes,        UNSIGNED, LE, 4) &amp;
            bytes(       header.relative_offset_of_local_header, UNSIGNED, LE, 4) &amp;
            header.file_name &amp;
            header.extra_field &amp;
            header.file_comment;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: writeHead (<span class="keywd">inout</span> <span class="type">file</span>: outFile, <span class="op">in</span> <span class="type">central_file_header</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    write(outFile, str(header));
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getCentralHeaderFilePath (<span class="keywd">inout</span> <span class="type">file</span>: inFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: filePath <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">bin32</span>: general_purpose_bit_flag <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <span class="type">integer</span>: file_name_length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: extra_field_length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: file_comment_length <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    stri := gets(inFile, ZIP_CENTRAL_HEADER_FIXED_SIZE);
    <span class="keywd">if</span> length(stri) = ZIP_CENTRAL_HEADER_FIXED_SIZE <span class="op">and</span>
        stri[.. 4] = ZIP_CENTRAL_HEADER_SIGNATURE <span class="keywd">then</span>
      general_purpose_bit_flag  := bin32(bytes2Int(stri[ 9 fixLen 2], UNSIGNED, LE));
      file_name_length                := bytes2Int(stri[29 fixLen 2], UNSIGNED, LE);
      extra_field_length              := bytes2Int(stri[31 fixLen 2], UNSIGNED, LE);
      file_comment_length             := bytes2Int(stri[33 fixLen 2], UNSIGNED, LE);
      filePath := gets(inFile, file_name_length);
      <span class="comment"># seek(inFile, tell(inFile) + extra_field_length + file_comment_length);</span>
      ignore(gets(inFile, extra_field_length + file_comment_length));
      <span class="keywd">if</span> general_purpose_bit_flag &amp; ZIP_FILE_NAME_IS_UTF8 &lt;> bin32(0) <span class="keywd">then</span>
        <span class="keywd">block</span>
          filePath := fromUtf8(filePath);
        exception
          catch RANGE_ERROR: noop;
        <span class="keywd">end</span> <span class="keywd">block</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
        filePath := filePath[.. pred(length(filePath))];
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">local_file_header</span>: toLocalHeader (<span class="op">in</span> <span class="type">central_file_header</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">local_file_header</span>: localHeader <span class="keywd">is</span> local_file_header.value;
  <span class="keywd">begin</span>
    localHeader.signature                 := ZIP_LOCAL_HEADER_SIGNATURE;
    localHeader.version_needed_to_extract := header.version_needed_to_extract;
    localHeader.general_purpose_bit_flag  := header.general_purpose_bit_flag;
    localHeader.compression_method        := header.compression_method;
    localHeader.last_mod_file_time        := header.last_mod_file_time;
    localHeader.last_mod_file_date        := header.last_mod_file_date;
    localHeader.crc_32                    := header.crc_32;
    localHeader.compressed_size           := header.compressed_size;
    localHeader.uncompressed_size         := header.uncompressed_size;
    localHeader.file_name                 := header.file_name;
    localHeader.extra_field               := header.extra_field;
    <span class="comment"># write(localHeader);</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: updateLocalHeader (<span class="keywd">inout</span> <span class="type">local_file_header</span>: localHeader,
    <span class="op">in</span> <span class="type">central_file_header</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    localHeader.compression_method := header.compression_method;
    localHeader.last_mod_file_time := header.last_mod_file_time;
    localHeader.last_mod_file_date := header.last_mod_file_date;
    localHeader.crc_32             := header.crc_32;
    localHeader.compressed_size    := header.compressed_size;
    localHeader.uncompressed_size  := header.uncompressed_size;
    <span class="comment"># write(localHeader);</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: initLastModFileTime (<span class="keywd">inout</span> <span class="type">central_file_header</span>: header,
    <span class="op">in</span> <span class="type">time</span>: modificationTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: timestamp <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: unixExtraField <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    timestamp := timestamp1970(modificationTime);
    unixExtraField :=
        bytes(timestamp, UNSIGNED, LE, 4) <span class="op">mult</span> 2 &amp;
        bytes(        0, UNSIGNED, LE, 2) <span class="op">mult</span> 2;
    header.extraFieldMap @:= [ZIP_UNIX_EXTRA_FIELD] unixExtraField;
    header.extra_field := extraFieldFromMap(header.extraFieldMap);
    header.last_mod_file_time := (modificationTime.hour &lt;&lt; 11) +
                                 (modificationTime.minute &lt;&lt; 5) +
                                 (modificationTime.second >> 1);
    header.last_mod_file_date := ((modificationTime.year - 1980) &lt;&lt; 9) +
                                  (modificationTime.month &lt;&lt; 5) +
                                   modificationTime.day;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: assignLastModFileTime (<span class="keywd">inout</span> <span class="type">local_file_header</span>: localHeader,
    <span class="op">in</span> <span class="type">time</span>: modificationTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: timestamp <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> ZIP_EXTENDED_TIMESTAMP_EXTRA_FIELD <span class="op">in</span> localHeader.extraFieldMap <span class="keywd">then</span>
      timestamp := timestamp1970(modificationTime);
      localHeader.extraFieldMap[ZIP_EXTENDED_TIMESTAMP_EXTRA_FIELD] @:=
          [2] bytes(timestamp, UNSIGNED, LE, 4);
      localHeader.extra_field := extraFieldFromMap(localHeader.extraFieldMap);
    <span class="keywd">elsif</span> ZIP_UNIX_EXTRA_FIELD <span class="op">in</span> localHeader.extraFieldMap <span class="keywd">then</span>
      timestamp := timestamp1970(modificationTime);
      <span class="comment"># Update last access time and modification time.</span>
      localHeader.extraFieldMap[ZIP_UNIX_EXTRA_FIELD] @:=
          [1] bytes(timestamp, UNSIGNED, LE, 4) <span class="op">mult</span> 2;
      localHeader.extra_field := extraFieldFromMap(localHeader.extraFieldMap);
    <span class="keywd">elsif</span> ZIP_NTFS_EXTRA_FIELD <span class="op">in</span> localHeader.extraFieldMap <span class="keywd">then</span>
      timestamp := timestamp1601(modificationTime);
      localHeader.extraFieldMap[ZIP_NTFS_EXTRA_FIELD] @:=
          [9] bytes(timestamp, UNSIGNED, LE, 8);
      localHeader.extra_field := extraFieldFromMap(localHeader.extraFieldMap);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    localHeader.last_mod_file_time := (modificationTime.hour &lt;&lt; 11) +
                                      (modificationTime.minute &lt;&lt; 5) +
                                      (modificationTime.second >> 1);
    localHeader.last_mod_file_date := ((modificationTime.year - 1980) &lt;&lt; 9) +
                                       (modificationTime.month &lt;&lt; 5) +
                                        modificationTime.day;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: assignLastModFileTime (<span class="keywd">inout</span> <span class="type">central_file_header</span>: header,
    <span class="op">in</span> <span class="type">time</span>: modificationTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: timestamp <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> ZIP_EXTENDED_TIMESTAMP_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
      timestamp := timestamp1970(modificationTime);
      header.extraFieldMap[ZIP_EXTENDED_TIMESTAMP_EXTRA_FIELD] @:=
          [2] bytes(timestamp, UNSIGNED, LE, 4);
      header.extra_field := extraFieldFromMap(header.extraFieldMap);
    <span class="keywd">elsif</span> ZIP_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
      timestamp := timestamp1970(modificationTime);
      <span class="comment"># Update last access time and modification time.</span>
      header.extraFieldMap[ZIP_UNIX_EXTRA_FIELD] @:=
          [1] bytes(timestamp, UNSIGNED, LE, 4) <span class="op">mult</span> 2;
      header.extra_field := extraFieldFromMap(header.extraFieldMap);
    <span class="keywd">elsif</span> ZIP_NTFS_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
      timestamp := timestamp1601(modificationTime);
      header.extraFieldMap[ZIP_NTFS_EXTRA_FIELD] @:=
          [9] bytes(timestamp, UNSIGNED, LE, 8);
      header.extra_field := extraFieldFromMap(header.extraFieldMap);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    header.last_mod_file_time := (modificationTime.hour &lt;&lt; 11) +
                                 (modificationTime.minute &lt;&lt; 5) +
                                 (modificationTime.second >> 1);
    header.last_mod_file_date := ((modificationTime.year - 1980) &lt;&lt; 9) +
                                  (modificationTime.month &lt;&lt; 5) +
                                   modificationTime.day;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: assignUserId (<span class="keywd">inout</span> <span class="type">local_file_header</span>: localHeader,
    <span class="op">in</span> <span class="type">integer</span>: uid) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: size <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> ZIP_UNIX_EXTRA_FIELD <span class="op">in</span> localHeader.extraFieldMap <span class="keywd">then</span>
      localHeader.extraFieldMap[ZIP_UNIX_EXTRA_FIELD] @:=
          [9] bytes(uid, UNSIGNED, LE, 2);
      localHeader.extra_field := extraFieldFromMap(localHeader.extraFieldMap);
    <span class="keywd">elsif</span> ZIP_ASI_UNIX_EXTRA_FIELD <span class="op">in</span> localHeader.extraFieldMap <span class="keywd">then</span>
      localHeader.extraFieldMap[ZIP_ASI_UNIX_EXTRA_FIELD] @:=
          [11] bytes(uid, UNSIGNED, LE, 2);
      localHeader.extra_field := extraFieldFromMap(localHeader.extraFieldMap);
    <span class="keywd">elsif</span> ZIP_NEW_UNIX_EXTRA_FIELD <span class="op">in</span> localHeader.extraFieldMap <span class="keywd">then</span>
      size := ord(localHeader.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD][2]);
      localHeader.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD] @:=
          [3] bytes(uid, UNSIGNED, LE, size);
      localHeader.extra_field := extraFieldFromMap(localHeader.extraFieldMap);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: assignUserId (<span class="keywd">inout</span> <span class="type">central_file_header</span>: header,
    <span class="op">in</span> <span class="type">integer</span>: uid) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: size <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> ZIP_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
      header.extraFieldMap[ZIP_UNIX_EXTRA_FIELD] @:=
          [9] bytes(uid, UNSIGNED, LE, 2);
      header.extra_field := extraFieldFromMap(header.extraFieldMap);
    <span class="keywd">elsif</span> ZIP_ASI_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
      header.extraFieldMap[ZIP_ASI_UNIX_EXTRA_FIELD] @:=
          [11] bytes(uid, UNSIGNED, LE, 2);
      header.extra_field := extraFieldFromMap(header.extraFieldMap);
    <span class="keywd">elsif</span> ZIP_NEW_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
      size := ord(header.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD][2]);
      header.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD] @:=
          [3] bytes(uid, UNSIGNED, LE, size);
      header.extra_field := extraFieldFromMap(header.extraFieldMap);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: assignGroupId (<span class="keywd">inout</span> <span class="type">local_file_header</span>: localHeader,
    <span class="op">in</span> <span class="type">integer</span>: gid) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: size <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> ZIP_UNIX_EXTRA_FIELD <span class="op">in</span> localHeader.extraFieldMap <span class="keywd">then</span>
      localHeader.extraFieldMap[ZIP_UNIX_EXTRA_FIELD] @:=
          [11] bytes(gid, UNSIGNED, LE, 2);
      localHeader.extra_field := extraFieldFromMap(localHeader.extraFieldMap);
    <span class="keywd">elsif</span> ZIP_ASI_UNIX_EXTRA_FIELD <span class="op">in</span> localHeader.extraFieldMap <span class="keywd">then</span>
      localHeader.extraFieldMap[ZIP_ASI_UNIX_EXTRA_FIELD] @:=
          [13] bytes(gid, UNSIGNED, LE, 2);
      localHeader.extra_field := extraFieldFromMap(localHeader.extraFieldMap);
    <span class="keywd">elsif</span> ZIP_NEW_UNIX_EXTRA_FIELD <span class="op">in</span> localHeader.extraFieldMap <span class="keywd">then</span>
      pos := 3 + ord(localHeader.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD][2]);
      size := ord(localHeader.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD][pos]);
      localHeader.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD] @:=
          [succ(pos)] bytes(gid, UNSIGNED, LE, size);
      localHeader.extra_field := extraFieldFromMap(localHeader.extraFieldMap);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: assignGroupId (<span class="keywd">inout</span> <span class="type">central_file_header</span>: header,
    <span class="op">in</span> <span class="type">integer</span>: gid) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: size <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> ZIP_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
      header.extraFieldMap[ZIP_UNIX_EXTRA_FIELD] @:=
          [11] bytes(gid, UNSIGNED, LE, 2);
      header.extra_field := extraFieldFromMap(header.extraFieldMap);
    <span class="keywd">elsif</span> ZIP_ASI_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
      header.extraFieldMap[ZIP_ASI_UNIX_EXTRA_FIELD] @:=
          [13] bytes(gid, UNSIGNED, LE, 2);
      header.extra_field := extraFieldFromMap(header.extraFieldMap);
    <span class="keywd">elsif</span> ZIP_NEW_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
      pos := 3 + ord(header.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD][2]);
      size := ord(header.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD][pos]);
      header.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD] @:=
          [succ(pos)] bytes(gid, UNSIGNED, LE, size);
      header.extra_field := extraFieldFromMap(header.extraFieldMap);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: zipCatalogType <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">string</span><span class="type">]</span> <span class="type">central_file_header</span>;
<span class="keywd">const</span> <span class="type">type</span>: zipReferenceMapType <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">bin32</span><span class="type">]</span> <span class="type">array</span> integer;


<span class="comment">(**
 *  [[filesys#fileSys|FileSys]] implementation type to access ZIP and JAR archives.
 *  The zip file system does not support the concept of a current
 *  working directory. The functions chdir and getcwd are not supported
 *  by the zip file system. The root path of a zip file system is "".
 *)</span>
<span class="keywd">const</span> <span class="type">type</span>: zipArchive <span class="keywd">is</span> <span class="keywd">sub</span> emptyFileSys <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">file</span>: zipFile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">archiveRegisterType</span>: register <span class="keywd">is</span> archiveRegisterType.value;
    <span class="keywd">var</span> <span class="type">zipCatalogType</span>: catalog <span class="keywd">is</span> zipCatalogType.value;
    <span class="keywd">var</span> <span class="type">zipReferenceMapType</span>: fileReferenceMap <span class="keywd">is</span> zipReferenceMapType.value;
    <span class="keywd">var</span> <span class="type">end_of_central_directory</span>: endOfCentralDir <span class="keywd">is</span> end_of_central_directory.value;
    <span class="keywd">var</span> <span class="type">integer</span>: endOfCentralDirPos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: startOfCentralDirPos <span class="keywd">is</span> 1;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="comment">(**
 *  Open a ZIP archive with the given zipFile.
 *  @param zipFile File that contains a ZIP archive.
 *  @return a file system that accesses the ZIP archive, or
 *          fileSys.value if it could not be opened.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">fileSys</span>: openZip (<span class="keywd">inout</span> <span class="type">file</span>: zipFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fileSys</span>: newFileSys <span class="keywd">is</span> fileSys.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: magic <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">end_of_central_directory</span>: endOfCentralDir <span class="keywd">is</span> end_of_central_directory.value;
    <span class="keywd">var</span> <span class="type">integer</span>: endOfCentralDirPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: centralHeaderPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: filePath <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">zipArchive</span>: zip <span class="keywd">is</span> zipArchive.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(zipFile) = 0 <span class="keywd">then</span>
      zip.zipFile := zipFile;
      zip.endOfCentralDir.signature := ZIP_END_OF_CENTRAL_DIRECTORY_SIGNATURE;
      newFileSys := toInterface(zip);
    <span class="keywd">else</span>
      seek(zipFile, 1);
      magic := gets(zipFile, length(ZIP_LOCAL_HEADER_SIGNATURE));
      <span class="keywd">if</span> magic = ZIP_LOCAL_HEADER_SIGNATURE <span class="op">or</span>
          magic = ZIP_END_OF_CENTRAL_DIRECTORY_SIGNATURE <span class="keywd">then</span>
        endOfCentralDir := readEndOfCentralDir(zipFile, endOfCentralDirPos);
        <span class="keywd">if</span> endOfCentralDir.signature = ZIP_END_OF_CENTRAL_DIRECTORY_SIGNATURE <span class="keywd">then</span>
          zip.zipFile := zipFile;
          zip.endOfCentralDir := endOfCentralDir;
          zip.endOfCentralDirPos := endOfCentralDirPos;
          zip.startOfCentralDirPos := succ(endOfCentralDir.offset_of_start_of_central_directory);
          <span class="comment"># writeln("startOfCentralDirPos: " &lt;&amp; zip.startOfCentralDirPos);</span>
          centralHeaderPos := zip.startOfCentralDirPos;
          seek(zip.zipFile, centralHeaderPos);
          filePath := getCentralHeaderFilePath(zip.zipFile);
          <span class="keywd">while</span> filePath &lt;> <span class="stri">""</span> <span class="keywd">do</span>
            <span class="comment"># writeln(filePath &lt;&amp; " " &lt;&amp; centralHeaderPos);</span>
            zip.register @:= [filePath] centralHeaderPos;
            centralHeaderPos := tell(zip.zipFile);
            filePath := getCentralHeaderFilePath(zip.zipFile);
          <span class="keywd">end</span> <span class="keywd">while</span>;
          newFileSys := toInterface(zip);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Open a ZIP archive with the given zipFileName.
 *  @param zipFileName Name of the ZIP archive to be opened.
 *  @return a file system that accesses the ZIP archive, or
 *          fileSys.value if it could not be opened.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">fileSys</span>: openZip (<span class="op">in</span> <span class="type">string</span>: zipFileName) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fileSys</span>: zip <span class="keywd">is</span> fileSys.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">file</span>: zipFile <span class="keywd">is</span> STD_NULL;
  <span class="keywd">begin</span>
    zipFile := open(zipFileName, <span class="stri">"r"</span>);
    zip := openZip(zipFile);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Close a ZIP archive. The ZIP file below stays open.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: close (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    zip := zipArchive.value;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">central_file_header</span>: addToCatalog (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
  <span class="keywd">begin</span>
    seek(zip.zipFile, zip.register[filePath]);
    header := get_central_header(zip.zipFile);
    zip.catalog @:= [filePath] header;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">central_file_header</span>: addImplicitDir (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip,
    <span class="op">in</span> <span class="type">string</span>: dirPath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
  <span class="keywd">begin</span>
    header.file_name := dirPath &amp; <span class="stri">"/"</span>;
    header.filePath := dirPath;
    header.relative_offset_of_local_header := -1;
    zip.catalog @:= [dirPath] header;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isRegularFile (<span class="op">in</span> <span class="type">central_file_header</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: isRegularFile <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> header.relative_offset_of_local_header &lt;> -1 <span class="keywd">then</span>
      <span class="comment"># It is not an implicit directory.</span>
      <span class="keywd">if</span> header.version_made_by >> 8 = ZIP_HOST_SYSTEM_UNIX <span class="keywd">then</span>
        isRegularFile := bin32(header.external_file_attributes >> 16) &amp;
                         MODE_FILE_TYPE_MASK = MODE_FILE_REGULAR;
      <span class="keywd">else</span>
        isRegularFile := <span class="op">not</span> endsWith(header.file_name, <span class="stri">"/"</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isSymlink (<span class="op">in</span> <span class="type">central_file_header</span>: header) <span class="keywd">is</span>
  <span class="keywd">return</span> header.version_made_by >> 8 = ZIP_HOST_SYSTEM_UNIX <span class="op">and</span>
            bin32(header.external_file_attributes >> 16) &amp;
                MODE_FILE_TYPE_MASK = MODE_FILE_SYMLINK;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: followSymlink (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: filePath,
    <span class="keywd">inout</span> <span class="type">central_file_header</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: missingPath <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: symlinkCount <span class="keywd">is</span> MAX_SYMLINK_CHAIN_LENGTH;
    <span class="keywd">var</span> <span class="type">boolean</span>: isSymlink <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">local_file_header</span>: localHeader <span class="keywd">is</span> local_file_header.value;
    <span class="keywd">var</span> <span class="type">string</span>: targetPath <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("followSymlink: " &lt;&amp; filePath);</span>
    <span class="keywd">repeat</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> zip.catalog <span class="keywd">then</span>
        header := zip.catalog[filePath];
      <span class="keywd">elsif</span> filePath <span class="op">in</span> zip.register <span class="keywd">then</span>
        header := addToCatalog(zip, filePath);
      <span class="keywd">elsif</span> implicitDir(zip.register, filePath) <span class="keywd">then</span>
        header := addImplicitDir(zip, filePath);
      <span class="keywd">else</span>
        <span class="comment"># The file does not exist.</span>
        missingPath := filePath;
        isSymlink := FALSE;
        <span class="comment"># writeln("missing: " &lt;&amp; missingPath);</span>
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> missingPath = <span class="stri">""</span> <span class="keywd">then</span>
        <span class="keywd">if</span> isSymlink(header) <span class="keywd">then</span>
          decr(symlinkCount);
          seek(zip.zipFile, succ(header.relative_offset_of_local_header));
          localHeader := get_local_header(zip.zipFile);
          <span class="comment"># write(localHeader);</span>
          <span class="keywd">if</span> localHeader.compression_method = ZIP_STORE <span class="keywd">then</span>
            <span class="comment"># The link destination is stored (no compression).</span>
            targetPath := gets(zip.zipFile, localHeader.compressed_size);
            filePath := symlinkDestination(filePath, targetPath);
          <span class="keywd">else</span>
            <span class="comment"># writeln("unsupported compression method: " &lt;&amp; localHeader.compression_method);</span>
            raise FILE_ERROR;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          isSymlink := FALSE;
          <span class="comment"># writeln("found: " &lt;&amp; header.filePath);</span>
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> <span class="op">not</span> isSymlink <span class="op">or</span> symlinkCount &lt; 0;
    <span class="keywd">if</span> isSymlink <span class="keywd">then</span>
      <span class="comment"># Too many symbolic links.</span>
      raise FILE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">central_file_header</span>: followSymlink (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: missingPath <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    missingPath := followSymlink(zip, filePath, header);
    <span class="keywd">if</span> missingPath &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      <span class="comment"># The file does not exist.</span>
      raise FILE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: fixRegisterAndCatalog (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">integer</span>: insertPos,
    <span class="op">in</span> <span class="type">integer</span>: numChars) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: headerPos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">string</span>: filePath <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> <span class="keywd">key</span> filePath <span class="keywd">range</span> zip.register <span class="keywd">do</span>
      <span class="keywd">if</span> zip.register[filePath] >= insertPos <span class="keywd">then</span>
        zip.register[filePath] +:= numChars;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> <span class="keywd">key</span> filePath <span class="keywd">range</span> zip.catalog <span class="keywd">do</span>
      <span class="keywd">if</span> succ(zip.catalog[filePath].relative_offset_of_local_header) >= insertPos <span class="keywd">then</span>
        zip.catalog[filePath].relative_offset_of_local_header +:= numChars;
        seek(zip.zipFile, zip.register[filePath]);
        writeHead(zip.zipFile, zip.catalog[filePath]);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> zip.startOfCentralDirPos >= insertPos <span class="keywd">then</span>
      zip.startOfCentralDirPos +:= numChars;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> zip.endOfCentralDirPos >= insertPos <span class="keywd">then</span>
      zip.endOfCentralDirPos +:= numChars;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: initializeFileReferenceMap (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: centralHeaderPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: compression_method <span class="keywd">is</span> ZIP_STORE;
    <span class="keywd">var</span> <span class="type">bin32</span>: crc_32 <span class="keywd">is</span> bin32(0);
  <span class="keywd">begin</span>
    <span class="keywd">for</span> centralHeaderPos <span class="keywd">range</span> sort(values(zip.register)) <span class="keywd">do</span>
      seek(zip.zipFile, centralHeaderPos);
      stri := gets(zip.zipFile, ZIP_CENTRAL_HEADER_FIXED_SIZE);
      <span class="keywd">if</span> length(stri) = ZIP_CENTRAL_HEADER_FIXED_SIZE <span class="op">and</span>
          stri[.. 4] = ZIP_CENTRAL_HEADER_SIGNATURE <span class="keywd">then</span>
        compression_method       := bytes2Int(stri[11 fixLen 2], UNSIGNED, LE);
        crc_32             := bin32(bytes2Int(stri[17 fixLen 4], UNSIGNED, LE));
        <span class="keywd">if</span> compression_method &lt;> ZIP_REFERENCE <span class="keywd">then</span>
          <span class="keywd">if</span> crc_32 <span class="op">in</span> zip.fileReferenceMap <span class="keywd">then</span>
            zip.fileReferenceMap[crc_32] &amp;:= centralHeaderPos;
          <span class="keywd">else</span>
            zip.fileReferenceMap @:= [crc_32] [] (centralHeaderPos);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: getReferencePaths (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip,
    <span class="op">in</span> <span class="type">bin32</span>: crc_32) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: filePathList <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: centralHeaderPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(zip.fileReferenceMap) = 0 <span class="keywd">then</span>
      initializeFileReferenceMap(zip);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> crc_32 <span class="op">in</span> zip.fileReferenceMap <span class="keywd">then</span>
      <span class="keywd">for</span> centralHeaderPos <span class="keywd">range</span> zip.fileReferenceMap[crc_32] <span class="keywd">do</span>
        seek(zip.zipFile, centralHeaderPos);
        filePathList &amp;:= getCentralHeaderFilePath(zip.zipFile);
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the file names in a directory inside a ZIP archive.
 *  Note that the function returns only the file names.
 *  Additional information must be obtained with other calls.
 *  @param zip Open ZIP archive.
 *  @param dirPath Path of a directory in the ZIP archive.
 *  @return an array with the file names.
 *  @exception RANGE_ERROR ''dirPath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''dirPath'' is not present in the ZIP archive.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: readDir (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: dirPath) <span class="keywd">is</span>
  <span class="keywd">return</span> readDir(zip.register, dirPath);


<span class="comment">(**
 *  Determine the file paths in a ZIP archive.
 *  Note that the function returns only the file paths.
 *  Additional information must be obtained with other calls.
 *  @param zip Open ZIP archive.
 *  @return an array with the file paths.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">string</span>: readDir (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, RECURSIVE) <span class="keywd">is</span>
  <span class="keywd">return</span> sort(keys(zip.register));


<span class="comment">(**
 *  Determine the type of a file in a ZIP archive.
 *  The function follows symbolic links. If the chain of
 *  symbolic links is too long the function returns ''FILE_SYMLINK''.
 *  A return value of ''FILE_ABSENT'' does not imply that a file
 *  with this name can be created, since missing directories and
 *  invalid file names cause also ''FILE_ABSENT''.
 *  @return the type of the file.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">fileType</span>: fileType (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fileType</span>: aFileType <span class="keywd">is</span> FILE_UNKNOWN;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">local_file_header</span>: localHeader <span class="keywd">is</span> local_file_header.value;
    <span class="keywd">var</span> <span class="type">integer</span>: symlinkCount <span class="keywd">is</span> MAX_SYMLINK_CHAIN_LENGTH;
    <span class="keywd">var</span> <span class="type">boolean</span>: isSymlink <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">string</span>: targetPath <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("fileType: " &lt;&amp; filePath);</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath = <span class="stri">""</span> <span class="keywd">then</span>
      aFileType := FILE_DIR;
    <span class="keywd">else</span>
      <span class="keywd">repeat</span>
        isSymlink := FALSE;
        <span class="keywd">if</span> filePath <span class="op">in</span> zip.catalog <span class="keywd">then</span>
          header := zip.catalog[filePath];
        <span class="keywd">elsif</span> filePath <span class="op">in</span> zip.register <span class="keywd">then</span>
          header := addToCatalog(zip, filePath);
        <span class="keywd">elsif</span> implicitDir(zip.register, filePath) <span class="keywd">then</span>
          header := addImplicitDir(zip, filePath);
        <span class="keywd">else</span>
          aFileType := FILE_ABSENT;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> aFileType = FILE_UNKNOWN <span class="keywd">then</span>
          <span class="keywd">case</span> header.version_made_by >> 8 <span class="keywd">of</span>
            <span class="keywd">when</span> {ZIP_HOST_SYSTEM_UNIX}:
              <span class="keywd">case</span> bin32(header.external_file_attributes >> 16) &amp; MODE_FILE_TYPE_MASK <span class="keywd">of</span>
                <span class="keywd">when</span> {MODE_FILE_REGULAR}: aFileType := FILE_REGULAR;
                <span class="keywd">when</span> {MODE_FILE_DIR}:     aFileType := FILE_DIR;
                <span class="keywd">when</span> {MODE_FILE_CHAR}:    aFileType := FILE_CHAR;
                <span class="keywd">when</span> {MODE_FILE_BLOCK}:   aFileType := FILE_BLOCK;
                <span class="keywd">when</span> {MODE_FILE_FIFO}:    aFileType := FILE_FIFO;
                <span class="keywd">when</span> {MODE_FILE_SOCKET}:  aFileType := FILE_SOCKET;
                <span class="keywd">when</span> {MODE_FILE_SYMLINK}:
                  isSymlink := TRUE;
                  decr(symlinkCount);
                  seek(zip.zipFile, succ(header.relative_offset_of_local_header));
                  localHeader := get_local_header(zip.zipFile);
                  <span class="comment"># write(localHeader);</span>
                  <span class="keywd">if</span> localHeader.compression_method = ZIP_STORE <span class="keywd">then</span>
                    <span class="comment"># The link destination is stored (no compression).</span>
                    targetPath := gets(zip.zipFile, localHeader.compressed_size);
                    filePath := symlinkDestination(filePath, targetPath);
                  <span class="keywd">else</span>
                    <span class="comment"># writeln("unsupported compression method: " &lt;&amp; localHeader.compression_method);</span>
                    raise FILE_ERROR;
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                <span class="keywd">otherwise</span>:                aFileType := FILE_UNKNOWN;
              <span class="keywd">end</span> <span class="keywd">case</span>;
            <span class="keywd">otherwise</span>:
              <span class="keywd">if</span> endsWith(header.file_name, <span class="stri">"/"</span>) <span class="keywd">then</span>
                aFileType := FILE_DIR;
              <span class="keywd">else</span>
                aFileType := FILE_REGULAR;
              <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">case</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> <span class="op">not</span> isSymlink <span class="op">or</span> symlinkCount &lt; 0;
      <span class="keywd">if</span> isSymlink <span class="keywd">then</span>
        aFileType := FILE_SYMLINK;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the type of a file in a ZIP archive.
 *  A return value of ''FILE_ABSENT'' does not imply that a file
 *  with this name can be created, since missing directories and
 *  invalid file names cause also ''FILE_ABSENT''.
 *  @return the type of the file.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">fileType</span>: fileTypeSL (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fileType</span>: aFileType <span class="keywd">is</span> FILE_UNKNOWN;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> zip.catalog <span class="keywd">then</span>
        header := zip.catalog[filePath];
      <span class="keywd">elsif</span> filePath <span class="op">in</span> zip.register <span class="keywd">then</span>
        header := addToCatalog(zip, filePath);
      <span class="keywd">elsif</span> implicitDir(zip.register, filePath) <span class="keywd">then</span>
        header := addImplicitDir(zip, filePath);
      <span class="keywd">else</span>
        aFileType := FILE_ABSENT;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> aFileType = FILE_UNKNOWN <span class="keywd">then</span>
        <span class="keywd">case</span> header.version_made_by >> 8 <span class="keywd">of</span>
          <span class="keywd">when</span> {ZIP_HOST_SYSTEM_UNIX}:
            <span class="keywd">case</span> bin32(header.external_file_attributes >> 16) &amp; MODE_FILE_TYPE_MASK <span class="keywd">of</span>
              <span class="keywd">when</span> {MODE_FILE_REGULAR}: aFileType := FILE_REGULAR;
              <span class="keywd">when</span> {MODE_FILE_DIR}:     aFileType := FILE_DIR;
              <span class="keywd">when</span> {MODE_FILE_CHAR}:    aFileType := FILE_CHAR;
              <span class="keywd">when</span> {MODE_FILE_BLOCK}:   aFileType := FILE_BLOCK;
              <span class="keywd">when</span> {MODE_FILE_FIFO}:    aFileType := FILE_FIFO;
              <span class="keywd">when</span> {MODE_FILE_SOCKET}:  aFileType := FILE_SOCKET;
              <span class="keywd">when</span> {MODE_FILE_SYMLINK}: aFileType := FILE_SYMLINK;
              <span class="keywd">otherwise</span>:                aFileType := FILE_UNKNOWN;
            <span class="keywd">end</span> <span class="keywd">case</span>;
          <span class="keywd">otherwise</span>:
            <span class="keywd">if</span> endsWith(header.file_name, <span class="stri">"/"</span>) <span class="keywd">then</span>
              aFileType := FILE_DIR;
            <span class="keywd">else</span>
              aFileType := FILE_REGULAR;
            <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the file mode (permissions) of a file in a ZIP archive.
 *  The function follows symbolic links.
 *  @return the file mode.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the ZIP archive.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">fileMode</span>: getFileMode (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fileMode</span>: mode <span class="keywd">is</span> fileMode.value;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">bin32</span>: FAT_READ_ONLY    <span class="keywd">is</span> bin32(16#01);
    <span class="keywd">const</span> <span class="type">bin32</span>: FAT_HIDDEN       <span class="keywd">is</span> bin32(16#02);
    <span class="keywd">const</span> <span class="type">bin32</span>: FAT_SYSTEM       <span class="keywd">is</span> bin32(16#04);
    <span class="keywd">const</span> <span class="type">bin32</span>: FAT_VOLUME_LABEL <span class="keywd">is</span> bin32(16#08);
    <span class="keywd">const</span> <span class="type">bin32</span>: FAT_DIRECTORY    <span class="keywd">is</span> bin32(16#10);
    <span class="keywd">const</span> <span class="type">bin32</span>: FAT_ARCHIVE      <span class="keywd">is</span> bin32(16#20);
    <span class="keywd">const</span> <span class="type">bin32</span>: FAT_DEVICE       <span class="keywd">is</span> bin32(16#40);
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">string</span>: extension <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      header := followSymlink(zip, filePath);
      <span class="keywd">case</span> header.version_made_by >> 8 <span class="keywd">of</span>
        <span class="keywd">when</span> {ZIP_HOST_SYSTEM_MS_DOS}:
          mode := {READ_USER, READ_GROUP, READ_OTHER};
          <span class="keywd">if</span> bin32(header.external_file_attributes) &amp; FAT_READ_ONLY = bin32(0) <span class="keywd">then</span>
            mode |:= {WRITE_USER};
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> bin32(header.external_file_attributes) &amp; FAT_DIRECTORY &lt;> bin32(0) <span class="keywd">then</span>
            mode |:= {EXEC_USER, EXEC_GROUP, EXEC_OTHER};
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> length(header.file_name) >= 5 <span class="keywd">then</span>
            extension := lower(header.file_name[length(header.file_name) - 3 ..]);
            <span class="keywd">if</span> extension <span class="op">in</span> {<span class="stri">".bat"</span>, <span class="stri">".cmd"</span>, <span class="stri">".com"</span>, <span class="stri">".exe"</span>} <span class="keywd">then</span>
              mode |:= {EXEC_USER, EXEC_GROUP, EXEC_OTHER};
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {ZIP_HOST_SYSTEM_UNIX}:
          <span class="comment"># The unix mode is in the high 16 bits of the attributes.</span>
          mode := fileMode((header.external_file_attributes >> 16) <span class="op">mod</span> 8#1000);
        <span class="keywd">otherwise</span>:
          mode := {READ_USER, READ_GROUP, READ_OTHER,
                   WRITE_USER};
          <span class="keywd">if</span> endsWith(header.file_name, <span class="stri">"/"</span>) <span class="keywd">then</span>
            mode |:= {EXEC_USER, EXEC_GROUP, EXEC_OTHER};
          <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Change the file mode (permissions) of a file in an ZIP archive.
 *  The function follows symbolic links.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the ZIP archive.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: setFileMode (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">fileMode</span>: mode) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      header := followSymlink(zip, filePath);
      header.external_file_attributes :=
          header.external_file_attributes <span class="op">mod</span> 16#10000 +
          (((header.external_file_attributes >> 25 &lt;&lt; 9) + integer(mode)) &lt;&lt; 16);
      zip.catalog @:= [filePath] header;
      seek(zip.zipFile, zip.register[filePath]);
      writeHead(zip.zipFile, header);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the size of a file in a ZIP archive.
 *  The file size is measured in bytes.
 *  For directories a size of 0 is returned.
 *  The function follows symbolic links.
 *  @return the size of the file.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the ZIP archive.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: fileSize (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: size <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      size := followSymlink(zip, filePath).uncompressed_size;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the modification time of a file in a ZIP archive.
 *  The function follows symbolic links.
 *  @return the modification time of the file.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the ZIP archive.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: getMTime (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: modificationTime <span class="keywd">is</span> time.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">integer</span>: timestamp <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      header := followSymlink(zip, filePath);
      <span class="keywd">if</span> ZIP_EXTENDED_TIMESTAMP_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
        timestamp := bytes2Int(
            header.extraFieldMap[ZIP_EXTENDED_TIMESTAMP_EXTRA_FIELD][2 fixLen 4],
            UNSIGNED, LE);
        modificationTime := timestamp1970ToTime(timestamp);
      <span class="keywd">elsif</span> ZIP_INFO_ZIP_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
        timestamp := bytes2Int(
            header.extraFieldMap[ZIP_INFO_ZIP_UNIX_EXTRA_FIELD][5 fixLen 4],
            UNSIGNED, LE);
        modificationTime := timestamp1970ToTime(timestamp);
      <span class="keywd">elsif</span> ZIP_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
        timestamp := bytes2Int(
            header.extraFieldMap[ZIP_UNIX_EXTRA_FIELD][5 fixLen 4],
            UNSIGNED, LE);
        modificationTime := timestamp1970ToTime(timestamp);
      <span class="keywd">elsif</span> ZIP_NTFS_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
        timestamp := bytes2Int(
            header.extraFieldMap[ZIP_NTFS_EXTRA_FIELD][9 fixLen 8],
            UNSIGNED, LE);
        modificationTime := timestamp1601ToTime(timestamp);
      <span class="keywd">else</span>
        modificationTime.year   := (header.last_mod_file_date >>  9) + 1980;
        modificationTime.month  := (header.last_mod_file_date >>  5) <span class="op">mod</span> 16;
        modificationTime.day    :=  header.last_mod_file_date        <span class="op">mod</span> 32;
        modificationTime.hour   :=  header.last_mod_file_time >> 11;
        modificationTime.minute := (header.last_mod_file_time >>  5) <span class="op">mod</span> 64;
        modificationTime.second := (header.last_mod_file_time        <span class="op">mod</span> 32) * 2;
        modificationTime := setLocalTZ(modificationTime);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Set the modification time of a file in an ZIP archive.
 *  The function follows symbolic links.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception RANGE_ERROR ''aTime'' is invalid or cannot be
 *             converted to the system file time.
 *  @exception FILE_ERROR ''filePath'' is not present in the ZIP archive.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: setMTime (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">time</span>: modificationTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">local_file_header</span>: localHeader <span class="keywd">is</span> local_file_header.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      header := followSymlink(zip, filePath);
      assignLastModFileTime(header, modificationTime);
      zip.catalog @:= [filePath] header;
      seek(zip.zipFile, zip.register[filePath]);
      writeHead(zip.zipFile, header);
      seek(zip.zipFile, succ(header.relative_offset_of_local_header));
      localHeader := get_local_header(zip.zipFile);
      assignLastModFileTime(localHeader, modificationTime);
      seek(zip.zipFile, succ(header.relative_offset_of_local_header));
      writeHead(zip.zipFile, localHeader);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the name of the owner (UID) of a file in a ZIP archive.
 *  The function follows symbolic links.
 *  @return the name of the file owner.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the ZIP archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getOwner (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: owner <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">integer</span>: size <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: uid <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      header := followSymlink(zip, filePath);
      <span class="keywd">if</span> ZIP_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
        uid := bytes2Int(
            header.extraFieldMap[ZIP_UNIX_EXTRA_FIELD][9 fixLen 2],
            UNSIGNED, LE);
        owner := str(uid);
      <span class="keywd">elsif</span> ZIP_ASI_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
        uid := bytes2Int(
            header.extraFieldMap[ZIP_ASI_UNIX_EXTRA_FIELD][11 fixLen 2],
            UNSIGNED, LE);
        owner := str(uid);
      <span class="keywd">elsif</span> ZIP_NEW_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
        size := ord(header.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD][2]);
        uid := bytes2Int(
            header.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD][3 fixLen size],
            UNSIGNED, LE);
        owner := str(uid);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Set the owner of a file in a ZIP archive.
 *  The function follows symbolic links. The ZIP archive format allows
 *  only a numeric UID. The ''owner'' "root" is mapped to the UID 0. Other
 *  ''owner'' names raise a RANGE_ERROR.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation, or the ''owner'' cannot be mapped to a UID.
 *  @exception FILE_ERROR ''filePath'' is not present in the ZIP archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: setOwner (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">string</span>: owner) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: uid <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">local_file_header</span>: localHeader <span class="keywd">is</span> local_file_header.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isDigitString(owner) <span class="keywd">then</span>
      uid := integer(owner);
    <span class="keywd">elsif</span> owner &lt;> <span class="stri">"root"</span> <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      header := followSymlink(zip, filePath);
      assignUserId(header, uid);
      zip.catalog @:= [filePath] header;
      seek(zip.zipFile, zip.register[filePath]);
      writeHead(zip.zipFile, header);
      seek(zip.zipFile, succ(header.relative_offset_of_local_header));
      localHeader := get_local_header(zip.zipFile);
      assignUserId(localHeader, uid);
      seek(zip.zipFile, succ(header.relative_offset_of_local_header));
      writeHead(zip.zipFile, localHeader);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the name of the group (GID) of a file in a ZIP archive.
 *  The function follows symbolic links.
 *  @return the name of the file group.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the ZIP archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getGroup (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: group <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: size <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: gid <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      header := followSymlink(zip, filePath);
      <span class="keywd">if</span> ZIP_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
        gid := bytes2Int(
            header.extraFieldMap[ZIP_UNIX_EXTRA_FIELD][11 fixLen 2],
            UNSIGNED, LE);
        group := str(gid);
      <span class="keywd">elsif</span> ZIP_ASI_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
        gid := bytes2Int(
            header.extraFieldMap[ZIP_ASI_UNIX_EXTRA_FIELD][13 fixLen 2],
            UNSIGNED, LE);
        group := str(gid);
      <span class="keywd">elsif</span> ZIP_NEW_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
        pos := 3 + ord(header.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD][2]);
        size := ord(header.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD][pos]);
        gid := bytes2Int(
            header.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD][succ(pos) fixLen size],
            UNSIGNED, LE);
        group := str(gid);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Set the group of a file in a ZIP archive.
 *  The function follows symbolic links. The ZIP archive format allows
 *  only a numeric GID. The ''group'' "root" is mapped to the GID 0. Other
 *  ''group'' names raise a RANGE_ERROR.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation, or the ''group'' cannot be mapped to a GID.
 *  @exception FILE_ERROR ''filePath'' is not present in the ZIP archive, or
 *             the chain of symbolic links is too long.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: setGroup (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">string</span>: group) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: gid <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">local_file_header</span>: localHeader <span class="keywd">is</span> local_file_header.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isDigitString(group) <span class="keywd">then</span>
      gid := integer(group);
    <span class="keywd">elsif</span> group &lt;> <span class="stri">"root"</span> <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      header := followSymlink(zip, filePath);
      assignGroupId(header, gid);
      zip.catalog @:= [filePath] header;
      seek(zip.zipFile, zip.register[filePath]);
      writeHead(zip.zipFile, header);
      seek(zip.zipFile, succ(header.relative_offset_of_local_header));
      localHeader := get_local_header(zip.zipFile);
      assignGroupId(localHeader, gid);
      seek(zip.zipFile, succ(header.relative_offset_of_local_header));
      writeHead(zip.zipFile, localHeader);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the file mode (permissions) of a symbolic link in a ZIP archive.
 *  The function only works for symbolic links and does not follow the
 *  symbolic link.
 *  @return the file mode.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR The file described with ''filePath'' is not
 *             present in the ZIP archive, or it is not a symbolic link.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">fileMode</span>: getFileMode (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath, SYMLINK) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fileMode</span>: mode <span class="keywd">is</span> fileMode.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("getFileMode: " &lt;&amp; filePath);</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath = <span class="stri">""</span> <span class="keywd">then</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> zip.catalog <span class="keywd">then</span>
        header := zip.catalog[filePath];
      <span class="keywd">elsif</span> filePath <span class="op">in</span> zip.register <span class="keywd">then</span>
        header := addToCatalog(zip, filePath);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> isSymlink(header) <span class="keywd">then</span>
        mode := fileMode((header.external_file_attributes >> 16) <span class="op">mod</span> 8#1000);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the modification time of a symbolic link in a ZIP archive.
 *  The function only works for symbolic links and does not follow the
 *  symbolic link.
 *  @return the modification time of the symbolic link.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR The file described with ''filePath'' is not
 *             present in the ZIP archive, or it is not a symbolic link.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: getMTime (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath, SYMLINK) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: modificationTime <span class="keywd">is</span> time.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">integer</span>: timestamp <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("getMTime: " &lt;&amp; filePath);</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath = <span class="stri">""</span> <span class="keywd">then</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> zip.catalog <span class="keywd">then</span>
        header := zip.catalog[filePath];
      <span class="keywd">elsif</span> filePath <span class="op">in</span> zip.register <span class="keywd">then</span>
        header := addToCatalog(zip, filePath);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> isSymlink(header) <span class="keywd">then</span>
        <span class="keywd">if</span> ZIP_EXTENDED_TIMESTAMP_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
          timestamp := bytes2Int(
              header.extraFieldMap[ZIP_EXTENDED_TIMESTAMP_EXTRA_FIELD][2 fixLen 4],
              UNSIGNED, LE);
          modificationTime := timestamp1970ToTime(timestamp);
        <span class="keywd">elsif</span> ZIP_INFO_ZIP_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
          timestamp := bytes2Int(
              header.extraFieldMap[ZIP_INFO_ZIP_UNIX_EXTRA_FIELD][5 fixLen 4],
              UNSIGNED, LE);
          modificationTime := timestamp1970ToTime(timestamp);
        <span class="keywd">elsif</span> ZIP_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
          timestamp := bytes2Int(
              header.extraFieldMap[ZIP_UNIX_EXTRA_FIELD][5 fixLen 4],
              UNSIGNED, LE);
          modificationTime := timestamp1970ToTime(timestamp);
        <span class="keywd">elsif</span> ZIP_NTFS_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
          timestamp := bytes2Int(
              header.extraFieldMap[ZIP_NTFS_EXTRA_FIELD][9 fixLen 8],
              UNSIGNED, LE);
          modificationTime := timestamp1601ToTime(timestamp);
        <span class="keywd">else</span>
          modificationTime.year   := (header.last_mod_file_date >>  9) + 1980;
          modificationTime.month  := (header.last_mod_file_date >>  5) <span class="op">mod</span> 16;
          modificationTime.day    :=  header.last_mod_file_date        <span class="op">mod</span> 32;
          modificationTime.hour   :=  header.last_mod_file_time >> 11;
          modificationTime.minute := (header.last_mod_file_time >>  5) <span class="op">mod</span> 64;
          modificationTime.second := (header.last_mod_file_time        <span class="op">mod</span> 32) * 2;
          modificationTime := setLocalTZ(modificationTime);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Set the modification time of a symbolic link in a ZIP archive.
 *  The function only works for symbolic links and does not follow the
 *  symbolic link.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception RANGE_ERROR ''modificationTime'' is invalid or it cannot be
 *             converted to the system file time.
 *  @exception FILE_ERROR The file described with ''filePath'' is not
 *             present in the ZIP archive, or it is not a symbolic link.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: setMTime (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">time</span>: modificationTime, SYMLINK) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">local_file_header</span>: localHeader <span class="keywd">is</span> local_file_header.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath = <span class="stri">""</span> <span class="keywd">then</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> zip.catalog <span class="keywd">then</span>
        header := zip.catalog[filePath];
      <span class="keywd">elsif</span> filePath <span class="op">in</span> zip.register <span class="keywd">then</span>
        header := addToCatalog(zip, filePath);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> isSymlink(header) <span class="keywd">then</span>
        assignLastModFileTime(header, modificationTime);
        zip.catalog @:= [filePath] header;
        seek(zip.zipFile, zip.register[filePath]);
        writeHead(zip.zipFile, header);
        seek(zip.zipFile, succ(header.relative_offset_of_local_header));
        localHeader := get_local_header(zip.zipFile);
        assignLastModFileTime(localHeader, modificationTime);
        seek(zip.zipFile, succ(header.relative_offset_of_local_header));
        writeHead(zip.zipFile, localHeader);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the name of the owner (UID) of a symbolic link in a ZIP archive.
 *  The function only works for symbolic links and does not follow the
 *  symbolic link.
 *  @return the name of the file owner.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR The file described with ''filePath'' is not
 *             present in the ZIP archive, or it is not a symbolic link.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getOwner (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath, SYMLINK) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: owner <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">integer</span>: size <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: uid <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("getOwner: " &lt;&amp; filePath);</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath = <span class="stri">""</span> <span class="keywd">then</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> zip.catalog <span class="keywd">then</span>
        header := zip.catalog[filePath];
      <span class="keywd">elsif</span> filePath <span class="op">in</span> zip.register <span class="keywd">then</span>
        header := addToCatalog(zip, filePath);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> isSymlink(header) <span class="keywd">then</span>
        <span class="keywd">if</span> ZIP_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
          uid := bytes2Int(
              header.extraFieldMap[ZIP_UNIX_EXTRA_FIELD][9 fixLen 2],
              UNSIGNED, LE);
          owner := str(uid);
        <span class="keywd">elsif</span> ZIP_ASI_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
          uid := bytes2Int(
              header.extraFieldMap[ZIP_ASI_UNIX_EXTRA_FIELD][11 fixLen 2],
              UNSIGNED, LE);
          owner := str(uid);
        <span class="keywd">elsif</span> ZIP_NEW_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
          size := ord(header.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD][2]);
          uid := bytes2Int(
              header.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD][3 fixLen size],
              UNSIGNED, LE);
          owner := str(uid);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Set the owner of a symbolic link in a ZIP archive.
 *  The function only works for symbolic links and does not follow the
 *  symbolic link. The ZIP archive format allows only a numeric UID.
 *  The ''owner'' "root" is mapped to the UID 0. Other ''owner'' names
 *  raise a RANGE_ERROR.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation, or the ''owner'' cannot be mapped to a UID.
 *  @exception FILE_ERROR The file described with ''filePath'' is not
 *             present in the ZIP archive, or it is not a symbolic link.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: setOwner (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">string</span>: owner, SYMLINK) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: uid <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">local_file_header</span>: localHeader <span class="keywd">is</span> local_file_header.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isDigitString(owner) <span class="keywd">then</span>
      uid := integer(owner);
    <span class="keywd">elsif</span> owner &lt;> <span class="stri">"root"</span> <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath = <span class="stri">""</span> <span class="keywd">then</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> zip.catalog <span class="keywd">then</span>
        header := zip.catalog[filePath];
      <span class="keywd">elsif</span> filePath <span class="op">in</span> zip.register <span class="keywd">then</span>
        header := addToCatalog(zip, filePath);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> isSymlink(header) <span class="keywd">then</span>
        assignUserId(header, uid);
        zip.catalog @:= [filePath] header;
        seek(zip.zipFile, zip.register[filePath]);
        writeHead(zip.zipFile, header);
        seek(zip.zipFile, succ(header.relative_offset_of_local_header));
        localHeader := get_local_header(zip.zipFile);
        assignUserId(localHeader, uid);
        seek(zip.zipFile, succ(header.relative_offset_of_local_header));
        writeHead(zip.zipFile, localHeader);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the name of the group (GID) of a symbolic link in a ZIP archive.
 *  The function only works for symbolic links and does not follow the
 *  symbolic link.
 *  @return the name of the file group.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR The file described with ''filePath'' is not
 *             present in the ZIP archive, or it is not a symbolic link.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getGroup (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath, SYMLINK) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: group <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: size <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: gid <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("getGroup: " &lt;&amp; filePath);</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath = <span class="stri">""</span> <span class="keywd">then</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> zip.catalog <span class="keywd">then</span>
        header := zip.catalog[filePath];
      <span class="keywd">elsif</span> filePath <span class="op">in</span> zip.register <span class="keywd">then</span>
        header := addToCatalog(zip, filePath);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> isSymlink(header) <span class="keywd">then</span>
        <span class="keywd">if</span> ZIP_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
          gid := bytes2Int(
              header.extraFieldMap[ZIP_UNIX_EXTRA_FIELD][11 fixLen 2],
              UNSIGNED, LE);
          group := str(gid);
        <span class="keywd">elsif</span> ZIP_ASI_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
          gid := bytes2Int(
              header.extraFieldMap[ZIP_ASI_UNIX_EXTRA_FIELD][13 fixLen 2],
              UNSIGNED, LE);
          group := str(gid);
        <span class="keywd">elsif</span> ZIP_NEW_UNIX_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap <span class="keywd">then</span>
          pos := 3 + ord(header.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD][2]);
          size := ord(header.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD][pos]);
          gid := bytes2Int(
              header.extraFieldMap[ZIP_NEW_UNIX_EXTRA_FIELD][succ(pos) fixLen size],
              UNSIGNED, LE);
          group := str(gid);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Set the group of a symbolic link in a ZIP archive.
 *  The function only works for symbolic links and does not follow the
 *  symbolic link. The ZIP archive format allows only a numeric GID.
 *  The ''group'' "root" is mapped to the GID 0. Other ''group'' names
 *  raise a RANGE_ERROR.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation, or the ''group'' cannot be mapped to a GID.
 *  @exception FILE_ERROR The file described with ''filePath'' is not
 *             present in the ZIP archive, or it is not a symbolic link.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: setGroup (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">string</span>: group, SYMLINK) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: gid <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">local_file_header</span>: localHeader <span class="keywd">is</span> local_file_header.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isDigitString(group) <span class="keywd">then</span>
      gid := integer(group);
    <span class="keywd">elsif</span> group &lt;> <span class="stri">"root"</span> <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath = <span class="stri">""</span> <span class="keywd">then</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> filePath <span class="op">in</span> zip.catalog <span class="keywd">then</span>
        header := zip.catalog[filePath];
      <span class="keywd">elsif</span> filePath <span class="op">in</span> zip.register <span class="keywd">then</span>
        header := addToCatalog(zip, filePath);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> isSymlink(header) <span class="keywd">then</span>
        assignGroupId(header, gid);
        zip.catalog @:= [filePath] header;
        seek(zip.zipFile, zip.register[filePath]);
        writeHead(zip.zipFile, header);
        seek(zip.zipFile, succ(header.relative_offset_of_local_header));
        localHeader := get_local_header(zip.zipFile);
        assignGroupId(localHeader, gid);
        seek(zip.zipFile, succ(header.relative_offset_of_local_header));
        writeHead(zip.zipFile, localHeader);
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads the destination of a symbolic link in a ZIP archive.
 *  @return The destination referred by the symbolic link.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the ZIP archive,
 *             or is not a symbolic link.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: readLink (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: linkPath <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">local_file_header</span>: localHeader <span class="keywd">is</span> local_file_header.value;
    <span class="keywd">var</span> <span class="type">string</span>: linkPath8 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">bin32</span>: crc_32 <span class="keywd">is</span> bin32(0);
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath <span class="op">in</span> zip.catalog <span class="keywd">then</span>
      header := zip.catalog[filePath];
    <span class="keywd">elsif</span> filePath <span class="op">in</span> zip.register <span class="keywd">then</span>
      header := addToCatalog(zip, filePath);
    <span class="keywd">else</span>
      raise FILE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> isSymlink(header) <span class="keywd">then</span>
      seek(zip.zipFile, succ(header.relative_offset_of_local_header));
      localHeader := get_local_header(zip.zipFile);
      <span class="comment"># write(localHeader);</span>
      <span class="keywd">if</span> localHeader.compression_method = ZIP_STORE <span class="keywd">then</span>
        <span class="comment"># The link destination is stored (no compression).</span>
        linkPath8 := gets(zip.zipFile, localHeader.compressed_size);
      <span class="keywd">else</span>
        <span class="comment"># writeln("unsupported compression method: " &lt;&amp; localHeader.compression_method);</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      crc_32 := crc32(linkPath8);
      <span class="keywd">if</span> localHeader.crc_32 &lt;> crc_32 <span class="op">or</span>
          localHeader.uncompressed_size &lt;> length(linkPath8) <span class="op">or</span>
          header.crc_32 &lt;> crc_32 <span class="op">or</span>
          header.uncompressed_size &lt;> length(linkPath8) <span class="keywd">then</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">block</span>
        linkPath := fromUtf8(linkPath8);
      exception
        catch RANGE_ERROR:
          linkPath := linkPath8;
      <span class="keywd">end</span> <span class="keywd">block</span>;
    <span class="keywd">else</span>
      raise FILE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Create a symbolic link in a ZIP archive.
 *  The symbolic link ''symlinkPath'' will refer to ''targetPath'' afterwards.
 *  The function does not follow symbolic links.
 *  @param zip Open ZIP archive.
 *  @param symlinkPath Name of the symbolic link to be created.
 *  @param targetPath String to be contained in the symbolic link.
 *  @exception RANGE_ERROR ''targetPath'' or ''symlinkPath'' does not use the
 *             standard path representation.
 *  @exception FILE_ERROR A system function returns an error.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: makeLink (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: symlinkPath,
    <span class="op">in</span> <span class="type">string</span>: targetPath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">local_file_header</span>: localHeader <span class="keywd">is</span> local_file_header.value;
    <span class="keywd">var</span> <span class="type">string</span>: symlinkPath8 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: targetPath8 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: roomForNewFile <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("makeLink: " &lt;&amp; literal(symlinkPath) &lt;&amp; " " &lt;&amp; literal(targetPath));</span>
    <span class="keywd">if</span> symlinkPath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(symlinkPath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> symlinkPath = <span class="stri">""</span> <span class="op">or</span> symlinkPath <span class="op">in</span> zip.catalog <span class="op">or</span>
        symlinkPath <span class="op">in</span> zip.register <span class="op">or</span> implicitDir(zip.register, symlinkPath) <span class="keywd">then</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      symlinkPath8 := toUtf8(symlinkPath);
      targetPath8 := toUtf8(targetPath);
      header.signature := ZIP_CENTRAL_HEADER_SIGNATURE;
      header.version_made_by            := (ZIP_HOST_SYSTEM_UNIX &lt;&lt; 8) + 16#1e;
      header.version_needed_to_extract  := 10;
      <span class="keywd">if</span> symlinkPath8 &lt;> symlinkPath <span class="keywd">then</span>
        header.general_purpose_bit_flag := ZIP_FILE_NAME_IS_UTF8;
      <span class="keywd">else</span>
        header.general_purpose_bit_flag := bin32(0);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      header.compression_method         := ZIP_STORE;
      header.crc_32                     := crc32(targetPath8);
      header.compressed_size            := length(targetPath8);
      header.uncompressed_size          := length(targetPath8);
      header.disk_number_start          := 0;
      header.internal_file_attributes   := 0;
      <span class="comment"># The unix mode is in the high 16 bits of the attributes.</span>
      header.external_file_attributes   := (ord(MODE_FILE_SYMLINK) + 8#777) &lt;&lt; 16;
      header.file_name                  := symlinkPath8;
      initLastModFileTime(header, time(NOW));
      header.file_comment               := <span class="stri">""</span>;
      header.relative_offset_of_local_header := pred(zip.startOfCentralDirPos);
      roomForNewFile := ZIP_LOCAL_HEADER_FIXED_SIZE + length(header.file_name) +
          length(header.extra_field) + header.compressed_size;
      insertArea(zip.zipFile, zip.startOfCentralDirPos, roomForNewFile);
      fixRegisterAndCatalog(zip, zip.startOfCentralDirPos, roomForNewFile);
      localHeader := toLocalHeader(header);
      seek(zip.zipFile, succ(header.relative_offset_of_local_header));
      writeHead(zip.zipFile, localHeader);
      write(zip.zipFile, targetPath8);
      seek(zip.zipFile, zip.endOfCentralDirPos);
      zip.register @:= [symlinkPath] zip.endOfCentralDirPos;
      writeHead(zip.zipFile, header);
      zip.catalog @:= [symlinkPath] header;
      zip.endOfCentralDirPos := tell(zip.zipFile);
      incr(zip.endOfCentralDir.entries_in_central_directory_on_this_disk);
      incr(zip.endOfCentralDir.entries_in_central_directory);
      zip.endOfCentralDir.size_of_central_directory := zip.endOfCentralDirPos - zip.startOfCentralDirPos;
      zip.endOfCentralDir.offset_of_start_of_central_directory := pred(zip.startOfCentralDirPos);
      write(zip.zipFile, str(zip.endOfCentralDir));
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: lzwDecompressShrink (<span class="keywd">inout</span> <span class="type">file</span>: inFile,
    <span class="op">in</span> <span class="type">integer</span>: compressedSize) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: decompressed <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">file</span>: compressedFile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">lsbInBitStream</span>: compressedStream <span class="keywd">is</span> lsbInBitStream.value;
  <span class="keywd">begin</span>
    compressedFile := openSubFile(inFile, tell(inFile), compressedSize);
    compressedStream := openLsbInBitStream(compressedFile);
    decompressed := lzwDecompressShrink(compressedStream);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getFile (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getReference (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">central_file_header</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: content <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: sha1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: filePath <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: found <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    sha1 := gets(zip.zipFile, header.compressed_size);
    <span class="keywd">if</span> length(sha1) &lt;> 20 <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">for</span> filePath <span class="keywd">range</span> getReferencePaths(zip, header.crc_32) <span class="keywd">do</span>
        content := getFile(zip, filePath);
        <span class="keywd">if</span> sha1(content) = sha1 <span class="keywd">then</span>
          <span class="keywd">if</span> found <span class="keywd">then</span>
            raise RANGE_ERROR;
          <span class="keywd">else</span>
            found := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">if</span> <span class="op">not</span> found <span class="keywd">then</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readDataDescriptor (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">central_file_header</span>: header,
    <span class="keywd">inout</span> <span class="type">local_file_header</span>: localHeader) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: dataDescriptorSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: signaturePos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    dataDescriptorSize := ZIP64_EXTRA_FIELD <span class="op">in</span> header.extraFieldMap ?
                          ZIP64_DATA_DESCRIPTOR_SIZE :
                          ZIP_DATA_DESCRIPTOR_SIZE;
    stri := gets(zip.zipFile, 4);
    <span class="keywd">if</span> stri = ZIP_DATA_DESCRIPTOR_SIGNATURE <span class="keywd">then</span>
      stri := gets(zip.zipFile, dataDescriptorSize);
    <span class="keywd">else</span>
      stri &amp;:= gets(zip.zipFile, dataDescriptorSize - 4);
      <span class="keywd">if</span> length(stri) = dataDescriptorSize <span class="keywd">then</span>
        signaturePos := pos(stri, ZIP_DATA_DESCRIPTOR_SIGNATURE);
        <span class="keywd">if</span> signaturePos &lt;> 0 <span class="keywd">then</span>
          stri := stri[signaturePos + 4 .. ] &amp;
                  gets(zip.zipFile, signaturePos + 3);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> length(stri) = dataDescriptorSize <span class="keywd">then</span>
      <span class="keywd">if</span> dataDescriptorSize = ZIP_DATA_DESCRIPTOR_SIZE <span class="keywd">then</span>
        localHeader.crc_32            := bin32(bytes2Int(stri[1 fixLen 4], UNSIGNED, LE));
        localHeader.compressed_size   :=       bytes2Int(stri[5 fixLen 4], UNSIGNED, LE);
        localHeader.uncompressed_size :=       bytes2Int(stri[9 fixLen 4], UNSIGNED, LE);
      <span class="keywd">else</span>
        localHeader.crc_32            := bin32(bytes2Int(stri[1 fixLen 4], UNSIGNED, LE));
        localHeader.compressed_size   :=       bytes2Int(stri[5 fixLen 8], UNSIGNED, LE);
        localHeader.uncompressed_size :=       bytes2Int(stri[9 fixLen 8], UNSIGNED, LE);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get the contents of a file in a ZIP archive.
 *  The function follows symbolic links.
 *  @return the specified file as string.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR ''filePath'' is not present in the ZIP archive,
 *             or the crc-32 checksum is not okay.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getFile (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: content <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">local_file_header</span>: localHeader <span class="keywd">is</span> local_file_header.value;
    <span class="keywd">var</span> <span class="type">bin32</span>: crc_32 <span class="keywd">is</span> bin32(0);
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      header := followSymlink(zip, filePath);
      <span class="keywd">if</span> isRegularFile(header) <span class="keywd">then</span>
        seek(zip.zipFile, succ(header.relative_offset_of_local_header));
        localHeader := get_local_header(zip.zipFile);
        <span class="comment"># write(localHeader);</span>
        <span class="keywd">case</span> localHeader.compression_method <span class="keywd">of</span>
          <span class="keywd">when</span> {ZIP_STORE}:
            content := gets(zip.zipFile, localHeader.compressed_size);
          <span class="keywd">when</span> {ZIP_SHRINK}:
            content := lzwDecompressShrink(zip.zipFile, localHeader.compressed_size);
          <span class="keywd">when</span> {ZIP_DEFLATE}:
            <span class="keywd">if</span> localHeader.general_purpose_bit_flag &amp; ZIP_HAS_DATA_DESCRIPTOR &lt;> bin32(0) <span class="keywd">then</span>
              <span class="comment"># The fields crc_32, compressed_size and uncompressed_size are 0.</span>
              <span class="comment"># There is a data descriptor after the compressed data instead.</span>
              content := inflate(zip.zipFile);
              readDataDescriptor(zip, header, localHeader);
            <span class="keywd">else</span>
              content := gets(zip.zipFile, localHeader.compressed_size);
              content := inflate(content);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">when</span> {ZIP_DEFLATE64}:
            <span class="keywd">if</span> localHeader.general_purpose_bit_flag &amp; ZIP_HAS_DATA_DESCRIPTOR &lt;> bin32(0) <span class="keywd">then</span>
              <span class="comment"># The fields crc_32, compressed_size and uncompressed_size are 0.</span>
              <span class="comment"># There is a data descriptor after the compressed data instead.</span>
              content := inflate64(zip.zipFile);
              readDataDescriptor(zip, header, localHeader);
            <span class="keywd">else</span>
              content := gets(zip.zipFile, localHeader.compressed_size);
              content := inflate64(content);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">when</span> {ZIP_BZIP2}:
            content := bzip2Decompress(gets(zip.zipFile, localHeader.compressed_size));
          <span class="keywd">when</span> {ZIP_LZMA}:
            content := lzmaDecompress(zip.zipFile, localHeader.uncompressed_size);
          <span class="keywd">when</span> {ZIP_REFERENCE}:
            content := getReference(zip, header);
          <span class="keywd">when</span> {ZIP_ZSTD}:
            content := zstdDecompress(zip.zipFile);
          <span class="keywd">when</span> {ZIP_XZ}:
            content := xzDecompress(zip.zipFile);
          <span class="keywd">otherwise</span>:
            <span class="comment"># writeln("unsupported compression method: " &lt;&amp; localHeader.compression_method);</span>
            raise FILE_ERROR;
        <span class="keywd">end</span> <span class="keywd">case</span>;
        crc_32 := crc32(content);
        <span class="keywd">if</span> localHeader.crc_32 &lt;> crc_32 <span class="op">or</span>
            localHeader.uncompressed_size &lt;> length(content) <span class="op">or</span>
            header.crc_32 &lt;> crc_32 <span class="op">or</span>
            header.uncompressed_size &lt;> length(content) <span class="keywd">then</span>
          raise FILE_ERROR;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        raise FILE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Write ''data'' to a ZIP archive with the given ''filePath''.
 *  If the file exists already, it is overwritten.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: putFile (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath,
    <span class="op">in</span> <span class="type">string</span>: data) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">local_file_header</span>: localHeader <span class="keywd">is</span> local_file_header.value;
    <span class="keywd">var</span> <span class="type">boolean</span>: fileExists <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">time</span>: modificationTime <span class="keywd">is</span> time.value;
    <span class="keywd">var</span> <span class="type">integer</span>: oldSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: newSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: localHeaderPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: filePath8 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: compressed <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: roomForNewFile <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> filePath = <span class="stri">""</span> <span class="op">or</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath <span class="op">in</span> zip.catalog <span class="keywd">then</span>
      header := zip.catalog[filePath];
    <span class="keywd">elsif</span> filePath <span class="op">in</span> zip.register <span class="keywd">then</span>
      header := addToCatalog(zip, filePath);
    <span class="keywd">elsif</span> implicitDir(zip.register, filePath) <span class="keywd">then</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      fileExists := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    compressed := deflate(data);
    oldSize := header.compressed_size;
    header.crc_32 := crc32(data);
    header.uncompressed_size := length(data);
    <span class="keywd">if</span> length(compressed) >= length(data) <span class="keywd">then</span>
      header.compression_method := ZIP_STORE;
      header.compressed_size := length(data);
      compressed := data;
    <span class="keywd">else</span>
      header.compression_method := ZIP_DEFLATE;
      header.compressed_size := length(compressed);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> fileExists <span class="keywd">then</span>
      <span class="keywd">if</span> endsWith(header.file_name, <span class="stri">"/"</span>) <span class="keywd">then</span>
        raise FILE_ERROR;
      <span class="keywd">else</span>
        modificationTime := time(NOW);
        assignLastModFileTime(header, modificationTime);
        localHeaderPos := succ(header.relative_offset_of_local_header);
        seek(zip.zipFile, localHeaderPos);
        localHeader := get_local_header(zip.zipFile);
        newSize := header.compressed_size;
        <span class="comment"># writeln("oldSize: " &lt;&amp; oldSize);</span>
        <span class="comment"># writeln("newSize: " &lt;&amp; newSize);</span>
        <span class="keywd">if</span> newSize > oldSize <span class="keywd">then</span>
          insertArea(zip.zipFile, localHeaderPos, newSize - oldSize);
          fixRegisterAndCatalog(zip, localHeaderPos, newSize - oldSize);
        <span class="keywd">elsif</span> newSize &lt; oldSize <span class="keywd">then</span>
          deleteArea(zip.zipFile, localHeaderPos, oldSize - newSize);
          fixRegisterAndCatalog(zip, localHeaderPos + (oldSize - newSize),
                                newSize - oldSize);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="comment"># Local header and file data are rewritten in place.</span>
        updateLocalHeader(localHeader, header);
        assignLastModFileTime(localHeader, modificationTime);
        seek(zip.zipFile, localHeaderPos);
        writeHead(zip.zipFile, localHeader);
        write(zip.zipFile, compressed);
        zip.catalog @:= [filePath] header;
        seek(zip.zipFile, zip.register[filePath]);
        writeHead(zip.zipFile, header);
        zip.endOfCentralDir.offset_of_start_of_central_directory := pred(zip.startOfCentralDirPos);
        seek(zip.zipFile, zip.endOfCentralDirPos);
        write(zip.zipFile, str(zip.endOfCentralDir));
        flush(zip.zipFile);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      filePath8 := toUtf8(filePath);
      header.signature := ZIP_CENTRAL_HEADER_SIGNATURE;
      header.version_made_by            := (ZIP_HOST_SYSTEM_UNIX &lt;&lt; 8) + 16#1e;
      header.version_needed_to_extract  := 10;
      <span class="keywd">if</span> filePath8 &lt;> filePath <span class="keywd">then</span>
        header.general_purpose_bit_flag := ZIP_FILE_NAME_IS_UTF8;
      <span class="keywd">else</span>
        header.general_purpose_bit_flag := bin32(0);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      header.disk_number_start          := 0;
      header.internal_file_attributes   := 0;
      <span class="comment"># The unix mode is in the high 16 bits of the attributes.</span>
      header.external_file_attributes   := (ord(MODE_FILE_REGULAR) + 8#664) &lt;&lt; 16;
      header.file_name                  := filePath8;
      initLastModFileTime(header, time(NOW));
      header.file_comment               := <span class="stri">""</span>;
      header.relative_offset_of_local_header := pred(zip.startOfCentralDirPos);
      roomForNewFile := ZIP_LOCAL_HEADER_FIXED_SIZE + length(header.file_name) +
          length(header.extra_field) + header.compressed_size;
      insertArea(zip.zipFile, zip.startOfCentralDirPos, roomForNewFile);
      fixRegisterAndCatalog(zip, zip.startOfCentralDirPos, roomForNewFile);
      localHeader := toLocalHeader(header);
      seek(zip.zipFile, succ(header.relative_offset_of_local_header));
      writeHead(zip.zipFile, localHeader);
      write(zip.zipFile, compressed);
      seek(zip.zipFile, zip.endOfCentralDirPos);
      zip.register @:= [filePath] zip.endOfCentralDirPos;
      writeHead(zip.zipFile, header);
      zip.catalog @:= [filePath] header;
      zip.endOfCentralDirPos := tell(zip.zipFile);
      incr(zip.endOfCentralDir.entries_in_central_directory_on_this_disk);
      incr(zip.endOfCentralDir.entries_in_central_directory);
      zip.endOfCentralDir.size_of_central_directory := zip.endOfCentralDirPos - zip.startOfCentralDirPos;
      zip.endOfCentralDir.offset_of_start_of_central_directory := pred(zip.startOfCentralDirPos);
      write(zip.zipFile, str(zip.endOfCentralDir));
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Create a new directory in a ZIP archive.
 *  The function does not follow symbolic links.
 *  @param zip Open ZIP archive.
 *  @param dirPath Name of the directory to be created.
 *  @exception RANGE_ERROR ''dirPath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR The file ''dirPath'' already exists.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: makeDir (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: dirPath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">local_file_header</span>: localHeader <span class="keywd">is</span> local_file_header.value;
    <span class="keywd">var</span> <span class="type">boolean</span>: fileExists <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">integer</span>: relative_offset_of_local_header <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: dirPath8 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: roomForNewFile <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> dirPath = <span class="stri">""</span> <span class="op">or</span> dirPath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(dirPath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> dirPath <span class="op">in</span> zip.catalog <span class="keywd">then</span>
      relative_offset_of_local_header := zip.catalog[dirPath].relative_offset_of_local_header;
    <span class="keywd">elsif</span> dirPath <span class="op">in</span> zip.register <span class="keywd">then</span>
      relative_offset_of_local_header := addToCatalog(zip, dirPath).relative_offset_of_local_header;
    <span class="keywd">elsif</span> implicitDir(zip.register, dirPath) <span class="keywd">then</span>
      relative_offset_of_local_header := addImplicitDir(zip, dirPath).relative_offset_of_local_header;
    <span class="keywd">else</span>
      fileExists := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> fileExists <span class="op">and</span> relative_offset_of_local_header &lt;> -1 <span class="keywd">then</span>
      <span class="comment"># The file exists and it is not an implicit directory.</span>
      raise FILE_ERROR;
    <span class="keywd">else</span>
      dirPath8 := toUtf8(dirPath);
      header.signature := ZIP_CENTRAL_HEADER_SIGNATURE;
      header.version_made_by            := (ZIP_HOST_SYSTEM_UNIX &lt;&lt; 8) + 16#1e;
      header.version_needed_to_extract  := 10;
      <span class="keywd">if</span> dirPath8 &lt;> dirPath <span class="keywd">then</span>
        header.general_purpose_bit_flag := ZIP_FILE_NAME_IS_UTF8;
      <span class="keywd">else</span>
        header.general_purpose_bit_flag := bin32(0);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      header.compression_method         := ZIP_STORE;
      header.compressed_size            := 0;
      header.uncompressed_size          := 0;
      header.disk_number_start          := 0;
      header.internal_file_attributes   := 0;
      <span class="comment"># The unix mode is in the high 16 bits of the attributes.</span>
      header.external_file_attributes   := (ord(MODE_FILE_DIR) + 8#775) &lt;&lt; 16;
      header.file_name                  := dirPath8 &amp; <span class="stri">"/"</span>;
      initLastModFileTime(header, time(NOW));
      header.file_comment               := <span class="stri">""</span>;
      header.relative_offset_of_local_header := pred(zip.startOfCentralDirPos);
      roomForNewFile := ZIP_LOCAL_HEADER_FIXED_SIZE + length(header.file_name) +
          length(header.extra_field);
      insertArea(zip.zipFile, zip.startOfCentralDirPos, roomForNewFile);
      fixRegisterAndCatalog(zip, zip.startOfCentralDirPos, roomForNewFile);
      localHeader := toLocalHeader(header);
      seek(zip.zipFile, succ(header.relative_offset_of_local_header));
      writeHead(zip.zipFile, localHeader);
      seek(zip.zipFile, zip.endOfCentralDirPos);
      zip.register @:= [dirPath] zip.endOfCentralDirPos;
      writeHead(zip.zipFile, header);
      zip.catalog @:= [dirPath] header;
      zip.endOfCentralDirPos := tell(zip.zipFile);
      incr(zip.endOfCentralDir.entries_in_central_directory_on_this_disk);
      incr(zip.endOfCentralDir.entries_in_central_directory);
      zip.endOfCentralDir.size_of_central_directory := zip.endOfCentralDirPos - zip.startOfCentralDirPos;
      zip.endOfCentralDir.offset_of_start_of_central_directory := pred(zip.startOfCentralDirPos);
      write(zip.zipFile, str(zip.endOfCentralDir));
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Remove any file except non-empty directories from a ZIP archive.
 *  The function does not follow symbolic links. An attempt to remove a
 *  directory that is not empty triggers FILE_ERROR.
 *  @param zip Open ZIP archive.
 *  @param filePath Name of the file to be removed.
 *  @exception RANGE_ERROR ''filePath'' does not use the standard path
 *             representation.
 *  @exception FILE_ERROR The file does not exist or it is a directory
 *             that is not empty.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: removeFile (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">central_file_header</span>: header <span class="keywd">is</span> central_file_header.value;
    <span class="keywd">var</span> <span class="type">local_file_header</span>: localHeader <span class="keywd">is</span> local_file_header.value;
    <span class="keywd">var</span> <span class="type">boolean</span>: fileExists <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">integer</span>: posOfHeaderToBeRemoved <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: numCharsToBeRemoved <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("removeFile(" &lt;&amp; literal(filePath) &lt;&amp; ")");</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">"/"</span> <span class="op">and</span> endsWith(filePath, <span class="stri">"/"</span>) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> filePath <span class="op">in</span> zip.catalog <span class="keywd">then</span>
      header := zip.catalog[filePath];
    <span class="keywd">elsif</span> filePath <span class="op">in</span> zip.register <span class="keywd">then</span>
      header := addToCatalog(zip, filePath);
    <span class="keywd">elsif</span> implicitDir(zip.register, filePath) <span class="keywd">then</span>
      header := addImplicitDir(zip, filePath);
    <span class="keywd">else</span>
      fileExists := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> fileExists <span class="op">and</span>
        (<span class="op">not</span> endsWith(header.file_name, <span class="stri">"/"</span>) <span class="op">or</span>
         isEmptyDir(zip.register, filePath)) <span class="keywd">then</span>
      <span class="comment"># Remove local header and file content.</span>
      posOfHeaderToBeRemoved := succ(header.relative_offset_of_local_header);
      numCharsToBeRemoved := ZIP_LOCAL_HEADER_FIXED_SIZE + length(header.file_name) +
        length(header.extra_field) + header.compressed_size;
      <span class="comment"># writeln("numCharsToBeRemoved: " &lt;&amp; numCharsToBeRemoved);</span>
      deleteArea(zip.zipFile, posOfHeaderToBeRemoved, numCharsToBeRemoved);
      fixRegisterAndCatalog(zip, posOfHeaderToBeRemoved + numCharsToBeRemoved,
                            -numCharsToBeRemoved);
      <span class="comment"># Remove central header.</span>
      posOfHeaderToBeRemoved := zip.register[filePath];
      numCharsToBeRemoved := ZIP_CENTRAL_HEADER_FIXED_SIZE + length(header.file_name) +
        length(header.extra_field) + length(header.file_comment);
      <span class="comment"># writeln("numCharsToBeRemoved: " &lt;&amp; numCharsToBeRemoved);</span>
      deleteArea(zip.zipFile, posOfHeaderToBeRemoved, numCharsToBeRemoved);
      excl(zip.register, filePath);
      excl(zip.catalog, filePath);
      fixRegisterAndCatalog(zip, posOfHeaderToBeRemoved + numCharsToBeRemoved,
                            -numCharsToBeRemoved);
      decr(zip.endOfCentralDir.entries_in_central_directory_on_this_disk);
      decr(zip.endOfCentralDir.entries_in_central_directory);
      zip.endOfCentralDir.size_of_central_directory := zip.endOfCentralDirPos - zip.startOfCentralDirPos;
      zip.endOfCentralDir.offset_of_start_of_central_directory := pred(zip.startOfCentralDirPos);
      seek(zip.zipFile, zip.endOfCentralDirPos);
      write(zip.zipFile, str(zip.endOfCentralDir));
      flush(zip.zipFile);
    <span class="keywd">else</span>
      raise FILE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getZipContent (<span class="op">in</span> <span class="type">string</span>: zipFilePath, <span class="op">in</span> <span class="type">string</span>: filePath) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: content <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">fileSys</span>: zip <span class="keywd">is</span> fileSys.value;
  <span class="keywd">begin</span>
    zip := openZip(zipFilePath);
    <span class="keywd">if</span> zip &lt;> fileSys.value <span class="keywd">then</span>
      content := getFile(zip, filePath);
      close(zip);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  For-loop which loops recursively over the paths in a ZIP archive.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: <span class="keywd">for</span> (<span class="keywd">inout</span> <span class="type">string</span>: filePath) <span class="keywd">range</span> (<span class="keywd">inout</span> <span class="type">zipArchive</span>: zip) <span class="keywd">do</span>
              (<span class="op">in</span> <span class="type">proc</span>: statements)
            <span class="keywd">end</span> <span class="keywd">for</span> <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">for</span> <span class="keywd">key</span> filePath <span class="keywd">range</span> zip.register <span class="keywd">do</span>
      statements;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
