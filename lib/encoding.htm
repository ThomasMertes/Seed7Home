<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  encoding.s7i  Encoding and decoding functions                   *)</span>
<span class="comment">(*  Copyright (C) 2007, 2008, 2011, 2013, 2015, 2016  Thomas Mertes *)</span>
<span class="comment">(*                2019 - 2024  Thomas Mertes                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/chartype.htm">chartype.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bytedata.htm">bytedata.s7i</a>"</span>;


<span class="comment">(**
 *  Encode a string with the Base64 encoding.
 *  Base64 encodes a byte string as ASCII string. This is done by
 *  taking packs of 6-bits and translating them into a radix-64
 *  representation. The radix-64 digits are encoded with letters
 *  (upper case followed by lower case), digits and the characters
 *  '+' and '/'.
 *  @return the Base64 encoded string.
 *  @exception RANGE_ERROR If characters beyond '\255;' are present.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: toBase64 (<span class="op">in</span> <span class="type">string</span>: byteStri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: base64 <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">string</span>: coding <span class="keywd">is</span> <span class="stri">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: subIndex <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: threeBytes <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: fourBytes <span class="keywd">is</span> <span class="stri">"    "</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: posToAddNewline <span class="keywd">is</span> 58;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length(byteStri) step 3 <span class="keywd">do</span>
      threeBytes := 0;
      <span class="keywd">for</span> subIndex <span class="keywd">range</span> index <span class="keywd">to</span> index + 2 <span class="keywd">do</span>
        threeBytes &lt;&lt;:= 8;
        <span class="keywd">if</span> subIndex &lt;= length(byteStri) <span class="keywd">then</span>
          ch := byteStri[subIndex];
          <span class="keywd">if</span> ch >= <span class="stri">'\256;'</span> <span class="keywd">then</span>
            raise RANGE_ERROR;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          threeBytes +:= ord(ch);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      fourBytes @:= [1] coding[succ( threeBytes >> 18)];
      fourBytes @:= [2] coding[succ((threeBytes >> 12) <span class="op">mod</span> 64)];
      fourBytes @:= [3] coding[succ((threeBytes >>  6) <span class="op">mod</span> 64)];
      fourBytes @:= [4] coding[succ( threeBytes        <span class="op">mod</span> 64)];
      <span class="keywd">if</span> index = posToAddNewline <span class="keywd">then</span>
        base64 &amp;:= <span class="stri">"\n"</span>;
        posToAddNewline +:= 57;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      base64 &amp;:= fourBytes;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    index := length(base64);
    <span class="keywd">if</span> length(byteStri) <span class="op">rem</span> 3 = 2 <span class="keywd">then</span>
      base64 @:= [index] <span class="stri">'='</span>;
    <span class="keywd">elsif</span> length(byteStri) <span class="op">rem</span> 3 = 1 <span class="keywd">then</span>
      base64 @:= [pred(index)] <span class="stri">"=="</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Decode a Base64 encoded string.
 *  @param base64 Base64 encoded string without leading or trailing
 *         whitespace characters.
 *  @return the decoded string.
 *  @exception RANGE_ERROR If ''base64'' is not in Base64 format.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: fromBase64 (<span class="op">in</span> <span class="type">string</span>: base64) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: decoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">array</span> <span class="type">integer</span>: decode <span class="keywd">is</span> [] (                      <span class="comment"># -1 is illegal</span>
        62, -1, -1, -1, 63,                                  <span class="comment"># + /</span>
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61,              <span class="comment"># 0 - 9</span>
        -1, -1, -1,  0, -1, -1, -1,                          <span class="comment"># =</span>
         0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,  <span class="comment"># A - M</span>
        13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,  <span class="comment"># N - Z</span>
        -1, -1, -1, -1, -1, -1,
        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,  <span class="comment"># a - m</span>
        39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51); <span class="comment"># n - z</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: subIndex <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: fourBytes <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: threeBytes <span class="keywd">is</span> <span class="stri">"   "</span>;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> index &lt;= length(base64) - 3 <span class="keywd">do</span>
      <span class="keywd">if</span> base64[index] >= <span class="stri">'+'</span> <span class="keywd">then</span>
        fourBytes := 0;
        <span class="keywd">for</span> subIndex <span class="keywd">range</span> index <span class="keywd">to</span> index + 3 <span class="keywd">do</span>
          number := decode[ord(base64[subIndex]) - ord(pred(<span class="stri">'+'</span>))];
          <span class="keywd">if</span> number = -1 <span class="keywd">then</span>
            raise RANGE_ERROR;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          fourBytes := (fourBytes &lt;&lt; 6) + number;
        <span class="keywd">end</span> <span class="keywd">for</span>;
        threeBytes @:= [1] chr( fourBytes >> 16);
        threeBytes @:= [2] chr((fourBytes >>  8) <span class="op">mod</span> 256);
        threeBytes @:= [3] chr( fourBytes        <span class="op">mod</span> 256);
        decoded &amp;:= threeBytes;
        index +:= 4;
      <span class="keywd">elsif</span> base64[index] = <span class="stri">'\n'</span> <span class="op">or</span> base64[index] = <span class="stri">'\r'</span> <span class="keywd">then</span>
        incr(index);
      <span class="keywd">else</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> index &lt;> succ(length(base64)) <span class="op">or</span>
        (length(base64) >= 2 <span class="op">and</span>
         pos(base64[.. length(base64) - 2], <span class="stri">'='</span>) &lt;> 0) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> length(base64) >= 2 <span class="op">and</span> base64[pred(length(base64)) fixLen 2] = <span class="stri">"=="</span> <span class="keywd">then</span>
      decoded := decoded[.. length(decoded) - 2];
    <span class="keywd">elsif</span> length(base64) >= 1 <span class="op">and</span> base64[length(base64)] = <span class="stri">'='</span> <span class="keywd">then</span>
      decoded := decoded[.. pred(length(decoded))];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Encode a string with the Quoted-printable encoding.
 *  Quoted-printable encodes a byte string as ASCII string. This
 *  is done by encoding printable ASCII characters except '=' as
 *  themself. Other byte values are encoded with '=' followed by two
 *  hexadecimal digits representing the byte's numeric value.
 *  @return the encoded string.
 *  @exception RANGE_ERROR If characters beyond '\255;' are present.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: toQuotedPrintable (<span class="op">in</span> <span class="type">string</span>: byteStri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: quoted <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: startPos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: counter <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length(byteStri) <span class="keywd">do</span>
      ch := byteStri[index];
      <span class="keywd">if</span> ch >= <span class="stri">'\256;'</span> <span class="keywd">then</span>
        raise RANGE_ERROR;
      <span class="keywd">elsif</span> ch = <span class="stri">'\n'</span> <span class="op">or</span> (ch = <span class="stri">'\r'</span> <span class="op">and</span>
          index &lt; length(byteStri) <span class="op">and</span> byteStri[succ(index)] = <span class="stri">'\n'</span>) <span class="keywd">then</span>
        <span class="keywd">if</span> index > 1 <span class="keywd">then</span>
          ch := byteStri[pred(index)];
          <span class="keywd">if</span> ch = <span class="stri">' '</span> <span class="op">or</span> ch = <span class="stri">'\t'</span> <span class="keywd">then</span>
            quoted &amp;:= byteStri[startPos .. index - 2];
            <span class="keywd">if</span> counter >= 76 <span class="keywd">then</span>
              quoted &amp;:= <span class="stri">"=\n"</span>;
              counter := 1;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            quoted &amp;:= <span class="stri">"="</span> &lt;&amp; ord(byteStri[pred(index)]) RADIX 16 <span class="op">lpad0</span> 2;
            counter +:= 3;
            startPos := index;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        counter := 1;
      <span class="keywd">elsif</span> ch >= <span class="stri">'\127;'</span> <span class="op">or</span> ch = <span class="stri">'='</span> <span class="op">or</span> (ch &lt; <span class="stri">' '</span> <span class="op">and</span> ch &lt;> <span class="stri">'\9;'</span>) <span class="keywd">then</span>
        quoted &amp;:= byteStri[startPos .. pred(index)];
        <span class="keywd">if</span> counter >= 74 <span class="keywd">then</span>
          quoted &amp;:= <span class="stri">"=\n"</span>;
          counter := 1;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        quoted &amp;:= <span class="stri">"="</span> &lt;&amp; ord(ch) RADIX 16 <span class="op">lpad0</span> 2;
        startPos := succ(index);
        counter +:= 3;
      <span class="keywd">elsif</span> counter >= 76 <span class="keywd">then</span>
        quoted &amp;:= byteStri[startPos .. pred(index)] &amp; <span class="stri">"=\n"</span>;
        startPos := index;
        counter := 2;
      <span class="keywd">else</span>
        incr(counter);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    quoted &amp;:= byteStri[startPos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Decode a quoted-printable encoded string.
 *  @return the decoded string.
 *  @exception RANGE_ERROR If ''quoted'' is not in quoted-printable format.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: fromQuotedPrintable (<span class="op">in</span> <span class="type">string</span>: quoted) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: decoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: startPos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: equalSignPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: twoChars <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    equalSignPos := pos(quoted, <span class="stri">"="</span>);
    <span class="keywd">while</span> equalSignPos &lt;> 0 <span class="keywd">do</span>
      decoded &amp;:= quoted[startPos .. pred(equalSignPos)];
      <span class="keywd">if</span> equalSignPos &lt; length(quoted) <span class="op">and</span>
          quoted[succ(equalSignPos)] = <span class="stri">'\n'</span> <span class="keywd">then</span>
        startPos := equalSignPos + 2;
      <span class="keywd">elsif</span> equalSignPos &lt;= length(quoted) - 2 <span class="keywd">then</span>
        twoChars := quoted[succ(equalSignPos) fixLen 2];
        <span class="keywd">if</span> twoChars[1] <span class="op">in</span> hexdigit_char <span class="op">and</span>
            twoChars[2] <span class="op">in</span> hexdigit_char <span class="keywd">then</span>
          decoded &amp;:= chr(integer(twoChars, 16));
        <span class="keywd">elsif</span> twoChars &lt;> <span class="stri">"\r\n"</span> <span class="keywd">then</span>
          raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        startPos := equalSignPos + 3;
      <span class="keywd">else</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      equalSignPos := pos(quoted, <span class="stri">"="</span>, startPos);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    decoded &amp;:= quoted[startPos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Encode a string with uuencoding.
 *  Uuencode encodes a byte string as ASCII string. This is done
 *  by taking packs of 6-bits and translating them into a radix-64
 *  representation. The radix-64 digits are encoded with consecutive
 *  ASCII characters starting from ' ' (which represents 0). Every
 *  line starts with a radix-64 digit character indicating the number
 *  of data bytes encoded on that line. Some newer uuencode tools use
 *  grave accent ('`') instead of space (' ') to encode 0. This can
 *  be emulated by using: replace(toUuencoded(source), " ", "`").
 *  @return the encoded string.
 *  @exception RANGE_ERROR If characters beyond '\255;' are present.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: toUuencoded (<span class="op">in</span> <span class="type">string</span>: byteStri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: uuencoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: subIndex <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: threeBytes <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: fourBytes <span class="keywd">is</span> <span class="stri">"    "</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: posToAddNewline <span class="keywd">is</span> 43;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(byteStri) &lt;> 0 <span class="keywd">then</span>
      <span class="keywd">if</span> length(byteStri) &lt; 45 <span class="keywd">then</span>
        uuencoded &amp;:= chr(32 + length(byteStri));
      <span class="keywd">else</span>
        uuencoded &amp;:= <span class="stri">"M"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length(byteStri) step 3 <span class="keywd">do</span>
        threeBytes := 0;
        <span class="keywd">for</span> subIndex <span class="keywd">range</span> index <span class="keywd">to</span> index + 2 <span class="keywd">do</span>
          threeBytes &lt;&lt;:= 8;
          <span class="keywd">if</span> subIndex &lt;= length(byteStri) <span class="keywd">then</span>
            ch := byteStri[subIndex];
            <span class="keywd">if</span> ch >= <span class="stri">'\256;'</span> <span class="keywd">then</span>
              raise RANGE_ERROR;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            threeBytes +:= ord(ch);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
        fourBytes @:= [1] chr(32 + (threeBytes >> 18));
        fourBytes @:= [2] chr(32 + (threeBytes >> 12) <span class="op">mod</span> 64);
        fourBytes @:= [3] chr(32 + (threeBytes >>  6) <span class="op">mod</span> 64);
        fourBytes @:= [4] chr(32 +  threeBytes        <span class="op">mod</span> 64);
        uuencoded &amp;:= fourBytes;
        <span class="keywd">if</span> index = posToAddNewline <span class="op">and</span> length(byteStri) > index + 2 <span class="keywd">then</span>
          <span class="keywd">if</span> length(byteStri) - index - 2 &lt; 45 <span class="keywd">then</span>
            uuencoded &amp;:= <span class="stri">"\n"</span> &lt;&amp; chr(32 + length(byteStri) - index - 2);
          <span class="keywd">else</span>
            uuencoded &amp;:= <span class="stri">"\nM"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          posToAddNewline +:= 45;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      uuencoded &amp;:= <span class="stri">"\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    uuencoded &amp;:= <span class="stri">"`\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Decode an uuencoded string.
 *  Space (' ') and grave accent ('`') both are used to encode 0.
 *  @return the decoded string.
 *  @exception RANGE_ERROR If ''uuencoded'' is not in uuencoded format.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: fromUuencoded (<span class="op">in</span> <span class="type">string</span>: uuencoded) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: decoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: lineLength <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: subIndex <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: fourBytes <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: threeBytes <span class="keywd">is</span> <span class="stri">"   "</span>;
  <span class="keywd">begin</span>
    lineLength := ord(uuencoded[1]) - 32;
    <span class="keywd">while</span> lineLength &lt;> 0 <span class="op">and</span> lineLength &lt;> 64 <span class="keywd">do</span>
      incr(index);
      <span class="keywd">while</span> lineLength >= 1 <span class="keywd">do</span>
        fourBytes := 0;
        <span class="keywd">for</span> subIndex <span class="keywd">range</span> index <span class="keywd">to</span> index + 3 <span class="keywd">do</span>
          number := ord(uuencoded[subIndex]) - 32;
          <span class="keywd">if</span> number = 64 <span class="keywd">then</span>
            number := 0;
          <span class="keywd">elsif</span> number &lt; 0 <span class="op">or</span> number > 64 <span class="keywd">then</span>
            raise RANGE_ERROR;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          fourBytes := (fourBytes &lt;&lt; 6) + number;
        <span class="keywd">end</span> <span class="keywd">for</span>;
        threeBytes @:= [1] chr( fourBytes >> 16);
        threeBytes @:= [2] chr((fourBytes >>  8) <span class="op">mod</span> 256);
        threeBytes @:= [3] chr( fourBytes        <span class="op">mod</span> 256);
        decoded &amp;:= threeBytes[ .. lineLength];
        lineLength -:= 3;
        index +:= 4;
      <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">while</span> index &lt;= length(uuencoded) <span class="op">and</span> uuencoded[index] &lt;> <span class="stri">'\n'</span> <span class="keywd">do</span>
        incr(index);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">if</span> index &lt; length(uuencoded) <span class="keywd">then</span>
        incr(index);
        lineLength := ord(uuencoded[index]) - 32;
      <span class="keywd">else</span>
        lineLength := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Encode a string with percent-encoding.
 *  Percent-encoding encodes a byte string as ASCII string. This is done
 *  by encoding all characters, which are not in the set of unreserved
 *  characters (A-Z, a-z, 0-9 - _ . ~). The encoding uses a percent sign
 *  ('%') followed by two hexadecimal digits, which represent the ordinal
 *  value of the encoded character.
 *  @return the encoded string.
 *  @exception RANGE_ERROR If characters beyond '\255;' are present.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: toPercentEncoded (<span class="op">in</span> <span class="type">string</span>: byteStri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: percentEncoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">set</span> <span class="type">of</span> <span class="type">char</span>: unreservedChars <span class="keywd">is</span> alphanum_char | {<span class="stri">'-'</span>, <span class="stri">'_'</span>, <span class="stri">'.'</span>, <span class="stri">'~'</span>};
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: start <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> ch <span class="keywd">key</span> pos <span class="keywd">range</span> byteStri <span class="keywd">do</span>
      <span class="keywd">if</span> ch > <span class="stri">'\255;'</span> <span class="keywd">then</span>
        raise RANGE_ERROR;
      <span class="keywd">elsif</span> ch <span class="op">not</span> <span class="op">in</span> unreservedChars <span class="keywd">then</span>
        percentEncoded &amp;:= byteStri[start .. pred(pos)];
        percentEncoded &amp;:= <span class="stri">"%"</span> &lt;&amp; ord(ch) RADIX 16 <span class="op">lpad0</span> 2;
        start := succ(pos);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    percentEncoded &amp;:= byteStri[start ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Decode a percent-encoded string.
 *  Percent-encoding encodes a byte string as ASCII string. It uses
 *  the percent sign ('%') followed by two hexadecimal digits to
 *  encode characters that otherwise would not be allowed in an
 *  URL. Allowed URL characters are encoded as themself.
 *  @return the decoded string.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: fromPercentEncoded (<span class="op">in</span> <span class="type">string</span>: percentEncoded) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: decoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    decoded := percentEncoded;
    pos := pos(decoded, <span class="stri">'%'</span>);
    <span class="keywd">while</span> pos &lt;> 0 <span class="keywd">do</span>
      <span class="keywd">if</span> pos &lt;= length(decoded) - 2 <span class="op">and</span>
          decoded[succ(pos)] <span class="op">in</span> hexdigit_char <span class="op">and</span>
          decoded[pos + 2] <span class="op">in</span> hexdigit_char <span class="keywd">then</span>
        decoded := decoded[.. pred(pos)] &amp;
            str(chr(integer(decoded[succ(pos) fixLen 2], 16))) &amp;
            decoded[pos + 3 ..];
      <span class="keywd">end</span> <span class="keywd">if</span>;
      pos := pos(decoded, <span class="stri">'%'</span>, succ(pos));
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Encode a string with URL encoding.
 *  URL encoding encodes a byte string as ASCII string. This is done
 *  by encoding all characters, which are not in the set of unreserved
 *  characters (A-Z, a-z, 0-9 - _ . ~). The encoding uses a percent sign
 *  ('%') followed by two hexadecimal digits, which represent the ordinal
 *  value of the encoded character. A plus sign ('+') is used to encode
 *  a space (' ').
 *  @return the encoded string.
 *  @exception RANGE_ERROR If characters beyond '\255;' are present.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: toUrlEncoded (<span class="op">in</span> <span class="type">string</span>: byteStri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: urlEncoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">set</span> <span class="type">of</span> <span class="type">char</span>: unreservedChars <span class="keywd">is</span> alphanum_char | {<span class="stri">'-'</span>, <span class="stri">'_'</span>, <span class="stri">'.'</span>, <span class="stri">'~'</span>};
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: start <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> ch <span class="keywd">key</span> pos <span class="keywd">range</span> byteStri <span class="keywd">do</span>
      <span class="keywd">if</span> ch > <span class="stri">'\255;'</span> <span class="keywd">then</span>
        raise RANGE_ERROR;
      <span class="keywd">elsif</span> ch = <span class="stri">' '</span> <span class="keywd">then</span>
        urlEncoded &amp;:= byteStri[start .. pred(pos)];
        urlEncoded &amp;:= <span class="stri">'+'</span>;
        start := succ(pos);
      <span class="keywd">elsif</span> ch <span class="op">not</span> <span class="op">in</span> unreservedChars <span class="keywd">then</span>
        urlEncoded &amp;:= byteStri[start .. pred(pos)];
        urlEncoded &amp;:= <span class="stri">"%"</span> &lt;&amp; ord(ch) RADIX 16 <span class="op">lpad0</span> 2;
        start := succ(pos);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    urlEncoded &amp;:= byteStri[start ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Decode an URL encoded string.
 *  URL encoding encodes a byte string as ASCII string. It uses
 *  the percent sign ('%') followed by two hexadecimal digits to
 *  encode characters that otherwise would not be allowed in an
 *  URL. A plus sign ('+') is used to encode a space (' ').
 *  Allowed URL characters are encoded as themself.
 *  @return the decoded string.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: fromUrlEncoded (<span class="op">in</span> <span class="type">string</span>: urlEncoded) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: decoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: start <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> ch <span class="keywd">key</span> pos <span class="keywd">range</span> urlEncoded <span class="keywd">do</span>
      <span class="keywd">if</span> ch = <span class="stri">'%'</span> <span class="op">and</span> pos &lt;= length(urlEncoded) - 2 <span class="op">and</span>
          urlEncoded[succ(pos)] <span class="op">in</span> hexdigit_char <span class="op">and</span>
          urlEncoded[pos + 2] <span class="op">in</span> hexdigit_char <span class="keywd">then</span>
        decoded &amp;:= urlEncoded[start .. pred(pos)];
        decoded &amp;:= chr(integer(urlEncoded[succ(pos) fixLen 2], 16));
        pos +:= 2;
        start := succ(pos);
      <span class="keywd">elsif</span> ch = <span class="stri">'+'</span> <span class="keywd">then</span>
        decoded &amp;:= urlEncoded[start .. pred(pos)];
        decoded &amp;:= <span class="stri">' '</span>;
        start := succ(pos);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    decoded &amp;:= urlEncoded[start ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Encode a string with the Ascii85 encoding.
 *  Ascii85 encodes a byte string as ASCII string. This is done by
 *  encoded every four bytes with five printable ASCII characters.
 *  Five radix 85 digits provide enough possible values to encode
 *  the possible values of four bytes. The radix 85 digits are encoded
 *  with the characters '!' (encodes 0) through 'u' (encodes 84).
 *  If the last block of the byte string contains fewer than 4 bytes,
 *  the block is padded with up to three null bytes before encoding.
 *  After encoding, as many bytes as were added as padding are removed
 *  from the end of the output. In files the end of an Ascii85 encoding
 *  is marked with "~>" (this end marker is not added by toAscii85).
 *  @return the Ascii85 encoded string.
 *  @exception RANGE_ERROR If characters beyond '\255;' are present.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: toAscii85 (<span class="op">in</span> <span class="type">string</span>: byteStri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: ascii85 <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: subIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: fourBytes <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: fiveBytes <span class="keywd">is</span> <span class="stri">"     "</span>;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length(byteStri) step 4 <span class="keywd">do</span>
      fourBytes := 0;
      <span class="keywd">for</span> subIndex <span class="keywd">range</span> index <span class="keywd">to</span> index + 3 <span class="keywd">do</span>
        fourBytes &lt;&lt;:= 8;
        <span class="keywd">if</span> subIndex &lt;= length(byteStri) <span class="keywd">then</span>
          ch := byteStri[subIndex];
          <span class="keywd">if</span> ch >= <span class="stri">'\256;'</span> <span class="keywd">then</span>
            raise RANGE_ERROR;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          fourBytes +:= ord(ch);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">if</span> fourBytes = 0 <span class="keywd">then</span>
        ascii85 &amp;:= <span class="stri">'z'</span>;
      <span class="keywd">else</span>
        <span class="keywd">for</span> subIndex <span class="keywd">range</span> 5 <span class="keywd">downto</span> 1 <span class="keywd">do</span>
          fiveBytes @:= [subIndex] chr(ord(<span class="stri">'!'</span>) + fourBytes <span class="op">rem</span> 85);
          fourBytes := fourBytes <span class="op">div</span> 85;
        <span class="keywd">end</span> <span class="keywd">for</span>;
        ascii85 &amp;:= fiveBytes;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> length(byteStri) <span class="op">rem</span> 4 &lt;> 0 <span class="keywd">then</span>
      ascii85 := ascii85[.. length(ascii85) - 4 + length(byteStri) <span class="op">rem</span> 4];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Decode an Ascii85 encoded string.
 *  Every block of five radix 85 characters is decoded to four bytes.
 *  Radix 85 characters are between '!' (encodes 0) and 'u' (encodes 84).
 *  The character 'z' is used to encode a block of four zero bytes.
 *  White space in the Ascii85 encoded string is ignored.
 *  The last block is padded to 5 bytes with the Ascii85 character "u",
 *  and as many bytes as were added as padding are omitted from the
 *  end of the output.
 *  @return the decoded string.
 *  @exception RANGE_ERROR If ''ascii85'' is not in Ascii85 format.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: fromAscii85 (<span class="op">in</span> <span class="type">string</span>: ascii85) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: decoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">set</span> <span class="type">of</span> <span class="type">char</span>: whiteSpace <span class="keywd">is</span> {<span class="stri">'\0;'</span>, <span class="stri">'\t'</span>, <span class="stri">'\n'</span>, <span class="stri">'\f'</span>, <span class="stri">'\r'</span>, <span class="stri">' '</span>};
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: digitIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: base85Number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: idx <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> ch <span class="keywd">range</span> ascii85 <span class="keywd">until</span> ch = <span class="stri">'~'</span> <span class="keywd">do</span>
      <span class="keywd">if</span> ch >= <span class="stri">'!'</span> <span class="op">and</span> ch &lt;= <span class="stri">'u'</span> <span class="keywd">then</span>
        incr(digitIndex);
        base85Number := base85Number * 85 + (ord(ch) - ord(<span class="stri">'!'</span>));
        <span class="keywd">if</span> digitIndex = 5 <span class="keywd">then</span>
          decoded &amp;:= bytes(base85Number, UNSIGNED, BE, 4);
          digitIndex := 0;
          base85Number := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> ch = <span class="stri">'z'</span> <span class="op">and</span> digitIndex = 0 <span class="keywd">then</span>
        decoded &amp;:= <span class="stri">"\0;\0;\0;\0;"</span>;
      <span class="keywd">elsif</span> ch <span class="op">not</span> <span class="op">in</span> whiteSpace <span class="keywd">then</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> digitIndex &lt;> 0 <span class="keywd">then</span>
      <span class="keywd">for</span> idx <span class="keywd">range</span> 1 <span class="keywd">to</span> 5 - digitIndex <span class="keywd">do</span>
        base85Number := base85Number * 85 + 84;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      decoded &amp;:= bytes(base85Number, UNSIGNED, BE, 4)[.. pred(digitIndex)];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Encode a string with the AsciiHex encoding.
 *  AsciiHex encodes a byte string as ASCII string.
 *  In AsciiHex each byte is encoded with two hexadecimal digits.
 *  White-space characters in an AsciiHex encoded string are ignored.
 *  The AsciiHex encoded string ends with the character '>'.
 *  @return the AsciiHex encoded string.
 *  @exception RANGE_ERROR If characters beyond '\255;' are present.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: toAsciiHex (<span class="op">in</span> <span class="type">string</span>: byteStri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: asciiHex <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">char</span>: endOfData <span class="keywd">is</span> <span class="stri">'>'</span>;
    <span class="keywd">const</span> <span class="type">integer</span>: encodingsPerLine <span class="keywd">is</span> 32;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> index &lt;= length(byteStri) <span class="keywd">do</span>
      asciiHex &amp;:= hex(byteStri[index len encodingsPerLine]);
      index +:= encodingsPerLine;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    asciiHex &amp;:= endOfData;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Decode an AsciiHex encoded string.
 *  In AsciiHex each byte is encoded with two hexadecimal digits.
 *  White-space characters in an AsciiHex encoded string are ignored.
 *  The AsciiHex encoded string ends with the character '>'.
 *  If a '>' follows the first hexadecimal digit of an encoded byte
 *  the decoding works as if a '0' is at the place of the '>'.
 *  The decoder works also correctly if the '>' is missing.
 *  @return the decoded string.
 *  @exception RANGE_ERROR If ''asciiHex'' is not in AsciiHex format.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: fromAsciiHex (<span class="op">in</span> <span class="type">string</span>: asciiHex) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">char</span>: endOfData <span class="keywd">is</span> <span class="stri">'>'</span>;
    <span class="keywd">const</span> <span class="type">set</span> <span class="type">of</span> <span class="type">char</span>: whiteSpace <span class="keywd">is</span> {<span class="stri">'\0;'</span>, <span class="stri">'\t'</span>, <span class="stri">'\n'</span>, <span class="stri">'\f'</span>, <span class="stri">'\r'</span>, <span class="stri">' '</span>};
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> index &lt; length(asciiHex) <span class="op">and</span> asciiHex[index] &lt;> endOfData <span class="keywd">do</span>
      <span class="keywd">if</span> asciiHex[index] <span class="op">not</span> <span class="op">in</span> whiteSpace <span class="keywd">then</span>
        <span class="keywd">if</span> asciiHex[succ(index)] = endOfData <span class="keywd">then</span>
          stri &amp;:= char(integer(asciiHex[index fixLen 1] &amp; <span class="stri">"0"</span>, 16));
          incr(index);
        <span class="keywd">else</span>
          stri &amp;:= char(integer(asciiHex[index fixLen 2], 16));
          index +:= 2;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        incr(index);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> index = length(asciiHex) <span class="op">and</span> asciiHex[index] &lt;> endOfData <span class="keywd">then</span>
      stri &amp;:= char(integer(asciiHex[index fixLen 1] &amp; <span class="stri">"0"</span>, 16));
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Encode a number with a positional numeric system.
 *  The encoded string starts with the most significant digit.
 *  @param number BigInteger number to be encoded.
 *  @param digits The digits used by the positional numeric system.
 *  @return the encoded string.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: toBase (<span class="op">in</span> <span class="type">bigInteger</span>: number, <span class="op">in</span> <span class="type">string</span>: <span class="op">digits</span>) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: encoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">bigInteger</span>: base <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <span class="type">quotRem</span>: quotientAndRemainder <span class="keywd">is</span> quotRem.value;
  <span class="keywd">begin</span>
    base := bigInteger(length(<span class="op">digits</span>));
    quotientAndRemainder.quotient := number;
    <span class="keywd">while</span> quotientAndRemainder.quotient &lt;> 0_ <span class="keywd">do</span>
      quotientAndRemainder := quotientAndRemainder.quotient divRem base;
      encoded &amp;:= <span class="op">digits</span>[succ(ord(quotientAndRemainder.remainder))];
    <span class="keywd">end</span> <span class="keywd">while</span>;
    encoded := reverse(encoded);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Decode a string that has been encoded with a positional numeric system.
 *  The encoded string starts with the most significant digit.
 *  @param encoded String containing the encoded data.
 *  @param digits The digits used by the positional numeric system.
 *  @return the decoded bigInteger Number.
 *  @exception RANGE_ERROR If characters are present, that are not found
 *                         in ''digits''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">bigInteger</span>: fromBaseToBigInt (<span class="op">in</span> <span class="type">string</span>: encoded, <span class="op">in</span> <span class="type">string</span>: <span class="op">digits</span>) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">bigInteger</span>: number <span class="keywd">is</span> 0_;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">bigInteger</span>: base <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <span class="type">bigInteger</span>: factor <span class="keywd">is</span> 1_;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: digit <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    base := bigInteger(length(<span class="op">digits</span>));
    <span class="keywd">for</span> index <span class="keywd">range</span> length(encoded) <span class="keywd">downto</span> 1 <span class="keywd">do</span>
      digit := pred(pos(<span class="op">digits</span>, encoded[index]));
      <span class="keywd">if</span> digit = -1 <span class="keywd">then</span>
        raise RANGE_ERROR;
      <span class="keywd">else</span>
        number +:= factor * bigInteger(digit);
        factor *:= base;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Encode a string of bytes with a positional numeric system.
 *  The encoded string starts with the most significant digit.
 *  Leading zero bytes in ''byteStri'' are converted into leading
 *  zero digits in the encoded string.
 *  @param byteStri String of bytes to be encoded.
 *  @param digits The digits used by the positional numeric system.
 *  @return the encoded string.
 *  @exception RANGE_ERROR If characters beyond '\255;' are present.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: toBase (<span class="op">in</span> <span class="type">string</span>: byteStri, <span class="op">in</span> <span class="type">string</span>: <span class="op">digits</span>) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: encoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> byteStri &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      encoded := toBase(bytes2BigInt(byteStri, UNSIGNED, BE), <span class="op">digits</span>);
      <span class="keywd">while</span> index &lt;= length(byteStri) <span class="op">and</span> byteStri[index] = <span class="stri">'\0;'</span> <span class="keywd">do</span>
        incr(index);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">if</span> index > 1 <span class="keywd">then</span>
        encoded := str(<span class="op">digits</span>[1]) <span class="op">mult</span> pred(index) &amp; encoded;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Decode a string that has been encoded with a positional numeric system.
 *  The encoded string starts with the most significant digit.
 *  Leading zero digits in the encoded string are converted into leading
 *  zero bytes in the decoded string.
 *  @param encoded String containing the encoded data.
 *  @param digits The digits used by the positional numeric system.
 *  @return the decoded string.
 *  @exception RANGE_ERROR If characters are present, that are not found
 *                         in ''digits''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: fromBase (<span class="op">in</span> <span class="type">string</span>: encoded, <span class="op">in</span> <span class="type">string</span>: <span class="op">digits</span>) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: decoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">bigInteger</span>: number <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    number := fromBaseToBigInt(encoded, <span class="op">digits</span>);
    <span class="keywd">if</span> number &lt;> 0_ <span class="keywd">then</span>
      decoded := bytes(number, UNSIGNED, BE);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">while</span> index &lt;= length(encoded) <span class="op">and</span> encoded[index] = <span class="op">digits</span>[1] <span class="keywd">do</span>
      incr(index);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> index > 1 <span class="keywd">then</span>
      decoded := <span class="stri">"\0;"</span> <span class="op">mult</span> pred(index) &amp; decoded;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">string</span>: defaultBase58Digits <span class="keywd">is</span> <span class="stri">"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"</span>;


<span class="comment">(**
 *  Encode a string with the Base58 encoding used by Bitcoin.
 *  Leading zero bytes ('\0;') in ''byteStri'' are converted into
 *  leading zero digits ('1') in the encoded string.
 *  @param byteStri String of bytes to be encoded.
 *  @return the encoded string.
 *  @exception RANGE_ERROR If characters beyond '\255;' are present.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: toBase58 (<span class="op">in</span> <span class="type">string</span>: byteStri) <span class="keywd">is</span>
  <span class="keywd">return</span> toBase(byteStri, defaultBase58Digits);


<span class="comment">(**
 *  Decode a Base58 encoded string.
 *  Leading '1' characters in ''base58'' are converted into
 *  leading zero bytes ('\0;') in the decoded string.
 *  @param base58 String containing Base58 encoded data.
 *  @return the decoded string.
 *  @exception RANGE_ERROR If characters are present, that are not valid
 *                         in the Base58 encoding used by Bitcoin.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: fromBase58 (<span class="op">in</span> <span class="type">string</span>: base58) <span class="keywd">is</span>
  <span class="keywd">return</span> fromBase(base58, defaultBase58Digits);
</pre>
</body>
</html>
