<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  ccittfax.s7i  CCITT fax decoding support library                *)</span>
<span class="comment">(*  Copyright (C) 2015, 2022, 2023, 2024  Thomas Mertes             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bytedata.htm">bytedata.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bitdata.htm">bitdata.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/huffman.htm">huffman.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/graph.htm">graph.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/pixelimage.htm">pixelimage.s7i</a>"</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">msbHuffmanDecoder</span>: createMsbHuffmanDecoder (<span class="op">in</span> <span class="type">integer</span>: maximumCodeLength) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">msbHuffmanDecoder</span>: decoder <span class="keywd">is</span> msbHuffmanDecoder.value;
  <span class="keywd">begin</span>
    decoder.maxBitWidth := maximumCodeLength;
    decoder.symbols := huffmanSymbolArray[.. pred(1 &lt;&lt; maximumCodeLength)] <span class="op">times</span> -2;
    decoder.codeLengths := msbHuffmanCodeLengthArray[.. pred(1 &lt;&lt; maximumCodeLength)] <span class="op">times</span> 0;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: addCode (<span class="keywd">inout</span> <span class="type">msbHuffmanDecoder</span>: decoder, <span class="op">in</span> <span class="type">integer</span>: symbol, <span class="op">in</span> <span class="type">string</span>: bits) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: codeLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: currentCode <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: tableIndex <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    codeLength := length(bits);
    currentCode := integer(bits, 2);
    tableIndex := currentCode &lt;&lt; (decoder.maxBitWidth - codeLength);
    <span class="keywd">while</span> currentCode = tableIndex >> (decoder.maxBitWidth - codeLength) <span class="keywd">do</span>
      decoder.symbols[tableIndex] := symbol;
      decoder.codeLengths[tableIndex] := codeLength;
      incr(tableIndex);
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">lsbHuffmanDecoder</span>: createLsbHuffmanDecoder (<span class="op">in</span> <span class="type">integer</span>: maximumCodeLength,
    <span class="op">in</span> <span class="type">integer</span>: minSymbol, <span class="op">in</span> <span class="type">integer</span>: maxSymbol) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">lsbHuffmanDecoder</span>: decoder <span class="keywd">is</span> lsbHuffmanDecoder.value;
  <span class="keywd">begin</span>
    decoder.maxBitWidth := maximumCodeLength;
    decoder.symbols := huffmanSymbolArray[.. pred(1 &lt;&lt; maximumCodeLength)] <span class="op">times</span> -2;
    decoder.codeLengths := [minSymbol .. maxSymbol] <span class="op">times</span> 0;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: addCode (<span class="keywd">inout</span> <span class="type">lsbHuffmanDecoder</span>: decoder, <span class="op">in</span> <span class="type">integer</span>: symbol, <span class="op">in</span> <span class="type">string</span>: bits) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: codeLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: currentCode <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: reversedCode <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: highBits <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    codeLength := length(bits);
    currentCode := integer(bits, 2);
    reversedCode := reverseBits(codeLength, currentCode);
    <span class="keywd">for</span> highBits <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(1 &lt;&lt; decoder.maxBitWidth) step 1 &lt;&lt; codeLength <span class="keywd">do</span>
      decoder.symbols[highBits + reversedCode] := symbol;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    decoder.codeLengths[symbol] := codeLength;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: huffmanSymbolBits <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: symbol <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: bits <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">huffmanSymbolBits</span>: huffmanSymbolBits (<span class="op">in</span> <span class="type">integer</span>: symbol, <span class="op">in</span> <span class="type">string</span>: bits) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">huffmanSymbolBits</span>: symbolBits <span class="keywd">is</span> huffmanSymbolBits.value;
  <span class="keywd">begin</span>
    symbolBits.symbol := symbol;
    symbolBits.bits := bits;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">array</span> <span class="type">huffmanSymbolBits</span>: whiteHuffmanSymbolBits <span class="keywd">is</span> [] (
    huffmanSymbolBits(  -1, <span class="stri">"000000000001"</span>),
    huffmanSymbolBits(   0, <span class="stri">"00110101"</span>),
    huffmanSymbolBits(   1, <span class="stri">"000111"</span>),
    huffmanSymbolBits(   2, <span class="stri">"0111"</span>),
    huffmanSymbolBits(   3, <span class="stri">"1000"</span>),
    huffmanSymbolBits(   4, <span class="stri">"1011"</span>),
    huffmanSymbolBits(   5, <span class="stri">"1100"</span>),
    huffmanSymbolBits(   6, <span class="stri">"1110"</span>),
    huffmanSymbolBits(   7, <span class="stri">"1111"</span>),
    huffmanSymbolBits(   8, <span class="stri">"10011"</span>),
    huffmanSymbolBits(   9, <span class="stri">"10100"</span>),
    huffmanSymbolBits(  10, <span class="stri">"00111"</span>),
    huffmanSymbolBits(  11, <span class="stri">"01000"</span>),
    huffmanSymbolBits(  12, <span class="stri">"001000"</span>),
    huffmanSymbolBits(  13, <span class="stri">"000011"</span>),
    huffmanSymbolBits(  14, <span class="stri">"110100"</span>),
    huffmanSymbolBits(  15, <span class="stri">"110101"</span>),
    huffmanSymbolBits(  16, <span class="stri">"101010"</span>),
    huffmanSymbolBits(  17, <span class="stri">"101011"</span>),
    huffmanSymbolBits(  18, <span class="stri">"0100111"</span>),
    huffmanSymbolBits(  19, <span class="stri">"0001100"</span>),
    huffmanSymbolBits(  20, <span class="stri">"0001000"</span>),
    huffmanSymbolBits(  21, <span class="stri">"0010111"</span>),
    huffmanSymbolBits(  22, <span class="stri">"0000011"</span>),
    huffmanSymbolBits(  23, <span class="stri">"0000100"</span>),
    huffmanSymbolBits(  24, <span class="stri">"0101000"</span>),
    huffmanSymbolBits(  25, <span class="stri">"0101011"</span>),
    huffmanSymbolBits(  26, <span class="stri">"0010011"</span>),
    huffmanSymbolBits(  27, <span class="stri">"0100100"</span>),
    huffmanSymbolBits(  28, <span class="stri">"0011000"</span>),
    huffmanSymbolBits(  29, <span class="stri">"00000010"</span>),
    huffmanSymbolBits(  30, <span class="stri">"00000011"</span>),
    huffmanSymbolBits(  31, <span class="stri">"00011010"</span>),
    huffmanSymbolBits(  32, <span class="stri">"00011011"</span>),
    huffmanSymbolBits(  33, <span class="stri">"00010010"</span>),
    huffmanSymbolBits(  34, <span class="stri">"00010011"</span>),
    huffmanSymbolBits(  35, <span class="stri">"00010100"</span>),
    huffmanSymbolBits(  36, <span class="stri">"00010101"</span>),
    huffmanSymbolBits(  37, <span class="stri">"00010110"</span>),
    huffmanSymbolBits(  38, <span class="stri">"00010111"</span>),
    huffmanSymbolBits(  39, <span class="stri">"00101000"</span>),
    huffmanSymbolBits(  40, <span class="stri">"00101001"</span>),
    huffmanSymbolBits(  41, <span class="stri">"00101010"</span>),
    huffmanSymbolBits(  42, <span class="stri">"00101011"</span>),
    huffmanSymbolBits(  43, <span class="stri">"00101100"</span>),
    huffmanSymbolBits(  44, <span class="stri">"00101101"</span>),
    huffmanSymbolBits(  45, <span class="stri">"00000100"</span>),
    huffmanSymbolBits(  46, <span class="stri">"00000101"</span>),
    huffmanSymbolBits(  47, <span class="stri">"00001010"</span>),
    huffmanSymbolBits(  48, <span class="stri">"00001011"</span>),
    huffmanSymbolBits(  49, <span class="stri">"01010010"</span>),
    huffmanSymbolBits(  50, <span class="stri">"01010011"</span>),
    huffmanSymbolBits(  51, <span class="stri">"01010100"</span>),
    huffmanSymbolBits(  52, <span class="stri">"01010101"</span>),
    huffmanSymbolBits(  53, <span class="stri">"00100100"</span>),
    huffmanSymbolBits(  54, <span class="stri">"00100101"</span>),
    huffmanSymbolBits(  55, <span class="stri">"01011000"</span>),
    huffmanSymbolBits(  56, <span class="stri">"01011001"</span>),
    huffmanSymbolBits(  57, <span class="stri">"01011010"</span>),
    huffmanSymbolBits(  58, <span class="stri">"01011011"</span>),
    huffmanSymbolBits(  59, <span class="stri">"01001010"</span>),
    huffmanSymbolBits(  60, <span class="stri">"01001011"</span>),
    huffmanSymbolBits(  61, <span class="stri">"00110010"</span>),
    huffmanSymbolBits(  62, <span class="stri">"00110011"</span>),
    huffmanSymbolBits(  63, <span class="stri">"00110100"</span>),
    huffmanSymbolBits(  64, <span class="stri">"11011"</span>),
    huffmanSymbolBits( 128, <span class="stri">"10010"</span>),
    huffmanSymbolBits( 192, <span class="stri">"010111"</span>),
    huffmanSymbolBits( 256, <span class="stri">"0110111"</span>),
    huffmanSymbolBits( 320, <span class="stri">"00110110"</span>),
    huffmanSymbolBits( 384, <span class="stri">"00110111"</span>),
    huffmanSymbolBits( 448, <span class="stri">"01100100"</span>),
    huffmanSymbolBits( 512, <span class="stri">"01100101"</span>),
    huffmanSymbolBits( 576, <span class="stri">"01101000"</span>),
    huffmanSymbolBits( 640, <span class="stri">"01100111"</span>),
    huffmanSymbolBits( 704, <span class="stri">"011001100"</span>),
    huffmanSymbolBits( 768, <span class="stri">"011001101"</span>),
    huffmanSymbolBits( 832, <span class="stri">"011010010"</span>),
    huffmanSymbolBits( 896, <span class="stri">"011010011"</span>),
    huffmanSymbolBits( 960, <span class="stri">"011010100"</span>),
    huffmanSymbolBits(1024, <span class="stri">"011010101"</span>),
    huffmanSymbolBits(1088, <span class="stri">"011010110"</span>),
    huffmanSymbolBits(1152, <span class="stri">"011010111"</span>),
    huffmanSymbolBits(1216, <span class="stri">"011011000"</span>),
    huffmanSymbolBits(1280, <span class="stri">"011011001"</span>),
    huffmanSymbolBits(1344, <span class="stri">"011011010"</span>),
    huffmanSymbolBits(1408, <span class="stri">"011011011"</span>),
    huffmanSymbolBits(1472, <span class="stri">"010011000"</span>),
    huffmanSymbolBits(1536, <span class="stri">"010011001"</span>),
    huffmanSymbolBits(1600, <span class="stri">"010011010"</span>),
    huffmanSymbolBits(1664, <span class="stri">"011000"</span>),
    huffmanSymbolBits(1728, <span class="stri">"010011011"</span>),
    huffmanSymbolBits(1792, <span class="stri">"00000001000"</span>),
    huffmanSymbolBits(1856, <span class="stri">"00000001100"</span>),
    huffmanSymbolBits(1920, <span class="stri">"00000001101"</span>),
    huffmanSymbolBits(1984, <span class="stri">"000000010010"</span>),
    huffmanSymbolBits(2048, <span class="stri">"000000010011"</span>),
    huffmanSymbolBits(2112, <span class="stri">"000000010100"</span>),
    huffmanSymbolBits(2176, <span class="stri">"000000010101"</span>),
    huffmanSymbolBits(2240, <span class="stri">"000000010110"</span>),
    huffmanSymbolBits(2304, <span class="stri">"000000010111"</span>),
    huffmanSymbolBits(2368, <span class="stri">"000000011100"</span>),
    huffmanSymbolBits(2432, <span class="stri">"000000011101"</span>),
    huffmanSymbolBits(2496, <span class="stri">"000000011110"</span>),
    huffmanSymbolBits(2560, <span class="stri">"000000011111"</span>));


<span class="keywd">const</span> <span class="type">array</span> <span class="type">huffmanSymbolBits</span>: blackHuffmanSymbolBits <span class="keywd">is</span> [] (
    huffmanSymbolBits(  -1, <span class="stri">"00000000000"</span>),
    huffmanSymbolBits(   0, <span class="stri">"0000110111"</span>),
    huffmanSymbolBits(   1, <span class="stri">"010"</span>),
    huffmanSymbolBits(   2, <span class="stri">"11"</span>),
    huffmanSymbolBits(   3, <span class="stri">"10"</span>),
    huffmanSymbolBits(   4, <span class="stri">"011"</span>),
    huffmanSymbolBits(   5, <span class="stri">"0011"</span>),
    huffmanSymbolBits(   6, <span class="stri">"0010"</span>),
    huffmanSymbolBits(   7, <span class="stri">"00011"</span>),
    huffmanSymbolBits(   8, <span class="stri">"000101"</span>),
    huffmanSymbolBits(   9, <span class="stri">"000100"</span>),
    huffmanSymbolBits(  10, <span class="stri">"0000100"</span>),
    huffmanSymbolBits(  11, <span class="stri">"0000101"</span>),
    huffmanSymbolBits(  12, <span class="stri">"0000111"</span>),
    huffmanSymbolBits(  13, <span class="stri">"00000100"</span>),
    huffmanSymbolBits(  14, <span class="stri">"00000111"</span>),
    huffmanSymbolBits(  15, <span class="stri">"000011000"</span>),
    huffmanSymbolBits(  16, <span class="stri">"0000010111"</span>),
    huffmanSymbolBits(  17, <span class="stri">"0000011000"</span>),
    huffmanSymbolBits(  18, <span class="stri">"0000001000"</span>),
    huffmanSymbolBits(  19, <span class="stri">"00001100111"</span>),
    huffmanSymbolBits(  20, <span class="stri">"00001101000"</span>),
    huffmanSymbolBits(  21, <span class="stri">"00001101100"</span>),
    huffmanSymbolBits(  22, <span class="stri">"00000110111"</span>),
    huffmanSymbolBits(  23, <span class="stri">"00000101000"</span>),
    huffmanSymbolBits(  24, <span class="stri">"00000010111"</span>),
    huffmanSymbolBits(  25, <span class="stri">"00000011000"</span>),
    huffmanSymbolBits(  26, <span class="stri">"000011001010"</span>),
    huffmanSymbolBits(  27, <span class="stri">"000011001011"</span>),
    huffmanSymbolBits(  28, <span class="stri">"000011001100"</span>),
    huffmanSymbolBits(  29, <span class="stri">"000011001101"</span>),
    huffmanSymbolBits(  30, <span class="stri">"000001101000"</span>),
    huffmanSymbolBits(  31, <span class="stri">"000001101001"</span>),
    huffmanSymbolBits(  32, <span class="stri">"000001101010"</span>),
    huffmanSymbolBits(  33, <span class="stri">"000001101011"</span>),
    huffmanSymbolBits(  34, <span class="stri">"000011010010"</span>),
    huffmanSymbolBits(  35, <span class="stri">"000011010011"</span>),
    huffmanSymbolBits(  36, <span class="stri">"000011010100"</span>),
    huffmanSymbolBits(  37, <span class="stri">"000011010101"</span>),
    huffmanSymbolBits(  38, <span class="stri">"000011010110"</span>),
    huffmanSymbolBits(  39, <span class="stri">"000011010111"</span>),
    huffmanSymbolBits(  40, <span class="stri">"000001101100"</span>),
    huffmanSymbolBits(  41, <span class="stri">"000001101101"</span>),
    huffmanSymbolBits(  42, <span class="stri">"000011011010"</span>),
    huffmanSymbolBits(  43, <span class="stri">"000011011011"</span>),
    huffmanSymbolBits(  44, <span class="stri">"000001010100"</span>),
    huffmanSymbolBits(  45, <span class="stri">"000001010101"</span>),
    huffmanSymbolBits(  46, <span class="stri">"000001010110"</span>),
    huffmanSymbolBits(  47, <span class="stri">"000001010111"</span>),
    huffmanSymbolBits(  48, <span class="stri">"000001100100"</span>),
    huffmanSymbolBits(  49, <span class="stri">"000001100101"</span>),
    huffmanSymbolBits(  50, <span class="stri">"000001010010"</span>),
    huffmanSymbolBits(  51, <span class="stri">"000001010011"</span>),
    huffmanSymbolBits(  52, <span class="stri">"000000100100"</span>),
    huffmanSymbolBits(  53, <span class="stri">"000000110111"</span>),
    huffmanSymbolBits(  54, <span class="stri">"000000111000"</span>),
    huffmanSymbolBits(  55, <span class="stri">"000000100111"</span>),
    huffmanSymbolBits(  56, <span class="stri">"000000101000"</span>),
    huffmanSymbolBits(  57, <span class="stri">"000001011000"</span>),
    huffmanSymbolBits(  58, <span class="stri">"000001011001"</span>),
    huffmanSymbolBits(  59, <span class="stri">"000000101011"</span>),
    huffmanSymbolBits(  60, <span class="stri">"000000101100"</span>),
    huffmanSymbolBits(  61, <span class="stri">"000001011010"</span>),
    huffmanSymbolBits(  62, <span class="stri">"000001100110"</span>),
    huffmanSymbolBits(  63, <span class="stri">"000001100111"</span>),
    huffmanSymbolBits(  64, <span class="stri">"0000001111"</span>),
    huffmanSymbolBits( 128, <span class="stri">"000011001000"</span>),
    huffmanSymbolBits( 192, <span class="stri">"000011001001"</span>),
    huffmanSymbolBits( 256, <span class="stri">"000001011011"</span>),
    huffmanSymbolBits( 320, <span class="stri">"000000110011"</span>),
    huffmanSymbolBits( 384, <span class="stri">"000000110100"</span>),
    huffmanSymbolBits( 448, <span class="stri">"000000110101"</span>),
    huffmanSymbolBits( 512, <span class="stri">"0000001101100"</span>),
    huffmanSymbolBits( 576, <span class="stri">"0000001101101"</span>),
    huffmanSymbolBits( 640, <span class="stri">"0000001001010"</span>),
    huffmanSymbolBits( 704, <span class="stri">"0000001001011"</span>),
    huffmanSymbolBits( 768, <span class="stri">"0000001001100"</span>),
    huffmanSymbolBits( 832, <span class="stri">"0000001001101"</span>),
    huffmanSymbolBits( 896, <span class="stri">"0000001110010"</span>),
    huffmanSymbolBits( 960, <span class="stri">"0000001110011"</span>),
    huffmanSymbolBits(1024, <span class="stri">"0000001110100"</span>),
    huffmanSymbolBits(1088, <span class="stri">"0000001110101"</span>),
    huffmanSymbolBits(1152, <span class="stri">"0000001110110"</span>),
    huffmanSymbolBits(1216, <span class="stri">"0000001110111"</span>),
    huffmanSymbolBits(1280, <span class="stri">"0000001010010"</span>),
    huffmanSymbolBits(1344, <span class="stri">"0000001010011"</span>),
    huffmanSymbolBits(1408, <span class="stri">"0000001010100"</span>),
    huffmanSymbolBits(1472, <span class="stri">"0000001010101"</span>),
    huffmanSymbolBits(1536, <span class="stri">"0000001011010"</span>),
    huffmanSymbolBits(1600, <span class="stri">"0000001011011"</span>),
    huffmanSymbolBits(1664, <span class="stri">"0000001100100"</span>),
    huffmanSymbolBits(1728, <span class="stri">"0000001100101"</span>),
    huffmanSymbolBits(1792, <span class="stri">"00000001000"</span>),
    huffmanSymbolBits(1856, <span class="stri">"00000001100"</span>),
    huffmanSymbolBits(1920, <span class="stri">"00000001101"</span>),
    huffmanSymbolBits(1984, <span class="stri">"000000010010"</span>),
    huffmanSymbolBits(2048, <span class="stri">"000000010011"</span>),
    huffmanSymbolBits(2112, <span class="stri">"000000010100"</span>),
    huffmanSymbolBits(2176, <span class="stri">"000000010101"</span>),
    huffmanSymbolBits(2240, <span class="stri">"000000010110"</span>),
    huffmanSymbolBits(2304, <span class="stri">"000000010111"</span>),
    huffmanSymbolBits(2368, <span class="stri">"000000011100"</span>),
    huffmanSymbolBits(2432, <span class="stri">"000000011101"</span>),
    huffmanSymbolBits(2496, <span class="stri">"000000011110"</span>),
    huffmanSymbolBits(2560, <span class="stri">"000000011111"</span>));


<span class="keywd">const</span> <span class="type">proc</span>: addHuffmanSymbols (<span class="keywd">inout</span> <span class="type">msbHuffmanDecoder</span>: decoder,
    <span class="op">in</span> <span class="type">array</span> <span class="type">huffmanSymbolBits</span>: symbolBitsArray) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">huffmanSymbolBits</span>: symbolBits <span class="keywd">is</span> huffmanSymbolBits.value;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> symbolBits <span class="keywd">range</span> symbolBitsArray <span class="keywd">do</span>
      addCode(decoder, symbolBits.symbol, symbolBits.bits);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: addHuffmanSymbols (<span class="keywd">inout</span> <span class="type">lsbHuffmanDecoder</span>: decoder,
    <span class="op">in</span> <span class="type">array</span> <span class="type">huffmanSymbolBits</span>: symbolBitsArray) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">huffmanSymbolBits</span>: symbolBits <span class="keywd">is</span> huffmanSymbolBits.value;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> symbolBits <span class="keywd">range</span> symbolBitsArray <span class="keywd">do</span>
      addCode(decoder, symbolBits.symbol, symbolBits.bits);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">msbHuffmanDecoder</span>: genWhiteMsbHuffmanDecoder <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">msbHuffmanDecoder</span>: decoder <span class="keywd">is</span> msbHuffmanDecoder.value;
  <span class="keywd">begin</span>
    decoder := createMsbHuffmanDecoder(12);
    addHuffmanSymbols(decoder, whiteHuffmanSymbolBits);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">msbHuffmanDecoder</span>: genBlackMsbHuffmanDecoder <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">msbHuffmanDecoder</span>: decoder <span class="keywd">is</span> msbHuffmanDecoder.value;
  <span class="keywd">begin</span>
    decoder := createMsbHuffmanDecoder(13);
    addHuffmanSymbols(decoder, blackHuffmanSymbolBits);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">lsbHuffmanDecoder</span>: genWhiteLsbHuffmanDecoder <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">lsbHuffmanDecoder</span>: decoder <span class="keywd">is</span> lsbHuffmanDecoder.value;
  <span class="keywd">begin</span>
    decoder := createLsbHuffmanDecoder(12, -1, 2560);
    addHuffmanSymbols(decoder, whiteHuffmanSymbolBits);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">lsbHuffmanDecoder</span>: genBlackLsbHuffmanDecoder <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">lsbHuffmanDecoder</span>: decoder <span class="keywd">is</span> lsbHuffmanDecoder.value;
  <span class="keywd">begin</span>
    decoder := createLsbHuffmanDecoder(13, -1, 2560);
    addHuffmanSymbols(decoder, blackHuffmanSymbolBits);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">msbHuffmanDecoder</span>: whiteMsbHuffmanDecoder <span class="keywd">is</span> genWhiteMsbHuffmanDecoder;
<span class="keywd">const</span> <span class="type">msbHuffmanDecoder</span>: blackMsbHuffmanDecoder <span class="keywd">is</span> genBlackMsbHuffmanDecoder;
<span class="keywd">const</span> <span class="type">lsbHuffmanDecoder</span>: whiteLsbHuffmanDecoder <span class="keywd">is</span> genWhiteLsbHuffmanDecoder;
<span class="keywd">const</span> <span class="type">lsbHuffmanDecoder</span>: blackLsbHuffmanDecoder <span class="keywd">is</span> genBlackLsbHuffmanDecoder;


<span class="keywd">const</span> <span class="type">integer</span>: CCITT_T4_PASS             <span class="keywd">is</span> 0;
<span class="keywd">const</span> <span class="type">integer</span>: CCITT_T4_HORIZONTAL       <span class="keywd">is</span> 1;
<span class="keywd">const</span> <span class="type">integer</span>: CCITT_T4_VERTICAL_0       <span class="keywd">is</span> 2;
<span class="keywd">const</span> <span class="type">integer</span>: CCITT_T4_VERTICAL_RIGHT_1 <span class="keywd">is</span> 3;
<span class="keywd">const</span> <span class="type">integer</span>: CCITT_T4_VERTICAL_RIGHT_2 <span class="keywd">is</span> 4;
<span class="keywd">const</span> <span class="type">integer</span>: CCITT_T4_VERTICAL_RIGHT_3 <span class="keywd">is</span> 5;
<span class="keywd">const</span> <span class="type">integer</span>: CCITT_T4_VERTICAL_LEFT_1  <span class="keywd">is</span> 6;
<span class="keywd">const</span> <span class="type">integer</span>: CCITT_T4_VERTICAL_LEFT_2  <span class="keywd">is</span> 7;
<span class="keywd">const</span> <span class="type">integer</span>: CCITT_T4_VERTICAL_LEFT_3  <span class="keywd">is</span> 8;
<span class="keywd">const</span> <span class="type">integer</span>: CCITT_T4_UNCOMPRESSED     <span class="keywd">is</span> 9;


<span class="keywd">const</span> <span class="type">array</span> <span class="type">huffmanSymbolBits</span>: t4HuffmanSymbolBits <span class="keywd">is</span> [] (
    huffmanSymbolBits(-1,                        <span class="stri">"000000000001"</span>),
    huffmanSymbolBits(CCITT_T4_PASS,             <span class="stri">"0001"</span>),         <span class="comment"># Pass</span>
    huffmanSymbolBits(CCITT_T4_HORIZONTAL,       <span class="stri">"001"</span>),          <span class="comment"># Horizontal</span>
    huffmanSymbolBits(CCITT_T4_VERTICAL_0,       <span class="stri">"1"</span>),            <span class="comment"># V(0)</span>
    huffmanSymbolBits(CCITT_T4_VERTICAL_RIGHT_1, <span class="stri">"011"</span>),          <span class="comment"># Vr(1)</span>
    huffmanSymbolBits(CCITT_T4_VERTICAL_RIGHT_2, <span class="stri">"000011"</span>),       <span class="comment"># Vr(2)</span>
    huffmanSymbolBits(CCITT_T4_VERTICAL_RIGHT_3, <span class="stri">"0000011"</span>),      <span class="comment"># Vr(3)</span>
    huffmanSymbolBits(CCITT_T4_VERTICAL_LEFT_1,  <span class="stri">"010"</span>),          <span class="comment"># Vl(1)</span>
    huffmanSymbolBits(CCITT_T4_VERTICAL_LEFT_2,  <span class="stri">"000010"</span>),       <span class="comment"># Vl(2)</span>
    huffmanSymbolBits(CCITT_T4_VERTICAL_LEFT_3,  <span class="stri">"0000010"</span>),      <span class="comment"># Vl(3)</span>
    huffmanSymbolBits(CCITT_T4_UNCOMPRESSED,     <span class="stri">"0000001111"</span>));  <span class="comment"># Uncompressed</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">msbHuffmanDecoder</span>: genT4MsbHuffmanDecoder <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">msbHuffmanDecoder</span>: decoder <span class="keywd">is</span> msbHuffmanDecoder.value;
  <span class="keywd">begin</span>
    decoder := createMsbHuffmanDecoder(12);
    addHuffmanSymbols(decoder, t4HuffmanSymbolBits)
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">lsbHuffmanDecoder</span>: genT4LsbHuffmanDecoder <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">lsbHuffmanDecoder</span>: decoder <span class="keywd">is</span> lsbHuffmanDecoder.value;
  <span class="keywd">begin</span>
    decoder := createLsbHuffmanDecoder(12, -2, 10);
    addHuffmanSymbols(decoder, t4HuffmanSymbolBits)
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">msbHuffmanDecoder</span>: t4MsbHuffmanDecoder <span class="keywd">is</span> genT4MsbHuffmanDecoder;
<span class="keywd">const</span> <span class="type">lsbHuffmanDecoder</span>: t4LsbHuffmanDecoder <span class="keywd">is</span> genT4LsbHuffmanDecoder;


<span class="keywd">const</span> <span class="type">proc</span>: DECLARE_CcittModifiedGroup3Fax_FUNCTIONS (<span class="op">in</span> <span class="type">type</span>: bitStream,
    <span class="op">in</span> <span class="type">type</span>: huffmanDecoder) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>

    <span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getWhiteBits (<span class="keywd">inout</span> <span class="type">bitStream</span>: ccittFaxStream,
        <span class="op">in</span> <span class="type">huffmanDecoder</span>: whiteHuffmanDecoder) <span class="keywd">is</span> <span class="keywd">func</span>
      <span class="keywd">result</span>
        <span class="keywd">var</span> <span class="type">integer</span>: whiteBits <span class="keywd">is</span> 0;
      <span class="keywd">local</span>
        <span class="keywd">var</span> <span class="type">integer</span>: additionalWhiteBits <span class="keywd">is</span> 0;
      <span class="keywd">begin</span>
        whiteBits := getHuffmanSymbol(ccittFaxStream, whiteHuffmanDecoder);
        <span class="comment"># writeln("W" &lt;&amp; whiteBits &lt;&amp; " ");</span>
        <span class="keywd">if</span> whiteBits >= 64 <span class="keywd">then</span>
          <span class="keywd">repeat</span>
            additionalWhiteBits := getHuffmanSymbol(ccittFaxStream, whiteHuffmanDecoder);
            <span class="comment"># writeln("W+" &lt;&amp; additionalWhiteBits &lt;&amp; " ");</span>
            whiteBits +:= additionalWhiteBits;
          <span class="keywd">until</span> additionalWhiteBits &lt; 64;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="comment"># writeln("W=" &lt;&amp; whiteBits &lt;&amp; " ");</span>
      <span class="keywd">end</span> <span class="keywd">func</span>;


    <span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getBlackBits (<span class="keywd">inout</span> <span class="type">bitStream</span>: ccittFaxStream,
        <span class="op">in</span> <span class="type">huffmanDecoder</span>: blackHuffmanDecoder) <span class="keywd">is</span> <span class="keywd">func</span>
      <span class="keywd">result</span>
        <span class="keywd">var</span> <span class="type">integer</span>: blackBits <span class="keywd">is</span> 0;
      <span class="keywd">local</span>
        <span class="keywd">var</span> <span class="type">integer</span>: additionalBlackBits <span class="keywd">is</span> 0;
      <span class="keywd">begin</span>
        blackBits := getHuffmanSymbol(ccittFaxStream, blackHuffmanDecoder);
        <span class="comment"># writeln("B" &lt;&amp; blackBits &lt;&amp; " ");</span>
        <span class="keywd">if</span> blackBits >= 64 <span class="keywd">then</span>
          <span class="keywd">repeat</span>
            additionalBlackBits := getHuffmanSymbol(ccittFaxStream, blackHuffmanDecoder);
            <span class="comment"># writeln("B+" &lt;&amp; additionalBlackBits &lt;&amp; " ");</span>
            blackBits +:= additionalBlackBits;
          <span class="keywd">until</span> additionalBlackBits &lt; 64;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="comment"># writeln("B=" &lt;&amp; blackBits &lt;&amp; " ");</span>
      <span class="keywd">end</span> <span class="keywd">func</span>;


    <span class="keywd">const</span> <span class="type">proc</span>: skipEol (<span class="keywd">inout</span> <span class="type">bitStream</span>: inBitStream, <span class="op">in</span> <span class="type">integer</span>: expected) <span class="keywd">is</span> <span class="keywd">func</span>
      <span class="keywd">local</span>
        <span class="keywd">var</span> <span class="type">integer</span>: symbol <span class="keywd">is</span> 0;
      <span class="keywd">begin</span>
        symbol := getBits(inBitStream, 12);
        <span class="keywd">if</span> symbol = 0 <span class="keywd">then</span>
          <span class="comment"># Fill bits are present.</span>
          <span class="keywd">repeat</span>
            symbol := getBit(inBitStream);
          <span class="keywd">until</span> symbol = 1;
        <span class="keywd">elsif</span> symbol &lt;> expected <span class="keywd">then</span>
          raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">func</span>;


    <span class="keywd">const</span> <span class="type">proc</span>: processCcittFaxRow (<span class="keywd">inout</span> <span class="type">bitStream</span>: faxDataStream,
        <span class="op">in</span> <span class="type">huffmanDecoder</span>: whiteHuffmanDecoder, <span class="op">in</span> <span class="type">huffmanDecoder</span>: blackHuffmanDecoder,
        <span class="op">in</span> <span class="type">pixel</span>: whitePixel, <span class="op">in</span> <span class="type">pixel</span>: blackPixel, <span class="op">in</span> <span class="type">integer</span>: width,
        <span class="keywd">inout</span> <span class="type">pixelArray</span>: imageLine) <span class="keywd">is</span> <span class="keywd">func</span>
      <span class="keywd">local</span>
        <span class="keywd">var</span> <span class="type">integer</span>: numWhitePixels <span class="keywd">is</span> 0;
        <span class="keywd">var</span> <span class="type">integer</span>: numBlackPixels <span class="keywd">is</span> 0;
        <span class="keywd">var</span> <span class="type">integer</span>: currentColumn <span class="keywd">is</span> 1;
      <span class="keywd">begin</span>
        <span class="keywd">repeat</span>
          numWhitePixels := getWhiteBits(faxDataStream, whiteHuffmanDecoder);
          <span class="keywd">if</span> numWhitePixels >= 0 <span class="keywd">then</span>
            setPixels(imageLine, currentColumn,
                      currentColumn + pred(numWhitePixels), whitePixel);
            currentColumn +:= numWhitePixels;
            <span class="keywd">if</span> currentColumn &lt;= width <span class="keywd">then</span>
              numBlackPixels := getBlackBits(faxDataStream, blackHuffmanDecoder);
              <span class="keywd">if</span> numBlackPixels >= 0 <span class="keywd">then</span>
                setPixels(imageLine, currentColumn,
                          currentColumn + pred(numBlackPixels), blackPixel);
                currentColumn +:= numBlackPixels;
              <span class="keywd">else</span>
                setPixels(imageLine, currentColumn, width, blackPixel);
                currentColumn := succ(width);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            setPixels(imageLine, currentColumn, width, whitePixel);
            currentColumn := succ(width);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">until</span> currentColumn > width;
      <span class="keywd">end</span> <span class="keywd">func</span>;

  <span class="keywd">end</span> <span class="keywd">func</span>;


DECLARE_CcittModifiedGroup3Fax_FUNCTIONS(msbBitStream, msbHuffmanDecoder);
DECLARE_CcittModifiedGroup3Fax_FUNCTIONS(lsbBitStream, lsbHuffmanDecoder);


<span class="comment">(**
 *  Read modified CCITT group 3 ''faxData'' with MSB bit ordering into ''image''.
 *  A modified CCITT Group 3 one-dimensional Huffman run-length encoding is used.
 *  The CCITT group 3 facsimile standard has been defined by CCITT in 1988.
 *  This encoding is used in [[tiff|TIFF]] files if compression = 2.
 *  MSB bit ordering processes the bits from the MSB (most significant bit) to
 *  the LSB (least significant bit). This function fills a part of the ''image''
 *  destination. The part starts with ''startLine'' and extends over ''height'' lines.
 *  @param faxData Modified CCITT group 3 one-dimensional encoded fax data with MSB bit ordering.
 *  @param whitePixel Pixel to be used for white.
 *  @param blackPixel Pixel to be used for black.
 *  @param startLine First line of ''image'' to which the pixels are assigned.
 *  @param height Number of lines to be processed.
 *  @param width Width of the lines to be processed.
 *  @param image Destination of the pixel lines.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: processCcittModifiedGroup3FaxMsb (<span class="op">in</span> <span class="type">string</span>: faxData,
    <span class="op">in</span> <span class="type">pixel</span>: whitePixel, <span class="op">in</span> <span class="type">pixel</span>: blackPixel, <span class="op">in</span> <span class="type">integer</span>: startLine,
    <span class="op">in</span> <span class="type">integer</span>: height, <span class="op">in</span> <span class="type">integer</span>: width, <span class="keywd">inout</span> <span class="type">pixelImage</span>: image) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">msbBitStream</span>: faxDataStream <span class="keywd">is</span> msbBitStream.value;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    faxDataStream := openMsbBitStream(faxData);
    <span class="keywd">for</span> line <span class="keywd">range</span> startLine <span class="keywd">to</span> startLine + height - 1 <span class="keywd">do</span>
      processCcittFaxRow(faxDataStream, whiteMsbHuffmanDecoder,
                         blackMsbHuffmanDecoder, whitePixel, blackPixel,
                         width, image[line]);
      <span class="comment"># Go to the next available byte boundary</span>
      ignore(gets(faxDataStream, 0));
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Read modified CCITT group 3 ''faxData'' with LSB bit ordering into ''image''.
 *  A modified CCITT Group 3 one-dimensional Huffman run-length encoding is used.
 *  The CCITT group 3 facsimile standard has been defined by CCITT in 1988.
 *  This encoding is used in [[tiff|TIFF]] files if compression = 2.
 *  LSB bit ordering processes the bits from the LSB (least significant bit) to
 *  the MSB (most significant bit). This function fills a part of the ''image''
 *  destination. The part starts with ''startLine'' and extends over ''height'' lines.
 *  @param faxData Modified CCITT group 3 one-dimensional encoded fax data with LSB bit ordering.
 *  @param whitePixel Pixel to be used for white.
 *  @param blackPixel Pixel to be used for black.
 *  @param startLine First line of ''image'' to which the pixels are assigned.
 *  @param height Number of lines to be processed.
 *  @param width Width of the lines to be processed.
 *  @param image Destination of the pixel lines.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: processCcittModifiedGroup3FaxLsb (<span class="op">in</span> <span class="type">string</span>: faxData,
    <span class="op">in</span> <span class="type">pixel</span>: whitePixel, <span class="op">in</span> <span class="type">pixel</span>: blackPixel, <span class="op">in</span> <span class="type">integer</span>: startLine,
    <span class="op">in</span> <span class="type">integer</span>: height, <span class="op">in</span> <span class="type">integer</span>: width, <span class="keywd">inout</span> <span class="type">pixelImage</span>: image) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">lsbBitStream</span>: faxDataStream <span class="keywd">is</span> lsbBitStream.value;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    faxDataStream := openLsbBitStream(faxData);
    <span class="keywd">for</span> line <span class="keywd">range</span> startLine <span class="keywd">to</span> startLine + height - 1 <span class="keywd">do</span>
      processCcittFaxRow(faxDataStream, whiteLsbHuffmanDecoder,
                         blackLsbHuffmanDecoder, whitePixel, blackPixel,
                         width, image[line]);
      <span class="comment"># Go to the next available byte boundary</span>
      ignore(gets(faxDataStream, 0));
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: ccittFaxValues <span class="keywd">is</span> <span class="type">array</span> <span class="type">[</span>1 .. ] integer;


<span class="keywd">const</span> <span class="type">proc</span>: DECLARE_CcittT6Fax_FUNCTIONS (<span class="op">in</span> <span class="type">type</span>: bitStream,
    <span class="op">in</span> <span class="type">type</span>: huffmanDecoder) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>

    <span class="keywd">const</span> <span class="type">proc</span>: processCcittT4Fax2dRow (<span class="keywd">inout</span> <span class="type">bitStream</span>: faxDataStream,
        <span class="op">in</span> <span class="type">huffmanDecoder</span>: t4HuffmanDecoder, <span class="op">in</span> <span class="type">huffmanDecoder</span>: whiteHuffmanDecoder,
        <span class="op">in</span> <span class="type">huffmanDecoder</span>: blackHuffmanDecoder, <span class="op">in</span> <span class="type">colorLookupTable</span>: blackOrWhite,
        <span class="op">in</span> <span class="type">integer</span>: width, <span class="keywd">inout</span> <span class="type">ccittFaxValues</span>: bValues,
        <span class="keywd">inout</span> <span class="type">pixelArray</span>: imageLine) <span class="keywd">is</span> <span class="keywd">func</span>
      <span class="keywd">local</span>
        <span class="keywd">var</span> <span class="type">pixel</span>: currentPixel <span class="keywd">is</span> pixel.value;
        <span class="keywd">var</span> <span class="type">integer</span>: mode <span class="keywd">is</span> 0;
        <span class="keywd">var</span> <span class="type">integer</span>: numBits1 <span class="keywd">is</span> 0;
        <span class="keywd">var</span> <span class="type">integer</span>: numBits2 <span class="keywd">is</span> 0;
        <span class="keywd">var</span> <span class="type">integer</span>: currentColumn <span class="keywd">is</span> 1;
        <span class="keywd">var</span> <span class="type">ccittFaxValues</span>: aValues <span class="keywd">is</span> ccittFaxValues.value;
        <span class="keywd">var</span> <span class="type">integer</span>: bIndex <span class="keywd">is</span> 1;
        <span class="keywd">var</span> <span class="type">integer</span>: currentBValue <span class="keywd">is</span> 0;
      <span class="keywd">begin</span>
        mode := getHuffmanSymbol(faxDataStream, t4HuffmanDecoder);
        <span class="keywd">while</span> mode >= 0 <span class="op">and</span> currentColumn &lt;= width <span class="keywd">do</span>
          <span class="keywd">if</span> bIndex &lt;= length(bValues) <span class="keywd">then</span>
            currentBValue := bValues[bIndex];
          <span class="keywd">else</span>
            currentBValue := succ(width);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">case</span> mode <span class="keywd">of</span>
            <span class="keywd">when</span> {CCITT_T4_PASS}:
              <span class="comment"># writeln("Pass");</span>
              currentPixel := blackOrWhite[bIndex <span class="op">mod</span> 2];
              incr(bIndex);
              <span class="keywd">if</span> bIndex &lt;= length(bValues) <span class="keywd">then</span>
                currentBValue := bValues[bIndex];
              <span class="keywd">else</span>
                currentBValue := succ(width);
              <span class="keywd">end</span> <span class="keywd">if</span>;
              setPixels(imageLine, currentColumn, currentBValue - 1, currentPixel);
              currentColumn := currentBValue;
              incr(bIndex);
            <span class="keywd">when</span> {CCITT_T4_HORIZONTAL}:
              <span class="keywd">if</span> odd(bIndex) <span class="keywd">then</span>
                numBits1 := getWhiteBits(faxDataStream, whiteHuffmanDecoder);
                numBits2 := getBlackBits(faxDataStream, blackHuffmanDecoder);
              <span class="keywd">else</span>
                numBits1 := getBlackBits(faxDataStream, blackHuffmanDecoder);
                numBits2 := getWhiteBits(faxDataStream, whiteHuffmanDecoder);
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="comment"># writeln("Horizontal " &lt;&amp; numBits1 &lt;&amp; " " &lt;&amp; numBits2);</span>
              currentPixel := blackOrWhite[bIndex <span class="op">mod</span> 2];
              setPixels(imageLine, currentColumn, currentColumn + pred(numBits1),
                        currentPixel);
              currentColumn +:= numBits1;
              aValues &amp;:= currentColumn;
              currentPixel := blackOrWhite[succ(bIndex) <span class="op">mod</span> 2];
              setPixels(imageLine, currentColumn, currentColumn + pred(numBits2),
                        currentPixel);
              currentColumn +:= numBits2;
              aValues &amp;:= currentColumn;
              <span class="keywd">while</span> bIndex &lt;= length(bValues) <span class="op">and</span> bValues[bIndex] &lt;= currentColumn <span class="keywd">do</span>
                bIndex +:= 2;
              <span class="keywd">end</span> <span class="keywd">while</span>;
            <span class="keywd">when</span> {CCITT_T4_VERTICAL_0}:
              <span class="comment"># writeln("V(0)");</span>
              currentPixel := blackOrWhite[bIndex <span class="op">mod</span> 2];
              setPixels(imageLine, currentColumn, currentBValue - 1, currentPixel);
              currentColumn := currentBValue;
              aValues &amp;:= currentColumn;
              incr(bIndex);
            <span class="keywd">when</span> {CCITT_T4_VERTICAL_RIGHT_1}:
              <span class="comment"># writeln("Vr(1)");</span>
              currentPixel := blackOrWhite[bIndex <span class="op">mod</span> 2];
              setPixels(imageLine, currentColumn, currentBValue, currentPixel);
              currentColumn := currentBValue + 1;
              aValues &amp;:= currentColumn;
              incr(bIndex);
              <span class="keywd">if</span> bIndex &lt;= length(bValues) <span class="op">and</span> bValues[bIndex] &lt;= currentColumn <span class="keywd">then</span>
                bIndex +:= 2;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {CCITT_T4_VERTICAL_RIGHT_2}:
              <span class="comment"># writeln("Vr(2)");</span>
              currentPixel := blackOrWhite[bIndex <span class="op">mod</span> 2];
              setPixels(imageLine, currentColumn, currentBValue + 1, currentPixel);
              currentColumn := currentBValue + 2;
              aValues &amp;:= currentColumn;
              incr(bIndex);
              <span class="keywd">if</span> bIndex &lt;= length(bValues) <span class="op">and</span> bValues[bIndex] &lt;= currentColumn <span class="keywd">then</span>
                bIndex +:= 2;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {CCITT_T4_VERTICAL_RIGHT_3}:
              <span class="comment"># writeln("Vr(3)");</span>
              currentPixel := blackOrWhite[bIndex <span class="op">mod</span> 2];
              setPixels(imageLine, currentColumn, currentBValue + 2, currentPixel);
              currentColumn := currentBValue + 3;
              aValues &amp;:= currentColumn;
              incr(bIndex);
              <span class="keywd">while</span> bIndex &lt;= length(bValues) <span class="op">and</span> bValues[bIndex] &lt;= currentColumn <span class="keywd">do</span>
                bIndex +:= 2;
              <span class="keywd">end</span> <span class="keywd">while</span>;
            <span class="keywd">when</span> {CCITT_T4_VERTICAL_LEFT_1}:
              <span class="comment"># writeln("Vl(1)");</span>
              currentPixel := blackOrWhite[bIndex <span class="op">mod</span> 2];
              setPixels(imageLine, currentColumn, currentBValue - 2, currentPixel);
              currentColumn := currentBValue - 1;
              aValues &amp;:= currentColumn;
              incr(bIndex);
            <span class="keywd">when</span> {CCITT_T4_VERTICAL_LEFT_2}:
              <span class="comment"># writeln("Vl(2)");</span>
              currentPixel := blackOrWhite[bIndex <span class="op">mod</span> 2];
              setPixels(imageLine, currentColumn, currentBValue - 3, currentPixel);
              currentColumn := currentBValue - 2;
              aValues &amp;:= currentColumn;
              <span class="keywd">if</span> bIndex > 1 <span class="op">and</span> (pred(bIndex) > length(bValues) <span class="op">or</span>
                  bValues[pred(bIndex)] > currentColumn) <span class="keywd">then</span>
                decr(bIndex);
              <span class="keywd">else</span>
                incr(bIndex);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {CCITT_T4_VERTICAL_LEFT_3}:
              <span class="comment"># writeln("Vl(3)");</span>
              currentPixel := blackOrWhite[bIndex <span class="op">mod</span> 2];
              setPixels(imageLine, currentColumn, currentBValue - 4, currentPixel);
              currentColumn := currentBValue - 3;
              aValues &amp;:= currentColumn;
              <span class="keywd">if</span> bIndex > 1 <span class="op">and</span> (pred(bIndex) > length(bValues) <span class="op">or</span>
                  bValues[pred(bIndex)] > currentColumn) <span class="keywd">then</span>
                decr(bIndex);
              <span class="keywd">else</span>
                incr(bIndex);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">otherwise</span>:
              raise RANGE_ERROR;
          <span class="keywd">end</span> <span class="keywd">case</span>;
          <span class="keywd">if</span> currentColumn &lt;= width <span class="keywd">then</span>
            mode := getHuffmanSymbol(faxDataStream, t4HuffmanDecoder);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">while</span>;
        bValues := aValues;
      <span class="keywd">end</span> <span class="keywd">func</span>;

  <span class="keywd">end</span> <span class="keywd">func</span>;


DECLARE_CcittT6Fax_FUNCTIONS(msbBitStream, msbHuffmanDecoder);
DECLARE_CcittT6Fax_FUNCTIONS(lsbBitStream, lsbHuffmanDecoder);


<span class="comment">(**
 *  Read CCITT T.6 bi-level ''faxData'' with MSB bit ordering into ''image''.
 *  CCITT T.6 belongs to the group 4 facsimile standard defined by CCITT in 1988.
 *  This encoding is used in [[tiff|TIFF]] files if compression = 4.
 *  MSB bit ordering processes the bits from the MSB (most significant bit) to
 *  the LSB (least significant bit). This function fills a part of the ''image''
 *  destination. The part starts with ''startLine'' and extends over ''height'' lines.
 *  @param faxData CCITT T.6 two-dimensional encoded fax data with MSB bit ordering.
 *  @param blackOrWhite Array with black and white pixel indexed from 0.
 *  @param startLine First line of ''image'' to which the pixels are assigned.
 *  @param height Number of lines to be processed.
 *  @param width Width of the lines to be processed.
 *  @param image Destination of the pixel lines.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: processCcittT6FaxMsb (<span class="op">in</span> <span class="type">string</span>: faxData,
    <span class="op">in</span> <span class="type">colorLookupTable</span>: blackOrWhite, <span class="op">in</span> <span class="type">integer</span>: startLine, <span class="op">in</span> <span class="type">integer</span>: height,
    <span class="op">in</span> <span class="type">integer</span>: width, <span class="keywd">inout</span> <span class="type">pixelImage</span>: image) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">msbBitStream</span>: faxDataStream <span class="keywd">is</span> msbBitStream.value;
    <span class="keywd">var</span> <span class="type">ccittFaxValues</span>: bValues <span class="keywd">is</span> ccittFaxValues.value;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    faxDataStream := openMsbBitStream(faxData);
    <span class="keywd">for</span> line <span class="keywd">range</span> startLine <span class="keywd">to</span> startLine + height - 1 <span class="keywd">do</span>
      processCcittT4Fax2dRow(faxDataStream, t4MsbHuffmanDecoder,
                             whiteMsbHuffmanDecoder, blackMsbHuffmanDecoder,
                             blackOrWhite, width, bValues, image[line]);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Read CCITT T.6 bi-level ''faxData'' with LSB bit ordering into ''image''.
 *  CCITT T.6 belongs to the group 4 facsimile standard defined by CCITT in 1988.
 *  This encoding is used in [[tiff|TIFF]] files if compression = 4.
 *  LSB bit ordering processes the bits from the LSB (least significant bit) to
 *  the MSB (most significant bit). This function fills a part of the ''image''
 *  destination. The part starts with ''startLine'' and extends over ''height'' lines.
 *  @param faxData CCITT T.6 two-dimensional encoded fax data with LSB bit ordering.
 *  @param blackOrWhite Array with black and white pixel indexed from 0.
 *  @param startLine First line of ''image'' to which the pixels are assigned.
 *  @param height Number of lines to be processed.
 *  @param width Width of the lines to be processed.
 *  @param image Destination of the pixel lines.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: processCcittT6FaxLsb (<span class="op">in</span> <span class="type">string</span>: faxData,
    <span class="op">in</span> <span class="type">colorLookupTable</span>: blackOrWhite, <span class="op">in</span> <span class="type">integer</span>: startLine, <span class="op">in</span> <span class="type">integer</span>: height,
    <span class="op">in</span> <span class="type">integer</span>: width, <span class="keywd">inout</span> <span class="type">pixelImage</span>: image) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">lsbBitStream</span>: faxDataStream <span class="keywd">is</span> lsbBitStream.value;
    <span class="keywd">var</span> <span class="type">ccittFaxValues</span>: bValues <span class="keywd">is</span> ccittFaxValues.value;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    faxDataStream := openLsbBitStream(faxData);
    <span class="keywd">for</span> line <span class="keywd">range</span> startLine <span class="keywd">to</span> startLine + height - 1 <span class="keywd">do</span>
      processCcittT4Fax2dRow(faxDataStream, t4LsbHuffmanDecoder,
                             whiteLsbHuffmanDecoder, blackLsbHuffmanDecoder,
                             blackOrWhite, width, bValues, image[line]);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Read CCITT T.4 bi-level one-dimensional ''faxData'' with MSB bit ordering into ''image''.
 *  CCITT T.4 belongs to the group 3 facsimile standard defined by CCITT in 1988.
 *  This encoding is used in [[tiff|TIFF]] files if compression = 3 and t4Options is even.
 *  MSB bit ordering processes the bits from the MSB (most significant bit) to
 *  the LSB (least significant bit). This function fills a part of the ''image''
 *  destination. The part starts with ''startLine'' and extends over ''height'' lines.
 *  @param faxData CCITT T.4 one-dimensional encoded fax data with MSB bit ordering.
 *  @param whitePixel Pixel to be used for white.
 *  @param blackPixel Pixel to be used for black.
 *  @param startLine First line of ''image'' to which the pixels are assigned.
 *  @param height Number of lines to be processed.
 *  @param width Width of the lines to be processed.
 *  @param image Destination of the pixel lines.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: processCcittT4Fax1dMsb (<span class="op">in</span> <span class="type">string</span>: faxData,
    <span class="op">in</span> <span class="type">pixel</span>: whitePixel, <span class="op">in</span> <span class="type">pixel</span>: blackPixel, <span class="op">in</span> <span class="type">integer</span>: startLine,
    <span class="op">in</span> <span class="type">integer</span>: height, <span class="op">in</span> <span class="type">integer</span>: width, <span class="keywd">inout</span> <span class="type">pixelImage</span>: image) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">msbBitStream</span>: faxDataStream <span class="keywd">is</span> msbBitStream.value;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    faxDataStream := openMsbBitStream(faxData);
    <span class="keywd">for</span> line <span class="keywd">range</span> startLine <span class="keywd">to</span> startLine + height - 1 <span class="keywd">do</span>
      skipEol(faxDataStream, 2#000000000001);
      processCcittFaxRow(faxDataStream, whiteMsbHuffmanDecoder,
                         blackMsbHuffmanDecoder, whitePixel, blackPixel,
                         width, image[line]);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Read CCITT T.4 bi-level one-dimensional ''faxData'' with LSB bit ordering into ''image''.
 *  CCITT T.4 belongs to the group 3 facsimile standard defined by CCITT in 1988.
 *  This encoding is used in [[tiff|TIFF]] files if compression = 3 and t4Options is even.
 *  LSB bit ordering processes the bits from the LSB (least significant bit) to
 *  the MSB (most significant bit). This function fills a part of the ''image''
 *  destination. The part starts with ''startLine'' and extends over ''height'' lines.
 *  @param faxData CCITT T.4 one-dimensional encoded fax data with LSB bit ordering.
 *  @param whitePixel Pixel to be used for white.
 *  @param blackPixel Pixel to be used for black.
 *  @param startLine First line of ''image'' to which the pixels are assigned.
 *  @param height Number of lines to be processed.
 *  @param width Width of the lines to be processed.
 *  @param image Destination of the pixel lines.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: processCcittT4Fax1dLsb (<span class="op">in</span> <span class="type">string</span>: faxData,
    <span class="op">in</span> <span class="type">pixel</span>: whitePixel, <span class="op">in</span> <span class="type">pixel</span>: blackPixel, <span class="op">in</span> <span class="type">integer</span>: startLine,
    <span class="op">in</span> <span class="type">integer</span>: height, <span class="op">in</span> <span class="type">integer</span>: width, <span class="keywd">inout</span> <span class="type">pixelImage</span>: image) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">lsbBitStream</span>: faxDataStream <span class="keywd">is</span> lsbBitStream.value;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    faxDataStream := openLsbBitStream(faxData);
    <span class="keywd">for</span> line <span class="keywd">range</span> startLine <span class="keywd">to</span> startLine + height - 1 <span class="keywd">do</span>
      skipEol(faxDataStream, 2#100000000000);
      processCcittFaxRow(faxDataStream, whiteLsbHuffmanDecoder,
                         blackLsbHuffmanDecoder, whitePixel, blackPixel,
                         width, image[line]);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: DECLARE_CcittT4Fax2d_FUNCTIONS (<span class="op">in</span> <span class="type">type</span>: bitStream,
    <span class="op">in</span> <span class="type">type</span>: huffmanDecoder) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>

    <span class="keywd">const</span> <span class="type">proc</span>: processCcittT4Fax1dRow (<span class="keywd">inout</span> <span class="type">bitStream</span>: faxDataStream,
        <span class="op">in</span> <span class="type">huffmanDecoder</span>: whiteHuffmanDecoder, <span class="op">in</span> <span class="type">huffmanDecoder</span>: blackHuffmanDecoder,
        <span class="op">in</span> <span class="type">pixel</span>: whitePixel, <span class="op">in</span> <span class="type">pixel</span>: blackPixel, <span class="op">in</span> <span class="type">integer</span>: width,
	<span class="keywd">inout</span> <span class="type">ccittFaxValues</span>: aValues, <span class="keywd">inout</span> <span class="type">pixelArray</span>: imageLine) <span class="keywd">is</span> <span class="keywd">func</span>
      <span class="keywd">local</span>
        <span class="keywd">var</span> <span class="type">integer</span>: numWhitePixels <span class="keywd">is</span> 0;
        <span class="keywd">var</span> <span class="type">integer</span>: numBlackPixels <span class="keywd">is</span> 0;
        <span class="keywd">var</span> <span class="type">integer</span>: currentColumn <span class="keywd">is</span> 1;
      <span class="keywd">begin</span>
        aValues := ccittFaxValues.value;
        <span class="keywd">repeat</span>
          numWhitePixels := getWhiteBits(faxDataStream, whiteHuffmanDecoder);
          <span class="keywd">if</span> numWhitePixels >= 0 <span class="keywd">then</span>
            setPixels(imageLine, currentColumn,
                      currentColumn + pred(numWhitePixels), whitePixel);
            currentColumn +:= numWhitePixels;
            aValues &amp;:= currentColumn;
            <span class="keywd">if</span> currentColumn &lt;= width <span class="keywd">then</span>
              numBlackPixels := getBlackBits(faxDataStream, blackHuffmanDecoder);
              <span class="keywd">if</span> numBlackPixels >= 0 <span class="keywd">then</span>
                setPixels(imageLine, currentColumn,
                          currentColumn + pred(numBlackPixels), blackPixel);
                currentColumn +:= numBlackPixels;
                aValues &amp;:= currentColumn;
              <span class="keywd">else</span>
                setPixels(imageLine, currentColumn, width, blackPixel);
                currentColumn := succ(width);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            setPixels(imageLine, currentColumn, width, whitePixel);
            currentColumn := succ(width);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">until</span> currentColumn > width;
      <span class="keywd">end</span> <span class="keywd">func</span>;

  <span class="keywd">end</span> <span class="keywd">func</span>;


DECLARE_CcittT4Fax2d_FUNCTIONS(msbBitStream, msbHuffmanDecoder);
DECLARE_CcittT4Fax2d_FUNCTIONS(lsbBitStream, lsbHuffmanDecoder);


<span class="comment">(**
 *  Read CCITT T.4 bi-level two-dimensional ''faxData'' with MSB bit ordering into ''image''.
 *  CCITT T.4 belongs to the group 3 facsimile standard defined by CCITT in 1988.
 *  This encoding is used in [[tiff|TIFF]] files if compression = 3 and t4Options is odd.
 *  MSB bit ordering processes the bits from the MSB (most significant bit) to
 *  the LSB (least significant bit). This function fills a part of the ''image''
 *  destination. The part starts with ''startLine'' and extends over ''height'' lines.
 *  @param faxData CCITT T.4 two-dimensional encoded fax data with MSB bit ordering.
 *  @param blackOrWhite Array with black and white pixel indexed from 0.
 *  @param startLine First line of ''image'' to which the pixels are assigned.
 *  @param height Number of lines to be processed.
 *  @param width Width of the lines to be processed.
 *  @param image Destination of the pixel lines.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: processCcittT4Fax2dMsb (<span class="op">in</span> <span class="type">string</span>: faxData,
    <span class="op">in</span> <span class="type">colorLookupTable</span>: blackOrWhite, <span class="op">in</span> <span class="type">integer</span>: startLine, <span class="op">in</span> <span class="type">integer</span>: height,
    <span class="op">in</span> <span class="type">integer</span>: width, <span class="keywd">inout</span> <span class="type">pixelImage</span>: image) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">msbBitStream</span>: faxDataStream <span class="keywd">is</span> msbBitStream.value;
    <span class="keywd">var</span> <span class="type">ccittFaxValues</span>: bValues <span class="keywd">is</span> ccittFaxValues.value;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    faxDataStream := openMsbBitStream(faxData);
    <span class="keywd">for</span> line <span class="keywd">range</span> startLine <span class="keywd">to</span> startLine + height - 1 <span class="keywd">do</span>
      skipEol(faxDataStream, 2#000000000001);
      <span class="keywd">if</span> getBit(faxDataStream) = 1 <span class="keywd">then</span>
        processCcittT4Fax1dRow(faxDataStream, whiteMsbHuffmanDecoder,
                               blackMsbHuffmanDecoder, blackOrWhite[1], blackOrWhite[0],
                               width, bValues, image[line]);
      <span class="keywd">else</span>
        processCcittT4Fax2dRow(faxDataStream, t4MsbHuffmanDecoder,
                               whiteMsbHuffmanDecoder, blackMsbHuffmanDecoder,
                               blackOrWhite, width, bValues, image[line]);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Read CCITT T.4 bi-level two-dimensional ''faxData'' with LSB bit ordering into ''image''.
 *  CCITT T.4 belongs to the group 3 facsimile standard defined by CCITT in 1988.
 *  This encoding is used in [[tiff|TIFF]] files if compression = 3 and t4Options is odd.
 *  LSB bit ordering processes the bits from the LSB (least significant bit) to
 *  the MSB (most significant bit). This function fills a part of the ''image''
 *  destination. The part starts with ''startLine'' and extends over ''height'' lines.
 *  @param faxData CCITT T.4 two-dimensional encoded fax data with LSB bit ordering.
 *  @param blackOrWhite Array with black and white pixel indexed from 0.
 *  @param startLine First line of ''image'' to which the pixels are assigned.
 *  @param height Number of lines to be processed.
 *  @param width Width of the lines to be processed.
 *  @param image Destination of the pixel lines.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: processCcittT4Fax2dLsb (<span class="op">in</span> <span class="type">string</span>: faxData,
    <span class="op">in</span> <span class="type">colorLookupTable</span>: blackOrWhite, <span class="op">in</span> <span class="type">integer</span>: startLine, <span class="op">in</span> <span class="type">integer</span>: height,
    <span class="op">in</span> <span class="type">integer</span>: width, <span class="keywd">inout</span> <span class="type">pixelImage</span>: image) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">lsbBitStream</span>: faxDataStream <span class="keywd">is</span> lsbBitStream.value;
    <span class="keywd">var</span> <span class="type">ccittFaxValues</span>: bValues <span class="keywd">is</span> ccittFaxValues.value;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    faxDataStream := openLsbBitStream(faxData);
    <span class="keywd">for</span> line <span class="keywd">range</span> startLine <span class="keywd">to</span> startLine + height - 1 <span class="keywd">do</span>
      skipEol(faxDataStream, 2#100000000000);
      <span class="keywd">if</span> getBit(faxDataStream) = 1 <span class="keywd">then</span>
        processCcittT4Fax1dRow(faxDataStream, whiteLsbHuffmanDecoder,
                               blackLsbHuffmanDecoder, blackOrWhite[1], blackOrWhite[0],
                               width, bValues, image[line]);
      <span class="keywd">else</span>
        processCcittT4Fax2dRow(faxDataStream, t4LsbHuffmanDecoder,
                               whiteLsbHuffmanDecoder, blackLsbHuffmanDecoder,
                               blackOrWhite, width, bValues, image[line]);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
