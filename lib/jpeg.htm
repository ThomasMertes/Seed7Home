<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  jpeg.s7i      Support for the JPEG image file format            *)</span>
<span class="comment">(*  Copyright (C) 2021 - 2024  Thomas Mertes                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bytedata.htm">bytedata.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bitdata.htm">bitdata.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/huffman.htm">huffman.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/draw.htm">draw.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/pixelimage.htm">pixelimage.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/exif.htm">exif.s7i</a>"</span>;


<span class="keywd">const</span> <span class="type">string</span>: JPEG_MAGIC <span class="keywd">is</span> <span class="stri">"\16#ff;\16#d8;\16#ff;"</span>;  <span class="comment"># Start of image (SOI) + ff</span>

<span class="keywd">const</span> <span class="type">char</span>: JPEG_MARKER_START <span class="keywd">is</span> <span class="stri">'\16#ff;'</span>;
<span class="keywd">const</span> <span class="type">char</span>: JPEG_SOF0   <span class="keywd">is</span> <span class="stri">'\16#c0;'</span>;  <span class="comment"># Start Of Frame (Baseline)</span>
<span class="keywd">const</span> <span class="type">char</span>: JPEG_SOF1   <span class="keywd">is</span> <span class="stri">'\16#c1;'</span>;  <span class="comment"># Start Of Frame (Extended sequential)</span>
<span class="keywd">const</span> <span class="type">char</span>: JPEG_SOF2   <span class="keywd">is</span> <span class="stri">'\16#c2;'</span>;  <span class="comment"># Start Of Frame (Progressive)</span>
<span class="keywd">const</span> <span class="type">char</span>: JPEG_DHT    <span class="keywd">is</span> <span class="stri">'\16#c4;'</span>;  <span class="comment"># Define Huffman Table</span>
<span class="keywd">const</span> <span class="type">char</span>: JPEG_RST0   <span class="keywd">is</span> <span class="stri">'\16#d0;'</span>;  <span class="comment"># Restart Marker 0</span>
<span class="keywd">const</span> <span class="type">char</span>: JPEG_RST7   <span class="keywd">is</span> <span class="stri">'\16#d7;'</span>;  <span class="comment"># Restart Marker 7</span>
<span class="keywd">const</span> <span class="type">char</span>: JPEG_SOI    <span class="keywd">is</span> <span class="stri">'\16#d8;'</span>;  <span class="comment"># Start Of Image</span>
<span class="keywd">const</span> <span class="type">char</span>: JPEG_EOI    <span class="keywd">is</span> <span class="stri">'\16#d9;'</span>;  <span class="comment"># End Of Image</span>
<span class="keywd">const</span> <span class="type">char</span>: JPEG_SOS    <span class="keywd">is</span> <span class="stri">'\16#da;'</span>;  <span class="comment"># Start Of Scan</span>
<span class="keywd">const</span> <span class="type">char</span>: JPEG_DQT    <span class="keywd">is</span> <span class="stri">'\16#db;'</span>;  <span class="comment"># Define Quantization Table</span>
<span class="keywd">const</span> <span class="type">char</span>: JPEG_DRI    <span class="keywd">is</span> <span class="stri">'\16#dd;'</span>;  <span class="comment"># Define Restart Interval</span>
<span class="keywd">const</span> <span class="type">char</span>: JPEG_APP0   <span class="keywd">is</span> <span class="stri">'\16#e0;'</span>;  <span class="comment"># Application Segment 0</span>
<span class="keywd">const</span> <span class="type">char</span>: JPEG_APP15  <span class="keywd">is</span> <span class="stri">'\16#ef;'</span>;  <span class="comment"># Application Segment 15</span>
<span class="keywd">const</span> <span class="type">char</span>: JPEG_COM    <span class="keywd">is</span> <span class="stri">'\16#fe;'</span>;  <span class="comment"># Comment</span>
<span class="keywd">const</span> <span class="type">char</span>: JPEG_FILLER <span class="keywd">is</span> <span class="stri">'\16#ff;'</span>;  <span class="comment"># Fill byte (ignored)</span>

<span class="keywd">const</span> <span class="type">integer</span>: JPEG_SOF_HEADER_FIXED_SIZE <span class="keywd">is</span> 8;

<span class="keywd">const</span> <span class="type">integer</span>: JPEG_BLOCK_SIZE <span class="keywd">is</span> 64;

<span class="keywd">const</span> <span class="type">integer</span>: JPEG_COMPTYPE_LUMA        <span class="keywd">is</span> 1;
<span class="keywd">const</span> <span class="type">integer</span>: JPEG_COMPTYPE_CHROMA_BLUE <span class="keywd">is</span> 2;
<span class="keywd">const</span> <span class="type">integer</span>: JPEG_COMPTYPE_CHROMA_RED  <span class="keywd">is</span> 3;

<span class="keywd">const</span> <span class="type">type</span>: jpegComponentTypeMap <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">integer</span><span class="type">]</span> <span class="type">integer</span>;

<span class="keywd">const</span> <span class="type">type</span>: jpegComponent <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: quantizationTableIndex <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: jpegScan <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: componentId <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: dcHuffmanTableIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: acHuffmanTableIndex <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: dataBlockType <span class="keywd">is</span> <span class="type">array</span> <span class="type">[</span>JPEG_BLOCK_SIZE] integer;
<span class="keywd">const</span> <span class="type">type</span>: twoDataBlocksArray <span class="keywd">is</span> <span class="type">array</span> <span class="type">[</span>1 .. 2] dataBlockType;
<span class="keywd">const</span> <span class="type">type</span>: fourDataBlocksArray <span class="keywd">is</span> <span class="type">array</span> <span class="type">[</span>1 .. 4] dataBlockType;
<span class="keywd">const</span> <span class="type">type</span>: jpegComponentArray <span class="keywd">is</span> <span class="type">array</span> <span class="type">[</span>1 ..] jpegComponent;
<span class="keywd">const</span> <span class="type">type</span>: jpegScanArray <span class="keywd">is</span> <span class="type">array</span> <span class="type">[</span>1 ..] jpegScan;
<span class="keywd">const</span> <span class="type">type</span>: fourHuffmanDecoders <span class="keywd">is</span> <span class="type">array</span> <span class="type">[</span>1 .. 4] msbHuffmanDecoder;

<span class="keywd">const</span> <span class="type">type</span>: jpegHeader <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: precision <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: width <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: height <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: framebytes <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">jpegComponentTypeMap</span>: componentType <span class="keywd">is</span> jpegComponentTypeMap.value;
    <span class="keywd">var</span> <span class="type">fourDataBlocksArray</span>: quantizationTable <span class="keywd">is</span> fourDataBlocksArray.value;
    <span class="keywd">var</span> <span class="type">jpegComponentArray</span>: component <span class="keywd">is</span> jpegComponentArray.value;
    <span class="keywd">var</span> <span class="type">jpegScanArray</span>: scan <span class="keywd">is</span> jpegScanArray.value;
    <span class="keywd">var</span> <span class="type">fourHuffmanDecoders</span>: dcDecoder <span class="keywd">is</span> fourHuffmanDecoders.value;
    <span class="keywd">var</span> <span class="type">fourHuffmanDecoders</span>: acDecoder <span class="keywd">is</span> fourHuffmanDecoders.value;
    <span class="keywd">var</span> <span class="type">dataBlockType</span>: lumaQuantization <span class="keywd">is</span> dataBlockType.value;
    <span class="keywd">var</span> <span class="type">dataBlockType</span>: chromaBlueQuantization <span class="keywd">is</span> dataBlockType.value;
    <span class="keywd">var</span> <span class="type">dataBlockType</span>: chromaRedQuantization <span class="keywd">is</span> dataBlockType.value;
    <span class="keywd">var</span> <span class="type">integer</span>: restartInterval <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: numberOfScans <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: startOfSpectral <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: endOfSpectral <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: approximationLow <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: approximationHigh <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: progressive <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: vertical <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: horizontal <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: numLuma <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: unitLines <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: unitColumns <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: blockLines <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: blockColumns <span class="keywd">is</span> 0;
    <span class="keywd">var</span> exifDataType: exifData <span class="keywd">is</span> exifDataType.value;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: jpegMinimumCodedUnit <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">fourDataBlocksArray</span>: luma <span class="keywd">is</span> fourDataBlocksArray.value;
    <span class="keywd">var</span> <span class="type">twoDataBlocksArray</span>: chroma <span class="keywd">is</span> twoDataBlocksArray.value;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">integer</span>: CHROMA_BLUE <span class="keywd">is</span> 1;
<span class="keywd">const</span> <span class="type">integer</span>: CHROMA_RED  <span class="keywd">is</span> 2;


<span class="keywd">const</span> <span class="type">proc</span>: readStartOfFrame (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile, <span class="keywd">inout</span> <span class="type">jpegHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: numComponents <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: componentData <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: componentId <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: sampling <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    stri := gets(jpegFile, JPEG_SOF_HEADER_FIXED_SIZE);
    <span class="keywd">if</span> length(stri) = JPEG_SOF_HEADER_FIXED_SIZE <span class="keywd">then</span>
      length           := bytes2Int(stri[1 fixLen 2], UNSIGNED, BE);
      header.precision := bytes2Int(stri[3 fixLen 1], UNSIGNED, BE);
      header.height    := bytes2Int(stri[4 fixLen 2], UNSIGNED, BE);
      header.width     := bytes2Int(stri[6 fixLen 2], UNSIGNED, BE);
      numComponents    := bytes2Int(stri[8 fixLen 1], UNSIGNED, BE);
      header.framebytes := header.width * header.height * numComponents;
      header.component := jpegComponentArray[.. numComponents] <span class="op">times</span> jpegComponent.value;
      componentData := gets(jpegFile, numComponents * 3);
      <span class="keywd">if</span> length(componentData) = numComponents * 3 <span class="keywd">then</span>
        <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> numComponents <span class="keywd">do</span>
          componentId := ord(componentData[1 + pred(index) * 3]);
          header.componentType @:= [componentId] index;
          sampling := ord(componentData[2 + pred(index) * 3]);
          <span class="keywd">if</span> index = JPEG_COMPTYPE_LUMA <span class="keywd">then</span>
            header.vertical := sampling <span class="op">mod</span> 16;
            header.horizontal := sampling >> 4;
            <span class="keywd">if</span> header.vertical > 2 <span class="op">or</span> header.horizontal > 2 <span class="keywd">then</span>
              raise RANGE_ERROR;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> sampling &lt;> 16#11 <span class="op">or</span> index > JPEG_COMPTYPE_CHROMA_RED <span class="keywd">then</span>
            raise RANGE_ERROR;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          header.component[index].quantizationTableIndex :=
              ord(componentData[3 + pred(index) * 3]) + 1;
        <span class="keywd">end</span> <span class="keywd">for</span>;
        header.numLuma := header.vertical * header.horizontal;
        header.unitLines := succ(pred(header.height) <span class="op">mdiv</span> (8 * header.vertical));
        header.unitColumns := succ(pred(header.width) <span class="op">mdiv</span> (8 * header.horizontal));
        header.blockLines := succ(pred(header.height) <span class="op">mdiv</span> 8);
        header.blockColumns := succ(pred(header.width) <span class="op">mdiv</span> 8);
        <span class="keywd">if</span> length &lt;> JPEG_SOF_HEADER_FIXED_SIZE + numComponents * 3 <span class="keywd">then</span>
          raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readDefineHuffmanTable (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile, <span class="keywd">inout</span> <span class="type">jpegHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: numberOfCodesWithLength <span class="keywd">is</span> 16 <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: maximumCodeLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: huffmanValues <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: aByte <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: tableClass <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: tableNumber <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: numberOfCodes <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: codeLength <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    stri := gets(jpegFile, 2);
    <span class="keywd">if</span> length(stri) = 2 <span class="keywd">then</span>
      length := bytes2Int(stri, UNSIGNED, BE) - 2;
      stri := gets(jpegFile, length);
      <span class="keywd">if</span> length(stri) = length <span class="keywd">then</span>
        <span class="keywd">while</span> pos &lt; length <span class="keywd">do</span>
          aByte := ord(stri[pos]);
          incr(pos);
          tableClass := aByte >> 4;
          tableNumber := succ(aByte <span class="op">mod</span> 16);
          numberOfCodes := 0;
          maximumCodeLength := 0;
          <span class="keywd">for</span> codeLength <span class="keywd">range</span> 1 <span class="keywd">to</span> 16 <span class="keywd">do</span>
            numberOfCodesWithLength[codeLength] := ord(stri[pos]);
            incr(pos);
            <span class="keywd">if</span> numberOfCodesWithLength[codeLength] &lt;> 0 <span class="keywd">then</span>
              maximumCodeLength := codeLength;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            numberOfCodes +:= numberOfCodesWithLength[codeLength];
          <span class="keywd">end</span> <span class="keywd">for</span>;
          huffmanValues := stri[pos fixLen numberOfCodes];
          pos +:= numberOfCodes;
          <span class="keywd">if</span> tableClass = 0 <span class="keywd">then</span>
            header.dcDecoder[tableNumber] := createMsbHuffmanDecoder(maximumCodeLength,
                numberOfCodesWithLength, huffmanValues);
          <span class="keywd">elsif</span> tableClass = 1 <span class="keywd">then</span>
            header.acDecoder[tableNumber] := createMsbHuffmanDecoder(maximumCodeLength,
                numberOfCodesWithLength, huffmanValues);
          <span class="keywd">else</span>
            raise RANGE_ERROR;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">if</span> pos &lt;> succ(length) <span class="keywd">then</span>
          raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readStartOfScan (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile, <span class="keywd">inout</span> <span class="type">jpegHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: aByte <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    stri := gets(jpegFile, 2);
    <span class="keywd">if</span> length(stri) = 2 <span class="keywd">then</span>
      length := bytes2Int(stri, UNSIGNED, BE) - 2;
      stri := gets(jpegFile, length);
      <span class="keywd">if</span> length(stri) = length <span class="keywd">then</span>
        <span class="keywd">if</span> pos &lt; length <span class="keywd">then</span>
          header.numberOfScans := ord(stri[pos]);
          incr(pos);
          header.scan := jpegScanArray[.. header.numberOfScans] <span class="op">times</span> jpegScan.value;
          <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> header.numberOfScans <span class="keywd">do</span>
            header.scan[index].componentId := ord(stri[pos]);
            incr(pos);
            <span class="keywd">if</span> header.scan[index].componentId <span class="op">not</span> <span class="op">in</span> header.componentType <span class="keywd">then</span>
              raise RANGE_ERROR;
            <span class="keywd">else</span>
              aByte := ord(stri[pos]);
              incr(pos);
              header.scan[index].dcHuffmanTableIndex := succ(aByte >> 4);
              header.scan[index].acHuffmanTableIndex := succ(aByte <span class="op">mod</span> 16);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">for</span>;
          header.startOfSpectral := succ(ord(stri[pos]));
          header.endOfSpectral := succ(ord(stri[pos + 1]));
          aByte := ord(stri[pos + 2]);
          pos +:= 3;
          header.approximationHigh := aByte >> 4;
          header.approximationLow := aByte <span class="op">mod</span> 16;
          <span class="keywd">if</span> header.progressive <span class="op">and</span> header.startOfSpectral = 1 <span class="op">and</span>
              header.endOfSpectral &lt;> 1 <span class="keywd">then</span>
            raise RANGE_ERROR;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> header.startOfSpectral > header.endOfSpectral <span class="op">or</span>
              header.endOfSpectral > JPEG_BLOCK_SIZE <span class="keywd">then</span>
            raise RANGE_ERROR;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> header.startOfSpectral &lt;> 1 <span class="op">and</span> header.numberOfScans &lt;> 1 <span class="keywd">then</span>
            raise RANGE_ERROR;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> header.approximationHigh &lt;> 0 <span class="op">and</span>
              header.approximationHigh &lt;> succ(header.approximationLow) <span class="keywd">then</span>
            raise RANGE_ERROR;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> pos &lt;> succ(length) <span class="keywd">then</span>
          raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readDefineQuantizationTable (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile, <span class="keywd">inout</span> <span class="type">jpegHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: aByte <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: elementPrecision <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: tableNumber <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    stri := gets(jpegFile, 2);
    <span class="keywd">if</span> length(stri) = 2 <span class="keywd">then</span>
      length := bytes2Int(stri, UNSIGNED, BE) - 2;
      stri := gets(jpegFile, length);
      <span class="keywd">if</span> length(stri) = length <span class="keywd">then</span>
        <span class="keywd">while</span> pos &lt; length <span class="keywd">do</span>
          aByte := ord(stri[pos]);
          incr(pos);
          elementPrecision := aByte >> 4;
          tableNumber := succ(aByte <span class="op">mod</span> 16);
          <span class="keywd">if</span> elementPrecision = 0 <span class="keywd">then</span>
            <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> JPEG_BLOCK_SIZE <span class="keywd">do</span>
              header.quantizationTable[tableNumber][index] := ord(stri[pos]);
              incr(pos);
            <span class="keywd">end</span> <span class="keywd">for</span>;
          <span class="keywd">elsif</span> elementPrecision = 1 <span class="keywd">then</span>
            <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> JPEG_BLOCK_SIZE <span class="keywd">do</span>
              header.quantizationTable[tableNumber][index] := bytes2Int(stri[pos fixLen 2], UNSIGNED, BE);
              pos +:= 2;
            <span class="keywd">end</span> <span class="keywd">for</span>;
          <span class="keywd">else</span>
            raise RANGE_ERROR;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">if</span> pos &lt;> succ(length) <span class="keywd">then</span>
          raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readDefineRestartInterval (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile, <span class="keywd">inout</span> <span class="type">jpegHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    stri := gets(jpegFile, 4);
    <span class="keywd">if</span> length(stri) = 4 <span class="keywd">then</span>
      length := bytes2Int(stri[1 fixLen 2], UNSIGNED, BE) - 2;
      <span class="keywd">if</span> length = 2 <span class="keywd">then</span>
        header.restartInterval := bytes2Int(stri[3 fixLen 2], UNSIGNED, BE);
      <span class="keywd">else</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readApplicationSegment (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile, <span class="op">in</span> <span class="type">integer</span>: appNumber,
    <span class="keywd">inout</span> <span class="type">jpegHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: data <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">string</span>: identifier <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := gets(jpegFile, 2);
    <span class="keywd">if</span> length(stri) = 2 <span class="keywd">then</span>
      length := bytes2Int(stri, UNSIGNED, BE) - 2;
      data := gets(jpegFile, length);
      <span class="keywd">if</span> length(data) = length <span class="keywd">then</span>
        identifier := getAsciiz(data, pos);
        <span class="keywd">if</span> appNumber = 1 <span class="op">and</span> identifier = EXIF_MAGIC <span class="keywd">then</span>
          readExifData(data[7 ..], header.exifData);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readComment (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: data <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := gets(jpegFile, 2);
    <span class="keywd">if</span> length(stri) = 2 <span class="keywd">then</span>
      length := bytes2Int(stri, UNSIGNED, BE) - 2;
      data := gets(jpegFile, length);
      <span class="keywd">if</span> length(data) &lt;> length <span class="keywd">then</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">##</span>
<span class="comment">#  Get a symbol with ''bitWidth'' bits from the ''stri'' bitstream.</span>
<span class="comment">#  Negative values are encoded with the highest bit set to zero.</span>
<span class="comment">#</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getSymbol (<span class="keywd">inout</span> msbInBitStream: entropyCodedStream,
    <span class="op">in</span> <span class="type">integer</span>: bitWidth) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: symbol <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    symbol := getBits(entropyCodedStream, bitWidth);
    <span class="keywd">if</span> symbol &lt; 1 &lt;&lt; pred(bitWidth) <span class="keywd">then</span>
      <span class="comment"># Negative value</span>
      symbol -:= pred(1 &lt;&lt; bitWidth);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">##</span>
<span class="comment">#  Read a block of IDCT coefficients.</span>
<span class="comment">#  There is one DC coefficient and 63 AC coefficients.</span>
<span class="comment">#  The DC coefficient (the first value) describes the average block value.</span>
<span class="comment">#  @param dataBlock Destination for the 64 coefficients.</span>
<span class="comment">#  @param dcDecoder Huffman decoder for the DC coefficient.</span>
<span class="comment">#  @param acDecoder Huffman decoder for the 63 AC coefficients.</span>
<span class="comment">#</span>
<span class="keywd">const</span> <span class="type">proc</span>: readBlock (<span class="keywd">inout</span> <span class="type">dataBlockType</span>: dataBlock,
    <span class="keywd">inout</span> msbInBitStream: entropyCodedStream, <span class="op">in</span> msbHuffmanDecoder: dcDecoder,
    <span class="op">in</span> msbHuffmanDecoder: acDecoder) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: bitWidth <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: aByte <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    dataBlock := dataBlockType.value;
    bitWidth := getHuffmanSymbol(entropyCodedStream, dcDecoder);
    <span class="keywd">if</span> bitWidth &lt;> 0 <span class="keywd">then</span>
      dataBlock[1] := getSymbol(entropyCodedStream, bitWidth);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">repeat</span>
      aByte := getHuffmanSymbol(entropyCodedStream, acDecoder);
      index +:= succ(aByte >> 4);
      bitWidth := aByte <span class="op">mod</span> 16;
      <span class="keywd">if</span> bitWidth &lt;> 0 <span class="keywd">then</span>
        dataBlock[index] := getSymbol(entropyCodedStream, bitWidth);
        <span class="keywd">if</span> index = JPEG_BLOCK_SIZE <span class="keywd">then</span>
          aByte := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> aByte = 0;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">##</span>
<span class="comment">#  Undo zigzagging of coefficients.</span>
<span class="comment">#  @param dataBlock 64 coefficients to dezigzag.</span>
<span class="comment">#  @return The dezigzagged coefficients.</span>
<span class="comment">#</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">dataBlockType</span>: unzigzag (<span class="op">in</span> <span class="type">dataBlockType</span>: dataBlock) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">dataBlockType</span>: unzigzag <span class="keywd">is</span> dataBlockType.value;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">array</span> <span class="type">integer</span>: zigzag <span class="keywd">is</span> [] (
         1,  2,  6,  7, 15, 16, 28, 29,
         3,  5,  8, 14, 17, 27, 30, 43,
         4,  9, 13, 18, 26, 31, 42, 44,
        10, 12, 19, 25, 32, 41, 45, 54,
        11, 20, 24, 33, 40, 46, 53, 55,
        21, 23, 34, 39, 47, 52, 56, 61,
        22, 35, 38, 48, 51, 57, 60, 62,
        36, 37, 49, 50, 58, 59, 63, 64);
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> JPEG_BLOCK_SIZE <span class="keywd">do</span>
      unzigzag[index] := dataBlock[zigzag[index]];
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">##</span>
<span class="comment">#  Fast inverse discrete cosine transform for a block line or block column.</span>
<span class="comment">#  For the internal calculation the values are scaled by 2048. At the end of</span>
<span class="comment">#  the function the scaling is reversed. This way the same function can be</span>
<span class="comment">#  used for lines and columns.</span>
<span class="comment">#  @param a1 .. a8 The coefficients of a line or column.</span>
<span class="comment">#</span>
<span class="keywd">const</span> <span class="type">proc</span>: fastIdct8 (<span class="keywd">inout</span> <span class="type">integer</span>: a1, <span class="keywd">inout</span> <span class="type">integer</span>: a2, <span class="keywd">inout</span> <span class="type">integer</span>: a3,
    <span class="keywd">inout</span> <span class="type">integer</span>: a4, <span class="keywd">inout</span> <span class="type">integer</span>: a5, <span class="keywd">inout</span> <span class="type">integer</span>: a6, <span class="keywd">inout</span> <span class="type">integer</span>: a7,
    <span class="keywd">inout</span> <span class="type">integer</span>: a8) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">integer</span>: W1 <span class="keywd">is</span> 2841;  <span class="comment"># 2048 * sqrt(2.0) * cos(1 * PI / 16)</span>
    <span class="keywd">const</span> <span class="type">integer</span>: W2 <span class="keywd">is</span> 2676;  <span class="comment"># 2048 * sqrt(2.0) * cos(2 * PI / 16)</span>
    <span class="keywd">const</span> <span class="type">integer</span>: W3 <span class="keywd">is</span> 2408;  <span class="comment"># 2048 * sqrt(2.0) * cos(3 * PI / 16)</span>
    <span class="keywd">const</span> <span class="type">integer</span>: W5 <span class="keywd">is</span> 1609;  <span class="comment"># 2048 * sqrt(2.0) * cos(5 * PI / 16)</span>
    <span class="keywd">const</span> <span class="type">integer</span>: W6 <span class="keywd">is</span> 1108;  <span class="comment"># 2048 * sqrt(2.0) * cos(6 * PI / 16)</span>
    <span class="keywd">const</span> <span class="type">integer</span>: W7 <span class="keywd">is</span>  565;  <span class="comment"># 2048 * sqrt(2.0) * cos(7 * PI / 16)</span>
    <span class="keywd">var</span> <span class="type">integer</span>: x0 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: x1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: x2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: x3 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: x4 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: x5 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: x6 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: x7 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: x8 <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> a2 = 0 <span class="op">and</span> a3 = 0 <span class="op">and</span> a4 = 0 <span class="op">and</span> a5 = 0 <span class="op">and</span> a6 = 0 <span class="op">and</span> a7 = 0 <span class="op">and</span> a8 = 0 <span class="keywd">then</span>
      a2 := a1;
      a3 := a1;
      a4 := a1;
      a5 := a1;
      a6 := a1;
      a7 := a1;
      a8 := a1;
    <span class="keywd">else</span>
      x0 := (a1 &lt;&lt; 11) + 128;
      x1 := a5 &lt;&lt; 11;
      x2 := a7;
      x3 := a3;
      x4 := a2;
      x5 := a8;
      x6 := a6;
      x7 := a4;

      <span class="comment"># First stage</span>
      x8 := W7 * (x4 + x5);
      x4 := x8 + (W1 - W7) * x4;
      x5 := x8 - (W1 + W7) * x5;
      x8 := W3 * (x6 + x7);
      x6 := x8 - (W3 - W5) * x6;
      x7 := x8 - (W3 + W5) * x7;

      <span class="comment"># Second stage</span>
      x8 := x0 + x1;
      x0 -:= x1;
      x1 := W6 * (x3 + x2);
      x2 := x1 - (W2 + W6) * x2;
      x3 := x1 + (W2 - W6) * x3;
      x1 := x4 + x6;
      x4 -:= x6;
      x6 := x5 + x7;
      x5 -:= x7;

      <span class="comment"># Third stage</span>
      x7 := x8 + x3;
      x8 -:= x3;
      x3 := x0 + x2;
      x0 -:= x2;
      x2 := (181 * (x4 + x5) + 128) >> 8;
      x4 := (181 * (x4 - x5) + 128) >> 8;

      <span class="comment"># Fourth stage</span>
      a1 := (x7 + x1) >> 11;
      a2 := (x3 + x2) >> 11;
      a3 := (x0 + x4) >> 11;
      a4 := (x8 + x6) >> 11;
      a5 := (x8 - x6) >> 11;
      a6 := (x0 - x4) >> 11;
      a7 := (x3 - x2) >> 11;
      a8 := (x7 - x1) >> 11;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">##</span>
<span class="comment">#  Perform a fast 2d inverse discrete cosine transform for a 8x8 block.</span>
<span class="comment">#  @param dataBlock 64 coefficients to transform.</span>
<span class="comment">#</span>
<span class="keywd">const</span> <span class="type">proc</span>: idct8x8 (<span class="keywd">inout</span> <span class="type">dataBlockType</span>: dataBlock) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 57 step 8 <span class="keywd">do</span>
      fastIdct8(dataBlock[index],
                dataBlock[index + 1],
                dataBlock[index + 2],
                dataBlock[index + 3],
                dataBlock[index + 4],
                dataBlock[index + 5],
                dataBlock[index + 6],
                dataBlock[index + 7]);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 8 <span class="keywd">do</span>
      fastIdct8(dataBlock[index],
                dataBlock[index + 8],
                dataBlock[index + 16],
                dataBlock[index + 24],
                dataBlock[index + 32],
                dataBlock[index + 40],
                dataBlock[index + 48],
                dataBlock[index + 56]);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">##</span>
<span class="comment">#  Read and process a 8x8 block of IDCT coefficients.</span>
<span class="comment">#  This function is used for luma and chroma blocks.</span>
<span class="comment">#  The processed block contains luma or chroma values of an 8x8</span>
<span class="comment">#  area scaled with factor 8 to the range -1024 .. 1023.</span>
<span class="comment">#  The values are not clamped so they might also be higher or</span>
<span class="comment">#  lower than the limit.</span>
<span class="comment">#</span>
<span class="keywd">const</span> <span class="type">proc</span>: processBlock (<span class="keywd">inout</span> <span class="type">dataBlockType</span>: dataBlock,
    <span class="keywd">inout</span> msbInBitStream: entropyCodedStream, <span class="op">in</span> msbHuffmanDecoder: dcDecoder,
    <span class="op">in</span> msbHuffmanDecoder: acDecoder, <span class="op">in</span> <span class="type">dataBlockType</span>: quantizationTable,
    <span class="keywd">inout</span> <span class="type">integer</span>: diff) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    readBlock(dataBlock, entropyCodedStream, dcDecoder, acDecoder);
    dataBlock[1] +:= diff;
    diff := dataBlock[1];
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> JPEG_BLOCK_SIZE <span class="keywd">do</span>
      dataBlock[index] *:= quantizationTable[index];
    <span class="keywd">end</span> <span class="keywd">for</span>;
    dataBlock := unzigzag(dataBlock);
    idct8x8(dataBlock);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: clampColor (<span class="op">in</span> <span class="type">integer</span>: col) <span class="keywd">is</span>
  <span class="keywd">return</span> (col &lt; 0 ? 0 : (col > 255 ? 255 : col)) * 256;


<span class="comment">##</span>
<span class="comment">#  Determine the pixel color from ''luminance'', ''chromaBlue'' and ''chromaRed''.</span>
<span class="comment">#  @param luminance Luminance scaled to 0 .. 255 (not clamped to it).</span>
<span class="comment">#  @param chromaBlue Blue croma scaled to -1024 .. 1023 (not clamped to it).</span>
<span class="comment">#  @param chromaRed Red croma scaled to -1024 .. 1023 (not clamped to it).</span>
<span class="comment">#  @return The pixel color in the RGB color space.</span>
<span class="comment">#</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">pixel</span>: setPixel (<span class="op">in</span> <span class="type">integer</span>: luminance, <span class="op">in</span> <span class="type">integer</span>: chromaBlue, <span class="op">in</span> <span class="type">integer</span>: chromaRed) <span class="keywd">is</span>
  <span class="keywd">return</span> rgbPixel(clampColor(chromaRed * 359 <span class="op">mdiv</span> 2048 + luminance),
                  clampColor(luminance - (chromaBlue * 88 + chromaRed * 183) <span class="op">mdiv</span> 2048),
                  clampColor(chromaBlue * 454 <span class="op">mdiv</span> 2048 + luminance));


<span class="keywd">const</span> <span class="type">proc</span>: colorMinimumCodedUnit11 (<span class="op">in</span> <span class="type">jpegHeader</span>: header, <span class="op">in</span> <span class="type">dataBlockType</span>: luma1,
    <span class="op">in</span> <span class="type">dataBlockType</span>: chromaBlue, <span class="op">in</span> <span class="type">dataBlockType</span>: chromaRed, <span class="keywd">inout</span> pixelImage: image,
    <span class="op">in</span> <span class="type">integer</span>: mcuTopLine, <span class="op">in</span> <span class="type">integer</span>: mcuLeftColumn) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: columnBeyond <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: dataIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: luminance <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    line := mcuTopLine;
    column := mcuLeftColumn;
    columnBeyond := column + 8;
    <span class="keywd">for</span> dataIndex <span class="keywd">range</span> 1 <span class="keywd">to</span> JPEG_BLOCK_SIZE <span class="keywd">do</span>
      <span class="keywd">if</span> line &lt;= header.height <span class="op">and</span> column &lt;= header.width <span class="keywd">then</span>
        luminance := luma1[dataIndex] <span class="op">mdiv</span> 8 + 128;
        image[line][column] := setPixel(luminance, chromaBlue[dataIndex], chromaRed[dataIndex]);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      incr(column);
      <span class="keywd">if</span> column = columnBeyond <span class="keywd">then</span>
        incr(line);
        column := mcuLeftColumn;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: colorMinimumCodedUnit12 (<span class="op">in</span> <span class="type">jpegHeader</span>: header, <span class="op">in</span> <span class="type">dataBlockType</span>: luma1,
    <span class="op">in</span> <span class="type">dataBlockType</span>: luma2, <span class="op">in</span> <span class="type">dataBlockType</span>: chromaBlue, <span class="op">in</span> <span class="type">dataBlockType</span>: chromaRed,
    <span class="keywd">inout</span> pixelImage: image, <span class="op">in</span> <span class="type">integer</span>: mcuTopLine, <span class="op">in</span> <span class="type">integer</span>: mcuLeftColumn) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: blockLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: blockColumn <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: blockColumnMax <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: dataIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: luminance <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    blockColumnMax := min(7, header.width - mcuLeftColumn);
    <span class="keywd">for</span> blockLine <span class="keywd">range</span> 0 <span class="keywd">to</span> 7 <span class="keywd">do</span>
      line := mcuTopLine + blockLine;
      <span class="keywd">if</span> line &lt;= header.height <span class="keywd">then</span>
        <span class="keywd">for</span> blockColumn <span class="keywd">range</span> 0 <span class="keywd">to</span> blockColumnMax <span class="keywd">do</span>
          column := mcuLeftColumn + blockColumn;
          luminance := luma1[blockLine * 8 + blockColumn + 1] <span class="op">mdiv</span> 8 + 128;
          dataIndex := succ(blockLine <span class="op">mdiv</span> 2 * 8 + blockColumn);
          image[line][column] := setPixel(luminance, chromaBlue[dataIndex], chromaRed[dataIndex]);
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> blockLine <span class="keywd">range</span> 8 <span class="keywd">to</span> 15 <span class="keywd">do</span>
      line := mcuTopLine + blockLine;
      <span class="keywd">if</span> line &lt;= header.height <span class="keywd">then</span>
        <span class="keywd">for</span> blockColumn <span class="keywd">range</span> 0 <span class="keywd">to</span> blockColumnMax <span class="keywd">do</span>
          column := mcuLeftColumn + blockColumn;
          luminance := luma2[(blockLine - 8) * 8 + blockColumn + 1] <span class="op">mdiv</span> 8 + 128;
          dataIndex := succ(blockLine <span class="op">mdiv</span> 2 * 8 + blockColumn);
          image[line][column] := setPixel(luminance, chromaBlue[dataIndex], chromaRed[dataIndex]);
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: colorMinimumCodedUnit21 (<span class="op">in</span> <span class="type">jpegHeader</span>: header, <span class="op">in</span> <span class="type">dataBlockType</span>: luma1,
    <span class="op">in</span> <span class="type">dataBlockType</span>: luma2, <span class="op">in</span> <span class="type">dataBlockType</span>: chromaBlue, <span class="op">in</span> <span class="type">dataBlockType</span>: chromaRed,
    <span class="keywd">inout</span> pixelImage: image, <span class="op">in</span> <span class="type">integer</span>: mcuTopLine, <span class="op">in</span> <span class="type">integer</span>: mcuLeftColumn) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: blockLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: blockColumn <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: blockColumnMax1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: blockColumnMax2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: dataIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: luminance <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    blockColumnMax1 := min(7, header.width - mcuLeftColumn);
    blockColumnMax2 := min(15, header.width - mcuLeftColumn);
    <span class="keywd">for</span> blockLine <span class="keywd">range</span> 0 <span class="keywd">to</span> min(7, header.height - mcuTopLine) <span class="keywd">do</span>
      line := mcuTopLine + blockLine;
      <span class="keywd">for</span> blockColumn <span class="keywd">range</span> 0 <span class="keywd">to</span> blockColumnMax1 <span class="keywd">do</span>
        column := mcuLeftColumn + blockColumn;
        luminance := luma1[blockLine * 8 + blockColumn + 1] <span class="op">mdiv</span> 8 + 128;
        dataIndex := succ(blockLine * 8 + blockColumn <span class="op">mdiv</span> 2);
        image[line][column] := setPixel(luminance, chromaBlue[dataIndex], chromaRed[dataIndex]);
      <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">for</span> blockColumn <span class="keywd">range</span> 8 <span class="keywd">to</span> blockColumnMax2 <span class="keywd">do</span>
        column := mcuLeftColumn + blockColumn;
        luminance := luma2[blockLine * 8 + blockColumn - 8 + 1] <span class="op">mdiv</span> 8 + 128;
        dataIndex := succ(blockLine * 8 + blockColumn <span class="op">mdiv</span> 2);
        image[line][column] := setPixel(luminance, chromaBlue[dataIndex], chromaRed[dataIndex]);
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: colorMinimumCodedUnit22 (<span class="op">in</span> <span class="type">jpegHeader</span>: header, <span class="op">in</span> <span class="type">dataBlockType</span>: luma1,
    <span class="op">in</span> <span class="type">dataBlockType</span>: luma2, <span class="op">in</span> <span class="type">dataBlockType</span>: luma3, <span class="op">in</span> <span class="type">dataBlockType</span>: luma4,
    <span class="op">in</span> <span class="type">dataBlockType</span>: chromaBlue, <span class="op">in</span> <span class="type">dataBlockType</span>: chromaRed, <span class="keywd">inout</span> pixelImage: image,
    <span class="op">in</span> <span class="type">integer</span>: mcuTopLine, <span class="op">in</span> <span class="type">integer</span>: mcuLeftColumn) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: blockLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: blockColumn <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: blockColumnMax1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: blockColumnMax2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: dataIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: luminance <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    blockColumnMax1 := min(7, header.width - mcuLeftColumn);
    blockColumnMax2 := min(15, header.width - mcuLeftColumn);
    <span class="keywd">for</span> blockLine <span class="keywd">range</span> 0 <span class="keywd">to</span> 7 <span class="keywd">do</span>
      line := mcuTopLine + blockLine;
      <span class="keywd">if</span> line &lt;= header.height <span class="keywd">then</span>
        <span class="keywd">for</span> blockColumn <span class="keywd">range</span> 0 <span class="keywd">to</span> blockColumnMax1 <span class="keywd">do</span>
          column := mcuLeftColumn + blockColumn;
          luminance := luma1[blockLine * 8 + blockColumn + 1] <span class="op">mdiv</span> 8 + 128;
          dataIndex := succ(blockLine <span class="op">mdiv</span> 2 * 8 + blockColumn <span class="op">mdiv</span> 2);
          image[line][column] := setPixel(luminance, chromaBlue[dataIndex], chromaRed[dataIndex]);
        <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">for</span> blockColumn <span class="keywd">range</span> 8 <span class="keywd">to</span> blockColumnMax2 <span class="keywd">do</span>
          column := mcuLeftColumn + blockColumn;
          luminance := luma2[blockLine * 8 + blockColumn - 8 + 1] <span class="op">mdiv</span> 8 + 128;
          dataIndex := succ(blockLine <span class="op">mdiv</span> 2 * 8 + blockColumn <span class="op">mdiv</span> 2);
          image[line][column] := setPixel(luminance, chromaBlue[dataIndex], chromaRed[dataIndex]);
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> blockLine <span class="keywd">range</span> 8 <span class="keywd">to</span> 15 <span class="keywd">do</span>
      line := mcuTopLine + blockLine;
      <span class="keywd">if</span> line &lt;= header.height <span class="keywd">then</span>
        <span class="keywd">for</span> blockColumn <span class="keywd">range</span> 0 <span class="keywd">to</span> blockColumnMax1 <span class="keywd">do</span>
          column := mcuLeftColumn + blockColumn;
          luminance := luma3[(blockLine - 8) * 8 + blockColumn + 1] <span class="op">mdiv</span> 8 + 128;
          dataIndex := succ(blockLine <span class="op">mdiv</span> 2 * 8 + blockColumn <span class="op">mdiv</span> 2);
          image[line][column] := setPixel(luminance, chromaBlue[dataIndex], chromaRed[dataIndex]);
        <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">for</span> blockColumn <span class="keywd">range</span> 8 <span class="keywd">to</span> blockColumnMax2 <span class="keywd">do</span>
          column := mcuLeftColumn + blockColumn;
          luminance := luma4[(blockLine - 8) * 8 + blockColumn - 8 + 1] <span class="op">mdiv</span> 8 + 128;
          dataIndex := succ(blockLine <span class="op">mdiv</span> 2 * 8 + blockColumn <span class="op">mdiv</span> 2);
          image[line][column] := setPixel(luminance, chromaBlue[dataIndex], chromaRed[dataIndex]);
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: setupQuantization (<span class="keywd">inout</span> <span class="type">jpegHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    header.lumaQuantization := header.quantizationTable[header.component[1].quantizationTableIndex];
    <span class="keywd">if</span> length(header.component) >= 2 <span class="keywd">then</span>
      header.chromaBlueQuantization := header.quantizationTable[header.component[2].quantizationTableIndex];
      <span class="keywd">if</span> length(header.component) >= 3 <span class="keywd">then</span>
        header.chromaRedQuantization := header.quantizationTable[header.component[3].quantizationTableIndex];
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">##</span>
<span class="comment">#  Read an entropy coded segment.</span>
<span class="comment">#  The entropy coded segment (ECS) is terminated with the start of the</span>
<span class="comment">#  next segment. In the ECS segment the sequence "\16#ff;\0;" is replaced</span>
<span class="comment">#  by "\16#ff;". The ECS segment ends, if a "\16#ff;" is not followed by</span>
<span class="comment">#  "\0;" (introducing the start of the next segment). The character after</span>
<span class="comment">#  the "\16#ff;" is the marker of the next segment (saved in bufferChar).</span>
<span class="comment">#  A segment marker in the range JPEG_RST0 .. JPEG_RST7 (restart marker)</span>
<span class="comment">#  indicates that the next segment is also an ECS segment. It can happen</span>
<span class="comment">#  that the last ECS segment is followed by a superfluous restart marker.</span>
<span class="comment">#  In this case the restart marker is ignored.</span>
<span class="comment">#</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: readEntropyCodedSegment (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: ecsData <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      ecsData &amp;:= getTerminatedString(jpegFile, JPEG_MARKER_START);
      <span class="keywd">if</span> jpegFile.bufferChar = JPEG_MARKER_START <span class="keywd">then</span>
        jpegFile.bufferChar := getc(jpegFile);
        <span class="keywd">if</span> jpegFile.bufferChar = <span class="stri">'\0;'</span> <span class="keywd">then</span>
          ecsData &amp;:= JPEG_MARKER_START;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> jpegFile.bufferChar &lt;> <span class="stri">'\0;'</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: loadMonochromeImage (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile, <span class="op">in</span> <span class="type">jpegHeader</span>: header,
    <span class="op">in</span> msbHuffmanDecoder: dcLumaTable, <span class="op">in</span> msbHuffmanDecoder: acLumaTable,
    <span class="keywd">inout</span> pixelImage: image) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: entropyCodedSegment <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> msbInBitStream: entropyCodedStream <span class="keywd">is</span> msbInBitStream.value;
    <span class="keywd">var</span> <span class="type">integer</span>: mcuTopLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: mcuLeftColumn <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: mcuCount <span class="keywd">is</span> -1;
    <span class="keywd">var</span> <span class="type">integer</span>: diffLuminance <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">dataBlockType</span>: luma <span class="keywd">is</span> dataBlockType.value;
    <span class="keywd">var</span> <span class="type">integer</span>: blockLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: blockLineMax <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: blockColumn <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: blockColumnMax <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: grayIntensity <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    entropyCodedSegment := readEntropyCodedSegment(jpegFile);
    entropyCodedStream := openMsbInBitStream(entropyCodedSegment);
    <span class="keywd">if</span> header.restartInterval &lt;> 0 <span class="keywd">then</span>
      mcuCount := header.restartInterval;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    image := pixelImage[.. header.height] <span class="op">times</span>
             pixelArray[.. header.width] <span class="op">times</span> pixel.value;
    <span class="keywd">for</span> mcuTopLine <span class="keywd">range</span> 1 <span class="keywd">to</span> header.height step 8 <span class="keywd">do</span>
      blockLineMax := min(7, header.height - mcuTopLine);
      <span class="keywd">for</span> mcuLeftColumn <span class="keywd">range</span> 1 <span class="keywd">to</span> header.width step 8 <span class="keywd">do</span>
        <span class="keywd">if</span> header.restartInterval &lt;> 0 <span class="keywd">then</span>
          <span class="keywd">if</span> mcuCount = 0 <span class="keywd">then</span>
            entropyCodedSegment := readEntropyCodedSegment(jpegFile);
            entropyCodedStream := openMsbInBitStream(entropyCodedSegment);
            diffLuminance := 0;
            mcuCount := header.restartInterval;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          decr(mcuCount);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        processBlock(luma, entropyCodedStream, dcLumaTable, acLumaTable,
                     header.lumaQuantization, diffLuminance);
        blockColumnMax := min(7, header.width - mcuLeftColumn);
        <span class="keywd">for</span> blockLine <span class="keywd">range</span> 0 <span class="keywd">to</span> blockLineMax <span class="keywd">do</span>
          line := mcuTopLine + blockLine;
          <span class="keywd">for</span> blockColumn <span class="keywd">range</span> 0 <span class="keywd">to</span> blockColumnMax <span class="keywd">do</span>
            grayIntensity := clampColor(luma[succ(blockLine * 8 + blockColumn)] <span class="op">mdiv</span> 8 + 128);
            image[line][mcuLeftColumn + blockColumn] :=
                rgbPixel(grayIntensity, grayIntensity, grayIntensity);
          <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: loadColorImage (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile, <span class="op">in</span> <span class="type">jpegHeader</span>: header,
    <span class="op">in</span> msbHuffmanDecoder: dcLumaTable, <span class="op">in</span> msbHuffmanDecoder: acLumaTable,
    <span class="op">in</span> msbHuffmanDecoder: dcChromaBlueTable, <span class="op">in</span> msbHuffmanDecoder: acChromaBlueTable,
    <span class="op">in</span> msbHuffmanDecoder: dcChromaRedTable, <span class="op">in</span> msbHuffmanDecoder: acChromaRedTable,
    <span class="keywd">inout</span> pixelImage: image) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: entropyCodedSegment <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> msbInBitStream: entropyCodedStream <span class="keywd">is</span> msbInBitStream.value;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: mcuCount <span class="keywd">is</span> -1;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: diffLuminance <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: diffChromaBlue <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: diffChromaRed <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">dataBlockType</span>: luma <span class="keywd">is</span> 4 <span class="op">times</span> dataBlockType.value;
    <span class="keywd">var</span> <span class="type">dataBlockType</span>: chromaBlue <span class="keywd">is</span> dataBlockType.value;
    <span class="keywd">var</span> <span class="type">dataBlockType</span>: chromaRed <span class="keywd">is</span> dataBlockType.value;
  <span class="keywd">begin</span>
    entropyCodedSegment := readEntropyCodedSegment(jpegFile);
    entropyCodedStream := openMsbInBitStream(entropyCodedSegment);
    <span class="keywd">if</span> header.restartInterval &lt;> 0 <span class="keywd">then</span>
      mcuCount := header.restartInterval;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    image := pixelImage[.. header.height] <span class="op">times</span>
             pixelArray[.. header.width] <span class="op">times</span> pixel.value;
    <span class="keywd">for</span> line <span class="keywd">range</span> 1 <span class="keywd">to</span> header.height step header.vertical * 8 <span class="keywd">do</span>
      <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> header.width step header.horizontal * 8 <span class="keywd">do</span>
        <span class="keywd">if</span> header.restartInterval &lt;> 0 <span class="keywd">then</span>
          <span class="keywd">if</span> mcuCount = 0 <span class="keywd">then</span>
            entropyCodedSegment := readEntropyCodedSegment(jpegFile);
            entropyCodedStream := openMsbInBitStream(entropyCodedSegment);
            diffLuminance := 0;
            diffChromaBlue := 0;
            diffChromaRed := 0;
            mcuCount := header.restartInterval;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          decr(mcuCount);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> header.numLuma <span class="keywd">do</span>
          processBlock(luma[index], entropyCodedStream, dcLumaTable, acLumaTable,
                       header.lumaQuantization, diffLuminance);
        <span class="keywd">end</span> <span class="keywd">for</span>;
        processBlock(chromaBlue, entropyCodedStream, dcChromaBlueTable, acChromaBlueTable,
                     header.chromaBlueQuantization, diffChromaBlue);
        processBlock(chromaRed, entropyCodedStream, dcChromaRedTable, acChromaRedTable,
                     header.chromaRedQuantization, diffChromaRed);
        <span class="keywd">if</span> header.horizontal = 1 <span class="keywd">then</span>
          <span class="keywd">if</span> header.vertical = 1 <span class="keywd">then</span>
            colorMinimumCodedUnit11(header, luma[1], chromaBlue, chromaRed,
                                    image, line, column);
          <span class="keywd">else</span>
            colorMinimumCodedUnit12(header, luma[1], luma[2],
                                    chromaBlue, chromaRed, image, line, column);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          <span class="keywd">if</span> header.vertical = 1 <span class="keywd">then</span>
            colorMinimumCodedUnit21(header, luma[1], luma[2],
                                    chromaBlue, chromaRed, image, line, column);
          <span class="keywd">else</span>
            colorMinimumCodedUnit22(header, luma[1], luma[2], luma[3], luma[4],
                                    chromaBlue, chromaRed, image, line, column);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: loadImage (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile, <span class="op">in</span> <span class="type">jpegHeader</span>: header,
    <span class="keywd">inout</span> pixelImage: image) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: dcLumaIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: acLumaIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: dcCbIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: acCbIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: dcCrIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: acCrIndex <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> header.componentType[header.scan[1].componentId] &lt;> JPEG_COMPTYPE_LUMA <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    dcLumaIndex := header.scan[1].dcHuffmanTableIndex;
    acLumaIndex := header.scan[1].acHuffmanTableIndex;
    <span class="keywd">if</span> header.numberOfScans = 1 <span class="keywd">then</span>
      loadMonochromeImage(jpegFile, header, header.dcDecoder[dcLumaIndex],
                          header.acDecoder[acLumaIndex], image);
    <span class="keywd">elsif</span> header.numberOfScans = 3 <span class="keywd">then</span>
      <span class="keywd">if</span> header.componentType[header.scan[2].componentId] &lt;> JPEG_COMPTYPE_CHROMA_BLUE <span class="op">or</span>
          header.componentType[header.scan[3].componentId] &lt;> JPEG_COMPTYPE_CHROMA_RED <span class="keywd">then</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      dcCbIndex  := header.scan[2].dcHuffmanTableIndex;
      acCbIndex  := header.scan[2].acHuffmanTableIndex;
      dcCrIndex  := header.scan[3].dcHuffmanTableIndex;
      acCrIndex  := header.scan[3].acHuffmanTableIndex;
      loadColorImage(jpegFile, header,
                     header.dcDecoder[dcLumaIndex], header.acDecoder[acLumaIndex],
                     header.dcDecoder[dcCbIndex], header.acDecoder[acCbIndex],
                     header.dcDecoder[dcCrIndex], header.acDecoder[acCrIndex],
                     image);
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">PRIMITIVE_WINDOW</span>: loadSequential (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile, <span class="op">in</span> <span class="type">jpegHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: pixmap <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> pixelImage: image <span class="keywd">is</span> pixelImage.value;
  <span class="keywd">begin</span>
    loadImage(jpegFile, header, image);
    <span class="keywd">if</span> header.exifData.orientation > EXIF_ORIENTATION_NORMAL <span class="op">and</span>
        header.exifData.orientation &lt; EXIF_ORIENTATION_UNDEFINED <span class="keywd">then</span>
      changeOrientation(image, header.exifData.orientation);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    pixmap := getPixmap(image);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">##</span>
<span class="comment">#  Read the DC coefficient of a block.</span>
<span class="comment">#</span>
<span class="keywd">const</span> <span class="type">proc</span>: readDcValue (<span class="keywd">inout</span> <span class="type">integer</span>: dcCoefficient,
    <span class="keywd">inout</span> msbInBitStream: entropyCodedStream, <span class="op">in</span> msbHuffmanDecoder: dcDecoder,
    <span class="keywd">inout</span> <span class="type">integer</span>: diff, <span class="op">in</span> <span class="type">integer</span>: approximationLow) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: bitWidth <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: aValue <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    bitWidth := getHuffmanSymbol(entropyCodedStream, dcDecoder);
    <span class="keywd">if</span> bitWidth &lt;> 0 <span class="keywd">then</span>
      aValue := getSymbol(entropyCodedStream, bitWidth);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    aValue +:= diff;
    diff := aValue;
    dcCoefficient := aValue &lt;&lt; approximationLow;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readLumaDcOfAllBlocks (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile, <span class="op">in</span> <span class="type">jpegHeader</span>: header,
    <span class="op">in</span> msbHuffmanDecoder: dcDecoder, <span class="keywd">inout</span> <span class="type">array</span> <span class="type">array</span> <span class="type">jpegMinimumCodedUnit</span>: mcuImage) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: entropyCodedSegment <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> msbInBitStream: entropyCodedStream <span class="keywd">is</span> msbInBitStream.value;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: diffLuminance <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: mcuCount <span class="keywd">is</span> -1;
  <span class="keywd">begin</span>
    entropyCodedSegment := readEntropyCodedSegment(jpegFile);
    entropyCodedStream := openMsbInBitStream(entropyCodedSegment);
    <span class="keywd">if</span> header.restartInterval &lt;> 0 <span class="keywd">then</span>
      mcuCount := header.restartInterval;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">for</span> line <span class="keywd">range</span> 1 <span class="keywd">to</span> header.blockLines <span class="keywd">do</span>
      <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> header.blockColumns <span class="keywd">do</span>
        <span class="keywd">if</span> header.restartInterval &lt;> 0 <span class="keywd">then</span>
          <span class="keywd">if</span> mcuCount = 0 <span class="keywd">then</span>
            entropyCodedSegment := readEntropyCodedSegment(jpegFile);
            entropyCodedStream := openMsbInBitStream(entropyCodedSegment);
            diffLuminance := 0;
            mcuCount := header.restartInterval;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          decr(mcuCount);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        index := succ(2 * (pred(line) <span class="op">mod</span> header.vertical) + pred(column) <span class="op">mod</span> header.horizontal);
        readDcValue(mcuImage[succ(pred(line) <span class="op">mdiv</span> header.vertical)]
                            [succ(pred(column) <span class="op">mdiv</span> header.horizontal)].luma[index][1],
                    entropyCodedStream, dcDecoder, diffLuminance, header.approximationLow);
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readDcValuesOfAllBlocks (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile, <span class="op">in</span> <span class="type">jpegHeader</span>: header,
    <span class="op">in</span> <span class="type">integer</span>: dcLumaIndex, <span class="op">in</span> <span class="type">integer</span>: dcCbIndex, <span class="op">in</span> <span class="type">integer</span>: dcCrIndex,
    <span class="keywd">inout</span> <span class="type">array</span> <span class="type">array</span> <span class="type">jpegMinimumCodedUnit</span>: mcuImage) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: entropyCodedSegment <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> msbInBitStream: entropyCodedStream <span class="keywd">is</span> msbInBitStream.value;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: diffLuminance <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: diffChromaBlue <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: diffChromaRed <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: mcuCount <span class="keywd">is</span> -1;
  <span class="keywd">begin</span>
    entropyCodedSegment := readEntropyCodedSegment(jpegFile);
    entropyCodedStream := openMsbInBitStream(entropyCodedSegment);
    <span class="keywd">if</span> header.restartInterval &lt;> 0 <span class="keywd">then</span>
      mcuCount := header.restartInterval;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">for</span> line <span class="keywd">range</span> 1 <span class="keywd">to</span> header.unitLines <span class="keywd">do</span>
      <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> header.unitColumns <span class="keywd">do</span>
        <span class="keywd">if</span> header.restartInterval &lt;> 0 <span class="keywd">then</span>
          <span class="keywd">if</span> mcuCount = 0 <span class="keywd">then</span>
            entropyCodedSegment := readEntropyCodedSegment(jpegFile);
            entropyCodedStream := openMsbInBitStream(entropyCodedSegment);
            diffLuminance := 0;
            diffChromaBlue := 0;
            diffChromaRed := 0;
            mcuCount := header.restartInterval;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          decr(mcuCount);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> dcLumaIndex &lt;> 0 <span class="keywd">then</span>
          <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> header.numLuma <span class="keywd">do</span>
            readDcValue(mcuImage[line][column].luma[index][1],
                        entropyCodedStream, header.dcDecoder[dcLumaIndex],
                        diffLuminance, header.approximationLow);
          <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> dcCbIndex &lt;> 0 <span class="keywd">then</span>
          readDcValue(mcuImage[line][column].chroma[CHROMA_BLUE][1],
                      entropyCodedStream, header.dcDecoder[dcCbIndex],
                      diffChromaBlue, header.approximationLow);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> dcCrIndex &lt;> 0 <span class="keywd">then</span>
          readDcValue(mcuImage[line][column].chroma[CHROMA_RED][1],
                      entropyCodedStream, header.dcDecoder[dcCrIndex],
                      diffChromaRed, header.approximationLow);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: refineDcValuesOfAllBlocks (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile, <span class="op">in</span> <span class="type">jpegHeader</span>: header,
    <span class="op">in</span> <span class="type">integer</span>: dcLumaIndex, <span class="op">in</span> <span class="type">integer</span>: dcCbIndex, <span class="op">in</span> <span class="type">integer</span>: dcCrIndex,
    <span class="keywd">inout</span> <span class="type">array</span> <span class="type">array</span> <span class="type">jpegMinimumCodedUnit</span>: mcuImage) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: entropyCodedSegment <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> msbInBitStream: entropyCodedStream <span class="keywd">is</span> msbInBitStream.value;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: mcuCount <span class="keywd">is</span> -1;
  <span class="keywd">begin</span>
    entropyCodedSegment := readEntropyCodedSegment(jpegFile);
    entropyCodedStream := openMsbInBitStream(entropyCodedSegment);
    <span class="keywd">if</span> header.restartInterval &lt;> 0 <span class="keywd">then</span>
      mcuCount := header.restartInterval;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">for</span> line <span class="keywd">range</span> 1 <span class="keywd">to</span> header.unitLines <span class="keywd">do</span>
      <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> header.unitColumns <span class="keywd">do</span>
        <span class="keywd">if</span> header.restartInterval &lt;> 0 <span class="keywd">then</span>
          <span class="keywd">if</span> mcuCount = 0 <span class="keywd">then</span>
            entropyCodedSegment := readEntropyCodedSegment(jpegFile);
            entropyCodedStream := openMsbInBitStream(entropyCodedSegment);
            mcuCount := header.restartInterval;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          decr(mcuCount);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> dcLumaIndex &lt;> 0 <span class="keywd">then</span>
          <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> header.numLuma <span class="keywd">do</span>
            <span class="keywd">if</span> getBit(entropyCodedStream) &lt;> 0 <span class="keywd">then</span>
              mcuImage[line][column].luma[index][1] +:= 1 &lt;&lt; header.approximationLow;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> dcCbIndex &lt;> 0 <span class="keywd">then</span>
          <span class="keywd">if</span> getBit(entropyCodedStream) &lt;> 0 <span class="keywd">then</span>
            mcuImage[line][column].chroma[CHROMA_BLUE][1] +:= 1 &lt;&lt; header.approximationLow;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> dcCrIndex &lt;> 0 <span class="keywd">then</span>
          <span class="keywd">if</span> getBit(entropyCodedStream) &lt;> 0 <span class="keywd">then</span>
            mcuImage[line][column].chroma[CHROMA_RED][1] +:= 1 &lt;&lt; header.approximationLow;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">##</span>
<span class="comment">#  Read the AC coefficients of a block.</span>
<span class="comment">#</span>
<span class="keywd">const</span> <span class="type">proc</span>: readBlockAc (<span class="keywd">inout</span> <span class="type">dataBlockType</span>: dataBlock,
    <span class="keywd">inout</span> msbInBitStream: entropyCodedStream, <span class="op">in</span> msbHuffmanDecoder: acDecoder,
    <span class="op">in</span> <span class="type">integer</span>: startOfSpectral, <span class="op">in</span> <span class="type">integer</span>: endOfSpectral,
    <span class="keywd">inout</span> <span class="type">integer</span>: eobRunLength, <span class="op">in</span> <span class="type">integer</span>: approximationLow) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: bitWidth <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: aByte <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: zeros <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bits <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    index := pred(startOfSpectral);
    <span class="keywd">repeat</span>
      aByte := getHuffmanSymbol(entropyCodedStream, acDecoder);
      zeros := aByte >> 4;
      bitWidth := aByte <span class="op">mod</span> 16;
      <span class="keywd">if</span> bitWidth = 0 <span class="keywd">then</span>
        <span class="keywd">if</span> zeros = 15 <span class="keywd">then</span>
          index +:= 16;
          <span class="keywd">if</span> index >= JPEG_BLOCK_SIZE <span class="keywd">then</span>
            raise RANGE_ERROR;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          eobRunLength := 1 &lt;&lt; zeros;
          <span class="keywd">if</span> zeros &lt;> 0 <span class="keywd">then</span>
            bits := getBits(entropyCodedStream, zeros);
            eobRunLength +:= bits;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          decr(eobRunLength);
          aByte := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        index +:= succ(zeros);
        dataBlock[index] := getSymbol(entropyCodedStream, bitWidth) &lt;&lt; approximationLow;
        <span class="keywd">if</span> index = endOfSpectral <span class="keywd">then</span>
          aByte := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> aByte = 0;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readLumaAcOfAllBlocks (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile, <span class="op">in</span> <span class="type">jpegHeader</span>: header,
    <span class="op">in</span> msbHuffmanDecoder: acDecoder, <span class="keywd">inout</span> <span class="type">array</span> <span class="type">array</span> <span class="type">jpegMinimumCodedUnit</span>: mcuImage) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: entropyCodedSegment <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> msbInBitStream: entropyCodedStream <span class="keywd">is</span> msbInBitStream.value;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: mcuCount <span class="keywd">is</span> -1;
    <span class="keywd">var</span> <span class="type">integer</span>: eobRunLength <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    entropyCodedSegment := readEntropyCodedSegment(jpegFile);
    entropyCodedStream := openMsbInBitStream(entropyCodedSegment);
    <span class="keywd">if</span> header.restartInterval &lt;> 0 <span class="keywd">then</span>
      mcuCount := header.restartInterval;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">for</span> line <span class="keywd">range</span> 1 <span class="keywd">to</span> header.blockLines <span class="keywd">do</span>
      <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> header.blockColumns <span class="keywd">do</span>
        <span class="keywd">if</span> header.restartInterval &lt;> 0 <span class="keywd">then</span>
          <span class="keywd">if</span> mcuCount = 0 <span class="keywd">then</span>
            entropyCodedSegment := readEntropyCodedSegment(jpegFile);
            entropyCodedStream := openMsbInBitStream(entropyCodedSegment);
            mcuCount := header.restartInterval;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          decr(mcuCount);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> eobRunLength > 0 <span class="keywd">then</span>
          decr(eobRunLength);
        <span class="keywd">else</span>
          index := succ(2 * (pred(line) <span class="op">mod</span> header.vertical) + pred(column) <span class="op">mod</span> header.horizontal);
          readBlockAc(mcuImage[succ(pred(line) <span class="op">mdiv</span> header.vertical)]
                              [succ(pred(column) <span class="op">mdiv</span> header.horizontal)].luma[index],
                      entropyCodedStream, acDecoder, header.startOfSpectral, header.endOfSpectral,
                      eobRunLength, header.approximationLow);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readChromaAcOfAllBlocks (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile, <span class="op">in</span> <span class="type">jpegHeader</span>: header,
    <span class="op">in</span> msbHuffmanDecoder: acDecoder, <span class="keywd">inout</span> <span class="type">array</span> <span class="type">array</span> <span class="type">jpegMinimumCodedUnit</span>: mcuImage,
    <span class="op">in</span> <span class="type">integer</span>: chromaIndex) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: entropyCodedSegment <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> msbInBitStream: entropyCodedStream <span class="keywd">is</span> msbInBitStream.value;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: mcuCount <span class="keywd">is</span> -1;
    <span class="keywd">var</span> <span class="type">integer</span>: eobRunLength <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    entropyCodedSegment := readEntropyCodedSegment(jpegFile);
    entropyCodedStream := openMsbInBitStream(entropyCodedSegment);
    <span class="keywd">if</span> header.restartInterval &lt;> 0 <span class="keywd">then</span>
      mcuCount := header.restartInterval;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">for</span> line <span class="keywd">range</span> 1 <span class="keywd">to</span> header.unitLines <span class="keywd">do</span>
      <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> header.unitColumns <span class="keywd">do</span>
        <span class="keywd">if</span> header.restartInterval &lt;> 0 <span class="keywd">then</span>
          <span class="keywd">if</span> mcuCount = 0 <span class="keywd">then</span>
            entropyCodedSegment := readEntropyCodedSegment(jpegFile);
            entropyCodedStream := openMsbInBitStream(entropyCodedSegment);
            mcuCount := header.restartInterval;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          decr(mcuCount);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> eobRunLength > 0 <span class="keywd">then</span>
          decr(eobRunLength);
        <span class="keywd">else</span>
          readBlockAc(mcuImage[line][column].chroma[chromaIndex],
                      entropyCodedStream, acDecoder, header.startOfSpectral,
                      header.endOfSpectral, eobRunLength,
                      header.approximationLow);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: refineNonZeroes (<span class="keywd">inout</span> <span class="type">dataBlockType</span>: dataBlock,
    <span class="keywd">inout</span> msbInBitStream: entropyCodedStream, <span class="keywd">inout</span> <span class="type">integer</span>: spectral,
    <span class="op">in</span> <span class="type">integer</span>: endOfSpectral, <span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: numberOfZeros,
    <span class="op">in</span> <span class="type">integer</span>: delta) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: enoughZeros <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: bit <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> spectral &lt;= endOfSpectral <span class="op">and</span> <span class="op">not</span> enoughZeros <span class="keywd">do</span>
      <span class="keywd">if</span> dataBlock[spectral] = 0 <span class="keywd">then</span>
        <span class="keywd">if</span> numberOfZeros = 0 <span class="keywd">then</span>
          enoughZeros := TRUE;
        <span class="keywd">else</span>
          decr(numberOfZeros);
          incr(spectral);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        bit := getBit(entropyCodedStream);
        <span class="keywd">if</span> bit &lt;> 0 <span class="keywd">then</span>
          <span class="keywd">if</span> dataBlock[spectral] >= 0 <span class="keywd">then</span>
            dataBlock[spectral] +:= delta;
          <span class="keywd">else</span>
            dataBlock[spectral] -:= delta;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        incr(spectral);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">##</span>
<span class="comment">#  Refine the AC coefficients of a block.</span>
<span class="comment">#</span>
<span class="keywd">const</span> <span class="type">proc</span>: refineBlockAc (<span class="keywd">inout</span> <span class="type">dataBlockType</span>: dataBlock,
    <span class="keywd">inout</span> msbInBitStream: entropyCodedStream, <span class="op">in</span> msbHuffmanDecoder: acDecoder,
    <span class="op">in</span> <span class="type">integer</span>: startOfSpectral, <span class="op">in</span> <span class="type">integer</span>: endOfSpectral,
    <span class="keywd">inout</span> <span class="type">integer</span>: eobRunLength, <span class="op">in</span> <span class="type">integer</span>: delta) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: spectral <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: coefficient <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bit <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: aByte <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: zeros <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bitWidth <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bits <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    spectral := startOfSpectral;
    <span class="keywd">while</span> spectral &lt;= endOfSpectral <span class="op">and</span> eobRunLength = 0 <span class="keywd">do</span>
      coefficient := 0;
      aByte := getHuffmanSymbol(entropyCodedStream, acDecoder);
      zeros := aByte >> 4;
      bitWidth := aByte <span class="op">mod</span> 16;
      <span class="keywd">if</span> bitWidth = 0 <span class="keywd">then</span>
        <span class="keywd">if</span> zeros &lt;> 15 <span class="keywd">then</span>
          eobRunLength := 1 &lt;&lt; zeros;
          <span class="keywd">if</span> zeros &lt;> 0 <span class="keywd">then</span>
            bits := getBits(entropyCodedStream, zeros);
            eobRunLength +:= bits;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> bitWidth = 1 <span class="keywd">then</span>
        coefficient := delta;
        bit := getBit(entropyCodedStream);
        <span class="keywd">if</span> bit = 0 <span class="keywd">then</span>
          coefficient := -coefficient;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> eobRunLength = 0 <span class="keywd">then</span>
        refineNonZeroes(dataBlock, entropyCodedStream, spectral, endOfSpectral, zeros, delta);
        <span class="keywd">if</span> spectral > endOfSpectral <span class="keywd">then</span>
          raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> coefficient &lt;> 0 <span class="keywd">then</span>
          dataBlock[spectral] := coefficient;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        incr(spectral);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> eobRunLength > 0 <span class="keywd">then</span>
      decr(eobRunLength);
      refineNonZeroes(dataBlock, entropyCodedStream, spectral, endOfSpectral, -1, delta);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: refineLumaAcOfAllBlocks (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile, <span class="op">in</span> <span class="type">jpegHeader</span>: header,
    <span class="op">in</span> msbHuffmanDecoder: acDecoder, <span class="keywd">inout</span> <span class="type">array</span> <span class="type">array</span> <span class="type">jpegMinimumCodedUnit</span>: mcuImage) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: entropyCodedSegment <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> msbInBitStream: entropyCodedStream <span class="keywd">is</span> msbInBitStream.value;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: mcuCount <span class="keywd">is</span> -1;
    <span class="keywd">var</span> <span class="type">integer</span>: eobRunLength <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    entropyCodedSegment := readEntropyCodedSegment(jpegFile);
    entropyCodedStream := openMsbInBitStream(entropyCodedSegment);
    <span class="keywd">if</span> header.restartInterval &lt;> 0 <span class="keywd">then</span>
      mcuCount := header.restartInterval;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">for</span> line <span class="keywd">range</span> 1 <span class="keywd">to</span> header.blockLines <span class="keywd">do</span>
      <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> header.blockColumns <span class="keywd">do</span>
        <span class="keywd">if</span> header.restartInterval &lt;> 0 <span class="keywd">then</span>
          <span class="keywd">if</span> mcuCount = 0 <span class="keywd">then</span>
            entropyCodedSegment := readEntropyCodedSegment(jpegFile);
            entropyCodedStream := openMsbInBitStream(entropyCodedSegment);
            mcuCount := header.restartInterval;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          decr(mcuCount);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        index := succ(2 * (pred(line) <span class="op">mod</span> header.vertical) + pred(column) <span class="op">mod</span> header.horizontal);
        refineBlockAc(mcuImage[succ(pred(line) <span class="op">mdiv</span> header.vertical)]
                              [succ(pred(column) <span class="op">mdiv</span> header.horizontal)].luma[index],
                      entropyCodedStream, acDecoder, header.startOfSpectral,
                      header.endOfSpectral, eobRunLength,
                      1 &lt;&lt; header.approximationLow);
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: refineChromaAcOfAllBlocks (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile, <span class="op">in</span> <span class="type">jpegHeader</span>: header,
    <span class="op">in</span> msbHuffmanDecoder: acDecoder, <span class="keywd">inout</span> <span class="type">array</span> <span class="type">array</span> <span class="type">jpegMinimumCodedUnit</span>: mcuImage,
    <span class="op">in</span> <span class="type">integer</span>: chromaIndex) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: entropyCodedSegment <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> msbInBitStream: entropyCodedStream <span class="keywd">is</span> msbInBitStream.value;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: mcuCount <span class="keywd">is</span> -1;
    <span class="keywd">var</span> <span class="type">integer</span>: eobRunLength <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    entropyCodedSegment := readEntropyCodedSegment(jpegFile);
    entropyCodedStream := openMsbInBitStream(entropyCodedSegment);
    <span class="keywd">if</span> header.restartInterval &lt;> 0 <span class="keywd">then</span>
      mcuCount := header.restartInterval;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">for</span> line <span class="keywd">range</span> 1 <span class="keywd">to</span> header.unitLines <span class="keywd">do</span>
      <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> header.unitColumns <span class="keywd">do</span>
        <span class="keywd">if</span> header.restartInterval &lt;> 0 <span class="keywd">then</span>
          <span class="keywd">if</span> mcuCount = 0 <span class="keywd">then</span>
            entropyCodedSegment := readEntropyCodedSegment(jpegFile);
            entropyCodedStream := openMsbInBitStream(entropyCodedSegment);
            mcuCount := header.restartInterval;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          decr(mcuCount);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        refineBlockAc(mcuImage[line][column].chroma[chromaIndex],
                      entropyCodedStream, acDecoder, header.startOfSpectral,
                      header.endOfSpectral, eobRunLength,
                      1 &lt;&lt; header.approximationLow);
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: loadProgressive (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile, <span class="op">in</span> <span class="type">jpegHeader</span>: header,
    <span class="keywd">inout</span> <span class="type">array</span> <span class="type">array</span> <span class="type">jpegMinimumCodedUnit</span>: mcuImage) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: dcLumaIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: dcCbIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: dcCrIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: acLumaIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: acCbIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: acCrIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> header.numberOfScans <span class="keywd">do</span>
      <span class="keywd">case</span> header.componentType[header.scan[index].componentId] <span class="keywd">of</span>
        <span class="keywd">when</span> {JPEG_COMPTYPE_LUMA}:
          dcLumaIndex := header.scan[index].dcHuffmanTableIndex;
          acLumaIndex := header.scan[index].acHuffmanTableIndex;
        <span class="keywd">when</span> {JPEG_COMPTYPE_CHROMA_BLUE}:
          dcCbIndex  := header.scan[index].dcHuffmanTableIndex;
          acCbIndex  := header.scan[index].acHuffmanTableIndex;
        <span class="keywd">when</span> {JPEG_COMPTYPE_CHROMA_RED}:
          dcCrIndex  := header.scan[index].dcHuffmanTableIndex;
          acCrIndex  := header.scan[index].acHuffmanTableIndex;
        <span class="keywd">otherwise</span>:
          raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> header.startOfSpectral = 1 <span class="op">and</span> header.endOfSpectral = 1 <span class="keywd">then</span>
      <span class="keywd">if</span> header.approximationHigh = 0 <span class="keywd">then</span>
        <span class="keywd">if</span> dcLumaIndex &lt;> 0 <span class="op">and</span> dcCbIndex = 0 <span class="op">and</span> dcCrIndex = 0 <span class="keywd">then</span>
          readLumaDcOfAllBlocks(jpegFile, header, header.dcDecoder[dcLumaIndex],
                                mcuImage);
        <span class="keywd">else</span>
          readDcValuesOfAllBlocks(jpegFile, header, dcLumaIndex,
                                  dcCbIndex, dcCrIndex, mcuImage);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        refineDcValuesOfAllBlocks(jpegFile, header, dcLumaIndex,
                                  dcCbIndex, dcCrIndex, mcuImage);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> header.approximationHigh = 0 <span class="keywd">then</span>
      <span class="keywd">if</span> acLumaIndex &lt;> 0 <span class="keywd">then</span>
        readLumaAcOfAllBlocks(jpegFile, header, header.acDecoder[acLumaIndex],
                              mcuImage);
      <span class="keywd">elsif</span> acCbIndex &lt;> 0 <span class="keywd">then</span>
        readChromaAcOfAllBlocks(jpegFile, header, header.acDecoder[acCbIndex],
                                mcuImage, CHROMA_BLUE);
      <span class="keywd">elsif</span> acCrIndex &lt;> 0 <span class="keywd">then</span>
        readChromaAcOfAllBlocks(jpegFile, header, header.acDecoder[acCrIndex],
                                mcuImage, CHROMA_RED);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      <span class="keywd">if</span> acLumaIndex &lt;> 0 <span class="keywd">then</span>
        refineLumaAcOfAllBlocks(jpegFile, header, header.acDecoder[acLumaIndex],
                                mcuImage);
      <span class="keywd">elsif</span> acCbIndex &lt;> 0 <span class="keywd">then</span>
        refineChromaAcOfAllBlocks(jpegFile, header, header.acDecoder[acCbIndex],
                                  mcuImage, CHROMA_BLUE);
      <span class="keywd">elsif</span> acCrIndex &lt;> 0 <span class="keywd">then</span>
        refineChromaAcOfAllBlocks(jpegFile, header, header.acDecoder[acCrIndex],
                                  mcuImage, CHROMA_RED);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">##</span>
<span class="comment">#  Process a 8x8 block of IDCT coefficients.</span>
<span class="comment">#  This function is used for luma and chroma blocks.</span>
<span class="comment">#  The resulting block contains luma or chroma values of an 8x8</span>
<span class="comment">#  area scaled with factor 8 to the range -1024 .. 1023.</span>
<span class="comment">#  The values are not clamped so they might also be higher or</span>
<span class="comment">#  lower than the limit.</span>
<span class="comment">#</span>
<span class="keywd">const</span> <span class="type">proc</span>: processBlock (<span class="keywd">inout</span> <span class="type">dataBlockType</span>: dataBlock, <span class="op">in</span> <span class="type">dataBlockType</span>: quantizationTable) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> JPEG_BLOCK_SIZE <span class="keywd">do</span>
      dataBlock[index] *:= quantizationTable[index];
    <span class="keywd">end</span> <span class="keywd">for</span>;
    dataBlock := unzigzag(dataBlock);
    idct8x8(dataBlock);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: colorMinimumCodedUnit (<span class="op">in</span> <span class="type">jpegHeader</span>: header,
    <span class="keywd">inout</span> <span class="type">jpegMinimumCodedUnit</span>: minimumCodedUnit,
    <span class="op">in</span> <span class="type">dataBlockType</span>: lumaQuantization, <span class="op">in</span> <span class="type">dataBlockType</span>: chromaBlueQuantization,
    <span class="op">in</span> <span class="type">dataBlockType</span>: chromaRedQuantization, <span class="keywd">inout</span> pixelImage: image,
    <span class="op">in</span> <span class="type">integer</span>: line, <span class="op">in</span> <span class="type">integer</span>: column) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> header.numLuma <span class="keywd">do</span>
      processBlock(minimumCodedUnit.luma[index], lumaQuantization);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    processBlock(minimumCodedUnit.chroma[CHROMA_BLUE], chromaBlueQuantization);
    processBlock(minimumCodedUnit.chroma[CHROMA_RED], chromaRedQuantization);

    <span class="keywd">if</span> header.horizontal = 1 <span class="keywd">then</span>
      <span class="keywd">if</span> header.vertical = 1 <span class="keywd">then</span>
        colorMinimumCodedUnit11(header, minimumCodedUnit.luma[1],
                                minimumCodedUnit.chroma[CHROMA_BLUE],
                                minimumCodedUnit.chroma[CHROMA_RED],
                                image, line, column);
      <span class="keywd">else</span>
        colorMinimumCodedUnit12(header, minimumCodedUnit.luma[1],
                                minimumCodedUnit.luma[2],
                                minimumCodedUnit.chroma[CHROMA_BLUE],
                                minimumCodedUnit.chroma[CHROMA_RED],
                                image, line, column);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      <span class="keywd">if</span> header.vertical = 1 <span class="keywd">then</span>
        colorMinimumCodedUnit21(header, minimumCodedUnit.luma[1],
                                minimumCodedUnit.luma[2],
                                minimumCodedUnit.chroma[CHROMA_BLUE],
                                minimumCodedUnit.chroma[CHROMA_RED],
                                image, line, column);
      <span class="keywd">else</span>
        colorMinimumCodedUnit22(header, minimumCodedUnit.luma[1],
                                minimumCodedUnit.luma[2],
                                minimumCodedUnit.luma[3],
                                minimumCodedUnit.luma[4],
                                minimumCodedUnit.chroma[CHROMA_BLUE],
                                minimumCodedUnit.chroma[CHROMA_RED],
                                image, line, column);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">PRIMITIVE_WINDOW</span>: colorAllMinimumCodedUnits (<span class="op">in</span> <span class="type">jpegHeader</span>: header,
    <span class="keywd">inout</span> <span class="type">array</span> <span class="type">array</span> <span class="type">jpegMinimumCodedUnit</span>: mcuImage, <span class="op">in</span> <span class="type">dataBlockType</span>: lumaQuantization,
    <span class="op">in</span> <span class="type">dataBlockType</span>: chromaBlueQuantization, <span class="op">in</span> <span class="type">dataBlockType</span>: chromaRedQuantization) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: pixmap <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> pixelImage: image <span class="keywd">is</span> pixelImage.value;
  <span class="keywd">begin</span>
    image := pixelImage[.. header.height] <span class="op">times</span>
             pixelArray[.. header.width] <span class="op">times</span> pixel.value;
    <span class="keywd">for</span> line <span class="keywd">range</span> 1 <span class="keywd">to</span> length(mcuImage) <span class="keywd">do</span>
      <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> length(mcuImage[line]) <span class="keywd">do</span>
        colorMinimumCodedUnit(header, mcuImage[line][column],
                              lumaQuantization, chromaBlueQuantization,
                              chromaRedQuantization, image,
                              succ(pred(line) * 8 * header.vertical),
                              succ(pred(column) * 8 * header.horizontal));
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> header.exifData.orientation > EXIF_ORIENTATION_NORMAL <span class="op">and</span>
        header.exifData.orientation &lt; EXIF_ORIENTATION_UNDEFINED <span class="keywd">then</span>
      changeOrientation(image, header.exifData.orientation);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    pixmap := getPixmap(image);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads a JPEG file into a pixmap.
 *  @param jpegFile File that contains a JPEG image.
 *  @return A pixmap with the JPEG image, or
 *          PRIMITIVE_WINDOW.value if the file does
 *          not contain a JPEG magic number.
 *  @exception RANGE_ERROR The file is not in the JPEG file format.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">PRIMITIVE_WINDOW</span>: readJpeg (<span class="keywd">inout</span> <span class="type">file</span>: jpegFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: pixmap <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: magic <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: readMarker <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">char</span>: segmentMarker <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: endOfImage <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">jpegHeader</span>: header <span class="keywd">is</span> jpegHeader.value;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">array</span> <span class="type">jpegMinimumCodedUnit</span>: mcuImage <span class="keywd">is</span> 0 <span class="op">times</span> 0 <span class="op">times</span> jpegMinimumCodedUnit.value;
  <span class="keywd">begin</span>
    magic := gets(jpegFile, length(JPEG_MAGIC));
    <span class="keywd">if</span> magic = JPEG_MAGIC <span class="keywd">then</span>
      <span class="comment"># Start Of Image (SOI)</span>
      <span class="keywd">repeat</span>
        <span class="keywd">if</span> readMarker <span class="keywd">then</span>
          segmentMarker := getc(jpegFile);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        readMarker := TRUE;
        <span class="keywd">case</span> segmentMarker <span class="keywd">of</span>
          <span class="keywd">when</span> {JPEG_SOF0, JPEG_SOF1}:
            readStartOfFrame(jpegFile, header);
          <span class="keywd">when</span> {JPEG_SOF2}:
            readStartOfFrame(jpegFile, header);
            header.progressive := TRUE;
            mcuImage := header.unitLines <span class="op">times</span> header.unitColumns <span class="op">times</span> jpegMinimumCodedUnit.value;
          <span class="keywd">when</span> {JPEG_DHT}:
            readDefineHuffmanTable(jpegFile, header);
          <span class="keywd">when</span> {JPEG_EOI}:
            <span class="comment"># End Of Image</span>
            endOfImage := TRUE;
            readMarker := FALSE;
          <span class="keywd">when</span> {JPEG_SOS}:
            readStartOfScan(jpegFile, header);
            <span class="keywd">if</span> header.progressive <span class="keywd">then</span>
              loadProgressive(jpegFile, header, mcuImage);
            <span class="keywd">else</span>
              setupQuantization(header);
              pixmap := loadSequential(jpegFile, header);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            segmentMarker := jpegFile.bufferChar;
            readMarker := FALSE;
          <span class="keywd">when</span> {JPEG_DQT}:
            readDefineQuantizationTable(jpegFile, header);
          <span class="keywd">when</span> {JPEG_DRI}:
            readDefineRestartInterval(jpegFile, header);
          <span class="keywd">when</span> {JPEG_APP0 .. JPEG_APP15}:
            readApplicationSegment(jpegFile, ord(segmentMarker) - ord(JPEG_APP0), header);
          <span class="keywd">when</span> {JPEG_COM}:
            readComment(jpegFile);
          <span class="keywd">when</span> {JPEG_FILLER}:
            <span class="comment"># Fill byte (16#ff), which is ignored.</span>
            segmentMarker := getc(jpegFile);
            readMarker := FALSE;
          <span class="keywd">when</span> {JPEG_RST0 .. JPEG_RST7}:
            <span class="comment"># Ignore superfluous restart marker after the last ECS segment.</span>
            noop;
          <span class="keywd">otherwise</span>:
            raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">case</span>;
        <span class="keywd">if</span> readMarker <span class="op">and</span> getc(jpegFile) &lt;> JPEG_MARKER_START <span class="keywd">then</span>
          raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> endOfImage;
      <span class="keywd">if</span> header.progressive <span class="keywd">then</span>
        setupQuantization(header);
        pixmap := colorAllMinimumCodedUnits(header, mcuImage,
                                            header.lumaQuantization,
                                            header.chromaBlueQuantization,
                                            header.chromaRedQuantization);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads a JPEG file with the given ''jpegFileName'' into a pixmap.
 *  @param jpegFileName Name of the JPEG file.
 *  @return A pixmap with the JPEG image, or
 *          PRIMITIVE_WINDOW.value if the file cannot be opened or
 *          does not contain a JPEG magic number.
 *  @exception RANGE_ERROR The file is not in the JPEG file format.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">PRIMITIVE_WINDOW</span>: readJpeg (<span class="op">in</span> <span class="type">string</span>: jpegFileName) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: pixmap <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">file</span>: jpegFile <span class="keywd">is</span> STD_NULL;
  <span class="keywd">begin</span>
    jpegFile := open(jpegFileName, <span class="stri">"r"</span>);
    <span class="keywd">if</span> jpegFile &lt;> STD_NULL <span class="keywd">then</span>
      pixmap := readJpeg(jpegFile);
      close(jpegFile);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
