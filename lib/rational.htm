<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  rational.s7i  Rational number support library                   *)</span>
<span class="comment">(*  Copyright (C) 1991 - 1994, 2005, 2007 - 2009  Thomas Mertes     *)</span>
<span class="comment">(*                2011, 2013 - 2015, 2018, 2023  Thomas Mertes      *)</span>
<span class="comment">(*                2024  Thomas Mertes                               *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="comment">(**
 *  Rational numbers represented with 'integer' numerator and denominator.
 *  The values of the type ''rational'' are finite and periodical
 *  decimal numbers. Rational literals do not exist. The result of a
 *  ''rational'' operation is undefined if it overflows.
 *)</span>
<span class="keywd">const</span> <span class="type">type</span>: rational <span class="keywd">is</span> <span class="keywd">new</span> object <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: numerator <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: denominator <span class="keywd">is</span> 1;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: normalize (<span class="keywd">inout</span> <span class="type">rational</span>: number) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> number.denominator &lt; 0 <span class="keywd">then</span>
      number.numerator := -number.numerator;
      number.denominator := -number.denominator;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: reduce (<span class="keywd">inout</span> <span class="type">rational</span>: number) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: a <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: b <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: help <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    a := abs(number.numerator);
    b := number.denominator;
    <span class="keywd">while</span> a &lt;> 0 <span class="keywd">do</span>
      help := b <span class="op">rem</span> a;
      b := a;
      a := help;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> b >= 2 <span class="keywd">then</span>
      number.numerator := number.numerator <span class="op">div</span> b;
      number.denominator := number.denominator <span class="op">div</span> b;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: gcd1 (<span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: a, <span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: b) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: gcd <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: help <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> a &lt;> 0 <span class="keywd">do</span>
      help := b <span class="op">rem</span> a;
      b := a;
      a := help;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    gcd := b;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: gcd2 (<span class="op">in</span> <span class="type">integer</span>: numerator, <span class="op">in</span> <span class="type">integer</span>: denominator) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: b <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: a <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: help <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> numerator >= 0 <span class="keywd">then</span>
      a := numerator;
    <span class="keywd">else</span>
      a := -numerator;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    b := denominator;
    <span class="keywd">while</span> a &lt;> 0 <span class="keywd">do</span>
      help := b <span class="op">rem</span> a;
      b := a;
      a := help;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Create a ''rational'' number from its numerator and denominator.
 *  @return the created ''rational'' value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">rational</span>: (<span class="op">in</span> <span class="type">integer</span>: numerator) / (<span class="op">in</span> <span class="type">integer</span>: denominator) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">rational</span>: aRational <span class="keywd">is</span> rational.value;
  <span class="keywd">begin</span>
    aRational.numerator := numerator;
    aRational.denominator := denominator;
    normalize(aRational);
    reduce(aRational);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Plus sign for ''rational'' numbers.
 *  @return its operand unchanged.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">rational</span>: + (<span class="op">in</span> <span class="type">rational</span>: number) <span class="keywd">is</span>
  <span class="keywd">return</span> number;


<span class="comment">(**
 *  Minus sign, negate a ''rational'' number.
 *  @return the negated value of the number.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">rational</span>: - (<span class="op">in</span> <span class="type">rational</span>: number) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">rational</span>: negatedNumber <span class="keywd">is</span> rational.value;
  <span class="keywd">begin</span>
    negatedNumber.numerator := -number.numerator;
    negatedNumber.denominator := number.denominator;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Add two ''rational'' numbers.
 *  @return the sum of the two numbers.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">rational</span>: (<span class="op">in</span> <span class="type">rational</span>: summand1) + (<span class="op">in</span> <span class="type">rational</span>: summand2) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">rational</span>: sum <span class="keywd">is</span> rational.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: gcd_denominator <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    gcd_denominator := gcd1(summand1.denominator, summand2.denominator);
    sum.numerator := (summand1.numerator * summand2.denominator +
        summand2.numerator * summand1.denominator) <span class="op">div</span> gcd_denominator;
    sum.denominator := summand1.denominator <span class="op">div</span> gcd_denominator * summand2.denominator;
    reduce(sum);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Compute the subtraction of two ''rational'' numbers.
 *  @return the difference of the two numbers.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">rational</span>: (<span class="op">in</span> <span class="type">rational</span>: minuend) - (<span class="op">in</span> <span class="type">rational</span>: subtrahend) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">rational</span>: difference <span class="keywd">is</span> rational.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: gcd_denominator <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    gcd_denominator := gcd1(minuend.denominator, subtrahend.denominator);
    difference.numerator := (minuend.numerator * subtrahend.denominator -
        subtrahend.numerator * minuend.denominator) <span class="op">div</span> gcd_denominator;
    difference.denominator := minuend.denominator <span class="op">div</span> gcd_denominator * subtrahend.denominator;
    reduce(difference);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Multiply two ''rational'' numbers.
 *  @return the product of the two numbers.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">rational</span>: (<span class="op">in</span> <span class="type">rational</span>: factor1) * (<span class="op">in</span> <span class="type">rational</span>: factor2) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">rational</span>: product <span class="keywd">is</span> rational.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: gcd1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: gcd2 <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    gcd1 := gcd2(factor1.numerator, factor2.denominator);
    gcd2 := gcd2(factor2.numerator, factor1.denominator);
    product.numerator := (factor1.numerator <span class="op">div</span> gcd1) * (factor2.numerator <span class="op">div</span> gcd2);
    product.denominator := (factor1.denominator <span class="op">div</span> gcd2) * (factor2.denominator <span class="op">div</span> gcd1);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Compute the division of two ''rational'' numbers.
 *  @return the quotient of the division.
 *  @exception NUMERIC_ERROR If a division by zero occurs.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">rational</span>: (<span class="op">in</span> <span class="type">rational</span>: dividend) / (<span class="op">in</span> <span class="type">rational</span>: divisor) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">rational</span>: quotient <span class="keywd">is</span> rational.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: gcd1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: gcd2 <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    gcd1 := gcd2(dividend.numerator, divisor.numerator);
    gcd2 := gcd2(divisor.denominator, dividend.denominator);
    quotient.numerator := (dividend.numerator <span class="op">div</span> gcd1) * (divisor.denominator <span class="op">div</span> gcd2);
    quotient.denominator := (dividend.denominator <span class="op">div</span> gcd2) * (divisor.numerator <span class="op">div</span> gcd1);
    normalize(quotient);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Increment a ''rational'' number by a delta.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">rational</span>: number) +:= (<span class="op">in</span> <span class="type">rational</span>: delta) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: gcd_denominator <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    gcd_denominator := gcd1(number.denominator, delta.denominator);
    number.numerator := (number.numerator * delta.denominator +
        delta.numerator * number.denominator) <span class="op">div</span> gcd_denominator;
    number.denominator *:= delta.denominator <span class="op">div</span> gcd_denominator;
    reduce(number);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Decrement a ''rational'' number by a delta.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">rational</span>: number) -:= (<span class="op">in</span> <span class="type">rational</span>: delta) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: gcd_denominator <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    gcd_denominator := gcd1(number.denominator, delta.denominator);
    number.numerator := (number.numerator * delta.denominator -
        delta.numerator * number.denominator) <span class="op">div</span> gcd_denominator;
    number.denominator *:= delta.denominator <span class="op">div</span> gcd_denominator;
    reduce(number);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Multiply a ''rational'' number by a factor and assign the result back to number.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">rational</span>: number) *:= (<span class="op">in</span> <span class="type">rational</span>: factor) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    number.numerator *:= factor.numerator;
    number.denominator *:= factor.denominator;
    reduce(number);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Divide a ''rational'' number by a divisor and assign the result back to number.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: (<span class="keywd">inout</span> <span class="type">rational</span>: number) /:= (<span class="op">in</span> <span class="type">rational</span>: divisor) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    number.numerator *:= divisor.denominator;
    number.denominator *:= divisor.numerator;
    normalize(number);
    reduce(number);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Compute the exponentiation of a ''rational'' base with an integer exponent.
 *  @return the result of the exponentiation.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">rational</span>: (<span class="op">in</span> <span class="type">rational</span>: base) ** (<span class="op">in</span> <span class="type">integer</span>: exponent) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">rational</span>: power <span class="keywd">is</span> rational.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> exponent >= 0 <span class="keywd">then</span>
      power.numerator := base.numerator ** exponent;
      power.denominator := base.denominator ** exponent;
    <span class="keywd">else</span>
      power.numerator := base.denominator ** (-exponent);
      power.denominator := base.numerator ** (-exponent);
      normalize(power);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Check if two ''rational'' numbers are equal.
 *  @return TRUE if both numbers are equal,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">rational</span>: number1) = (<span class="op">in</span> <span class="type">rational</span>: number2) <span class="keywd">is</span>
  <span class="keywd">return</span> number1.numerator   = number2.numerator <span class="op">and</span>
         number1.denominator = number2.denominator;


<span class="comment">(**
 *  Check if two ''rational'' numbers are not equal.
 *  @return FALSE if both numbers are equal,
 *          TRUE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">rational</span>: number1) &lt;> (<span class="op">in</span> <span class="type">rational</span>: number2) <span class="keywd">is</span>
  <span class="keywd">return</span> number1.numerator   &lt;> number2.numerator <span class="op">or</span>
         number1.denominator &lt;> number2.denominator;


<span class="comment">(**
 *  Check if number1 is less than number2.
 *  @return TRUE if number1 is less than number2,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">rational</span>: number1) &lt; (<span class="op">in</span> <span class="type">rational</span>: number2) <span class="keywd">is</span>
  <span class="keywd">return</span> number1.numerator * number2.denominator &lt;
         number2.numerator * number1.denominator;


<span class="comment">(**
 *  Check if number1 is greater than number2.
 *  @return TRUE if number1 is greater than number2,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">rational</span>: number1) > (<span class="op">in</span> <span class="type">rational</span>: number2) <span class="keywd">is</span>
  <span class="keywd">return</span> number1.numerator * number2.denominator >
         number2.numerator * number1.denominator;


<span class="comment">(**
 *  Check if number1 is less than or equal to number2.
 *  @return TRUE if number1 is less than or equal to number2,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">rational</span>: number1) &lt;= (<span class="op">in</span> <span class="type">rational</span>: number2) <span class="keywd">is</span>
  <span class="keywd">return</span> number1.numerator * number2.denominator &lt;=
         number2.numerator * number1.denominator;


<span class="comment">(**
 *  Check if number1 is greater than or equal to number2.
 *  @return TRUE if number1 is greater than or equal to number2,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">rational</span>: number1) >= (<span class="op">in</span> <span class="type">rational</span>: number2) <span class="keywd">is</span>
  <span class="keywd">return</span> number1.numerator * number2.denominator >=
         number2.numerator * number1.denominator;


<span class="comment">(**
 *  Compare two ''rational'' numbers.
 *  @return -1, 0 or 1 if the first argument is considered to be
 *          respectively less than, equal to, or greater than the
 *          second.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: compare (<span class="op">in</span> <span class="type">rational</span>: number1, <span class="op">in</span> <span class="type">rational</span>: number2) <span class="keywd">is</span>
  <span class="keywd">return</span> compare(number1.numerator * number2.denominator,
                 number2.numerator * number1.denominator);


<span class="comment">(**
 *  Compute the hash value of a ''rational'' number.
 *  @return the hash value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: hashCode (<span class="op">in</span> <span class="type">rational</span>: number) <span class="keywd">is</span>
  <span class="keywd">return</span> number.numerator <span class="op">mod</span> 16#40000000 + number.denominator <span class="op">mod</span> 16#40000000;


<span class="comment">(**
 *  Return the conversion of an integer to a ''rational''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">rational</span>: rat (<span class="op">in</span> <span class="type">integer</span>: number) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">rational</span>: aRational <span class="keywd">is</span> rational.value;
  <span class="keywd">begin</span>
    aRational.numerator := number;
    aRational.denominator := 1;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Return the conversion of an integer to a ''rational''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">rational</span>: rational (<span class="op">in</span> <span class="type">integer</span>: number) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">rational</span>: aRational <span class="keywd">is</span> rational.value;
  <span class="keywd">begin</span>
    aRational.numerator := number;
    aRational.denominator := 1;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Return the conversion of an integer to a ''rational''.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">rational</span>: (attr rational) <span class="op">conv</span> (<span class="op">in</span> <span class="type">integer</span>: number) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">rational</span>: aRational <span class="keywd">is</span> rational.value;
  <span class="keywd">begin</span>
    aRational.numerator := number;
    aRational.denominator := 1;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Compute the absolute value of a ''rational'' number.
 *  @return the absolute value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">rational</span>: abs (<span class="op">in</span> <span class="type">rational</span>: number) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">rational</span>: absoluteValue <span class="keywd">is</span> rational.value;
  <span class="keywd">begin</span>
    absoluteValue.numerator := abs(number.numerator);
    absoluteValue.denominator := number.denominator;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Return a rational number truncated towards negative infinity.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: floor (<span class="op">in</span> <span class="type">rational</span>: number) <span class="keywd">is</span>
  <span class="keywd">return</span> number.numerator <span class="op">mdiv</span> number.denominator;


<span class="comment">(**
 *  Return a rational number rounded up towards positive infinity.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: ceil (<span class="op">in</span> <span class="type">rational</span>: number) <span class="keywd">is</span>
  <span class="keywd">return</span> -(number.numerator <span class="op">mdiv</span> -number.denominator);


<span class="comment">(**
 *  Return a rational number truncated towards zero.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: trunc (<span class="op">in</span> <span class="type">rational</span>: number) <span class="keywd">is</span>
  <span class="keywd">return</span> number.numerator <span class="op">div</span> number.denominator;


<span class="comment">(**
 *  Round a ''rational'' number to the nearest [[integer]].
 *  Halfway cases are rounded away from zero.
 *  @return the rounded value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: round (<span class="op">in</span> <span class="type">rational</span>: number) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: int_val <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> number.numerator >= 0 <span class="keywd">then</span>
      int_val := (2 * number.numerator + number.denominator) <span class="op">div</span> (2 * number.denominator);
    <span class="keywd">else</span>
      int_val := (2 * number.numerator - number.denominator) <span class="op">div</span> (2 * number.denominator);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Round a ''rational'' number with a decimal ''precision''.
 *  Halfway cases are rounded away from zero.
 *  @return the rounded value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">rational</span>: round10 (<span class="op">in</span> <span class="type">rational</span>: number, <span class="op">in</span> <span class="type">integer</span>: precision) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">rational</span>: rounded <span class="keywd">is</span> rational.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> precision &lt; 0 <span class="keywd">then</span>
      rounded.numerator := (abs(number.numerator) <span class="op">div</span> 10 ** pred(-precision) +
                           number.denominator * 5) <span class="op">div</span> (number.denominator * 10) *
                           10 ** (-precision);
      rounded.denominator := 1;
    <span class="keywd">else</span>
      rounded.numerator := (abs(number.numerator) * 10 ** succ(precision) +
                           number.denominator * 5) <span class="op">div</span> (number.denominator * 10);
      rounded.denominator := 10 ** precision;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> number.numerator &lt; 0 <span class="keywd">then</span>
      rounded.numerator := -rounded.numerator;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: INT_REMAINDER_HASH_TYPE <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">integer</span><span class="type">]</span> <span class="type">integer</span>;


<span class="comment">(**
 *  Convert a ''rational'' number to a [[string]].
 *  The number is converted to a string with a decimal representation
 *  (e.g.: "1.25"). The representation has a decimal point and at
 *  least one digit before and after the decimal point. Negative
 *  numbers are preceded by a minus sign (e.g.: "-1.25"). The
 *  decimal number can have repeating decimals, which are enclosed
 *  in parentheses ("e.g.: "0.(3)"). The repeating decimals will
 *  not start before the decimal point.
 *  @return the string result of the conversion.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">rational</span>: number) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: remainder <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">INT_REMAINDER_HASH_TYPE</span>: remainderHash <span class="keywd">is</span> INT_REMAINDER_HASH_TYPE.value;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> number.denominator = 0 <span class="keywd">then</span>
      <span class="keywd">if</span> number.numerator > 0 <span class="keywd">then</span>
        stri := <span class="stri">"Infinity"</span>;
      <span class="keywd">elsif</span> number.numerator = 0 <span class="keywd">then</span>
        stri := <span class="stri">"NaN"</span>;
      <span class="keywd">else</span>
        stri := <span class="stri">"-Infinity"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      stri := str(abs(number.numerator) <span class="op">div</span> number.denominator);
      stri &amp;:= <span class="stri">"."</span>;
      remainder := abs(number.numerator) <span class="op">rem</span> number.denominator;
      <span class="keywd">if</span> remainder = 0 <span class="keywd">then</span>
        stri &amp;:= <span class="stri">"0"</span>;
      <span class="keywd">else</span>
        <span class="keywd">repeat</span>
          remainderHash @:= [remainder] length(stri);
          remainder *:= 10;
          stri &amp;:= str(remainder <span class="op">div</span> number.denominator);
          remainder := remainder <span class="op">rem</span> number.denominator;
        <span class="keywd">until</span> remainder = 0 <span class="op">or</span> remainder <span class="op">in</span> remainderHash;
        <span class="keywd">if</span> remainder &lt;> 0 <span class="keywd">then</span>
          pos := remainderHash[remainder];
          stri := stri[.. pos] &amp; <span class="stri">"("</span> &amp; stri[succ(pos) ..] &amp; <span class="stri">")"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> number.numerator &lt; 0 <span class="keywd">then</span>
        stri := <span class="stri">"-"</span> &amp; stri;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Convert a ''rational'' to a [[string]] with a fraction.
 *   fraction(rational("0.(3)"))  returns  "1/3"
 *  @return the string with the corrresponding fraction.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: fraction (<span class="op">in</span> <span class="type">rational</span>: number) <span class="keywd">is</span>
    <span class="keywd">return</span> str(number.numerator) &amp; <span class="stri">"/"</span> &amp; str(number.denominator);


<span class="comment">(**
 *  Convert a ''rational'' number to a [[string]] in decimal fixed point notation.
 *  The number is rounded to the specified number of digits (''precision'').
 *  Halfway cases are rounded away from zero. Except for a ''precision'' of
 *  zero the representation has a decimal point and at least one digit
 *  before and after the decimal point. Negative numbers are preceded by
 *  a minus sign (e.g.: "-1.25"). If all digits in the result are 0 a
 *  possible negative sign is omitted.
 *   1/64 digits 7     returns "0.0156250"
 *   1/64 digits 4     returns "0.0156"
 *   1/64 digits 2     returns "0.02"
 *   355/113 digits 6  returns "3.141593"
 *   22/7 digits 0     returns "3"
 *   -1/2 digits 1     returns "-1"
 *   1/0 digits 5      returns "Infinity"
 *   -1/0 digits 6     returns "-Infinity"
 *   0/0 digits 7      returns "NaN"
 *   -1/2048 digits 3  returns "0.000"
 *  @param precision Number of digits after the decimal point.
 *         If the ''precision'' is zero the decimal point is omitted.
 *  @return the string result of the conversion.
 *  @exception RANGE_ERROR If the ''precision'' is negative.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">rational</span>: number) <span class="op">digits</span> (<span class="op">in</span> <span class="type">integer</span>: precision) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: mantissa <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> precision &lt; 0 <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> number.denominator = 0 <span class="keywd">then</span>
      <span class="keywd">if</span> number.numerator > 0 <span class="keywd">then</span>
        stri := <span class="stri">"Infinity"</span>;
      <span class="keywd">elsif</span> number.numerator = 0 <span class="keywd">then</span>
        stri := <span class="stri">"NaN"</span>;
      <span class="keywd">else</span>
        stri := <span class="stri">"-Infinity"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      mantissa := (abs(number.numerator) * 10 ** succ(precision) +
                  number.denominator * 5) <span class="op">div</span> (number.denominator * 10);
      stri := str(mantissa);
      <span class="keywd">if</span> precision >= length(stri) <span class="keywd">then</span>
        stri := <span class="stri">"0"</span> <span class="op">mult</span> (precision - length(stri) + 1) &amp; stri;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> precision &lt;> 0 <span class="keywd">then</span>
        stri := stri[ .. length(stri) - precision] &amp; <span class="stri">"."</span> &amp;
            stri[length(stri) - precision + 1 .. ];
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> number.numerator &lt; 0 <span class="op">and</span> mantissa &lt;> 0 <span class="keywd">then</span>
        stri := <span class="stri">"-"</span> &amp; stri;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: decimalExponent (<span class="op">in</span> <span class="type">rational</span>: number) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: exponent <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> abs(number.numerator) >= number.denominator <span class="keywd">then</span>
      exponent := log10(abs(number.numerator) <span class="op">div</span> number.denominator);
    <span class="keywd">else</span>
      exponent := -log10(number.denominator <span class="op">div</span> abs(number.numerator)) - 1;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Convert a ''rational'' number to a [[string]] in scientific notation.
 *  Scientific notation uses a decimal significand and a decimal exponent.
 *  The significand has an optional sign and exactly one digit before the
 *  decimal point. The fractional part of the significand is rounded
 *  to the specified number of digits (''precision''). Halfway cases are
 *  rounded away from zero. The fractional part is followed by the
 *  letter e and an exponent, which is always signed. The value zero is
 *  never written with a negative sign.
 *   1/64 sci 4     returns "1.5625e-2"
 *   1/64 sci 3     returns "1.563e-2"
 *   1/64 sci 2     returns "1.56e-2"
 *   355/113 sci 6  returns "3.141593e+0"
 *   22/7 sci 0     returns "3e+0"
 *   -1/2 sci 1     returns "-5.0e-1"
 *   1/0 sci 5      returns "Infinity"
 *   -1/0 sci 6     returns "-Infinity"
 *   0/0 sci 7      returns "NaN"
 *   -1/2048 sci 3  returns "-4.883e-4"
 *   -0/1 sci 2     returns "0.00e+0"
 *  @param precision Number of digits after the decimal point.
 *         If the ''precision'' is zero the decimal point is omitted.
 *  @return the string result of the conversion.
 *  @exception RANGE_ERROR If the ''precision'' is negative.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: (<span class="op">in</span> <span class="type">rational</span>: number) <span class="op">sci</span> (<span class="op">in</span> <span class="type">integer</span>: precision) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: exponent <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: mantissa <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> precision &lt; 0 <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">elsif</span> number.denominator = 0 <span class="keywd">then</span>
      <span class="keywd">if</span> number.numerator > 0 <span class="keywd">then</span>
        stri := <span class="stri">"Infinity"</span>;
      <span class="keywd">elsif</span> number.numerator = 0 <span class="keywd">then</span>
        stri := <span class="stri">"NaN"</span>;
      <span class="keywd">else</span>
        stri := <span class="stri">"-Infinity"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> number.numerator = 0 <span class="keywd">then</span>
      <span class="keywd">if</span> precision = 0 <span class="keywd">then</span>
        stri := <span class="stri">"0e+0"</span>;
      <span class="keywd">else</span>
        stri := <span class="stri">"0."</span> &amp; <span class="stri">"0"</span> <span class="op">mult</span> precision &amp; <span class="stri">"e+0"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      exponent := decimalExponent(number);
      <span class="keywd">if</span> succ(precision) >= exponent <span class="keywd">then</span>
        mantissa := (abs(number.numerator) * 10 ** succ(precision - exponent) +
                    number.denominator * 5) <span class="op">div</span> (number.denominator * 10);
      <span class="keywd">else</span>
        mantissa := (abs(number.numerator) <span class="op">div</span> 10 ** pred(exponent - precision) +
                    number.denominator * 5) <span class="op">div</span> (number.denominator * 10);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      stri := str(mantissa);
      <span class="keywd">if</span> length(stri) > succ(precision) <span class="keywd">then</span>
        <span class="comment"># Rounding up increased the number of digits.</span>
        incr(exponent);
        stri := stri[.. succ(precision)];
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> precision &lt;> 0 <span class="keywd">then</span>
        stri := stri[1 fixLen 1] &amp; <span class="stri">"."</span> &amp; stri[2 .. ];
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> exponent >= 0 <span class="keywd">then</span>
        stri &amp;:= <span class="stri">"e+"</span> &lt;&amp; exponent;
      <span class="keywd">else</span>
        stri &amp;:= <span class="stri">"e"</span> &lt;&amp; exponent;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> number.numerator &lt; 0 <span class="keywd">then</span>
        stri := <span class="stri">"-"</span> &amp; stri;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Convert a [[string]] to a ''rational'' number.
 *  The [[string]] must contain a fraction (e.g.: "3/5") or a decimal number
 *  (e.g.: "1.25"). In a fraction numerator and denominator are separated
 *  with a slash (/). A decimal number can have repeating decimals,
 *  which are enclosed in parentheses ("e.g.: "0.(3)"). The repeating
 *  decimals are not allowed to start before the decimal point.
 *   rational("3/5")         returns   3 /   5
 *   rational("1.25")        returns   5 /   4
 *   rational("0.(3)")       returns   1 /   3
 *   rational("1.23(45)")    returns 679 / 550
 *   rational("3.(142857)")  returns  22 /   7
 *   rational("0.(846153)")  returns  11 /  13
 *  @return the ''rational'' result of the conversion.
 *  @exception RANGE_ERROR If stri contains not a valid ''rational'' value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">rational</span>: rational (<span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">rational</span>: aRational <span class="keywd">is</span> rational.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: negative <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">string</span>: fraction <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: period <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      <span class="keywd">if</span> stri[1] = <span class="stri">'-'</span> <span class="keywd">then</span>
        stri := stri[2 ..];
        negative := TRUE;
      <span class="keywd">elsif</span> stri[1] = <span class="stri">'+'</span> <span class="keywd">then</span>
        stri := stri[2 ..];
      <span class="keywd">end</span> <span class="keywd">if</span>;
      aRational.numerator := integer(getint(stri));
      <span class="keywd">if</span> stri[1] = <span class="stri">'/'</span> <span class="keywd">then</span>
        stri := stri[2 ..];
        aRational.denominator := integer(getint(stri));
        reduce(aRational);
      <span class="keywd">elsif</span> stri[1] = <span class="stri">'.'</span> <span class="keywd">then</span>
        stri := stri[2 ..];
        <span class="keywd">if</span> startsWith(stri, <span class="stri">"("</span>) <span class="keywd">then</span>
          stri := stri[2 ..];
          period := getint(stri);
          aRational.denominator := 1;
          aRational +:= integer(period) / pred(10 ** length(period));
          <span class="keywd">if</span> stri[1] = <span class="stri">')'</span> <span class="keywd">then</span>
            stri := stri[2 ..];
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          fraction := getint(stri);
          aRational.denominator := 10 ** length(fraction);
          aRational.numerator *:= aRational.denominator;
          aRational.numerator +:= integer(fraction);
          <span class="keywd">if</span> startsWith(stri, <span class="stri">"("</span>) <span class="keywd">then</span>
            stri := stri[2 ..];
            period := getint(stri);
            aRational +:= integer(period) / (pred(10 ** length(period)) * aRational.denominator);
            <span class="keywd">if</span> stri[1] = <span class="stri">')'</span> <span class="keywd">then</span>
              stri := stri[2 ..];
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        reduce(aRational);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        raise RANGE_ERROR;
      <span class="keywd">elsif</span> negative <span class="keywd">then</span>
        aRational.numerator := -aRational.numerator;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Convert a [[string]] to a ''rational'' number.
 *  The [[string]] must contain a fraction (e.g.: "3/5") or a decimal number
 *  (e.g.: "1.25"). In a fraction numerator and denominator are separated
 *  with a slash (/). A decimal number can have repeating decimals,
 *  which are enclosed in parentheses ("e.g.: "0.(3)"). The repeating
 *  decimals are not allowed to start before the decimal point.
 *   rational parse "3/5"         returns   3 /   5
 *   rational parse "1.25"        returns   5 /   4
 *   rational parse "0.(3)"       returns   1 /   3
 *   rational parse "1.23(45)"    returns 679 / 550
 *   rational parse "3.(142857)"  returns  22 /   7
 *   rational parse "0.(846153)"  returns  11 /  13
 *  @return the ''rational'' result of the conversion.
 *  @exception RANGE_ERROR If stri contains not a valid ''rational'' value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">rational</span>: (attr rational) <span class="op">parse</span> (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span>
    <span class="keywd">return</span> rational(stri);


enable_io(rational);
DECLARE_TERNARY(rational);
DECLARE_MIN_MAX(rational);


<span class="comment"># Allows 'array rational' everywhere without extra type definition.</span>
<span class="keywd">const</span> <span class="type">type</span>: _rationalArray <span class="keywd">is</span> <span class="type">array</span> <span class="type">rational</span>;
</pre>
</body>
</html>
