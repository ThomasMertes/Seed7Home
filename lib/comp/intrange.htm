<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../../style1.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  intrange.s7i  Handle ranges of possible values for expressions. *)</span>
<span class="comment">(*  Copyright (C) 2020, 2021, 2022  Thomas Mertes                   *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 compiler.                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">const</span> <span class="type">type</span>: intRange <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: minValue <span class="keywd">is</span> integer.first;
    <span class="keywd">var</span> <span class="type">integer</span>: maxValue <span class="keywd">is</span> integer.last;
    <span class="keywd">var</span> <span class="type">boolean</span>: mayOverflow <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: mayRaiseException <span class="keywd">is</span> TRUE;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="keywd">ref</span> <span class="type">intRange</span>: range1) = (<span class="keywd">ref</span> <span class="type">intRange</span>: range2) <span class="keywd">is</span>
  <span class="keywd">return</span> range1.minValue = range2.minValue <span class="op">and</span> range1.maxValue = range2.maxValue;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="keywd">ref</span> <span class="type">intRange</span>: range1) &lt;> (<span class="keywd">ref</span> <span class="type">intRange</span>: range2) <span class="keywd">is</span>
  <span class="keywd">return</span> range1.minValue &lt;> range2.minValue <span class="op">or</span> range1.maxValue &lt;> range2.maxValue;


<span class="keywd">const</span> <span class="type">type</span>: intRangeOfVariableHash <span class="keywd">is</span> <span class="type">hash</span><span class="type">[</span><span class="type">reference</span><span class="type">]</span> <span class="type">intRange</span>;

<span class="keywd">var</span> <span class="type">intRangeOfVariableHash</span>: intRangeOfVariable <span class="keywd">is</span> intRangeOfVariableHash.value;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getIntRange (<span class="op">in</span> <span class="type">reference</span>: intExpression) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getIntAbsRange (<span class="op">in</span> <span class="type">intRange</span>: argument1Range) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: absRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> argument1Range.minValue > argument1Range.maxValue <span class="keywd">then</span>
      absRange.minValue := 0;
      absRange.maxValue := -1;
    <span class="keywd">else</span>
      <span class="keywd">if</span> argument1Range.minValue = integer.first <span class="keywd">then</span>
        <span class="keywd">if</span> argument1Range.maxValue = integer.first <span class="keywd">then</span>
          <span class="comment"># Will always raise RANGE_ERROR.</span>
          absRange.minValue := 0;
          absRange.maxValue := -1;
          absRange.mayOverflow := TRUE;
        <span class="keywd">else</span>
          <span class="keywd">if</span> argument1Range.maxValue >= 0 <span class="keywd">then</span>
            absRange.minValue := 0;
          <span class="keywd">else</span>
            absRange.minValue := -argument1Range.maxValue;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          absRange.mayOverflow := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        <span class="keywd">if</span> argument1Range.minValue &lt;= 0 <span class="op">and</span> argument1Range.maxValue >= 0 <span class="keywd">then</span>
          absRange.minValue := 0;
        <span class="keywd">else</span>
          absRange.minValue := min(abs(argument1Range.minValue),
                                   abs(argument1Range.maxValue));
        <span class="keywd">end</span> <span class="keywd">if</span>;
        absRange.maxValue := max(abs(argument1Range.minValue),
                               abs(argument1Range.maxValue));
      <span class="keywd">end</span> <span class="keywd">if</span>;
      absRange.mayRaiseException := argument1Range.mayRaiseException <span class="op">or</span>
                                    absRange.mayOverflow;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getIntAddRange (<span class="op">in</span> <span class="type">intRange</span>: summand1Range, <span class="op">in</span> <span class="type">intRange</span>: summand2Range) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: sumRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: valueOutOfRange <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> summand1Range.minValue > summand1Range.maxValue <span class="op">or</span>
        summand2Range.minValue > summand2Range.maxValue <span class="keywd">then</span>
      sumRange.minValue := 0;
      sumRange.maxValue := -1;
    <span class="keywd">else</span>
      <span class="keywd">if</span> summand1Range.minValue &lt; 0 <span class="keywd">then</span>
        <span class="keywd">if</span> summand2Range.minValue >= 0 <span class="op">or</span>
            summand1Range.minValue >= integer.first - summand2Range.minValue <span class="keywd">then</span>
          sumRange.minValue := summand1Range.minValue + summand2Range.minValue;
        <span class="keywd">else</span>
          sumRange.mayOverflow := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        <span class="keywd">if</span> summand2Range.minValue &lt;= 0 <span class="op">or</span>
            summand1Range.minValue &lt;= integer.last - summand2Range.minValue <span class="keywd">then</span>
          sumRange.minValue := summand1Range.minValue + summand2Range.minValue;
        <span class="keywd">else</span>
          valueOutOfRange := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> summand1Range.maxValue > 0 <span class="keywd">then</span>
        <span class="keywd">if</span> summand2Range.maxValue &lt;= 0 <span class="op">or</span>
            summand1Range.maxValue &lt;= integer.last - summand2Range.maxValue <span class="keywd">then</span>
          sumRange.maxValue := summand1Range.maxValue + summand2Range.maxValue;
        <span class="keywd">else</span>
          sumRange.mayOverflow := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        <span class="keywd">if</span> summand2Range.maxValue >= 0 <span class="op">or</span>
            summand1Range.maxValue >= integer.first - summand2Range.maxValue <span class="keywd">then</span>
          sumRange.maxValue := summand1Range.maxValue + summand2Range.maxValue;
        <span class="keywd">else</span>
          valueOutOfRange := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> sumRange.minValue > sumRange.maxValue <span class="op">or</span> valueOutOfRange <span class="keywd">then</span>
        sumRange.minValue := 0;
        sumRange.maxValue := -1;
        sumRange.mayOverflow := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      sumRange.mayRaiseException := summand1Range.mayRaiseException <span class="op">or</span>
                                    summand2Range.mayRaiseException <span class="op">or</span>
                                    sumRange.mayOverflow;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getIntSbtrRange (<span class="op">in</span> <span class="type">intRange</span>: minuendRange, <span class="op">in</span> <span class="type">intRange</span>: subtrahendRange) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: differenceRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: valueOutOfRange <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> minuendRange.minValue > minuendRange.maxValue <span class="op">or</span>
        subtrahendRange.minValue > subtrahendRange.maxValue <span class="keywd">then</span>
      differenceRange.minValue := 0;
      differenceRange.maxValue := -1;
    <span class="keywd">else</span>
      <span class="keywd">if</span> minuendRange.minValue &lt; 0 <span class="keywd">then</span>
        <span class="keywd">if</span> subtrahendRange.maxValue &lt;= 0 <span class="op">or</span>
            minuendRange.minValue >= integer.first + subtrahendRange.maxValue <span class="keywd">then</span>
          differenceRange.minValue := minuendRange.minValue - subtrahendRange.maxValue;
        <span class="keywd">else</span>
          differenceRange.mayOverflow := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        <span class="keywd">if</span> subtrahendRange.maxValue >= 0 <span class="op">or</span>
            minuendRange.minValue &lt;= integer.last + subtrahendRange.maxValue <span class="keywd">then</span>
          differenceRange.minValue := minuendRange.minValue - subtrahendRange.maxValue;
        <span class="keywd">else</span>
          valueOutOfRange := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> minuendRange.maxValue >= 0 <span class="keywd">then</span>
        <span class="keywd">if</span> subtrahendRange.minValue >= 0 <span class="op">or</span>
            minuendRange.maxValue &lt;= integer.last + subtrahendRange.minValue <span class="keywd">then</span>
          differenceRange.maxValue := minuendRange.maxValue - subtrahendRange.minValue;
        <span class="keywd">else</span>
          differenceRange.mayOverflow := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        <span class="keywd">if</span> subtrahendRange.minValue &lt;= 0 <span class="op">or</span>
            minuendRange.maxValue >= integer.first + subtrahendRange.minValue <span class="keywd">then</span>
          differenceRange.maxValue := minuendRange.maxValue - subtrahendRange.minValue;
        <span class="keywd">else</span>
          valueOutOfRange := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> differenceRange.minValue > differenceRange.maxValue <span class="op">or</span> valueOutOfRange <span class="keywd">then</span>
        differenceRange.minValue := 0;
        differenceRange.maxValue := -1;
        differenceRange.mayOverflow := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      differenceRange.mayRaiseException := minuendRange.mayRaiseException <span class="op">or</span>
                                           subtrahendRange.mayRaiseException <span class="op">or</span>
                                           differenceRange.mayOverflow;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getIntLshiftRange (<span class="op">in</span> <span class="type">intRange</span>: numberRange, <span class="op">in</span> <span class="type">intRange</span>: lshiftRange) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: valueRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: valueOutOfRange <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> numberRange.minValue > numberRange.maxValue <span class="op">or</span>
        lshiftRange.minValue > lshiftRange.maxValue <span class="keywd">then</span>
      valueRange.minValue := 0;
      valueRange.maxValue := -1;
    <span class="keywd">elsif</span> lshiftRange.maxValue &lt; 0 <span class="op">or</span>
        lshiftRange.minValue > bitLength(integer.last) <span class="keywd">then</span>
      valueRange.minValue := 0;
      valueRange.maxValue := -1;
      valueRange.mayOverflow := TRUE;
    <span class="keywd">else</span>
      <span class="keywd">if</span> numberRange.minValue &lt; 0 <span class="keywd">then</span>
        <span class="keywd">if</span> lshiftRange.maxValue &lt;= bitLength(integer.last) <span class="op">and</span>
            numberRange.minValue >= integer.first >> lshiftRange.maxValue <span class="keywd">then</span>
          valueRange.minValue := numberRange.minValue &lt;&lt; lshiftRange.maxValue;
        <span class="keywd">else</span>
          valueRange.mayOverflow := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> numberRange.minValue > 0 <span class="keywd">then</span>
        <span class="keywd">if</span> lshiftRange.minValue >= 0 <span class="keywd">then</span>
          <span class="keywd">if</span> numberRange.minValue &lt;= integer.last >> lshiftRange.minValue <span class="keywd">then</span>
            valueRange.minValue := numberRange.minValue &lt;&lt; lshiftRange.minValue;
          <span class="keywd">else</span>
            <span class="comment"># No valid valueRange because minValue > integer.last holds.</span>
            valueOutOfRange := TRUE;
            valueRange.mayOverflow := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          valueRange.minValue := numberRange.minValue;
          valueRange.mayOverflow := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        valueRange.minValue := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> numberRange.maxValue &lt; 0 <span class="keywd">then</span>
        <span class="keywd">if</span> lshiftRange.minValue >= 0 <span class="keywd">then</span>
          <span class="keywd">if</span> numberRange.maxValue >= integer.first >> lshiftRange.minValue <span class="keywd">then</span>
            valueRange.maxValue := numberRange.maxValue &lt;&lt; lshiftRange.minValue;
          <span class="keywd">else</span>
            <span class="comment"># No valid valueRange because maxValue &lt; integer.first holds.</span>
            valueOutOfRange := TRUE;
            valueRange.mayOverflow := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          valueRange.maxValue := numberRange.maxValue;
          valueRange.mayOverflow := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> numberRange.maxValue > 0 <span class="keywd">then</span>
        <span class="keywd">if</span> lshiftRange.maxValue &lt;= bitLength(integer.last) <span class="op">and</span>
            numberRange.maxValue &lt;= integer.last >> lshiftRange.maxValue <span class="keywd">then</span>
          valueRange.maxValue := numberRange.maxValue &lt;&lt; lshiftRange.maxValue;
        <span class="keywd">else</span>
          valueRange.mayOverflow := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        valueRange.maxValue := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> valueRange.minValue > valueRange.maxValue <span class="op">or</span> valueOutOfRange <span class="keywd">then</span>
        valueRange.minValue := 0;
        valueRange.maxValue := -1;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      valueRange.mayOverflow := valueRange.mayOverflow <span class="op">or</span>
                                lshiftRange.minValue &lt; 0 <span class="op">or</span>
                                lshiftRange.maxValue > bitLength(integer.last);
      valueRange.mayRaiseException := numberRange.mayRaiseException <span class="op">or</span>
                                      lshiftRange.mayRaiseException <span class="op">or</span>
                                      valueRange.mayOverflow;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getIntRshiftRange (<span class="op">in</span> <span class="type">intRange</span>: numberRange, <span class="op">in</span> <span class="type">intRange</span>: rshiftRange) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: valueRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: valueOutOfRange <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> numberRange.minValue > numberRange.maxValue <span class="op">or</span>
        rshiftRange.minValue > rshiftRange.maxValue <span class="keywd">then</span>
      valueRange.minValue := 0;
      valueRange.maxValue := -1;
    <span class="keywd">elsif</span> rshiftRange.maxValue &lt; 0 <span class="op">or</span>
        rshiftRange.minValue > bitLength(integer.last) <span class="keywd">then</span>
      valueRange.minValue := 0;
      valueRange.maxValue := -1;
      valueRange.mayOverflow := TRUE;
    <span class="keywd">else</span>
      <span class="keywd">if</span> numberRange.minValue &lt; 0 <span class="keywd">then</span>
        <span class="keywd">if</span> rshiftRange.minValue >= 0 <span class="keywd">then</span>
          valueRange.minValue := numberRange.minValue >> rshiftRange.minValue;
        <span class="keywd">else</span>
          valueRange.minValue := numberRange.minValue;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> numberRange.minValue > 0 <span class="keywd">then</span>
        <span class="keywd">if</span> rshiftRange.maxValue &lt;= bitLength(integer.last) <span class="keywd">then</span>
          valueRange.minValue := numberRange.minValue >> rshiftRange.maxValue;
        <span class="keywd">else</span>
          valueRange.minValue := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        valueRange.minValue := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> numberRange.maxValue &lt; 0 <span class="keywd">then</span>
        <span class="keywd">if</span> rshiftRange.maxValue &lt;= bitLength(integer.last) <span class="keywd">then</span>
          valueRange.maxValue := numberRange.maxValue >> rshiftRange.maxValue;
        <span class="keywd">else</span>
          valueRange.maxValue := -1;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> numberRange.maxValue > 0 <span class="keywd">then</span>
        <span class="keywd">if</span> rshiftRange.minValue >= 0 <span class="keywd">then</span>
          valueRange.maxValue := numberRange.maxValue >> rshiftRange.minValue;
        <span class="keywd">else</span>
          valueRange.maxValue := numberRange.maxValue;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        valueRange.maxValue := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> valueRange.minValue > valueRange.maxValue <span class="keywd">then</span>
        valueRange.minValue := 0;
        valueRange.maxValue := -1;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      valueRange.mayOverflow := rshiftRange.minValue &lt; 0 <span class="op">or</span>
                                rshiftRange.maxValue > bitLength(integer.last);
      valueRange.mayRaiseException := numberRange.mayRaiseException <span class="op">or</span>
                                      rshiftRange.mayRaiseException <span class="op">or</span>
                                      valueRange.mayOverflow;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getIntModRange (<span class="op">in</span> <span class="type">reference</span>: dividend, <span class="op">in</span> <span class="type">reference</span>: divisor) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: valueRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: divisorRange <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">integer</span>: dividendValue <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">intRange</span>: valueRange2 <span class="keywd">is</span> intRange.value;
  <span class="keywd">begin</span>
    divisorRange := getIntRange(divisor);
    <span class="keywd">if</span> divisorRange.minValue > 0 <span class="keywd">then</span>
      valueRange.minValue := 0;
      valueRange.maxValue := pred(divisorRange.maxValue);
    <span class="keywd">elsif</span> divisorRange.maxValue &lt; 0 <span class="keywd">then</span>
      valueRange.minValue := succ(divisorRange.minValue);
      valueRange.maxValue := 0;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> getConstant(dividend, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      dividendValue := getValue(evaluatedParam, integer);
      <span class="keywd">if</span> dividendValue = integer.first <span class="keywd">then</span>
        valueRange2.minValue := succ(integer.first) <span class="op">div</span> 2;
        valueRange2.maxValue := -2 - integer.first;
      <span class="keywd">elsif</span> dividendValue = integer.last <span class="keywd">then</span>
        valueRange2.minValue := 2 - integer.last;
        valueRange2.maxValue := pred(integer.last) <span class="op">div</span> 2;
      <span class="keywd">elsif</span> dividendValue > 0 <span class="keywd">then</span>
        <span class="keywd">if</span> integer.first + dividendValue &lt;= 2 - dividendValue <span class="keywd">then</span>
          valueRange2.minValue := integer.first + dividendValue;
        <span class="keywd">else</span>
          valueRange2.minValue := 2 - dividendValue;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        valueRange2.maxValue := dividendValue;
      <span class="keywd">elsif</span> dividendValue = 0 <span class="keywd">then</span>
        valueRange2.minValue := 0;
        valueRange2.maxValue := 0;
      <span class="keywd">else</span> <span class="comment"># dividendValue &lt; 0 then</span>
        valueRange2.minValue := dividendValue;
        <span class="keywd">if</span> integer.last + dividendValue >= -(dividendValue + 2) <span class="keywd">then</span>
          valueRange2.maxValue := integer.last + dividendValue;
        <span class="keywd">else</span>
          valueRange2.maxValue := -(dividendValue + 2);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      valueRange.minValue := max(valueRange.minValue, valueRange2.minValue);
      valueRange.maxValue := min(valueRange.maxValue, valueRange2.maxValue);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> valueRange.minValue > valueRange.maxValue <span class="keywd">then</span>
      valueRange.minValue := 0;
      valueRange.maxValue := -1;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getIntNegateRange (<span class="op">in</span> <span class="type">intRange</span>: argument1Range) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: negatedRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> argument1Range.maxValue &lt; argument1Range.minValue <span class="keywd">then</span>
      negatedRange.minValue := 0;
      negatedRange.maxValue := -1;
    <span class="keywd">elsif</span> argument1Range.maxValue &lt; -integer.last <span class="keywd">then</span>
      negatedRange.minValue := 0;
      negatedRange.maxValue := -1;
      negatedRange.mayOverflow := TRUE;
    <span class="keywd">else</span>
      negatedRange.minValue := -argument1Range.maxValue;
      <span class="keywd">if</span> argument1Range.minValue &lt; -integer.last <span class="keywd">then</span>
        negatedRange.maxValue := integer.last;
        negatedRange.mayOverflow := TRUE;
      <span class="keywd">else</span>
        negatedRange.maxValue := -argument1Range.minValue;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      negatedRange.mayRaiseException := argument1Range.mayRaiseException <span class="op">or</span>
                                        negatedRange.mayOverflow;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getIntMultRange (<span class="op">in</span> <span class="type">integer</span>: factor1, <span class="op">in</span> <span class="type">intRange</span>: factor2Range) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: productRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: valueOutOfRange <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> factor1 >= 2 <span class="keywd">then</span>
      <span class="keywd">if</span> factor2Range.minValue &lt;= integer.last <span class="op">div</span> factor1 <span class="keywd">then</span>
        <span class="keywd">if</span> factor2Range.minValue >= integer.first <span class="op">div</span> factor1 <span class="keywd">then</span>
          productRange.minValue := factor2Range.minValue * factor1;
        <span class="keywd">else</span>
          productRange.minValue := integer.first <span class="op">div</span> factor1 * factor1;
          productRange.mayOverflow := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        valueOutOfRange := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> factor2Range.maxValue >= integer.first <span class="op">div</span> factor1 <span class="keywd">then</span>
        <span class="keywd">if</span> factor2Range.maxValue &lt;= integer.last <span class="op">div</span> factor1 <span class="keywd">then</span>
          productRange.maxValue := factor2Range.maxValue * factor1;
        <span class="keywd">else</span>
          productRange.maxValue := integer.last <span class="op">div</span> factor1 * factor1;
          productRange.mayOverflow := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        valueOutOfRange := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> factor1 = 1 <span class="keywd">then</span>
      productRange := factor2Range;
      productRange.mayOverflow := FALSE;
    <span class="keywd">elsif</span> factor1 = 0 <span class="keywd">then</span>
      productRange.minValue := 0;
      productRange.maxValue := 0;
    <span class="keywd">elsif</span> factor1 = -1 <span class="keywd">then</span>
      productRange := getIntNegateRange(factor2Range);
    <span class="keywd">else</span> <span class="comment"># factor1 &lt;= -2 then</span>
      <span class="keywd">if</span> factor2Range.minValue &lt;= integer.first <span class="op">div</span> factor1 <span class="keywd">then</span>
        <span class="keywd">if</span> factor2Range.minValue >= integer.last <span class="op">div</span> factor1 <span class="keywd">then</span>
          productRange.maxValue := factor2Range.minValue * factor1;
        <span class="keywd">else</span>
          productRange.maxValue := integer.last <span class="op">div</span> factor1 * factor1;
          productRange.mayOverflow := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        valueOutOfRange := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> factor2Range.maxValue >= integer.last <span class="op">div</span> factor1 <span class="keywd">then</span>
        <span class="keywd">if</span> factor2Range.maxValue &lt;= integer.first <span class="op">div</span> factor1 <span class="keywd">then</span>
          productRange.minValue := factor2Range.maxValue * factor1;
        <span class="keywd">else</span>
          productRange.minValue := integer.first <span class="op">div</span> factor1 * factor1;
          productRange.mayOverflow := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        valueOutOfRange := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> valueOutOfRange <span class="keywd">then</span>
      productRange.minValue := 0;
      productRange.maxValue := -1;
      productRange.mayOverflow := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    productRange.mayRaiseException := factor2Range.mayRaiseException <span class="op">or</span>
                                      productRange.mayOverflow;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getIntMultRange (<span class="op">in</span> <span class="type">intRange</span>: factor1Range, <span class="op">in</span> <span class="type">intRange</span>: factor2Range) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: productRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: valueOutOfRange <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: minProduct <span class="keywd">is</span> integer.last;
    <span class="keywd">var</span> <span class="type">integer</span>: maxProduct <span class="keywd">is</span> integer.first;
    <span class="keywd">var</span> <span class="type">boolean</span>: maxFound <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> factor1Range.minValue > factor1Range.maxValue <span class="op">or</span>
        factor2Range.minValue > factor2Range.maxValue <span class="keywd">then</span>
      productRange.minValue := 0;
      productRange.maxValue := -1;
    <span class="keywd">elsif</span> factor1Range.minValue = factor1Range.maxValue <span class="keywd">then</span>
      productRange := getIntMultRange(factor1Range.minValue, factor2Range)
    <span class="keywd">elsif</span> factor2Range.minValue = factor2Range.maxValue <span class="keywd">then</span>
      productRange := getIntMultRange(factor2Range.minValue, factor1Range)
    <span class="keywd">else</span>
      <span class="keywd">if</span> factor1Range.maxValue > 0 <span class="keywd">then</span>
        <span class="keywd">if</span> factor2Range.minValue &lt; 0 <span class="keywd">then</span>
          <span class="keywd">if</span> factor2Range.minValue >= integer.first <span class="op">div</span> factor1Range.maxValue <span class="keywd">then</span>
            minProduct := factor1Range.maxValue * factor2Range.minValue;
          <span class="keywd">else</span>
            minProduct := integer.first;
            productRange.mayOverflow := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> factor2Range.minValue = 0 <span class="keywd">then</span>
          minProduct := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> factor2Range.maxValue > 0 <span class="keywd">then</span>
          <span class="keywd">if</span> factor1Range.maxValue &lt;= integer.last <span class="op">div</span> factor2Range.maxValue <span class="keywd">then</span>
            maxProduct := factor1Range.maxValue * factor2Range.maxValue;
          <span class="keywd">else</span>
            maxProduct := integer.last;
            productRange.mayOverflow := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> factor2Range.maxValue = 0 <span class="keywd">then</span>
          maxProduct := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> factor1Range.maxValue = 0 <span class="keywd">then</span>
        <span class="keywd">if</span> factor2Range.minValue &lt;= 0 <span class="keywd">then</span>
          minProduct := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> factor2Range.maxValue >= 0 <span class="keywd">then</span>
          maxProduct := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span> <span class="comment"># factor1Range.maxValue &lt; 0</span>
        <span class="keywd">if</span> factor2Range.maxValue &lt; 0 <span class="keywd">then</span>
          <span class="keywd">if</span> (factor1Range.maxValue &lt;> integer.first <span class="op">or</span> factor2Range.maxValue &lt;> -1) <span class="op">and</span>
              (factor1Range.maxValue &lt;> -1 <span class="op">or</span> factor2Range.maxValue &lt;> integer.first) <span class="op">and</span>
              factor1Range.maxValue >= integer.last <span class="op">div</span> factor2Range.maxValue <span class="keywd">then</span>
            minProduct := factor1Range.maxValue * factor2Range.maxValue;
          <span class="keywd">else</span>
            <span class="comment"># No valid productRange because minProduct > integer.last holds.</span>
            valueOutOfRange := TRUE;
            productRange.mayOverflow := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> factor2Range.maxValue = 0 <span class="keywd">then</span>
          minProduct := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> factor2Range.minValue > 0 <span class="keywd">then</span>
          <span class="keywd">if</span> factor1Range.maxValue >= integer.first <span class="op">div</span> factor2Range.minValue <span class="keywd">then</span>
            maxProduct := factor1Range.maxValue * factor2Range.minValue;
          <span class="keywd">else</span>
            <span class="comment"># No valid productRange because maxProduct &lt; integer.first holds.</span>
            valueOutOfRange := TRUE;
            productRange.mayOverflow := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> factor2Range.minValue = 0 <span class="keywd">then</span>
          maxProduct := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> factor1Range.minValue > 0 <span class="keywd">then</span>
        <span class="keywd">if</span> factor2Range.minValue > 0 <span class="keywd">then</span>
          <span class="keywd">if</span> factor1Range.minValue &lt;= integer.last <span class="op">div</span> factor2Range.minValue <span class="keywd">then</span>
            minProduct := min(minProduct,
                              factor1Range.minValue * factor2Range.minValue);
          <span class="keywd">else</span>
            <span class="comment"># No valid productRange because minProduct > integer.last holds.</span>
            valueOutOfRange := TRUE;
            productRange.mayOverflow := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> factor2Range.minValue = 0 <span class="keywd">then</span>
          minProduct := min(minProduct, 0);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> factor2Range.maxValue &lt; 0 <span class="keywd">then</span>
          <span class="keywd">if</span> factor2Range.maxValue >= integer.first <span class="op">div</span> factor1Range.minValue <span class="keywd">then</span>
            maxProduct := max(maxProduct,
                              factor1Range.minValue * factor2Range.maxValue);
          <span class="keywd">else</span>
            <span class="comment"># No valid productRange because maxProduct &lt; integer.first holds.</span>
            valueOutOfRange := TRUE;
            productRange.mayOverflow := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> factor2Range.maxValue = 0 <span class="keywd">then</span>
          maxProduct := max(maxProduct, 0);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> factor1Range.minValue = 0 <span class="keywd">then</span>
        <span class="keywd">if</span> factor2Range.minValue >= 0 <span class="keywd">then</span>
          minProduct := min(minProduct, 0);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> factor2Range.minValue &lt;= 0 <span class="keywd">then</span>
          maxProduct := max(maxProduct, 0);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span> <span class="comment"># factor1Range.minValue &lt; 0</span>
        <span class="keywd">if</span> factor2Range.maxValue > 0 <span class="keywd">then</span>
          <span class="keywd">if</span> factor1Range.minValue >= integer.first <span class="op">div</span> factor2Range.maxValue <span class="keywd">then</span>
            minProduct := min(minProduct,
                              factor1Range.minValue * factor2Range.maxValue);
          <span class="keywd">else</span>
            minProduct := integer.first;
            productRange.mayOverflow := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> factor2Range.maxValue = 0 <span class="keywd">then</span>
          minProduct := min(minProduct, 0);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> factor2Range.minValue &lt; 0 <span class="keywd">then</span>
          <span class="keywd">if</span> (factor1Range.minValue &lt;> integer.first <span class="op">or</span> factor2Range.minValue &lt;> -1) <span class="op">and</span>
              (factor1Range.minValue &lt;> -1 <span class="op">or</span> factor2Range.minValue &lt;> integer.first) <span class="op">and</span>
              factor1Range.minValue >= integer.last <span class="op">div</span> factor2Range.minValue <span class="keywd">then</span>
            maxProduct := max(maxProduct,
                              factor1Range.minValue * factor2Range.minValue);
          <span class="keywd">else</span>
            maxProduct := integer.last;
            productRange.mayOverflow := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> factor2Range.minValue = 0 <span class="keywd">then</span>
          maxProduct := max(maxProduct, 0);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      productRange.minValue := minProduct;
      productRange.maxValue := maxProduct;
      <span class="keywd">if</span> productRange.minValue > productRange.maxValue <span class="op">or</span> valueOutOfRange <span class="keywd">then</span>
        productRange.minValue := 0;
        productRange.maxValue := -1;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      productRange.mayRaiseException := factor1Range.mayRaiseException <span class="op">or</span>
                                        factor2Range.mayRaiseException <span class="op">or</span>
                                        productRange.mayOverflow;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getIntBytes2UIntRange (<span class="op">in</span> <span class="type">reference</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: valueRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    valueRange.minValue := 0;
    <span class="keywd">if</span> isActionExpression(stri, <span class="stri">"STR_SUBSTR"</span>) <span class="op">and</span>
        category(getValue(stri, ref_list)[6]) = INTOBJECT <span class="op">and</span>
        <span class="op">not</span> isVar(getValue(stri, ref_list)[6]) <span class="keywd">then</span>
      length := getValue(getValue(stri, ref_list)[6], integer);
      <span class="keywd">if</span> length >= 1 <span class="op">and</span> length &lt; 8 <span class="keywd">then</span>
        valueRange.maxValue := pred(2 ** (length * 8));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getSetRandRange (<span class="op">in</span> <span class="type">reference</span>: aSet) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: valueRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">bitset</span>: setValue <span class="keywd">is</span> {};
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(aSet, SETOBJECT, evaluatedParam) <span class="keywd">then</span>
      setValue := getValue(evaluatedParam, bitset);
      <span class="keywd">if</span> setValue = {} <span class="keywd">then</span>
        valueRange.minValue := 0;
        valueRange.maxValue := -1;
      <span class="keywd">else</span>
        valueRange.minValue := min(setValue);
        valueRange.maxValue := max(setValue);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getBigOrdOfBigModRange (<span class="op">in</span> <span class="type">bigInteger</span>: divisor) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: valueRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> divisor > 0_ <span class="op">and</span> log2(divisor) &lt;= 63_ <span class="op">and</span>
        2_ ** ord(log2(divisor)) = divisor <span class="keywd">then</span>
      valueRange.minValue := 0;
      valueRange.maxValue := ord(pred(divisor));
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getIntRange (<span class="op">in</span> <span class="type">reference</span>: intExpression) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: valueRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: function <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">string</span>: actionName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">intRange</span>: argument1Range <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">intRange</span>: argument2Range <span class="keywd">is</span> intRange.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> reduceOverflowChecks <span class="keywd">then</span>
      <span class="keywd">if</span> getConstant(intExpression, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
        number := getValue(evaluatedParam, integer);
        valueRange.minValue := number;
        valueRange.maxValue := number;
        valueRange.mayRaiseException := FALSE;
        <span class="comment"># writeln("intRange of constant: " &lt;&amp; valueRange.minValue &lt;&amp; ".." &lt;&amp; valueRange.maxValue);</span>
      <span class="keywd">elsif</span> intExpression <span class="op">in</span> intRangeOfVariable <span class="keywd">then</span>
        valueRange := intRangeOfVariable[intExpression];
        valueRange.mayRaiseException := FALSE;
        <span class="comment"># writeln("intRange of variable: " &lt;&amp; valueRange.minValue &lt;&amp; ".." &lt;&amp; valueRange.maxValue);</span>
      <span class="keywd">elsif</span> category(intExpression) = CALLOBJECT <span class="keywd">then</span>
        params := getValue(intExpression, ref_list);
        function := params[1];
        params := params[2 ..];
        <span class="keywd">if</span> category(function) = ACTOBJECT <span class="keywd">then</span>
          actionName := str(getValue(function, ACTION));
          <span class="keywd">case</span> actionName <span class="keywd">of</span>
            <span class="keywd">when</span> {<span class="stri">"ARR_LNG"</span>, <span class="stri">"BIG_BIT_LENGTH"</span>, <span class="stri">"BST_LNG"</span>, <span class="stri">"FIL_LNG"</span>, <span class="stri">"HSH_LNG"</span>, <span class="stri">"RFL_LNG"</span>,
                  <span class="stri">"SET_CARD"</span>,
                  <span class="stri">"SQL_STMT_COLUMN_COUNT"</span>}:
              valueRange.minValue := 0;
              valueRange.maxValue := integer.last;
            <span class="keywd">when</span> {<span class="stri">"BIG_CMP"</span>, <span class="stri">"BIN_CMP"</span>, <span class="stri">"BST_CMP"</span>, <span class="stri">"CHR_CMP"</span>, <span class="stri">"DRW_CMP"</span>,
                  <span class="stri">"FLT_CMP"</span>, <span class="stri">"INT_CMP"</span>, <span class="stri">"ITF_CMP"</span>, <span class="stri">"PCS_CMP"</span>, <span class="stri">"REF_CMP"</span>,
                  <span class="stri">"SET_CMP"</span>, <span class="stri">"SQL_CMP_DB"</span>, <span class="stri">"SQL_CMP_STMT"</span>, <span class="stri">"STR_CMP"</span>,
                  <span class="stri">"TYP_CMP"</span>}:
              valueRange.minValue := -1;
              valueRange.maxValue := 1;
            <span class="keywd">when</span> {<span class="stri">"BIG_LOWEST_SET_BIT"</span>}:
              valueRange.minValue := -1;
              valueRange.maxValue := integer.last;
            <span class="keywd">when</span> {<span class="stri">"BIG_ORD"</span>}:
              <span class="keywd">if</span> isActionExpression(params[1], <span class="stri">"BIG_MOD"</span>) <span class="op">and</span>
                  getConstant(getActionParameter(params[1], 3),
                              BIGINTOBJECT, evaluatedParam) <span class="keywd">then</span>
                valueRange := getBigOrdOfBigModRange(
                    getValue(evaluatedParam, bigInteger));
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"BIN_CARD"</span>}:
              valueRange.minValue := 0;
              valueRange.maxValue := ccConf.INTTYPE_SIZE;
            <span class="keywd">when</span> {<span class="stri">"BLN_ORD"</span>}:
              valueRange.minValue := 0;
              valueRange.maxValue := 1;
            <span class="keywd">when</span> {<span class="stri">"BLN_TERNARY"</span>}:
              <span class="keywd">if</span> getConstant(params[1], ENUMLITERALOBJECT, evaluatedParam) <span class="keywd">then</span>
                <span class="keywd">if</span> getValue(evaluatedParam, boolean) <span class="keywd">then</span>
                  valueRange := getIntRange(params[3]);
                <span class="keywd">else</span>
                  valueRange := getIntRange(params[5]);
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">else</span>
                argument1Range := getIntRange(params[3]);
                argument2Range := getIntRange(params[5]);
                valueRange.minValue := min(argument1Range.minValue,
                                           argument2Range.minValue);
                valueRange.maxValue := max(argument1Range.maxValue,
                                           argument2Range.maxValue);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"CHR_ORD"</span>}:
              <span class="keywd">if</span> ccConf.TWOS_COMPLEMENT_INTTYPE <span class="keywd">then</span>
                valueRange.minValue := -2147483648;
              <span class="keywd">else</span>
                valueRange.minValue := -2147483647;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              valueRange.maxValue := 2147483647;
            <span class="keywd">when</span> {<span class="stri">"ENU_ORD2"</span>}:
              valueRange.minValue := 0;
              valueRange.maxValue :=
                  pred(length(getValue(evaluate(prog, params[2]), ref_list)));
            <span class="keywd">when</span> {<span class="stri">"FIL_TELL"</span>}:
              valueRange.minValue := 1;
              valueRange.maxValue := integer.last;
            <span class="keywd">when</span> {<span class="stri">"INT_ABS"</span>}:
              valueRange := getIntAbsRange(getIntRange(params[1]));
            <span class="keywd">when</span> {<span class="stri">"INT_ADD"</span>}:
              valueRange := getIntAddRange(getIntRange(params[1]),
                                           getIntRange(params[3]));
            <span class="keywd">when</span> {<span class="stri">"INT_BIT_LENGTH"</span>}:
              valueRange.minValue := 0;
              argument1Range := getIntRange(params[1]);
              <span class="keywd">if</span> argument1Range.minValue &lt;= 0 <span class="op">and</span> argument1Range.maxValue >= 0 <span class="keywd">then</span>
                valueRange.minValue := 0;
              <span class="keywd">else</span>
                valueRange.minValue := min(bitLength(argument1Range.minValue),
                                           bitLength(argument1Range.maxValue));
              <span class="keywd">end</span> <span class="keywd">if</span>;
              valueRange.maxValue := max(bitLength(argument1Range.minValue),
                                         bitLength(argument1Range.maxValue));
            <span class="keywd">when</span> {<span class="stri">"INT_BYTES_BE_2_UINT"</span>,
                  <span class="stri">"INT_BYTES_LE_2_UINT"</span>}:
              valueRange := getIntBytes2UIntRange(params[1]);
            <span class="keywd">when</span> {<span class="stri">"INT_DIV"</span>}:
              <span class="keywd">if</span> getConstant(params[3], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := getValue(evaluatedParam, integer);
                <span class="keywd">if</span> number > 0 <span class="keywd">then</span>
                  valueRange.minValue := integer.first <span class="op">div</span> number;
                  valueRange.maxValue := integer.last <span class="op">div</span> number;
                <span class="keywd">elsif</span> number = -1 <span class="keywd">then</span>
                  valueRange.minValue := -integer.last;
                <span class="keywd">elsif</span> number &lt; -1 <span class="keywd">then</span>
                  valueRange.minValue := integer.last <span class="op">div</span> number;
                  valueRange.maxValue := integer.first <span class="op">div</span> number;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">elsif</span> getConstant(params[1], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := getValue(evaluatedParam, integer);
                <span class="keywd">if</span> number >= 0 <span class="keywd">then</span>
                  valueRange.minValue := -number;
                  valueRange.maxValue := number;
                <span class="keywd">elsif</span> number &lt;> integer.first <span class="keywd">then</span>
                  valueRange.minValue := number;
                  valueRange.maxValue := -number;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"INT_ICONV1"</span>}:
              valueRange := getIntRange(params[1]);
            <span class="keywd">when</span> {<span class="stri">"INT_ICONV3"</span>}:
              valueRange := getIntRange(params[3]);
            <span class="keywd">when</span> {<span class="stri">"INT_LOG10"</span>}:
              argument1Range := getIntRange(params[1]);
              <span class="keywd">if</span> argument1Range.maxValue >= 0 <span class="keywd">then</span>
                <span class="keywd">if</span> argument1Range.minValue >= 0 <span class="keywd">then</span>
                  valueRange.minValue := log10(argument1Range.minValue);
                <span class="keywd">else</span>
                  valueRange.minValue := -1;
                <span class="keywd">end</span> <span class="keywd">if</span>;
                valueRange.maxValue := log10(argument1Range.maxValue);
              <span class="keywd">else</span>
                valueRange.minValue := 0;
                valueRange.maxValue := -1;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"INT_LOG2"</span>}:
              argument1Range := getIntRange(params[1]);
              <span class="keywd">if</span> argument1Range.maxValue >= 0 <span class="keywd">then</span>
                <span class="keywd">if</span> argument1Range.minValue >= 0 <span class="keywd">then</span>
                  valueRange.minValue := log2(argument1Range.minValue);
                <span class="keywd">else</span>
                  valueRange.minValue := -1;
                <span class="keywd">end</span> <span class="keywd">if</span>;
                valueRange.maxValue := log2(argument1Range.maxValue);
              <span class="keywd">else</span>
                valueRange.minValue := 0;
                valueRange.maxValue := -1;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"INT_LOWEST_SET_BIT"</span>}:
              valueRange.minValue := -1;
              valueRange.maxValue := pred(ccConf.INTTYPE_SIZE);
            <span class="keywd">when</span> {<span class="stri">"INT_LSHIFT"</span>}:
              valueRange := getIntLshiftRange(getIntRange(params[1]),
                                              getIntRange(params[3]));
            <span class="keywd">when</span> {<span class="stri">"INT_MDIV"</span>}:
              <span class="keywd">if</span> getConstant(params[3], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := getValue(evaluatedParam, integer);
                <span class="keywd">if</span> number > 0 <span class="keywd">then</span>
                  valueRange.minValue := integer.first <span class="op">mdiv</span> number;
                  valueRange.maxValue := integer.last <span class="op">mdiv</span> number;
                <span class="keywd">elsif</span> number = -1 <span class="keywd">then</span>
                  valueRange.minValue := -integer.last;
                <span class="keywd">elsif</span> number &lt; -1 <span class="keywd">then</span>
                  valueRange.minValue := integer.last <span class="op">mdiv</span> number;
                  valueRange.maxValue := integer.first <span class="op">mdiv</span> number;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">elsif</span> getConstant(params[1], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := getValue(evaluatedParam, integer);
                <span class="keywd">if</span> number >= 0 <span class="keywd">then</span>
                  valueRange.minValue := -number;
                  valueRange.maxValue := number;
                <span class="keywd">elsif</span> number &lt;> integer.first <span class="keywd">then</span>
                  valueRange.minValue := number;
                  valueRange.maxValue := -number;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"INT_MOD"</span>}:
              valueRange := getIntModRange(params[1], params[3]);
            <span class="keywd">when</span> {<span class="stri">"INT_MULT"</span>}:
              valueRange := getIntMultRange(getIntRange(params[1]),
                                            getIntRange(params[3]));
            <span class="keywd">when</span> {<span class="stri">"INT_NEGATE"</span>}:
              valueRange := getIntNegateRange(getIntRange(params[2]));
            <span class="keywd">when</span> {<span class="stri">"INT_PRED"</span>}:
              argument1Range := getIntRange(params[1]);
              <span class="keywd">if</span> argument1Range.minValue &lt;> integer.first <span class="keywd">then</span>
                valueRange.minValue := pred(argument1Range.minValue);
              <span class="keywd">else</span>
                valueRange.minValue := integer.first;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> argument1Range.maxValue &lt;> integer.first <span class="keywd">then</span>
                valueRange.maxValue := pred(argument1Range.maxValue);
              <span class="keywd">else</span>
                valueRange.maxValue := integer.first;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> <span class="op">not</span> argument1Range.mayRaiseException <span class="op">and</span>
                  argument1Range.minValue &lt;> integer.first <span class="keywd">then</span>
                valueRange.mayRaiseException := FALSE;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"INT_RAND"</span>}:
              argument1Range := getIntRange(params[1]);
              argument2Range := getIntRange(params[2]);
              valueRange.minValue := argument1Range.minValue;
              valueRange.maxValue := argument2Range.maxValue;
              <span class="keywd">if</span> <span class="op">not</span> (argument1Range.mayRaiseException <span class="op">or</span>
                      argument2Range.mayRaiseException) <span class="op">and</span>
                  argument1Range.maxValue &lt;= argument2Range.minValue <span class="keywd">then</span>
                valueRange.mayRaiseException := FALSE;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"INT_REM"</span>}:
              <span class="keywd">if</span> getConstant(params[3], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := getValue(evaluatedParam, integer);
                <span class="keywd">if</span> number > 0 <span class="keywd">then</span>
                  valueRange.minValue := -pred(number);
                  valueRange.maxValue := pred(number);
                <span class="keywd">elsif</span> number &lt; 0 <span class="keywd">then</span>
                  valueRange.minValue := succ(number);
                  valueRange.maxValue := -succ(number);
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">elsif</span> getConstant(params[1], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := getValue(evaluatedParam, integer);
                <span class="keywd">if</span> number >= 0 <span class="keywd">then</span>
                  valueRange.minValue := 0;
                  valueRange.maxValue := number;
                <span class="keywd">elsif</span> number = 0 <span class="keywd">then</span>
                  valueRange.minValue := 0;
                  valueRange.maxValue := 0;
                <span class="keywd">else</span> <span class="comment"># number &lt; 0 then</span>
                  valueRange.minValue := number;
                  valueRange.maxValue := 0;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"INT_RSHIFT"</span>}:
              valueRange := getIntRshiftRange(getIntRange(params[1]),
                                              getIntRange(params[3]));
            <span class="keywd">when</span> {<span class="stri">"INT_SBTR"</span>}:
              valueRange := getIntSbtrRange(getIntRange(params[1]),
                                            getIntRange(params[3]));
            <span class="keywd">when</span> {<span class="stri">"INT_SQRT"</span>}:
              argument1Range := getIntRange(params[1]);
              <span class="keywd">if</span> argument1Range.maxValue >= 0 <span class="keywd">then</span>
                <span class="keywd">if</span> argument1Range.minValue >= 0 <span class="keywd">then</span>
                  valueRange.minValue := sqrt(argument1Range.minValue);
                <span class="keywd">else</span>
                  valueRange.minValue := 0;
                <span class="keywd">end</span> <span class="keywd">if</span>;
                valueRange.maxValue := sqrt(argument1Range.maxValue);
              <span class="keywd">else</span>
                valueRange.minValue := 0;
                valueRange.maxValue := -1;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"INT_SUCC"</span>}:
              argument1Range := getIntRange(params[1]);
              <span class="keywd">if</span> argument1Range.minValue &lt;> integer.last <span class="keywd">then</span>
                valueRange.minValue := succ(argument1Range.minValue);
              <span class="keywd">else</span>
                valueRange.minValue := integer.last;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> argument1Range.maxValue &lt;> integer.last <span class="keywd">then</span>
                valueRange.maxValue := succ(argument1Range.maxValue);
              <span class="keywd">else</span>
                valueRange.maxValue := integer.last;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> <span class="op">not</span> argument1Range.mayRaiseException <span class="op">and</span>
                  argument1Range.maxValue &lt;> integer.last <span class="keywd">then</span>
                valueRange.mayRaiseException := FALSE;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"SET_RAND"</span>}:
              valueRange := getSetRandRange(params[1]);
            <span class="keywd">when</span> {<span class="stri">"STR_CHIPOS"</span>, <span class="stri">"STR_CHPOS"</span>, <span class="stri">"STR_IPOS"</span>, <span class="stri">"STR_POS"</span>,
                  <span class="stri">"STR_RCHIPOS"</span>, <span class="stri">"STR_RCHPOS"</span>, <span class="stri">"STR_RIPOS"</span>, <span class="stri">"STR_RPOS"</span>}:
              <span class="keywd">if</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := length(getValue(evaluatedParam, string));
                valueRange.minValue := 0;
                valueRange.maxValue := number;
              <span class="keywd">elsif</span> ccConf.POINTER_SIZE > ccConf.INTTYPE_SIZE <span class="keywd">then</span>
                valueRange.minValue := 0;
                valueRange.maxValue := integer.last;
              <span class="keywd">else</span>
                valueRange.minValue := 0;
                <span class="comment"># Because of UTF-32 the available bytes are divided by four.</span>
                valueRange.maxValue := 2 ** (ccConf.POINTER_SIZE - 2);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"STR_LNG"</span>}:
              <span class="keywd">if</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := length(getValue(evaluatedParam, string));
                valueRange.minValue := number;
                valueRange.maxValue := number;
                valueRange.mayRaiseException := FALSE;
              <span class="keywd">elsif</span> isActionExpression(params[1], <span class="stri">"STR_SUBSTR_FIXLEN"</span>) <span class="op">and</span>
                  getConstant(getActionParameter(params[1], 5), INTOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := getValue(evaluatedParam, integer);
                valueRange.minValue := number;
                valueRange.maxValue := number;
              <span class="keywd">elsif</span> isActionExpression(params[1], <span class="stri">"STR_SUBSTR"</span>) <span class="op">and</span>
                  getConstant(getActionParameter(params[1], 5), INTOBJECT, evaluatedParam) <span class="keywd">then</span>
                valueRange.minValue := 0;
                valueRange.maxValue := getValue(evaluatedParam, integer);
              <span class="keywd">elsif</span> ccConf.POINTER_SIZE > ccConf.INTTYPE_SIZE <span class="keywd">then</span>
                valueRange.minValue := 0;
                valueRange.maxValue := integer.last;
              <span class="keywd">else</span>
                valueRange.minValue := 0;
                <span class="comment"># Because of UTF-32 the available bytes are divided by four.</span>
                valueRange.maxValue := 2 ** (ccConf.POINTER_SIZE - 2);
              <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">case</span>;
          <span class="comment"># writeln(actionName &lt;&amp; ": " &lt;&amp; valueRange.minValue &lt;&amp; " " &lt;&amp; valueRange.maxValue);</span>
        <span class="keywd">elsif</span> category(function) = BLOCKOBJECT <span class="keywd">then</span>
          <span class="keywd">if</span> resultVar(function) = NIL <span class="op">and</span>
              resultInitValue(function) = NIL <span class="op">and</span>
              localConsts(function) = ref_list.EMPTY <span class="op">and</span>
              localVars(function) = ref_list.EMPTY <span class="keywd">then</span>
            valueRange := getIntRange(body(function));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="comment"># writeln("BLOCKOBJECT: " &lt;&amp; valueRange.minValue &lt;&amp; " " &lt;&amp; valueRange.maxValue);</span>
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
