<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  flt_act.s7i   Generate code for actions of the type float.      *)</span>
<span class="comment">(*  Copyright (C) 1990 - 1994, 2004 - 2016  Thomas Mertes           *)</span>
<span class="comment">(*                2019 - 2022  Thomas Mertes                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 compiler.                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_ABS             <span class="keywd">is</span> action <span class="stri">"FLT_ABS"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_ACOS            <span class="keywd">is</span> action <span class="stri">"FLT_ACOS"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_ADD             <span class="keywd">is</span> action <span class="stri">"FLT_ADD"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_ADD_ASSIGN      <span class="keywd">is</span> action <span class="stri">"FLT_ADD_ASSIGN"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_ASIN            <span class="keywd">is</span> action <span class="stri">"FLT_ASIN"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_ATAN            <span class="keywd">is</span> action <span class="stri">"FLT_ATAN"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_ATAN2           <span class="keywd">is</span> action <span class="stri">"FLT_ATAN2"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_BITS2DOUBLE     <span class="keywd">is</span> action <span class="stri">"FLT_BITS2DOUBLE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_BITS2SINGLE     <span class="keywd">is</span> action <span class="stri">"FLT_BITS2SINGLE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_CEIL            <span class="keywd">is</span> action <span class="stri">"FLT_CEIL"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_CMP             <span class="keywd">is</span> action <span class="stri">"FLT_CMP"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_COS             <span class="keywd">is</span> action <span class="stri">"FLT_COS"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_COSH            <span class="keywd">is</span> action <span class="stri">"FLT_COSH"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_CPY             <span class="keywd">is</span> action <span class="stri">"FLT_CPY"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_DECOMPOSE       <span class="keywd">is</span> action <span class="stri">"FLT_DECOMPOSE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_DGTS            <span class="keywd">is</span> action <span class="stri">"FLT_DGTS"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_DIV             <span class="keywd">is</span> action <span class="stri">"FLT_DIV"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_DIV_ASSIGN      <span class="keywd">is</span> action <span class="stri">"FLT_DIV_ASSIGN"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_DOUBLE2BITS     <span class="keywd">is</span> action <span class="stri">"FLT_DOUBLE2BITS"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_EQ              <span class="keywd">is</span> action <span class="stri">"FLT_EQ"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_EXP             <span class="keywd">is</span> action <span class="stri">"FLT_EXP"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_EXPM1           <span class="keywd">is</span> action <span class="stri">"FLT_EXPM1"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_FLOOR           <span class="keywd">is</span> action <span class="stri">"FLT_FLOOR"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_GE              <span class="keywd">is</span> action <span class="stri">"FLT_GE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_GT              <span class="keywd">is</span> action <span class="stri">"FLT_GT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_HASHCODE        <span class="keywd">is</span> action <span class="stri">"FLT_HASHCODE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_ICONV1          <span class="keywd">is</span> action <span class="stri">"FLT_ICONV1"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_ICONV3          <span class="keywd">is</span> action <span class="stri">"FLT_ICONV3"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_IPOW            <span class="keywd">is</span> action <span class="stri">"FLT_IPOW"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_ISNAN           <span class="keywd">is</span> action <span class="stri">"FLT_ISNAN"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_ISNEGATIVEZERO  <span class="keywd">is</span> action <span class="stri">"FLT_ISNEGATIVEZERO"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_LE              <span class="keywd">is</span> action <span class="stri">"FLT_LE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_LOG             <span class="keywd">is</span> action <span class="stri">"FLT_LOG"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_LOG10           <span class="keywd">is</span> action <span class="stri">"FLT_LOG10"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_LOG1P           <span class="keywd">is</span> action <span class="stri">"FLT_LOG1P"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_LOG2            <span class="keywd">is</span> action <span class="stri">"FLT_LOG2"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_LSHIFT          <span class="keywd">is</span> action <span class="stri">"FLT_LSHIFT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_LT              <span class="keywd">is</span> action <span class="stri">"FLT_LT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_MOD             <span class="keywd">is</span> action <span class="stri">"FLT_MOD"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_MULT            <span class="keywd">is</span> action <span class="stri">"FLT_MULT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_MULT_ASSIGN     <span class="keywd">is</span> action <span class="stri">"FLT_MULT_ASSIGN"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_NE              <span class="keywd">is</span> action <span class="stri">"FLT_NE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_NEGATE          <span class="keywd">is</span> action <span class="stri">"FLT_NEGATE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_PARSE1          <span class="keywd">is</span> action <span class="stri">"FLT_PARSE1"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_PLUS            <span class="keywd">is</span> action <span class="stri">"FLT_PLUS"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_POW             <span class="keywd">is</span> action <span class="stri">"FLT_POW"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_RAND            <span class="keywd">is</span> action <span class="stri">"FLT_RAND"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_REM             <span class="keywd">is</span> action <span class="stri">"FLT_REM"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_ROUND           <span class="keywd">is</span> action <span class="stri">"FLT_ROUND"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_RSHIFT          <span class="keywd">is</span> action <span class="stri">"FLT_RSHIFT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_SBTR            <span class="keywd">is</span> action <span class="stri">"FLT_SBTR"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_SBTR_ASSIGN     <span class="keywd">is</span> action <span class="stri">"FLT_SBTR_ASSIGN"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_SCI             <span class="keywd">is</span> action <span class="stri">"FLT_SCI"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_SIN             <span class="keywd">is</span> action <span class="stri">"FLT_SIN"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_SINGLE2BITS     <span class="keywd">is</span> action <span class="stri">"FLT_SINGLE2BITS"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_SINH            <span class="keywd">is</span> action <span class="stri">"FLT_SINH"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_SQRT            <span class="keywd">is</span> action <span class="stri">"FLT_SQRT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_STR             <span class="keywd">is</span> action <span class="stri">"FLT_STR"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_STR_SCIENTIFIC  <span class="keywd">is</span> action <span class="stri">"FLT_STR_SCIENTIFIC"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_TAN             <span class="keywd">is</span> action <span class="stri">"FLT_TAN"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_TANH            <span class="keywd">is</span> action <span class="stri">"FLT_TANH"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_TRUNC           <span class="keywd">is</span> action <span class="stri">"FLT_TRUNC"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: FLT_VALUE           <span class="keywd">is</span> action <span class="stri">"FLT_VALUE"</span>;


<span class="keywd">const</span> <span class="type">proc</span>: flt_prototypes (<span class="keywd">inout</span> <span class="type">file</span>: c_prog) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> ccConf.HAS_EXP10 <span class="keywd">then</span>
      declareExtern(c_prog, <span class="stri">"double exp10(double x);"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    declareExtern(c_prog, <span class="stri">"intType     fltCmp (floatType, floatType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     fltCmpGeneric (const genericType, const genericType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        fltCpyGeneric (genericType *const, const genericType);"</span>);
    <span class="keywd">if</span> <span class="op">not</span> ccConf.FREXP_FUNCTION_OKAY <span class="keywd">then</span>
      declareExtern(c_prog, <span class="stri">"floatType   fltDecompose (const floatType, intType *const);"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    declareExtern(c_prog, <span class="stri">"striType    fltDgts (floatType, intType);"</span>);
    <span class="keywd">if</span> <span class="op">not</span> ccConf.FLOAT_COMPARISON_OKAY <span class="keywd">then</span>
      declareExtern(c_prog, <span class="stri">"boolType    fltEq (floatType, floatType);"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> ccConf.EXP_FUNCTION_OKAY <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"#define     fltExp(exponent) exp(exponent)"</span>);
    <span class="keywd">else</span>
      declareExtern(c_prog, <span class="stri">"floatType   fltExp (floatType number);"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> ccConf.HAS_EXPM1 <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"#define     fltExpM1(exponent) expm1(exponent)"</span>);
    <span class="keywd">else</span>
      declareExtern(c_prog, <span class="stri">"floatType   fltExpM1 (floatType number);"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="op">not</span> ccConf.FLOAT_COMPARISON_OKAY <span class="keywd">then</span>
      declareExtern(c_prog, <span class="stri">"boolType    fltGe (floatType, floatType);"</span>);
      declareExtern(c_prog, <span class="stri">"boolType    fltGt (floatType, floatType);"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    declareExtern(c_prog, <span class="stri">"floatType   fltIPow (floatType, intType);"</span>);
    declareExtern(c_prog, <span class="stri">"boolType    fltIsNegativeZero (floatType);"</span>);
    writeln(c_prog, <span class="stri">"#define     fltIsNegativeZeroMacro(number) (memcmp(&amp;(number), &amp;negativeZero, sizeof(floatType)) == 0)"</span>);
    <span class="keywd">if</span> ccConf.LDEXP_FUNCTION_OKAY <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"#define     fltLdexp(number, exponent) ldexp(number, exponent)"</span>);
    <span class="keywd">else</span>
      declareExtern(c_prog, <span class="stri">"floatType   fltLdexp (floatType number, int exponent);"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="op">not</span> ccConf.FLOAT_COMPARISON_OKAY <span class="keywd">then</span>
      declareExtern(c_prog, <span class="stri">"boolType    fltLe (floatType, floatType);"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> ccConf.LOG_FUNCTION_OKAY <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"#define     fltLog(number) log(number)"</span>);
    <span class="keywd">else</span>
      declareExtern(c_prog, <span class="stri">"floatType   fltLog (floatType);"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> ccConf.LOG10_FUNCTION_OKAY <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"#define     fltLog10(number) log10(number)"</span>);
    <span class="keywd">else</span>
      declareExtern(c_prog, <span class="stri">"floatType   fltLog10 (floatType);"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> ccConf.LOG1P_FUNCTION_OKAY <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"#define     fltLog1p(number) log1p(number)"</span>);
    <span class="keywd">else</span>
      declareExtern(c_prog, <span class="stri">"floatType   fltLog1p (floatType);"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> ccConf.LOG2_FUNCTION_OKAY <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"#define     fltLog2(number) log2(number)"</span>);
    <span class="keywd">else</span>
      declareExtern(c_prog, <span class="stri">"floatType   fltLog2 (floatType);"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="op">not</span> ccConf.FLOAT_COMPARISON_OKAY <span class="keywd">then</span>
      declareExtern(c_prog, <span class="stri">"boolType    fltLt (floatType, floatType);"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    declareExtern(c_prog, <span class="stri">"floatType   fltMod (floatType, floatType);"</span>);
    declareExtern(c_prog, <span class="stri">"floatType   fltParse (const const_striType);"</span>);
    <span class="keywd">if</span> ccConf.POW_FUNCTION_OKAY <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"#define     fltPow(base, exponent) pow(base, exponent)"</span>);
    <span class="keywd">else</span>
      declareExtern(c_prog, <span class="stri">"floatType   fltPow (floatType, floatType);"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    declareExtern(c_prog, <span class="stri">"floatType   fltRand (floatType, floatType);"</span>);
    declareExtern(c_prog, <span class="stri">"floatType   fltRandNoChk (floatType, floatType);"</span>);
    <span class="keywd">if</span> ccConf.FMOD_FUNCTION_OKAY <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"#define     fltRem(dividend, divisor) fmod(dividend, divisor)"</span>);
    <span class="keywd">else</span>
      declareExtern(c_prog, <span class="stri">"floatType   fltRem (floatType, floatType);"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    declareExtern(c_prog, <span class="stri">"striType    fltSci (floatType, intType);"</span>);
    <span class="keywd">if</span> ccConf.SQRT_FUNCTION_OKAY <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"#define     fltSqrt(number) sqrt(number)"</span>);
    <span class="keywd">else</span>
      declareExtern(c_prog, <span class="stri">"floatType   fltSqrt (floatType);"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    declareExtern(c_prog, <span class="stri">"striType    fltStr (floatType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    fltStrScientific (floatType);"</span>);
    declareExtern(c_prog, <span class="stri">"floatType   fltValue (const const_objRefType);"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_ABS, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"fabs("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_ACOS, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"acos("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_ADD, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">") + ("</span>;
    process_expr(params[3], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_ADD_ASSIGN, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    process_expr(params[1], statement);
    statement.expr &amp;:= <span class="stri">"+="</span>;
    process_expr(params[3], statement);
    statement.expr &amp;:= <span class="stri">";\n"</span>;
    doLocalDeclsOfStatement(statement, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_ASIN, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"asin("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_ATAN, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"atan("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_ATAN2, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"atan2("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    process_expr(params[2], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_BITS2DOUBLE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: union_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    union_name := defineTempVariable(<span class="stri">"double2BitsUnion"</span>, <span class="stri">"conv_"</span>, c_expr);
    c_expr.expr &amp;:= <span class="stri">"("</span>;
    c_expr.expr &amp;:= union_name;
    c_expr.expr &amp;:= <span class="stri">".bits=(uintType)("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">"),"</span>;
    c_expr.expr &amp;:= union_name;
    c_expr.expr &amp;:= <span class="stri">".aDouble)"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_BITS2SINGLE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: number_range <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">string</span>: temp_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: union_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> config.conversion_range_check <span class="keywd">then</span>
      number_range := getIntRange(params[1]);
      <span class="keywd">if</span> number_range.maxValue &lt; 0 <span class="op">or</span> number_range.minValue >= 2 ** 32 <span class="keywd">then</span>
        warning(DOES_RAISE, <span class="stri">"RANGE_ERROR"</span>, c_expr);
        c_expr.expr &amp;:= intRaiseError(<span class="stri">"RANGE_ERROR"</span>);
      <span class="keywd">elsif</span> number_range.minValue &lt; 0 <span class="op">or</span> number_range.maxValue >= 2 ** 32 <span class="keywd">then</span>
        incr(count.rangeChecks);
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        temp_name := getTempVariable(<span class="stri">"intType"</span>, <span class="stri">"tmp_"</span>, params[1], c_expr);
        union_name := defineTempVariable(<span class="stri">"float2BitsUnion"</span>, <span class="stri">"conv_"</span>, c_expr);
        c_expr.expr &amp;:= <span class="stri">"rngChk((uintType)"</span>;
        c_expr.expr &amp;:= temp_name;
        c_expr.expr &amp;:= <span class="stri">">"</span>;
        c_expr.expr &amp;:= integerLiteral(pred(2 ** 32));
        c_expr.expr &amp;:= <span class="stri">")?"</span>;
        c_expr.expr &amp;:= intRaiseError(<span class="stri">"RANGE_ERROR"</span>);
        c_expr.expr &amp;:= <span class="stri">":("</span>;
        c_expr.expr &amp;:= union_name;
        c_expr.expr &amp;:= <span class="stri">".bits=(uint32Type)("</span>;
        c_expr.expr &amp;:= temp_name;
        c_expr.expr &amp;:= <span class="stri">"),"</span>;
        c_expr.expr &amp;:= union_name;
        c_expr.expr &amp;:= <span class="stri">".aFloat))"</span>;
      <span class="keywd">else</span>
        countRangeOptimizations(c_expr);
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        union_name := defineTempVariable(<span class="stri">"float2BitsUnion"</span>, <span class="stri">"conv_"</span>, c_expr);
        c_expr.expr &amp;:= union_name;
        c_expr.expr &amp;:= <span class="stri">".bits=(uint32Type)("</span>;
        process_expr(params[1], c_expr);
        c_expr.expr &amp;:= <span class="stri">"),"</span>;
        c_expr.expr &amp;:= union_name;
        c_expr.expr &amp;:= <span class="stri">".aFloat)"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      incr(count.noRangeChecks);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      union_name := defineTempVariable(<span class="stri">"float2BitsUnion"</span>, <span class="stri">"conv_"</span>, c_expr);
      c_expr.expr &amp;:= union_name;
      c_expr.expr &amp;:= <span class="stri">".bits=(uint32Type)("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">"),"</span>;
      c_expr.expr &amp;:= union_name;
      c_expr.expr &amp;:= <span class="stri">".aFloat)"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_CEIL, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"ceil("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_CMP, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"fltCmp("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    process_expr(params[2], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_COS, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"cos("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_COSH, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"cosh("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_CPY, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    statement.temp_num := c_expr.temp_num;
    process_expr(params[1], statement);
    statement.expr &amp;:= <span class="stri">"="</span>;
    process_expr(params[3], statement);
    statement.expr &amp;:= <span class="stri">";\n"</span>;
    doLocalDeclsOfStatement(statement, c_expr);
    c_expr.temp_num := statement.temp_num;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_DECOMPOSE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: exponentName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> ccConf.FREXP_FUNCTION_OKAY <span class="keywd">then</span>
      exponentName := defineTempVariable(<span class="stri">"int"</span>, <span class="stri">"exponent_"</span>, c_expr);
      process_expr(params[2], c_expr);
      c_expr.expr &amp;:= <span class="stri">" = frexp("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", &amp;"</span>;
      c_expr.expr &amp;:= exponentName;
      c_expr.expr &amp;:= <span class="stri">");\n"</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">" = (intType)("</span>;
      c_expr.expr &amp;:= exponentName;
      c_expr.expr &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">else</span>
      process_expr(params[2], c_expr);
      c_expr.expr &amp;:= <span class="stri">" = fltDecompose("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", &amp;("</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">"));\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_DGTS, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_stri_result(c_expr);
    c_expr.result_expr := <span class="stri">"fltDgts("</span>;
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">", "</span>;
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_flt_div (<span class="op">in</span> <span class="type">reference</span>: dividend, <span class="op">in</span> <span class="type">float</span>: divisor,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedDividend <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">float</span>: quotient <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">string</span>: dividend_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    incr(count.optimizations);
    <span class="keywd">if</span> divisor = 0.0 <span class="op">and</span> (ccConf.FLOAT_ZERO_DIV_ERROR <span class="op">or</span> ccConf.CHECK_FLOAT_DIV_BY_ZERO) <span class="keywd">then</span>
      <span class="keywd">if</span> getConstant(dividend, FLOATOBJECT, evaluatedDividend) <span class="keywd">then</span>
        quotient := getValue(evaluatedDividend, float) / divisor;
        c_expr.expr &amp;:= floatLiteral(quotient);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        dividend_name := getParameterAsVariable(<span class="stri">"floatType"</span>, <span class="stri">"tmp_"</span>, dividend, c_expr);
        c_expr.expr &amp;:= dividend_name;
        c_expr.expr &amp;:= <span class="stri">"==0.0 || os_isnan("</span>;
        c_expr.expr &amp;:= dividend_name;
        c_expr.expr &amp;:= <span class="stri">") ? NOT_A_NUMBER : ("</span>;
        c_expr.expr &amp;:= dividend_name;
        <span class="keywd">if</span> isNegativeZero(divisor) <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"&lt;0.0 ? POSITIVE_INFINITY : NEGATIVE_INFINITY))"</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"&lt;0.0 ? NEGATIVE_INFINITY : POSITIVE_INFINITY))"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      process_expr(dividend, c_expr);
      c_expr.expr &amp;:= <span class="stri">") / "</span>;
      c_expr.expr &amp;:= floatLiteral(divisor);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_DIV, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: dividend <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: divisor <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[3], FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_div(params[1], getValue(evaluatedParam, float), c_expr);
    <span class="keywd">elsif</span> ccConf.FLOAT_ZERO_DIV_ERROR <span class="op">and</span> isActionExpression(params[3], <span class="stri">"FLT_NEGATE"</span>) <span class="op">and</span>
          category(getActionParameter(params[3], 2)) = FLOATOBJECT <span class="op">and</span>
          <span class="op">not</span> isVar(getActionParameter(params[3], 2)) <span class="op">and</span>
          getValue(getActionParameter(params[3], 2), float) = 0.0 <span class="keywd">then</span>
      process_const_flt_div(params[1], getValue(evaluate(prog, params[3]), float), c_expr);
    <span class="keywd">elsif</span> ccConf.FLOAT_ZERO_DIV_ERROR <span class="op">and</span> config.evaluate_const_expr = 0 <span class="op">and</span>
          category(params[3]) = FLOATOBJECT <span class="op">and</span> <span class="op">not</span> isVar(params[3]) <span class="op">and</span>
          getValue(params[3], float) = 0.0 <span class="keywd">then</span>
      process_const_flt_div(params[1], getValue(evaluate(prog, params[3]), float), c_expr);
    <span class="keywd">elsif</span> ccConf.CHECK_FLOAT_DIV_BY_ZERO <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      dividend := getParameterAsVariable(<span class="stri">"floatType"</span>, <span class="stri">"tmp_"</span>, params[1], c_expr);
      divisor := getParameterAsVariable(<span class="stri">"floatType"</span>, <span class="stri">"tmp_"</span>, params[3], c_expr);
      c_expr.expr &amp;:= divisor;
      c_expr.expr &amp;:= <span class="stri">"==0.0 ? ("</span>;
      c_expr.expr &amp;:= dividend;
      c_expr.expr &amp;:= <span class="stri">"==0.0 || os_isnan("</span>;
      c_expr.expr &amp;:= dividend;
      c_expr.expr &amp;:= <span class="stri">") ? NOT_A_NUMBER : (("</span>;
      c_expr.expr &amp;:= dividend;
      c_expr.expr &amp;:= <span class="stri">"&lt;0.0)==fltIsNegativeZero("</span>;
      c_expr.expr &amp;:= divisor;
      c_expr.expr &amp;:= <span class="stri">") ? POSITIVE_INFINITY : NEGATIVE_INFINITY)) : "</span>;
      c_expr.expr &amp;:= dividend;
      c_expr.expr &amp;:= <span class="stri">" / "</span>;
      c_expr.expr &amp;:= divisor;
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">") / ("</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_flt_div_assign (<span class="op">in</span> <span class="type">reference</span>: param1, <span class="op">in</span> <span class="type">float</span>: divisor,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">string</span>: dividend <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    incr(count.optimizations);
    <span class="keywd">if</span> divisor = 0.0 <span class="op">and</span> (ccConf.FLOAT_ZERO_DIV_ERROR <span class="op">or</span> ccConf.CHECK_FLOAT_DIV_BY_ZERO) <span class="keywd">then</span>
      <span class="keywd">if</span> isNormalVariable(param1) <span class="keywd">then</span>
        dividend := normalVariable(param1, statement);
      <span class="keywd">else</span>
        incr(statement.temp_num);
        dividend := <span class="stri">"tmp_"</span> &amp; str(statement.temp_num);
        statement.temp_decls &amp;:= <span class="stri">"floatType *"</span>;
        statement.temp_decls &amp;:= dividend;
        statement.temp_decls &amp;:= <span class="stri">";\n"</span>;
        statement.expr &amp;:= dividend;
        statement.expr &amp;:= <span class="stri">"=&amp;("</span>;
        process_expr(param1, statement);
        statement.expr &amp;:= <span class="stri">");\n"</span>;
        dividend := <span class="stri">"*"</span> &amp; dividend;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      statement.expr &amp;:= dividend;
      statement.expr &amp;:= <span class="stri">"=("</span>;
      statement.expr &amp;:= dividend;
      statement.expr &amp;:= <span class="stri">"==0.0 || os_isnan("</span>;
      statement.expr &amp;:= dividend;
      statement.expr &amp;:= <span class="stri">") ? NOT_A_NUMBER : ("</span>;
      statement.expr &amp;:= dividend;
      <span class="keywd">if</span> isNegativeZero(divisor) <span class="keywd">then</span>
        statement.expr &amp;:= <span class="stri">"&lt;0.0 ? POSITIVE_INFINITY : NEGATIVE_INFINITY));\n"</span>;
      <span class="keywd">else</span>
        statement.expr &amp;:= <span class="stri">"&lt;0.0 ? NEGATIVE_INFINITY : POSITIVE_INFINITY));\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      statement.expr &amp;:= <span class="stri">"("</span>;
      process_expr(param1, statement);
      statement.expr &amp;:= <span class="stri">")/="</span>; <span class="comment"># icc has problems if */ precedes /=</span>
      statement.expr &amp;:= floatLiteral(divisor);
      statement.expr &amp;:= <span class="stri">";\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    doLocalDeclsOfStatement(statement, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_DIV_ASSIGN, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">string</span>: dividend <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: divisor <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[3], FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_div_assign(params[1], getValue(evaluatedParam, float), c_expr);
    <span class="keywd">elsif</span> ccConf.FLOAT_ZERO_DIV_ERROR <span class="op">and</span> isActionExpression(params[3], <span class="stri">"FLT_NEGATE"</span>) <span class="op">and</span>
        category(getActionParameter(params[3], 2)) = FLOATOBJECT <span class="op">and</span>
        <span class="op">not</span> isVar(getActionParameter(params[3], 2)) <span class="keywd">then</span>
      process_const_flt_div_assign(params[1], getValue(evaluate(prog, params[3]), float), c_expr);
    <span class="keywd">elsif</span> ccConf.CHECK_FLOAT_DIV_BY_ZERO <span class="keywd">then</span>
      <span class="keywd">if</span> isNormalVariable(params[1]) <span class="keywd">then</span>
        dividend := normalVariable(params[1], statement);
      <span class="keywd">else</span>
        incr(statement.temp_num);
        dividend := <span class="stri">"tmp_"</span> &amp; str(statement.temp_num);
        statement.temp_decls &amp;:= <span class="stri">"floatType *"</span>;
        statement.temp_decls &amp;:= dividend;
        statement.temp_decls &amp;:= <span class="stri">";\n"</span>;
        statement.expr &amp;:= dividend;
        statement.expr &amp;:= <span class="stri">"=&amp;("</span>;
        process_expr(params[1], statement);
        statement.expr &amp;:= <span class="stri">");\n"</span>;
        dividend := <span class="stri">"*"</span> &amp; dividend;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> isNormalVariable(params[3]) <span class="keywd">then</span>
        divisor := normalVariable(params[3], statement);
      <span class="keywd">else</span>
        incr(statement.temp_num);
        divisor := <span class="stri">"tmp_"</span> &amp; str(statement.temp_num);
        statement.temp_decls &amp;:= <span class="stri">"floatType "</span>;
        statement.temp_decls &amp;:= divisor;
        statement.temp_decls &amp;:= <span class="stri">";\n"</span>;
        statement.expr &amp;:= divisor;
        statement.expr &amp;:= <span class="stri">"="</span>;
        process_expr(params[3], statement);
        statement.expr &amp;:= <span class="stri">";\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      statement.expr &amp;:= dividend;
      statement.expr &amp;:= <span class="stri">"=("</span>;
      statement.expr &amp;:= divisor;
      statement.expr &amp;:= <span class="stri">"==0.0 ? ("</span>;
      statement.expr &amp;:= dividend;
      statement.expr &amp;:= <span class="stri">"==0.0 || os_isnan("</span>;
      statement.expr &amp;:= dividend;
      statement.expr &amp;:= <span class="stri">") ? NOT_A_NUMBER : (("</span>;
      statement.expr &amp;:= dividend;
      statement.expr &amp;:= <span class="stri">"&lt;0.0)==fltIsNegativeZero("</span>;
      statement.expr &amp;:= divisor;
      statement.expr &amp;:= <span class="stri">") ? POSITIVE_INFINITY : NEGATIVE_INFINITY)) : "</span>;
      statement.expr &amp;:= dividend;
      statement.expr &amp;:= <span class="stri">" / "</span>;
      statement.expr &amp;:= divisor;
      statement.expr &amp;:= <span class="stri">");\n"</span>;
      doLocalDeclsOfStatement(statement, c_expr);
    <span class="keywd">else</span>
      statement.expr &amp;:= <span class="stri">"("</span>;
      process_expr(params[1], statement);
      statement.expr &amp;:= <span class="stri">")/="</span>; <span class="comment"># icc has problems if */ precedes /=</span>
      process_expr(params[3], statement);
      statement.expr &amp;:= <span class="stri">";\n"</span>;
      doLocalDeclsOfStatement(statement, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_DOUBLE2BITS, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: union_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    union_name := defineTempVariable(<span class="stri">"double2BitsUnion"</span>, <span class="stri">"conv_"</span>, c_expr);
    c_expr.expr &amp;:= <span class="stri">"("</span>;
    c_expr.expr &amp;:= union_name;
    c_expr.expr &amp;:= <span class="stri">".aDouble="</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">",(intType)(uintType)("</span>;
    c_expr.expr &amp;:= union_name;
    c_expr.expr &amp;:= <span class="stri">".bits))"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_flt_eq (<span class="op">in</span> <span class="type">float</span>: number, <span class="op">in</span> <span class="type">reference</span>: param3,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">float</span>: number2 <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isNaN(number) <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= <span class="stri">"0/*NaN == anything*/"</span>;
    <span class="keywd">elsif</span> getConstant(param3, FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      incr(count.optimizations);
      number2 := getValue(evaluatedParam, float);
      c_expr.expr &amp;:= str(ord(number = number2));
      c_expr.expr &amp;:= <span class="stri">"/*"</span>;
      c_expr.expr &amp;:= str(number);
      c_expr.expr &amp;:= <span class="stri">" == "</span>;
      c_expr.expr &amp;:= str(number2);
      c_expr.expr &amp;:= <span class="stri">"*/"</span>;
    <span class="keywd">elsif</span> <span class="op">not</span> ccConf.FLOAT_COMPARISON_OKAY <span class="keywd">then</span>
      programUses.mathLibrary := TRUE;
      c_expr.expr &amp;:= <span class="stri">"fltEq("</span>;
      c_expr.expr &amp;:= floatLiteral(number);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(param3, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= floatLiteral(number);
      c_expr.expr &amp;:= <span class="stri">" == ("</span>;
      process_expr(param3, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;

<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_EQ, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_eq(getValue(evaluatedParam, float), params[3], c_expr);
    <span class="keywd">elsif</span> getConstant(params[3], FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_eq(getValue(evaluatedParam, float), params[1], c_expr);
    <span class="keywd">elsif</span> <span class="op">not</span> ccConf.FLOAT_COMPARISON_OKAY <span class="keywd">then</span>
      programUses.mathLibrary := TRUE;
      c_expr.expr &amp;:= <span class="stri">"fltEq("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">") == ("</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_EXP, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"fltExp("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_EXPM1, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"fltExpM1("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_FLOOR, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"floor("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_flt_ge (<span class="op">in</span> <span class="type">float</span>: number, <span class="op">in</span> <span class="type">reference</span>: param3,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">float</span>: number2 <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isNaN(number) <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= <span class="stri">"0/*NaN >= anything*/"</span>;
    <span class="keywd">elsif</span> getConstant(param3, FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      incr(count.optimizations);
      number2 := getValue(evaluatedParam, float);
      c_expr.expr &amp;:= str(ord(number >= number2));
      c_expr.expr &amp;:= <span class="stri">"/*"</span>;
      c_expr.expr &amp;:= str(number);
      c_expr.expr &amp;:= <span class="stri">" >= "</span>;
      c_expr.expr &amp;:= str(number2);
      c_expr.expr &amp;:= <span class="stri">"*/"</span>;
    <span class="keywd">elsif</span> <span class="op">not</span> ccConf.FLOAT_COMPARISON_OKAY <span class="keywd">then</span>
      programUses.mathLibrary := TRUE;
      c_expr.expr &amp;:= <span class="stri">"fltGe("</span>;
      c_expr.expr &amp;:= floatLiteral(number);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(param3, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= floatLiteral(number);
      c_expr.expr &amp;:= <span class="stri">" >= ("</span>;
      process_expr(param3, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_flt_ge (<span class="op">in</span> <span class="type">reference</span>: param1, <span class="op">in</span> <span class="type">float</span>: number,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> isNaN(number) <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= <span class="stri">"0/*anything >= NaN*/"</span>;
    <span class="keywd">elsif</span> <span class="op">not</span> ccConf.FLOAT_COMPARISON_OKAY <span class="keywd">then</span>
      programUses.mathLibrary := TRUE;
      c_expr.expr &amp;:= <span class="stri">"fltGe("</span>;
      process_expr(param1, c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      c_expr.expr &amp;:= floatLiteral(number);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      process_expr(param1, c_expr);
      c_expr.expr &amp;:= <span class="stri">") >= "</span>;
      c_expr.expr &amp;:= floatLiteral(number);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_GE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_ge(getValue(evaluatedParam, float), params[3], c_expr);
    <span class="keywd">elsif</span> getConstant(params[3], FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_ge(params[1], getValue(evaluatedParam, float), c_expr);
    <span class="keywd">elsif</span> <span class="op">not</span> ccConf.FLOAT_COMPARISON_OKAY <span class="keywd">then</span>
      programUses.mathLibrary := TRUE;
      c_expr.expr &amp;:= <span class="stri">"fltGe("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">") >= ("</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_GT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> <span class="op">not</span> ccConf.FLOAT_COMPARISON_OKAY <span class="keywd">then</span>
      programUses.mathLibrary := TRUE;
      c_expr.expr &amp;:= <span class="stri">"fltGt("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">") > ("</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_HASHCODE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: temp_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    temp_name := defineTempVariable(<span class="stri">"rtlValueUnion"</span>, <span class="stri">"tmp_"</span>, c_expr);
    c_expr.expr &amp;:= <span class="stri">"("</span>;
    c_expr.expr &amp;:= temp_name;
    c_expr.expr &amp;:= <span class="stri">".floatValue="</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">","</span>;
    c_expr.expr &amp;:= temp_name;
    c_expr.expr &amp;:= <span class="stri">".intValue)"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_ICONV1, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"(floatType)("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_ICONV3, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"(floatType)("</span>;
    process_expr(params[3], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_flt_ipow (<span class="op">in</span> <span class="type">float</span>: base, <span class="op">in</span> <span class="type">reference</span>: exponent,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedExponent <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">intRange</span>: exponentRange <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">string</span>: exponentName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(exponent, INTOBJECT, evaluatedExponent) <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= floatLiteral(base ** getValue(evaluatedExponent, integer));
    <span class="keywd">elsif</span> base = -1.0 <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"(("</span>;
      process_expr(exponent, c_expr);
      c_expr.expr &amp;:= <span class="stri">")&amp;1?"</span>;
      c_expr.expr &amp;:= floatLiteral(-1.0);
      c_expr.expr &amp;:= <span class="stri">":"</span>;
      c_expr.expr &amp;:= floatLiteral(1.0);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">elsif</span> base = 0.0 <span class="keywd">then</span>
      incr(count.optimizations);
      exponentRange := getIntRange(exponent);
      <span class="keywd">if</span> isNegativeZero(base) <span class="keywd">then</span>
        <span class="keywd">if</span> exponentRange.maxValue &lt; 0 <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"("</span>;
          process_expr(exponent, c_expr);
          c_expr.expr &amp;:= <span class="stri">")&amp;1?"</span>;
          c_expr.expr &amp;:= floatLiteral(-Infinity);
          c_expr.expr &amp;:= <span class="stri">":"</span>;
          c_expr.expr &amp;:= floatLiteral(Infinity);
        <span class="keywd">elsif</span> exponentRange.minValue > 0 <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"("</span>;
          process_expr(exponent, c_expr);
          c_expr.expr &amp;:= <span class="stri">")&amp;1?"</span>;
          c_expr.expr &amp;:= floatLiteral(-0.0);
          c_expr.expr &amp;:= <span class="stri">":0.0"</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"("</span>;
          exponentName := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"exp_"</span>, exponent, c_expr);
          <span class="keywd">if</span> exponentRange.minValue &lt; 0 <span class="keywd">then</span>
            c_expr.expr &amp;:= exponentName;
            c_expr.expr &amp;:= <span class="stri">"&lt;0?("</span>;
            c_expr.expr &amp;:= exponentName;
            c_expr.expr &amp;:= <span class="stri">"&amp;1?"</span>;
            c_expr.expr &amp;:= floatLiteral(-Infinity);
            c_expr.expr &amp;:= <span class="stri">":"</span>;
            c_expr.expr &amp;:= floatLiteral(Infinity);
            c_expr.expr &amp;:= <span class="stri">"):"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> exponentRange.maxValue > 0 <span class="keywd">then</span>
            <span class="keywd">if</span> exponentRange.minValue &lt; 0 <span class="keywd">then</span>
              c_expr.expr &amp;:= <span class="stri">"("</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            c_expr.expr &amp;:= exponentName;
            c_expr.expr &amp;:= <span class="stri">">0?("</span>;
            c_expr.expr &amp;:= exponentName;
            c_expr.expr &amp;:= <span class="stri">"&amp;1?"</span>;
            c_expr.expr &amp;:= floatLiteral(-0.0);
            c_expr.expr &amp;:= <span class="stri">":0.0):"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">"1.0"</span>;
          <span class="keywd">if</span> exponentRange.maxValue > 0 <span class="op">and</span>
              exponentRange.minValue &lt; 0 <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">")"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        <span class="keywd">if</span> exponentRange.maxValue &lt; 0 <span class="keywd">then</span>
          c_expr.expr &amp;:= floatLiteral(Infinity);
        <span class="keywd">elsif</span> exponentRange.minValue > 0 <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"0.0"</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"("</span>;
          exponentName := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"exp_"</span>, exponent, c_expr);
          <span class="keywd">if</span> exponentRange.minValue &lt; 0 <span class="keywd">then</span>
            c_expr.expr &amp;:= exponentName;
            c_expr.expr &amp;:= <span class="stri">"&lt;0?"</span>;
            c_expr.expr &amp;:= floatLiteral(Infinity);
            c_expr.expr &amp;:= <span class="stri">":"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> exponentRange.maxValue > 0 <span class="keywd">then</span>
            c_expr.expr &amp;:= exponentName;
            c_expr.expr &amp;:= <span class="stri">">0?0.0:"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">"1.0)"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> base = 1.0 <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= floatLiteral(1.0);
    <span class="keywd">elsif</span> base = -2.0 <span class="keywd">then</span>
      incr(count.optimizations);
      exponentRange := getIntRange(exponent);
      <span class="keywd">if</span> exponentRange.minValue >= ccConf.INT_MIN <span class="op">and</span>
          exponentRange.maxValue &lt;= ccConf.INT_MAX <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        exponentName := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"exp_"</span>, exponent, c_expr);
        c_expr.expr &amp;:= <span class="stri">"fltLdexp("</span>;
        c_expr.expr &amp;:= exponentName;
        c_expr.expr &amp;:= <span class="stri">"&amp;1? -1.0:1.0, (int)"</span>;
        c_expr.expr &amp;:= exponentName;
        c_expr.expr &amp;:= <span class="stri">"))"</span>;
      <span class="keywd">elsif</span> exponentRange.maxValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        process_expr(exponent, c_expr);
        c_expr.expr &amp;:= <span class="stri">")&amp;1?"</span>;
        c_expr.expr &amp;:= floatLiteral(-0.0);
        c_expr.expr &amp;:= <span class="stri">":0.0"</span>;
      <span class="keywd">elsif</span> exponentRange.minValue > ccConf.INT_MAX <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        process_expr(exponent, c_expr);
        c_expr.expr &amp;:= <span class="stri">")&amp;1?"</span>;
        c_expr.expr &amp;:= floatLiteral(-Infinity);
        c_expr.expr &amp;:= <span class="stri">":"</span>;
        c_expr.expr &amp;:= floatLiteral(Infinity);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        exponentName := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"exp_"</span>, exponent, c_expr);
        c_expr.expr &amp;:= <span class="stri">"fltLdexp("</span>;
        c_expr.expr &amp;:= exponentName;
        c_expr.expr &amp;:= <span class="stri">"&amp;1? -1.0:1.0, (int)("</span>;
        <span class="keywd">if</span> exponentRange.minValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
          c_expr.expr &amp;:= exponentName;
          c_expr.expr &amp;:= <span class="stri">"&lt;"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MIN);
          c_expr.expr &amp;:= <span class="stri">"?"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MIN);
          c_expr.expr &amp;:= <span class="stri">":"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> exponentRange.maxValue > ccConf.INT_MAX <span class="keywd">then</span>
          <span class="keywd">if</span> exponentRange.minValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"("</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= exponentName;
          c_expr.expr &amp;:= <span class="stri">">"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MAX);
          c_expr.expr &amp;:= <span class="stri">"?"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MAX);
          c_expr.expr &amp;:= <span class="stri">":"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= exponentName;
        <span class="keywd">if</span> exponentRange.maxValue > ccConf.INT_MAX <span class="op">and</span>
            exponentRange.minValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">")))"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> base = 2.0 <span class="keywd">then</span>
      incr(count.optimizations);
      exponentRange := getIntRange(exponent);
      <span class="keywd">if</span> exponentRange.minValue >= ccConf.INT_MIN <span class="op">and</span>
          exponentRange.maxValue &lt;= ccConf.INT_MAX <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"fltLdexp(1.0, (int)("</span>;
        process_expr(exponent, c_expr);
        c_expr.expr &amp;:= <span class="stri">"))"</span>;
      <span class="keywd">elsif</span> exponentRange.maxValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
        c_expr.expr &amp;:= floatLiteral(0.0);
      <span class="keywd">elsif</span> exponentRange.minValue > ccConf.INT_MAX <span class="keywd">then</span>
        c_expr.expr &amp;:= floatLiteral(Infinity);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        exponentName := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"exp_"</span>, exponent, c_expr);
        <span class="keywd">if</span> exponentRange.minValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
          c_expr.expr &amp;:= exponentName;
          c_expr.expr &amp;:= <span class="stri">"&lt;"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MIN);
          c_expr.expr &amp;:= <span class="stri">"?0.0:"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> exponentRange.maxValue > ccConf.INT_MAX <span class="keywd">then</span>
          <span class="keywd">if</span> exponentRange.minValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"("</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= exponentName;
          c_expr.expr &amp;:= <span class="stri">">"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MAX);
          c_expr.expr &amp;:= <span class="stri">"?"</span>;
          c_expr.expr &amp;:= floatLiteral(Infinity);
          c_expr.expr &amp;:= <span class="stri">":"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"fltLdexp(1.0, (int)"</span>;
        c_expr.expr &amp;:= exponentName;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">if</span> exponentRange.maxValue > ccConf.INT_MAX <span class="op">and</span>
            exponentRange.minValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> base >= 4.0 <span class="op">and</span>
          base &lt;= flt(ccConf.INT_RANGE_IN_FLOATTYPE_MAX) <span class="op">and</span>
          floor(base) = base <span class="op">and</span>
          2 ** log2(trunc(base)) = trunc(base) <span class="keywd">then</span>
      incr(count.optimizations);
      exponentRange := getIntRange(exponent);
      <span class="keywd">if</span> exponentRange.minValue >= ccConf.INT_MIN <span class="op">div</span> log2(trunc(base)) <span class="op">and</span>
          exponentRange.maxValue &lt;= ccConf.INT_MAX <span class="op">div</span> log2(trunc(base)) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"fltLdexp(1.0, (int)("</span>;
        process_expr(exponent, c_expr);
        c_expr.expr &amp;:= <span class="stri">")*"</span>;
        c_expr.expr &amp;:= str(log2(trunc(base)));
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">elsif</span> exponentRange.maxValue &lt; ccConf.INT_MIN <span class="op">div</span> log2(trunc(base)) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"0.0"</span>;
      <span class="keywd">elsif</span> exponentRange.minValue > ccConf.INT_MAX <span class="op">div</span> log2(trunc(base)) <span class="keywd">then</span>
        c_expr.expr &amp;:= floatLiteral(Infinity);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        exponentName := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"exp_"</span>, exponent, c_expr);
        <span class="keywd">if</span> exponentRange.minValue &lt; ccConf.INT_MIN <span class="op">div</span> log2(trunc(base)) <span class="keywd">then</span>
          c_expr.expr &amp;:= exponentName;
          c_expr.expr &amp;:= <span class="stri">"&lt;"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MIN <span class="op">div</span> log2(trunc(base)));
          c_expr.expr &amp;:= <span class="stri">"?0.0:"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> exponentRange.maxValue > ccConf.INT_MAX <span class="op">div</span> log2(trunc(base)) <span class="keywd">then</span>
          <span class="keywd">if</span> exponentRange.minValue &lt; ccConf.INT_MIN <span class="op">div</span> log2(trunc(base)) <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"("</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= exponentName;
          c_expr.expr &amp;:= <span class="stri">">"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MAX <span class="op">div</span> log2(trunc(base)));
          c_expr.expr &amp;:= <span class="stri">"?"</span>;
          c_expr.expr &amp;:= floatLiteral(Infinity);
          c_expr.expr &amp;:= <span class="stri">":"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"fltLdexp(1.0, (int)"</span>;
        c_expr.expr &amp;:= exponentName;
        c_expr.expr &amp;:= <span class="stri">"*"</span>;
        c_expr.expr &amp;:= str(log2(trunc(base)));
        c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">if</span> exponentRange.maxValue > ccConf.INT_MAX <span class="op">div</span> log2(trunc(base)) <span class="op">and</span>
            exponentRange.minValue &lt; ccConf.INT_MIN <span class="op">div</span> log2(trunc(base)) <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"fltIPow("</span>;
      c_expr.expr &amp;:= floatLiteral(base);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(exponent, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_flt_ipow (<span class="op">in</span> <span class="type">reference</span>: base, <span class="op">in</span> <span class="type">integer</span>: exponent,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: power <span class="keywd">is</span> [2] (
        <span class="comment">(*  2 *)</span> <span class="stri">"x*x"</span>, <span class="stri">"x*x*x"</span>, <span class="stri">"(a=x*x,a*a)"</span>, <span class="stri">"(a=x*x,a*a*x)"</span>, <span class="stri">"(a=x*x*x,a*a)"</span>,
        <span class="comment">(*  7 *)</span> <span class="stri">"(a=x*x,a*a*a*x)"</span>, <span class="stri">"(b=(a=x*x,a*a),b*b)"</span>, <span class="stri">"(b=(a=x*x,a*a),b*b*x)"</span>,
        <span class="comment">(* 10 *)</span> <span class="stri">"(b=(a=x*x,a*a*x),b*b)"</span>, <span class="stri">"(b=(a=x*x,a*a*x),b*b*x)"</span>,
        <span class="comment">(* 12 *)</span> <span class="stri">"(b=(a=x*x*x,a*a),b*b)"</span>, <span class="stri">"(b=(a=x*x,a*a),b*b*b*x)"</span>,
        <span class="comment">(* 14 *)</span> <span class="stri">"(b=(a=x*x,a*a*a*x),b*b)"</span>, <span class="stri">"(b=(a=x*x*x,a*a),b*b*a)"</span>,
        <span class="comment">(* 16 *)</span> <span class="stri">"(c=(b=(a=x*x,a*a),b*b),c*c)"</span>, <span class="stri">"(c=(b=(a=x*x,a*a),b*b),c*c*x)"</span>,
        <span class="comment">(* 18 *)</span> <span class="stri">"(c=(b=(a=x*x,a*a),b*b),c*c*a)"</span>, <span class="stri">"(c=(b=(a=x*x,a*a*x),b*a),c*c*b)"</span>,
        <span class="comment">(* 20 *)</span> <span class="stri">"(c=(b=(a=x*x,a*a*x),b*b),c*c)"</span>, <span class="stri">"(c=(b=(a=x*x,a*a*x),b*b),c*c*x)"</span>,
        <span class="comment">(* 22 *)</span> <span class="stri">"(c=(b=(a=x*x,a*a*x),b*b*x),c*c)"</span>);
    <span class="keywd">const</span> <span class="type">string</span>: variables <span class="keywd">is</span> <span class="stri">"abc"</span>;
    <span class="keywd">var</span> <span class="type">string</span>: powerTemplate <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: baseName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: variableName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> exponent = -1 <span class="keywd">then</span>
      incr(count.optimizations);
      <span class="keywd">if</span> ccConf.CHECK_FLOAT_DIV_BY_ZERO <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        baseName := getParameterAsVariable(<span class="stri">"floatType"</span>, <span class="stri">"tmp_"</span>, base, c_expr);
        c_expr.expr &amp;:= baseName;
        c_expr.expr &amp;:= <span class="stri">"==0.0 ? (fltIsNegativeZero("</span>;
        c_expr.expr &amp;:= baseName;
        c_expr.expr &amp;:= <span class="stri">") ? NEGATIVE_INFINITY : POSITIVE_INFINITY) : 1.0 / "</span>;
        c_expr.expr &amp;:= baseName;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"1.0 / ("</span>;
        process_expr(base, c_expr);
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exponent = 0 <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= floatLiteral(1.0);
    <span class="keywd">elsif</span> exponent = 1 <span class="keywd">then</span>
      incr(count.optimizations);
      process_expr(base, c_expr);
    <span class="keywd">elsif</span> exponent &lt; 0 <span class="op">and</span> exponent <span class="op">in</span> {-maxIdx(power) .. -2} <span class="keywd">then</span>
      incr(count.optimizations);
      powerTemplate := power[-exponent];
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      baseName := getParameterAsVariable(<span class="stri">"floatType"</span>, <span class="stri">"tmp_"</span>, base, c_expr);
      <span class="keywd">for</span> ch <span class="keywd">range</span> variables <span class="keywd">do</span>
        <span class="keywd">if</span> pos(powerTemplate, ch) &lt;> 0 <span class="keywd">then</span>
          variableName := defineTempVariable(<span class="stri">"floatType"</span>, str(ch) &amp; <span class="stri">"_"</span>, c_expr);
          powerTemplate := replace(powerTemplate, str(ch), variableName);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">if</span> ccConf.CHECK_FLOAT_DIV_BY_ZERO <span class="keywd">then</span>
        c_expr.expr &amp;:= baseName;
        c_expr.expr &amp;:= <span class="stri">"==0.0 ? "</span>;
        <span class="keywd">if</span> odd(exponent) <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"(fltIsNegativeZero("</span>;
          c_expr.expr &amp;:= baseName;
          c_expr.expr &amp;:= <span class="stri">") ? NEGATIVE_INFINITY : POSITIVE_INFINITY) : "</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"POSITIVE_INFINITY : "</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">"1.0 / ("</span>;
      c_expr.expr &amp;:= replace(powerTemplate, <span class="stri">"x"</span>, baseName);
      c_expr.expr &amp;:= <span class="stri">"))"</span>;
    <span class="keywd">elsif</span> exponent <span class="op">in</span> {2 .. maxIdx(power)} <span class="keywd">then</span>
      incr(count.optimizations);
      powerTemplate := power[exponent];
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      baseName := getParameterAsVariable(<span class="stri">"floatType"</span>, <span class="stri">"tmp_"</span>, base, c_expr);
      <span class="keywd">for</span> ch <span class="keywd">range</span> variables <span class="keywd">do</span>
        <span class="keywd">if</span> pos(powerTemplate, ch) &lt;> 0 <span class="keywd">then</span>
          variableName := defineTempVariable(<span class="stri">"floatType"</span>, str(ch) &amp; <span class="stri">"_"</span>, c_expr);
          powerTemplate := replace(powerTemplate, str(ch), variableName);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      c_expr.expr &amp;:= replace(powerTemplate, <span class="stri">"x"</span>, baseName);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">elsif</span> exponent >= -ccConf.INT_RANGE_IN_FLOATTYPE_MAX <span class="op">and</span>
          exponent &lt;= ccConf.INT_RANGE_IN_FLOATTYPE_MAX <span class="op">and</span>
          ccConf.POW_FUNCTION_OKAY <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"pow("</span>;
      process_expr(base, c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      c_expr.expr &amp;:= floatLiteral(flt(exponent));
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"fltIPow("</span>;
      process_expr(base, c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      c_expr.expr &amp;:= integerLiteral(exponent);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_IPOW, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_ipow(getValue(evaluatedParam, float), params[3], c_expr);
    <span class="keywd">elsif</span> getConstant(params[3], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_ipow(params[1], getValue(evaluatedParam, integer), c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"fltIPow("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_ISNAN, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: argument_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="comment"># There are two reasons to use a variable as argument of os_isnan():</span>
    <span class="comment"># 1. os_isnan() is probably a macro, which might evaluate the argument</span>
    <span class="comment">#    multiple times.</span>
    <span class="comment"># 2. The argument of os_isnan() might contain preprocessor directives.</span>
    <span class="comment">#    Some C compilers do not allow preprocessor directives (e.g.</span>
    <span class="comment">#    #line directives) in the argument list of a macro.</span>
    c_expr.expr &amp;:= <span class="stri">"("</span>;
    argument_name := getParameterAsVariable(<span class="stri">"floatType"</span>, <span class="stri">"arg_"</span>, params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">"os_isnan("</span>;
    c_expr.expr &amp;:= argument_name;
    c_expr.expr &amp;:= <span class="stri">"))"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_ISNEGATIVEZERO, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"fltIsNegativeZero("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_flt_le (<span class="op">in</span> <span class="type">float</span>: number, <span class="op">in</span> <span class="type">reference</span>: param3,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">float</span>: number2 <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isNaN(number) <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= <span class="stri">"0/*NaN &lt;= anything*/"</span>;
    <span class="keywd">elsif</span> getConstant(param3, FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      incr(count.optimizations);
      number2 := getValue(evaluatedParam, float);
      c_expr.expr &amp;:= str(ord(number &lt;= number2));
      c_expr.expr &amp;:= <span class="stri">"/*"</span>;
      c_expr.expr &amp;:= str(number);
      c_expr.expr &amp;:= <span class="stri">" &lt;= "</span>;
      c_expr.expr &amp;:= str(number2);
      c_expr.expr &amp;:= <span class="stri">"*/"</span>;
    <span class="keywd">elsif</span> <span class="op">not</span> ccConf.FLOAT_COMPARISON_OKAY <span class="keywd">then</span>
      programUses.mathLibrary := TRUE;
      c_expr.expr &amp;:= <span class="stri">"fltLe("</span>;
      c_expr.expr &amp;:= floatLiteral(number);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(param3, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= floatLiteral(number);
      c_expr.expr &amp;:= <span class="stri">" &lt;= ("</span>;
      process_expr(param3, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_flt_le (<span class="op">in</span> <span class="type">reference</span>: param1, <span class="op">in</span> <span class="type">float</span>: number,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> isNaN(number) <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= <span class="stri">"0/*anything &lt;= NaN*/"</span>;
    <span class="keywd">elsif</span> <span class="op">not</span> ccConf.FLOAT_COMPARISON_OKAY <span class="keywd">then</span>
      programUses.mathLibrary := TRUE;
      c_expr.expr &amp;:= <span class="stri">"fltLe("</span>;
      process_expr(param1, c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      c_expr.expr &amp;:= floatLiteral(number);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      process_expr(param1, c_expr);
      c_expr.expr &amp;:= <span class="stri">") &lt;= "</span>;
      c_expr.expr &amp;:= floatLiteral(number);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_LE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_le(getValue(evaluatedParam, float), params[3], c_expr);
    <span class="keywd">elsif</span> getConstant(params[3], FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_le(params[1], getValue(evaluatedParam, float), c_expr);
    <span class="keywd">elsif</span> <span class="op">not</span> ccConf.FLOAT_COMPARISON_OKAY <span class="keywd">then</span>
      programUses.mathLibrary := TRUE;
      c_expr.expr &amp;:= <span class="stri">"fltLe("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">") &lt;= ("</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_LOG, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"fltLog("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_LOG10, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"fltLog10("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_LOG1P, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"fltLog1p("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_LOG2, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"fltLog2("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_flt_lshift (<span class="op">in</span> <span class="type">float</span>: number, <span class="op">in</span> <span class="type">reference</span>: lshift,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">intRange</span>: lshiftRange <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">integer</span>: lshiftNum <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: lshiftName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> number = 0.0 <span class="op">or</span> abs(number) = Infinity <span class="op">or</span> isNaN(number) <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= floatLiteral(number);
    <span class="keywd">elsif</span> getConstant(lshift, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      incr(count.optimizations);
      lshiftNum := getValue(evaluatedParam, integer);
      c_expr.expr &amp;:= floatLiteral(number &lt;&lt; lshiftNum);
    <span class="keywd">else</span>
      lshiftRange := getIntRange(lshift);
      <span class="keywd">if</span> lshiftRange.minValue >= ccConf.INT_MIN <span class="op">and</span>
          lshiftRange.maxValue &lt;= ccConf.INT_MAX <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"fltLdexp("</span>;
        c_expr.expr &amp;:= floatLiteral(number);
        c_expr.expr &amp;:= <span class="stri">", (int)("</span>;
        process_expr(lshift, c_expr);
        c_expr.expr &amp;:= <span class="stri">"))"</span>;
      <span class="keywd">elsif</span> lshiftRange.maxValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
        <span class="keywd">if</span> number &lt; 0.0 <span class="keywd">then</span>
          c_expr.expr &amp;:= floatLiteral(-0.0);
        <span class="keywd">else</span>
          c_expr.expr &amp;:= floatLiteral(0.0);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> lshiftRange.minValue > ccConf.INT_MAX <span class="keywd">then</span>
        <span class="keywd">if</span> number &lt; 0.0 <span class="keywd">then</span>
          c_expr.expr &amp;:= floatLiteral(-Infinity);
        <span class="keywd">else</span>
          c_expr.expr &amp;:= floatLiteral(Infinity);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        lshiftName := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"lshift_"</span>, lshift, c_expr);
        <span class="keywd">if</span> lshiftRange.minValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
          c_expr.expr &amp;:= lshiftName;
          c_expr.expr &amp;:= <span class="stri">"&lt;"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MIN);
          c_expr.expr &amp;:= <span class="stri">"?"</span>;
          <span class="keywd">if</span> number &lt; 0.0 <span class="keywd">then</span>
            c_expr.expr &amp;:= floatLiteral(-0.0);
          <span class="keywd">else</span>
            c_expr.expr &amp;:= floatLiteral(0.0);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">":"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> lshiftRange.maxValue > ccConf.INT_MAX <span class="keywd">then</span>
          <span class="keywd">if</span> lshiftRange.minValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"("</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= lshiftName;
          c_expr.expr &amp;:= <span class="stri">">"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MAX);
          c_expr.expr &amp;:= <span class="stri">"?"</span>;
          <span class="keywd">if</span> number &lt; 0.0 <span class="keywd">then</span>
            c_expr.expr &amp;:= floatLiteral(-Infinity);
          <span class="keywd">else</span>
            c_expr.expr &amp;:= floatLiteral(Infinity);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">":"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"fltLdexp("</span>;
        c_expr.expr &amp;:= floatLiteral(number);
        c_expr.expr &amp;:= <span class="stri">", (int)"</span>;
        c_expr.expr &amp;:= lshiftName;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">if</span> lshiftRange.maxValue > ccConf.INT_MAX <span class="op">and</span>
            lshiftRange.minValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_flt_lshift (<span class="op">in</span> <span class="type">reference</span>: number, <span class="op">in</span> <span class="type">integer</span>: lshift,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">float</span>: powerOfTwo <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> lshift = 0 <span class="keywd">then</span>
      incr(count.optimizations);
      process_expr(number, c_expr);
    <span class="keywd">else</span>
      powerOfTwo := 2.0 ** lshift;
      <span class="keywd">if</span> powerOfTwo > 1.0 <span class="op">and</span> powerOfTwo &lt; Infinity <span class="keywd">then</span>
        <span class="comment"># The range (0.0 to 1.0] would also work,</span>
        <span class="comment"># but extended precision computations makes tests fail.</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        process_expr(number, c_expr);
        c_expr.expr &amp;:= <span class="stri">") * "</span>;
        c_expr.expr &amp;:= floatLiteral(powerOfTwo);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"fltLdexp("</span>;
        process_expr(number, c_expr);
        c_expr.expr &amp;:= <span class="stri">", (int)"</span>;
        <span class="keywd">if</span> lshift > ccConf.INT_MAX <span class="keywd">then</span>
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MAX);
        <span class="keywd">elsif</span> lshift &lt; ccConf.INT_MIN <span class="keywd">then</span>
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MIN);
        <span class="keywd">else</span>
          c_expr.expr &amp;:= integerLiteral(lshift);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_LSHIFT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: numberName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">intRange</span>: lshiftRange <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">string</span>: lshiftName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_lshift(getValue(evaluatedParam, float), params[3], c_expr);
    <span class="keywd">elsif</span> getConstant(params[3], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_lshift(params[1], getValue(evaluatedParam, integer), c_expr);
    <span class="keywd">else</span>
      lshiftRange := getIntRange(params[3]);
      <span class="keywd">if</span> lshiftRange.minValue >= ccConf.INT_MIN <span class="op">and</span>
          lshiftRange.maxValue &lt;= ccConf.INT_MAX <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"fltLdexp("</span>;
        process_expr(params[1], c_expr);
        c_expr.expr &amp;:= <span class="stri">", (int)("</span>;
        process_expr(params[3], c_expr);
        c_expr.expr &amp;:= <span class="stri">"))"</span>;
      <span class="keywd">elsif</span> lshiftRange.maxValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        numberName := getParameterAsVariable(<span class="stri">"floatType"</span>, <span class="stri">"number_"</span>, params[1], c_expr);
        c_expr.expr &amp;:= <span class="stri">"os_isnan("</span>;
        c_expr.expr &amp;:= numberName;
        c_expr.expr &amp;:= <span class="stri">")||"</span>;
        c_expr.expr &amp;:= numberName;
        c_expr.expr &amp;:= <span class="stri">"==0.0||fabs("</span>;
        c_expr.expr &amp;:= numberName;
        c_expr.expr &amp;:= <span class="stri">")=="</span>;
        c_expr.expr &amp;:= floatLiteral(Infinity);
        c_expr.expr &amp;:= <span class="stri">"?"</span>;
        c_expr.expr &amp;:= numberName;
        c_expr.expr &amp;:= <span class="stri">":("</span>;
        c_expr.expr &amp;:= numberName;
        c_expr.expr &amp;:= <span class="stri">"&lt;0.0?"</span>;
        c_expr.expr &amp;:= floatLiteral(-0.0);
        c_expr.expr &amp;:= <span class="stri">":"</span>;
        c_expr.expr &amp;:= floatLiteral(0.0);
        c_expr.expr &amp;:= <span class="stri">"))"</span>;
      <span class="keywd">elsif</span> lshiftRange.minValue > ccConf.INT_MAX <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        numberName := getParameterAsVariable(<span class="stri">"floatType"</span>, <span class="stri">"number_"</span>, params[1], c_expr);
        c_expr.expr &amp;:= <span class="stri">"os_isnan("</span>;
        c_expr.expr &amp;:= numberName;
        c_expr.expr &amp;:= <span class="stri">")||"</span>;
        c_expr.expr &amp;:= numberName;
        c_expr.expr &amp;:= <span class="stri">"==0.0?"</span>;
        c_expr.expr &amp;:= numberName;
        c_expr.expr &amp;:= <span class="stri">":("</span>;
        c_expr.expr &amp;:= numberName;
        c_expr.expr &amp;:= <span class="stri">"&lt;0.0?"</span>;
        c_expr.expr &amp;:= floatLiteral(-Infinity);
        c_expr.expr &amp;:= <span class="stri">":"</span>;
        c_expr.expr &amp;:= floatLiteral(Infinity);
        c_expr.expr &amp;:= <span class="stri">"))"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        lshiftName := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"lshift_"</span>, params[3], c_expr);
        c_expr.expr &amp;:= <span class="stri">"fltLdexp("</span>;
        process_expr(params[1], c_expr);
        c_expr.expr &amp;:= <span class="stri">", (int)("</span>;
        <span class="keywd">if</span> lshiftRange.minValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
          c_expr.expr &amp;:= lshiftName;
          c_expr.expr &amp;:= <span class="stri">"&lt;"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MIN);
          c_expr.expr &amp;:= <span class="stri">"?"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MIN);
          c_expr.expr &amp;:= <span class="stri">":"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> lshiftRange.maxValue > ccConf.INT_MAX <span class="keywd">then</span>
          <span class="keywd">if</span> lshiftRange.minValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"("</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= lshiftName;
          c_expr.expr &amp;:= <span class="stri">">"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MAX);
          c_expr.expr &amp;:= <span class="stri">"?"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MAX);
          c_expr.expr &amp;:= <span class="stri">":"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= lshiftName;
        <span class="keywd">if</span> lshiftRange.maxValue > ccConf.INT_MAX <span class="op">and</span>
            lshiftRange.minValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">")))"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_LT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> <span class="op">not</span> ccConf.FLOAT_COMPARISON_OKAY <span class="keywd">then</span>
      programUses.mathLibrary := TRUE;
      c_expr.expr &amp;:= <span class="stri">"fltLt("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">") &lt; ("</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_MOD, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"fltMod("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    process_expr(params[3], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Generate code for expressions like: factor * base ** exponent
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: process_flt_mult_with_flt_ipow (<span class="op">in</span> <span class="type">reference</span>: factor,
    <span class="op">in</span> <span class="type">float</span>: base, <span class="op">in</span> <span class="type">reference</span>: exponent, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: factorName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">intRange</span>: exponentRange <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">string</span>: exponentName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: exponentNum <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(exponent, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      incr(count.optimizations);
      exponentNum := getValue(evaluatedParam, integer);
      <span class="keywd">if</span> getConstant(factor, FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
        c_expr.expr &amp;:= floatLiteral(getValue(evaluatedParam, float) * base ** exponentNum);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        process_expr(factor, c_expr);
        c_expr.expr &amp;:= <span class="stri">") * "</span>;
        c_expr.expr &amp;:= floatLiteral(base ** exponentNum);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> base = 1.0 <span class="keywd">then</span>
      incr(count.optimizations);
      process_expr(factor, c_expr);
    <span class="keywd">elsif</span> base = 2.0 <span class="keywd">then</span>
      incr(count.optimizations);
      exponentRange := getIntRange(exponent);
      <span class="keywd">if</span> exponentRange.minValue >= ccConf.INT_MIN <span class="op">and</span>
          exponentRange.maxValue &lt;= ccConf.INT_MAX <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        factorName := getParameterAsVariable(<span class="stri">"floatType"</span>, <span class="stri">"factor_"</span>, factor, c_expr);
        exponentName := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"exp_"</span>, exponent, c_expr);
        <span class="keywd">if</span> exponentRange.minValue &lt; 0 <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"fabs("</span>;
          c_expr.expr &amp;:= factorName;
          c_expr.expr &amp;:= <span class="stri">")=="</span>;
          c_expr.expr &amp;:= floatLiteral(Infinity);
          c_expr.expr &amp;:= <span class="stri">"||"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= factorName;
        c_expr.expr &amp;:= <span class="stri">"==0.0?"</span>;
        c_expr.expr &amp;:= factorName;
        c_expr.expr &amp;:= <span class="stri">"*fltLdexp(1.0, (int)"</span>;
        c_expr.expr &amp;:= exponentName;
        c_expr.expr &amp;:= <span class="stri">"):fltLdexp("</span>;
        c_expr.expr &amp;:= factorName;
        c_expr.expr &amp;:= <span class="stri">", (int)"</span>;
        c_expr.expr &amp;:= exponentName;
        c_expr.expr &amp;:= <span class="stri">"))"</span>;
      <span class="keywd">elsif</span> exponentRange.maxValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        process_expr(factor, c_expr);
        c_expr.expr &amp;:= <span class="stri">")*0.0"</span>;
      <span class="keywd">elsif</span> exponentRange.minValue > ccConf.INT_MAX <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        process_expr(factor, c_expr);
        c_expr.expr &amp;:= <span class="stri">")*"</span>;
        c_expr.expr &amp;:= floatLiteral(Infinity);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        factorName := getParameterAsVariable(<span class="stri">"floatType"</span>, <span class="stri">"factor_"</span>, factor, c_expr);
        exponentName := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"exp_"</span>, exponent, c_expr);
        <span class="keywd">if</span> exponentRange.minValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
          c_expr.expr &amp;:= exponentName;
          c_expr.expr &amp;:= <span class="stri">"&lt;"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MIN);
          c_expr.expr &amp;:= <span class="stri">"?("</span>;
          c_expr.expr &amp;:= factorName;
          c_expr.expr &amp;:= <span class="stri">"*0.0):"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> exponentRange.maxValue > ccConf.INT_MAX <span class="keywd">then</span>
          <span class="keywd">if</span> exponentRange.minValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"("</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= exponentName;
          c_expr.expr &amp;:= <span class="stri">">"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MAX);
          c_expr.expr &amp;:= <span class="stri">"?("</span>;
          c_expr.expr &amp;:= factorName;
          c_expr.expr &amp;:= <span class="stri">"*"</span>;
          c_expr.expr &amp;:= floatLiteral(Infinity);
          c_expr.expr &amp;:= <span class="stri">"):"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        <span class="keywd">if</span> exponentRange.minValue &lt; 0 <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"fabs("</span>;
          c_expr.expr &amp;:= factorName;
          c_expr.expr &amp;:= <span class="stri">")=="</span>;
          c_expr.expr &amp;:= floatLiteral(Infinity);
          c_expr.expr &amp;:= <span class="stri">"||"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= factorName;
        c_expr.expr &amp;:= <span class="stri">"==0.0?"</span>;
        c_expr.expr &amp;:= factorName;
        c_expr.expr &amp;:= <span class="stri">"*fltLdexp(1.0, (int)"</span>;
        c_expr.expr &amp;:= exponentName;
        c_expr.expr &amp;:= <span class="stri">"):fltLdexp("</span>;
        c_expr.expr &amp;:= factorName;
        c_expr.expr &amp;:= <span class="stri">", (int)"</span>;
        c_expr.expr &amp;:= exponentName;
        c_expr.expr &amp;:= <span class="stri">"))"</span>;
        <span class="keywd">if</span> exponentRange.maxValue > ccConf.INT_MAX <span class="op">and</span>
            exponentRange.minValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> base >= 4.0 <span class="op">and</span>
          base &lt;= flt(ccConf.INT_RANGE_IN_FLOATTYPE_MAX) <span class="op">and</span>
          floor(base) = base <span class="op">and</span>
          2 ** log2(trunc(base)) = trunc(base) <span class="keywd">then</span>
      incr(count.optimizations);
      exponentRange := getIntRange(exponent);
      <span class="keywd">if</span> exponentRange.minValue >= ccConf.INT_MIN <span class="op">div</span> log2(trunc(base)) <span class="op">and</span>
          exponentRange.maxValue &lt;= ccConf.INT_MAX <span class="op">div</span> log2(trunc(base)) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        factorName := getParameterAsVariable(<span class="stri">"floatType"</span>, <span class="stri">"factor_"</span>, factor, c_expr);
        exponentName := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"exp_"</span>, exponent, c_expr);
        <span class="keywd">if</span> exponentRange.minValue &lt; 0 <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"fabs("</span>;
          c_expr.expr &amp;:= factorName;
          c_expr.expr &amp;:= <span class="stri">")=="</span>;
          c_expr.expr &amp;:= floatLiteral(Infinity);
          c_expr.expr &amp;:= <span class="stri">"||"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= factorName;
        c_expr.expr &amp;:= <span class="stri">"==0.0?"</span>;
        c_expr.expr &amp;:= factorName;
        c_expr.expr &amp;:= <span class="stri">"*fltLdexp(1.0, (int)"</span>;
        c_expr.expr &amp;:= exponentName;
        c_expr.expr &amp;:= <span class="stri">"*"</span>;
        c_expr.expr &amp;:= str(log2(trunc(base)));
        c_expr.expr &amp;:= <span class="stri">"):fltLdexp("</span>;
        c_expr.expr &amp;:= factorName;
        c_expr.expr &amp;:= <span class="stri">", (int)"</span>;
        c_expr.expr &amp;:= exponentName;
        c_expr.expr &amp;:= <span class="stri">"*"</span>;
        c_expr.expr &amp;:= str(log2(trunc(base)));
        c_expr.expr &amp;:= <span class="stri">"))"</span>;
      <span class="keywd">elsif</span> exponentRange.maxValue &lt; ccConf.INT_MIN <span class="op">div</span> log2(trunc(base)) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        process_expr(factor, c_expr);
        c_expr.expr &amp;:= <span class="stri">")*0.0"</span>;
      <span class="keywd">elsif</span> exponentRange.minValue > ccConf.INT_MAX <span class="op">div</span> log2(trunc(base)) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        process_expr(factor, c_expr);
        c_expr.expr &amp;:= <span class="stri">")*"</span>;
        c_expr.expr &amp;:= floatLiteral(Infinity);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        factorName := getParameterAsVariable(<span class="stri">"floatType"</span>, <span class="stri">"factor_"</span>, factor, c_expr);
        exponentName := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"exp_"</span>, exponent, c_expr);
        <span class="keywd">if</span> exponentRange.minValue &lt; ccConf.INT_MIN <span class="op">div</span> log2(trunc(base)) <span class="keywd">then</span>
          c_expr.expr &amp;:= exponentName;
          c_expr.expr &amp;:= <span class="stri">"&lt;"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MIN <span class="op">div</span> log2(trunc(base)));
          c_expr.expr &amp;:= <span class="stri">"?("</span>;
          c_expr.expr &amp;:= factorName;
          c_expr.expr &amp;:= <span class="stri">"*0.0):"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> exponentRange.maxValue > ccConf.INT_MAX <span class="op">div</span> log2(trunc(base)) <span class="keywd">then</span>
          <span class="keywd">if</span> exponentRange.minValue &lt; ccConf.INT_MIN <span class="op">div</span> log2(trunc(base)) <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"("</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= exponentName;
          c_expr.expr &amp;:= <span class="stri">">"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MAX <span class="op">div</span> log2(trunc(base)));
          c_expr.expr &amp;:= <span class="stri">"?("</span>;
          c_expr.expr &amp;:= factorName;
          c_expr.expr &amp;:= <span class="stri">"*"</span>;
          c_expr.expr &amp;:= floatLiteral(Infinity);
          c_expr.expr &amp;:= <span class="stri">"):"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        <span class="keywd">if</span> exponentRange.minValue &lt; 0 <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"fabs("</span>;
          c_expr.expr &amp;:= factorName;
          c_expr.expr &amp;:= <span class="stri">")=="</span>;
          c_expr.expr &amp;:= floatLiteral(Infinity);
          c_expr.expr &amp;:= <span class="stri">"||"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= factorName;
        c_expr.expr &amp;:= <span class="stri">"==0.0?"</span>;
        c_expr.expr &amp;:= factorName;
        c_expr.expr &amp;:= <span class="stri">"*fltLdexp(1.0, (int)"</span>;
        c_expr.expr &amp;:= exponentName;
        c_expr.expr &amp;:= <span class="stri">"*"</span>;
        c_expr.expr &amp;:= str(log2(trunc(base)));
        c_expr.expr &amp;:= <span class="stri">"):fltLdexp("</span>;
        c_expr.expr &amp;:= factorName;
        c_expr.expr &amp;:= <span class="stri">", (int)"</span>;
        c_expr.expr &amp;:= exponentName;
        c_expr.expr &amp;:= <span class="stri">"*"</span>;
        c_expr.expr &amp;:= str(log2(trunc(base)));
        c_expr.expr &amp;:= <span class="stri">"))"</span>;
        <span class="keywd">if</span> exponentRange.maxValue > ccConf.INT_MAX <span class="op">div</span> log2(trunc(base)) <span class="op">and</span>
            exponentRange.minValue &lt; ccConf.INT_MIN <span class="op">div</span> log2(trunc(base)) <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      process_expr(factor, c_expr);
      c_expr.expr &amp;:= <span class="stri">") * ("</span>;
      process_const_flt_ipow(base, exponent, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_MULT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isActionExpression(params[1], <span class="stri">"FLT_IPOW"</span>) <span class="op">and</span>
        getConstant(getActionParameter(params[1], 1),
                    FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_flt_mult_with_flt_ipow(params[3],
          getValue(evaluatedParam, float),
          getActionParameter(params[1], 3), c_expr);
    <span class="keywd">elsif</span> isActionExpression(params[3], <span class="stri">"FLT_IPOW"</span>) <span class="op">and</span>
        getConstant(getActionParameter(params[3], 1),
                    FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_flt_mult_with_flt_ipow(params[1],
          getValue(evaluatedParam, float),
          getActionParameter(params[3], 3), c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">") * ("</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_MULT_ASSIGN, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    process_expr(params[1], statement);
    statement.expr &amp;:= <span class="stri">"*="</span>;
    process_expr(params[3], statement);
    statement.expr &amp;:= <span class="stri">";\n"</span>;
    doLocalDeclsOfStatement(statement, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_flt_ne (<span class="op">in</span> <span class="type">float</span>: number, <span class="op">in</span> <span class="type">reference</span>: param3,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">float</span>: number2 <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isNaN(number) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"1/*NaN != anything*/"</span>;
    <span class="keywd">elsif</span> getConstant(param3, FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      incr(count.optimizations);
      number2 := getValue(evaluatedParam, float);
      c_expr.expr &amp;:= str(ord(number &lt;> number2));
      c_expr.expr &amp;:= <span class="stri">"/*"</span>;
      c_expr.expr &amp;:= str(number);
      c_expr.expr &amp;:= <span class="stri">" != "</span>;
      c_expr.expr &amp;:= str(number2);
      c_expr.expr &amp;:= <span class="stri">"*/"</span>;
    <span class="keywd">elsif</span> <span class="op">not</span> ccConf.FLOAT_COMPARISON_OKAY <span class="keywd">then</span>
      programUses.mathLibrary := TRUE;
      c_expr.expr &amp;:= <span class="stri">"!fltEq("</span>;
      c_expr.expr &amp;:= floatLiteral(number);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(param3, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= floatLiteral(number);
      c_expr.expr &amp;:= <span class="stri">" != ("</span>;
      process_expr(param3, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_NE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_ne(getValue(evaluatedParam, float), params[3], c_expr);
    <span class="keywd">elsif</span> getConstant(params[3], FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_ne(getValue(evaluatedParam, float), params[1], c_expr);
    <span class="keywd">elsif</span> <span class="op">not</span> ccConf.FLOAT_COMPARISON_OKAY <span class="keywd">then</span>
      programUses.mathLibrary := TRUE;
      c_expr.expr &amp;:= <span class="stri">"!fltEq("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">") != ("</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_NEGATE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[2], FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= floatLiteral(-getValue(evaluatedParam, float));
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"-("</span>;
      process_expr(params[2], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_PARSE1, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"fltParse("</span>;
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_PLUS, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    process_expr(params[2], c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_flt_pow (<span class="op">in</span> <span class="type">float</span>: base, <span class="op">in</span> <span class="type">reference</span>: exponent,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedExponent <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: exponentName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(exponent, FLOATOBJECT, evaluatedExponent) <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= floatLiteral(base ** getValue(evaluatedExponent, float));
    <span class="keywd">elsif</span> base = 1.0 <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= floatLiteral(1.0);
    <span class="keywd">elsif</span> base = 2.0 <span class="op">and</span> ccConf.HAS_EXP2 <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= <span class="stri">"exp2("</span>;
      process_expr(exponent, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">elsif</span> base = 10.0 <span class="op">and</span> ccConf.HAS_EXP10 <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= <span class="stri">"exp10("</span>;
      process_expr(exponent, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">elsif</span> base = E <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= <span class="stri">"fltExp("</span>;
      process_expr(exponent, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"fltPow("</span>;
      c_expr.expr &amp;:= floatLiteral(base);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(exponent, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_flt_pow (<span class="op">in</span> <span class="type">reference</span>: base, <span class="op">in</span> <span class="type">float</span>: exponent,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> exponent >= flt(-ccConf.INT_RANGE_IN_FLOATTYPE_MAX) <span class="op">and</span>
        exponent &lt;= flt(ccConf.INT_RANGE_IN_FLOATTYPE_MAX) <span class="op">and</span>
        floor(exponent) = exponent <span class="keywd">then</span>
      process_const_flt_ipow(base, trunc(exponent), c_expr);
<span class="comment">(*
    elsif exponent = -0.5 then
      incr(count.optimizations);
      c_expr.expr &amp;:= "1.0/";
      c_expr.expr &amp;:= "fltSqrt(";
      process_expr(base, c_expr);
      c_expr.expr &amp;:= ")";
*)</span>
    <span class="keywd">elsif</span> exponent = 0.33333333333333333333333333333333333333333333333333 <span class="op">and</span>
        ccConf.HAS_CBRT <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= <span class="stri">"cbrt("</span>;
      process_expr(base, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">elsif</span> exponent = 0.5 <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= <span class="stri">"fltSqrt("</span>;
      process_expr(base, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"fltPow("</span>;
      process_expr(base, c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      c_expr.expr &amp;:= floatLiteral(exponent);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_POW, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_pow(getValue(evaluatedParam, float), params[3], c_expr);
    <span class="keywd">elsif</span> getConstant(params[3], FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_pow(params[1], getValue(evaluatedParam, float), c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"fltPow("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_flt_rand (<span class="op">in</span> <span class="type">float</span>: low, <span class="op">in</span> <span class="type">float</span>: high,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="comment"># The predecessor of 1.0 is needed to estimate if a loop is necessary.</span>
    <span class="comment"># To get the predecessor the binary representation of 1.0 is reduced by 1.</span>
    <span class="comment"># This switches all mantissa bits from 0 to 1 and reduces the exponent by 1.</span>
    <span class="comment"># Conversions between float and integer must be done via bin64.</span>
    <span class="keywd">const</span> <span class="type">float</span>: justBelow1 <span class="keywd">is</span> float(bin64(pred(integer(bin64(1.0)))));
    <span class="keywd">var</span> <span class="type">float</span>: delta <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">string</span>: randName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: union_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: binaryExponent <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> low >= high <span class="keywd">then</span>
      warning(DOES_RAISE, <span class="stri">"RANGE_ERROR"</span>, c_expr);
      c_expr.expr &amp;:= intRaiseError(<span class="stri">"RANGE_ERROR"</span>);
    <span class="keywd">else</span>
      delta := high - low;
      <span class="keywd">if</span> isNaN(delta) <span class="keywd">then</span>
        warning(DOES_RAISE, <span class="stri">"RANGE_ERROR"</span>, c_expr);
        c_expr.expr &amp;:= intRaiseError(<span class="stri">"RANGE_ERROR"</span>);
      <span class="keywd">elsif</span> delta = Infinity <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"fltRand("</span>;
        c_expr.expr &amp;:= floatLiteral(low);
        c_expr.expr &amp;:= <span class="stri">", "</span>;
        c_expr.expr &amp;:= floatLiteral(high);
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">elsif</span> config.inlineFunctions <span class="keywd">then</span>
        <span class="keywd">if</span> delta > 0.0 <span class="op">and</span> 2.0 ** floor(log2(delta)) = delta <span class="keywd">then</span>
          <span class="comment"># Delta is a power of two.</span>
          incr(count.inlinedFunctions);
          binaryExponent := trunc(log2(delta));
          union_name := defineTempVariable(<span class="stri">"double2BitsUnion"</span>, <span class="stri">"conv_"</span>, c_expr);
          c_expr.expr &amp;:= <span class="stri">"("</span>;
          c_expr.expr &amp;:= union_name;
          c_expr.expr &amp;:= <span class="stri">".bits=uintRandMantissa() | "</span>;
          c_expr.expr &amp;:= integerLiteral((ccConf.FLOATTYPE_EXPONENT_OFFSET +
              binaryExponent) &lt;&lt; ccConf.FLOATTYPE_MANTISSA_BITS);
          c_expr.expr &amp;:= <span class="stri">", "</span>;
          c_expr.expr &amp;:= union_name;
          c_expr.expr &amp;:= <span class="stri">".aDouble - "</span>;
          c_expr.expr &amp;:= floatLiteral(delta - low);
          c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">elsif</span> justBelow1 * delta + low &lt; high <span class="keywd">then</span>
          <span class="comment"># The computed number is always in the range [low, high).</span>
          <span class="comment"># No loop is necessary to repeat the computation.</span>
          incr(count.inlinedFunctions);
          union_name := defineTempVariable(<span class="stri">"double2BitsUnion"</span>, <span class="stri">"conv_"</span>, c_expr);
          c_expr.expr &amp;:= <span class="stri">"("</span>;
          c_expr.expr &amp;:= union_name;
          c_expr.expr &amp;:= <span class="stri">".bits=uintRandMantissa() | "</span>;
          c_expr.expr &amp;:= integerLiteral(integer(bin64(1.0)));
          c_expr.expr &amp;:= <span class="stri">",("</span>;
          c_expr.expr &amp;:= union_name;
          c_expr.expr &amp;:= <span class="stri">".aDouble - 1.0)"</span>;
          <span class="comment"># The expression above is a random number in the range [0.0, 1.0).</span>
          <span class="keywd">if</span> delta &lt;> 1.0 <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">" * "</span>;
            c_expr.expr &amp;:= floatLiteral(delta);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> low &lt;> 0.0 <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">" + "</span>;
            c_expr.expr &amp;:= floatLiteral(low);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">elsif</span> ccConf.STMT_BLOCK_IN_PARENTHESES_OK <span class="keywd">then</span>
          <span class="comment"># The computation might result in a number >= high.</span>
          <span class="comment"># Repeat the computation until the number is in the range [low, high).</span>
          incr(count.inlinedFunctions);
          incr(c_expr.temp_num);
          union_name := <span class="stri">"conv_"</span> &lt;&amp; c_expr.temp_num;
          c_expr.expr &amp;:= <span class="stri">"({double2BitsUnion "</span>;
          c_expr.expr &amp;:= union_name;
          c_expr.expr &amp;:= <span class="stri">"; do {"</span>;
          c_expr.expr &amp;:= union_name;
          c_expr.expr &amp;:= <span class="stri">".bits=uintRandMantissa() | "</span>;
          c_expr.expr &amp;:= integerLiteral(integer(bin64(1.0)));
          c_expr.expr &amp;:= <span class="stri">";"</span>;
          c_expr.expr &amp;:= union_name;
          c_expr.expr &amp;:= <span class="stri">".aDouble=("</span>;
          c_expr.expr &amp;:= union_name;
          c_expr.expr &amp;:= <span class="stri">".aDouble - 1.0)"</span>;
          <span class="comment"># The expression above is a random number in the range [0.0, 1.0).</span>
          <span class="keywd">if</span> delta &lt;> 1.0 <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">" * "</span>;
            c_expr.expr &amp;:= floatLiteral(delta);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> low &lt;> 0.0 <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">" + "</span>;
            c_expr.expr &amp;:= floatLiteral(low);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">";} while ("</span>;
          c_expr.expr &amp;:= union_name;
          c_expr.expr &amp;:= <span class="stri">".aDouble"</span>;
          c_expr.expr &amp;:= <span class="stri">">="</span>;
          c_expr.expr &amp;:= floatLiteral(high);
          c_expr.expr &amp;:= <span class="stri">"); "</span>;
          c_expr.expr &amp;:= union_name;
          c_expr.expr &amp;:= <span class="stri">".aDouble"</span>;
          c_expr.expr &amp;:= <span class="stri">";})"</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"fltRandNoChk("</span>;
          c_expr.expr &amp;:= floatLiteral(low);
          c_expr.expr &amp;:= <span class="stri">", "</span>;
          c_expr.expr &amp;:= floatLiteral(high);
          c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"fltRandNoChk("</span>;
        c_expr.expr &amp;:= floatLiteral(low);
        c_expr.expr &amp;:= <span class="stri">", "</span>;
        c_expr.expr &amp;:= floatLiteral(high);
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_RAND, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedLowerBound <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedUpperBound <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span>  getConstant(params[1], FLOATOBJECT, evaluatedLowerBound) <span class="op">and</span>
        getConstant(params[2], FLOATOBJECT, evaluatedUpperBound) <span class="keywd">then</span>
      process_const_flt_rand(getValue(evaluatedLowerBound, float),
                             getValue(evaluatedUpperBound, float), c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"fltRand("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(params[2], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_flt_rem (<span class="op">in</span> <span class="type">float</span>: dividend, <span class="op">in</span> <span class="type">reference</span>: divisor,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: divisor_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isNaN(dividend) <span class="op">or</span> dividend = Infinity <span class="op">or</span> dividend = -Infinity <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= <span class="stri">"NOT_A_NUMBER"</span>;
    <span class="keywd">elsif</span> getConstant(divisor, FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= floatLiteral(dividend <span class="op">rem</span> getValue(evaluatedParam, float));
    <span class="keywd">elsif</span> dividend = 0.0 <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      divisor_name := getParameterAsVariable(<span class="stri">"floatType"</span>, <span class="stri">"tmp_"</span>, divisor, c_expr);
      c_expr.expr &amp;:= divisor_name;
      c_expr.expr &amp;:= <span class="stri">"==0.0 || os_isnan("</span>;
      c_expr.expr &amp;:= divisor_name;
      c_expr.expr &amp;:= <span class="stri">")?NOT_A_NUMBER:"</span>;
      c_expr.expr &amp;:= floatLiteral(dividend);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"fltRem("</span>;
      c_expr.expr &amp;:= floatLiteral(dividend);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(divisor, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_flt_rem (<span class="op">in</span> <span class="type">reference</span>: dividend, <span class="op">in</span> <span class="type">float</span>: divisor,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: dividend_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isNaN(divisor) <span class="op">or</span> divisor = 0.0 <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= <span class="stri">"NOT_A_NUMBER"</span>;
    <span class="keywd">elsif</span> divisor = Infinity <span class="op">or</span> divisor = -Infinity <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      dividend_name := getParameterAsVariable(<span class="stri">"floatType"</span>, <span class="stri">"tmp_"</span>, dividend, c_expr);
      c_expr.expr &amp;:= dividend_name;
      c_expr.expr &amp;:= <span class="stri">"==POSITIVE_INFINITY || "</span>;
      c_expr.expr &amp;:= dividend_name;
      c_expr.expr &amp;:= <span class="stri">"==NEGATIVE_INFINITY || os_isnan("</span>;
      c_expr.expr &amp;:= dividend_name;
      c_expr.expr &amp;:= <span class="stri">")?NOT_A_NUMBER:"</span>;
      process_expr(dividend, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"fltRem("</span>;
      process_expr(dividend, c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      c_expr.expr &amp;:= floatLiteral(divisor);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_REM, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_rem(getValue(evaluatedParam, float), params[3], c_expr);
    <span class="keywd">elsif</span> getConstant(params[3], FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_rem(params[1], getValue(evaluatedParam, float), c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"fltRem("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_ROUND, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: number <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> category(params[1]) = FLOATOBJECT <span class="op">and</span> <span class="op">not</span> isVar(params[1]) <span class="keywd">then</span>
      <span class="comment">(* Some compilers (cl) truncate different than the runtime  *)</span>
      <span class="comment">(* library. This is related to the behaviour of printf in   *)</span>
      <span class="comment">(* this runtime library: The function printf is not able    *)</span>
      <span class="comment">(* to write a float value of a power of two exactly. The    *)</span>
      <span class="comment">(* combination of inexact float literals and a C compiler   *)</span>
      <span class="comment">(* that trunctates this literals leads to errors. To avoid  *)</span>
      <span class="comment">(* problems we do the rounding instead of the C compiler.   *)</span>
      incr(count.optimizations);
      <span class="keywd">block</span>
        c_expr.expr &amp;:= integerLiteral(round(getValue(params[1], float)));
      exception
        catch RANGE_ERROR:
          warning(DOES_RAISE, <span class="stri">"RANGE_ERROR"</span>, c_expr);
          c_expr.expr &amp;:= intRaiseError(<span class="stri">"RANGE_ERROR"</span>);
      <span class="keywd">end</span> <span class="keywd">block</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      number := getParameterAsVariable(<span class="stri">"floatType"</span>, <span class="stri">"tmp_"</span>, params[1], c_expr);
      <span class="keywd">if</span> config.conversion_range_check <span class="keywd">then</span>
        incr(count.rangeChecks);
        c_expr.expr &amp;:= <span class="stri">"rngChk(os_isnan("</span>;
        c_expr.expr &amp;:= number;
        c_expr.expr &amp;:= <span class="stri">")||"</span>;
        c_expr.expr &amp;:= number;
        c_expr.expr &amp;:= <span class="stri">"&lt; (floatType) "</span>;
        c_expr.expr &amp;:= integerLiteral(ccConf.MINIMUM_TRUNC_ARGUMENT);
        c_expr.expr &amp;:= <span class="stri">"||"</span>;
        c_expr.expr &amp;:= number;
        c_expr.expr &amp;:= <span class="stri">"> (floatType) "</span>;
        c_expr.expr &amp;:= integerLiteral(ccConf.MAXIMUM_TRUNC_ARGUMENT);
        c_expr.expr &amp;:= <span class="stri">")?"</span>;
        c_expr.expr &amp;:= intRaiseError(<span class="stri">"RANGE_ERROR"</span>);
        c_expr.expr &amp;:= <span class="stri">":"</span>;
      <span class="keywd">else</span>
        incr(count.noRangeChecks);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="comment">(* Formula used: (a&lt;0.0?-((intType)(0.5-a)):(intType)(0.5+a)) *)</span>
      c_expr.expr &amp;:= number;
      c_expr.expr &amp;:= <span class="stri">"&lt;0.0?(intType)("</span>;
      c_expr.expr &amp;:= number;
      c_expr.expr &amp;:= <span class="stri">"-0.5):(intType)("</span>;
      c_expr.expr &amp;:= number;
      c_expr.expr &amp;:= <span class="stri">"+0.5))"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_flt_rshift (<span class="op">in</span> <span class="type">float</span>: number, <span class="op">in</span> <span class="type">reference</span>: rshift,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">intRange</span>: rshiftRange <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">integer</span>: rshiftNum <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: rshiftName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> number = 0.0 <span class="op">or</span> abs(number) = Infinity <span class="op">or</span> isNaN(number) <span class="keywd">then</span>
      incr(count.optimizations);
      c_expr.expr &amp;:= floatLiteral(number);
    <span class="keywd">elsif</span> getConstant(rshift, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      incr(count.optimizations);
      rshiftNum := getValue(evaluatedParam, integer);
      c_expr.expr &amp;:= floatLiteral(number >> rshiftNum);
    <span class="keywd">else</span>
      rshiftRange := getIntRange(rshift);
      <span class="keywd">if</span> rshiftRange.minValue > ccConf.INT_MIN <span class="op">and</span>
          rshiftRange.maxValue &lt;= ccConf.INT_MAX <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"fltLdexp("</span>;
        c_expr.expr &amp;:= floatLiteral(number);
        c_expr.expr &amp;:= <span class="stri">", -(int)("</span>;
        process_expr(rshift, c_expr);
        c_expr.expr &amp;:= <span class="stri">"))"</span>;
      <span class="keywd">elsif</span> rshiftRange.maxValue &lt;= ccConf.INT_MIN <span class="keywd">then</span>
        <span class="keywd">if</span> number &lt; 0.0 <span class="keywd">then</span>
          c_expr.expr &amp;:= floatLiteral(-Infinity);
        <span class="keywd">else</span>
          c_expr.expr &amp;:= floatLiteral(Infinity);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> rshiftRange.minValue > ccConf.INT_MAX <span class="keywd">then</span>
        <span class="keywd">if</span> number &lt; 0.0 <span class="keywd">then</span>
          c_expr.expr &amp;:= floatLiteral(-0.0);
        <span class="keywd">else</span>
          c_expr.expr &amp;:= floatLiteral(0.0);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        rshiftName := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"rshift_"</span>, rshift, c_expr);
        <span class="keywd">if</span> rshiftRange.minValue &lt;= ccConf.INT_MIN <span class="keywd">then</span>
          c_expr.expr &amp;:= rshiftName;
          c_expr.expr &amp;:= <span class="stri">"&lt;="</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MIN);
          c_expr.expr &amp;:= <span class="stri">"?"</span>;
          <span class="keywd">if</span> number &lt; 0.0 <span class="keywd">then</span>
            c_expr.expr &amp;:= floatLiteral(-Infinity);
          <span class="keywd">else</span>
            c_expr.expr &amp;:= floatLiteral(Infinity);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">":"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> rshiftRange.maxValue > ccConf.INT_MAX <span class="keywd">then</span>
          <span class="keywd">if</span> rshiftRange.minValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"("</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= rshiftName;
          c_expr.expr &amp;:= <span class="stri">">"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MAX);
          c_expr.expr &amp;:= <span class="stri">"?"</span>;
          <span class="keywd">if</span> number &lt; 0.0 <span class="keywd">then</span>
            c_expr.expr &amp;:= floatLiteral(-0.0);
          <span class="keywd">else</span>
            c_expr.expr &amp;:= floatLiteral(0.0);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">":"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"fltLdexp("</span>;
        c_expr.expr &amp;:= floatLiteral(number);
        c_expr.expr &amp;:= <span class="stri">", -(int)"</span>;
        c_expr.expr &amp;:= rshiftName;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">if</span> rshiftRange.maxValue > ccConf.INT_MAX <span class="op">and</span>
            rshiftRange.minValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_flt_rshift (<span class="op">in</span> <span class="type">reference</span>: number, <span class="op">in</span> <span class="type">integer</span>: rshift,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">float</span>: powerOfTwo <span class="keywd">is</span> Infinity;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> rshift = 0 <span class="keywd">then</span>
      incr(count.optimizations);
      process_expr(number, c_expr);
    <span class="keywd">else</span>
      <span class="keywd">if</span> rshift &lt;> integer.first <span class="keywd">then</span>
        powerOfTwo := 2.0 ** (-rshift);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> powerOfTwo > 1.0 <span class="op">and</span> powerOfTwo &lt; Infinity <span class="keywd">then</span>
        <span class="comment"># The range (0.0 to 1.0] would also work,</span>
        <span class="comment"># but extended precision computations makes tests fail.</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        process_expr(number, c_expr);
        c_expr.expr &amp;:= <span class="stri">") * "</span>;
        c_expr.expr &amp;:= floatLiteral(powerOfTwo);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"fltLdexp("</span>;
        process_expr(number, c_expr);
        c_expr.expr &amp;:= <span class="stri">", (int)"</span>;
        <span class="keywd">if</span> rshift > ccConf.INT_MAX <span class="keywd">then</span>
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MIN);
        <span class="keywd">elsif</span> rshift &lt;= ccConf.INT_MIN <span class="keywd">then</span>
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MAX);
        <span class="keywd">else</span>
          c_expr.expr &amp;:= integerLiteral(-rshift);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_RSHIFT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: numberName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">intRange</span>: rshiftRange <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">string</span>: rshiftName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], FLOATOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_rshift(getValue(evaluatedParam, float), params[3], c_expr);
    <span class="keywd">elsif</span> getConstant(params[3], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_flt_rshift(params[1], getValue(evaluatedParam, integer), c_expr);
    <span class="keywd">else</span>
      rshiftRange := getIntRange(params[3]);
      <span class="keywd">if</span> rshiftRange.minValue > ccConf.INT_MIN <span class="op">and</span>
          rshiftRange.maxValue &lt;= ccConf.INT_MAX <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"fltLdexp("</span>;
        process_expr(params[1], c_expr);
        c_expr.expr &amp;:= <span class="stri">", -(int)("</span>;
        process_expr(params[3], c_expr);
        c_expr.expr &amp;:= <span class="stri">"))"</span>;
      <span class="keywd">elsif</span> rshiftRange.maxValue &lt;= ccConf.INT_MIN <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        numberName := getParameterAsVariable(<span class="stri">"floatType"</span>, <span class="stri">"number_"</span>, params[1], c_expr);
        c_expr.expr &amp;:= <span class="stri">"os_isnan("</span>;
        c_expr.expr &amp;:= numberName;
        c_expr.expr &amp;:= <span class="stri">")||"</span>;
        c_expr.expr &amp;:= numberName;
        c_expr.expr &amp;:= <span class="stri">"==0.0?"</span>;
        c_expr.expr &amp;:= numberName;
        c_expr.expr &amp;:= <span class="stri">":("</span>;
        c_expr.expr &amp;:= numberName;
        c_expr.expr &amp;:= <span class="stri">"&lt;0.0?"</span>;
        c_expr.expr &amp;:= floatLiteral(-Infinity);
        c_expr.expr &amp;:= <span class="stri">":"</span>;
        c_expr.expr &amp;:= floatLiteral(Infinity);
        c_expr.expr &amp;:= <span class="stri">"))"</span>;
      <span class="keywd">elsif</span> rshiftRange.minValue > ccConf.INT_MAX <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        numberName := getParameterAsVariable(<span class="stri">"floatType"</span>, <span class="stri">"number_"</span>, params[1], c_expr);
        c_expr.expr &amp;:= <span class="stri">"os_isnan("</span>;
        c_expr.expr &amp;:= numberName;
        c_expr.expr &amp;:= <span class="stri">")||"</span>;
        c_expr.expr &amp;:= numberName;
        c_expr.expr &amp;:= <span class="stri">"==0.0||fabs("</span>;
        c_expr.expr &amp;:= numberName;
        c_expr.expr &amp;:= <span class="stri">")=="</span>;
        c_expr.expr &amp;:= floatLiteral(Infinity);
        c_expr.expr &amp;:= <span class="stri">"?"</span>;
        c_expr.expr &amp;:= numberName;
        c_expr.expr &amp;:= <span class="stri">":("</span>;
        c_expr.expr &amp;:= numberName;
        c_expr.expr &amp;:= <span class="stri">"&lt;0.0?"</span>;
        c_expr.expr &amp;:= floatLiteral(-0.0);
        c_expr.expr &amp;:= <span class="stri">":"</span>;
        c_expr.expr &amp;:= floatLiteral(0.0);
        c_expr.expr &amp;:= <span class="stri">"))"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        rshiftName := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"rshift_"</span>, params[3], c_expr);
        c_expr.expr &amp;:= <span class="stri">"fltLdexp("</span>;
        process_expr(params[1], c_expr);
        c_expr.expr &amp;:= <span class="stri">", (int)("</span>;
        <span class="keywd">if</span> rshiftRange.minValue &lt;= ccConf.INT_MIN <span class="keywd">then</span>
          c_expr.expr &amp;:= rshiftName;
          c_expr.expr &amp;:= <span class="stri">"&lt;="</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MIN);
          c_expr.expr &amp;:= <span class="stri">"?"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MAX);
          c_expr.expr &amp;:= <span class="stri">":"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> rshiftRange.maxValue > ccConf.INT_MAX <span class="keywd">then</span>
          <span class="keywd">if</span> rshiftRange.minValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"("</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= rshiftName;
          c_expr.expr &amp;:= <span class="stri">">"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MAX);
          c_expr.expr &amp;:= <span class="stri">"?"</span>;
          c_expr.expr &amp;:= integerLiteral(ccConf.INT_MIN);
          c_expr.expr &amp;:= <span class="stri">":"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"-("</span>;
        c_expr.expr &amp;:= rshiftName;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">if</span> rshiftRange.maxValue > ccConf.INT_MAX <span class="op">and</span>
            rshiftRange.minValue &lt; ccConf.INT_MIN <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">")))"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_SBTR, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">") - ("</span>;
    process_expr(params[3], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_SBTR_ASSIGN, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    process_expr(params[1], statement);
    statement.expr &amp;:= <span class="stri">"-="</span>;
    process_expr(params[3], statement);
    statement.expr &amp;:= <span class="stri">";\n"</span>;
    doLocalDeclsOfStatement(statement, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_SCI, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_stri_result(c_expr);
    c_expr.result_expr := <span class="stri">"fltSci("</span>;
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">", "</span>;
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_SIN, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"sin("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_SINGLE2BITS, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: union_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    union_name := defineTempVariable(<span class="stri">"float2BitsUnion"</span>, <span class="stri">"conv_"</span>, c_expr);
    c_expr.expr &amp;:= <span class="stri">"("</span>;
    c_expr.expr &amp;:= union_name;
    c_expr.expr &amp;:= <span class="stri">".aFloat=(float)("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">"),(intType)(uintType)("</span>;
    c_expr.expr &amp;:= union_name;
    c_expr.expr &amp;:= <span class="stri">".bits))"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_SINH, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"sinh("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_SQRT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"fltSqrt("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_STR, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_stri_result(c_expr);
    c_expr.result_expr := <span class="stri">"fltStr("</span>;
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_STR_SCIENTIFIC, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_stri_result(c_expr);
    c_expr.result_expr := <span class="stri">"fltStrScientific("</span>;
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_TAN, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"tan("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_TANH, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"tanh("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_TRUNC, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: number <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> category(params[1]) = FLOATOBJECT <span class="op">and</span> <span class="op">not</span> isVar(params[1]) <span class="keywd">then</span>
      <span class="comment">(* Some compilers (cl) truncate different than the runtime  *)</span>
      <span class="comment">(* library. This is related to the behaviour of printf in   *)</span>
      <span class="comment">(* this runtime library: The function printf is not able    *)</span>
      <span class="comment">(* to write a float value of a power of two exactly. The    *)</span>
      <span class="comment">(* combination of inexact float literals and a C compiler   *)</span>
      <span class="comment">(* that trunctates this literals leads to errors. To avoid  *)</span>
      <span class="comment">(* problems we do the truncation instead of the C compiler. *)</span>
      incr(count.optimizations);
      <span class="keywd">block</span>
        c_expr.expr &amp;:= integerLiteral(trunc(getValue(params[1], float)));
      exception
        catch RANGE_ERROR:
          warning(DOES_RAISE, <span class="stri">"RANGE_ERROR"</span>, c_expr);
          c_expr.expr &amp;:= intRaiseError(<span class="stri">"RANGE_ERROR"</span>);
      <span class="keywd">end</span> <span class="keywd">block</span>;
    <span class="keywd">elsif</span> config.conversion_range_check <span class="keywd">then</span>
      incr(count.rangeChecks);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      number := getParameterAsVariable(<span class="stri">"floatType"</span>, <span class="stri">"tmp_"</span>, params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">"rngChk(os_isnan("</span>;
      c_expr.expr &amp;:= number;
      c_expr.expr &amp;:= <span class="stri">")||"</span>;
      c_expr.expr &amp;:= number;
      c_expr.expr &amp;:= <span class="stri">"&lt; (floatType) "</span>;
      c_expr.expr &amp;:= integerLiteral(ccConf.MINIMUM_TRUNC_ARGUMENT);
      c_expr.expr &amp;:= <span class="stri">"||"</span>;
      c_expr.expr &amp;:= number;
      c_expr.expr &amp;:= <span class="stri">"> (floatType) "</span>;
      c_expr.expr &amp;:= integerLiteral(ccConf.MAXIMUM_TRUNC_ARGUMENT);
      c_expr.expr &amp;:= <span class="stri">")?"</span>;
      c_expr.expr &amp;:= intRaiseError(<span class="stri">"RANGE_ERROR"</span>);
      c_expr.expr &amp;:= <span class="stri">":(intType)("</span>;
      c_expr.expr &amp;:= number;
      c_expr.expr &amp;:= <span class="stri">"))"</span>;
    <span class="keywd">else</span>
      incr(count.noRangeChecks);
      c_expr.expr &amp;:= <span class="stri">"(intType)("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (FLT_VALUE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"fltValue("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
