<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  bas7.sd7      Basic interpreter                                 *)</span>
<span class="comment">(*  Copyright (C) 1994, 2001, 2004 - 2010, 2013, 2016 - 2020        *)</span>
<span class="comment">(*                Thomas Mertes                                     *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This basic interpreter implements the following functions and   *)</span>
<span class="comment">(*  statements ( ** means recognized but not implemented):          *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  ABS, ASC, ATN, **BEEP, BLOAD, **CALL, CASE, CDBL, CHAIN, CHR$,  *)</span>
<span class="comment">(*  CINT, **CIRCLE, CLEAR, CLNG, CLOSE, CLS, **COLOR, **COMMON,     *)</span>
<span class="comment">(*  CONST, COS, CSNG, CSRLIN, CVD, CVDMBF, CVI, CVL, CVS, CVSMBF,   *)</span>
<span class="comment">(*  DATA, DATE$, **DECLARE, DECR, DEF FN, **DEF SEG, DEFDBL,        *)</span>
<span class="comment">(*  DEFINT, DEFLNG, DEFSNG, DEFSTR, DELAY, DIM, DISPLAY, DO,        *)</span>
<span class="comment">(*  DO UNTIL, DO WHILE, **DRAW, ELSE, ELSEIF, END, ENDIF, EOF,      *)</span>
<span class="comment">(*  **ERASE, ERR, ERROR, EXIT DO, EXIT FOR, EXP, FIELD, FIX,        *)</span>
<span class="comment">(*  **FLASH, FOR, FRE, FREEFILE, **FUNCTION, GET, GET#, GOSUB,      *)</span>
<span class="comment">(*  GOSUB OF, GOTO, GOTO OF, GR, HEX$, HGR, HOME, HPLOT, HTAB,      *)</span>
<span class="comment">(*  IF THEN, IF GOSUB, IF GOTO, INCR, INKEY$, **INP, INPUT, INPUT#, *)</span>
<span class="comment">(*  INPUT$, INSTR, INT, **INVERSE, **KEY, LBOUND, LCASE$, LEFT$,    *)</span>
<span class="comment">(*  LEN, LET, LINE INPUT, LINE INPUT#, LINPUT, LINPUT# LOCATE, LOF, *)</span>
<span class="comment">(*  LOG, LOOP, LOOP UNTIL, LOOP WHILE, LSET, LTRIM$, MID$, MKD$,    *)</span>
<span class="comment">(*  MKDMBF$, MKI$, MKL$, MKS$, MKSMBF$, NEXT, **NORMAL, OCT$,       *)</span>
<span class="comment">(*  ON ERROR, ON GOSUB, ON GOTO, **ON KEY, **ON TIMER, OPEN,        *)</span>
<span class="comment">(*  OPTION BASE, **OUT, **PAINT, **PALETTE, **PEEK, **PLAY, PLOT,   *)</span>
<span class="comment">(*  **POINT, **POKE, POS, PRESET, PRINT, PRINT#, PRINT USING,       *)</span>
<span class="comment">(*  **PR#, PSET, PUT, PUT#, RANDOMIZE, READ, REDIM, REM, RESET,     *)</span>
<span class="comment">(*  RESTORE, RESUME, RETURN, RIGHT$, RND, RPT$, RSET, RTRIM$,       *)</span>
<span class="comment">(*  **RUN, SCREEN, SEEK#, SEG$, SELECT, SGN, SIN, SLEEP, **SOUND,   *)</span>
<span class="comment">(*  SPACE$, SPC, SQR, STOP, STR$, **STRIG, STRING$, **SUB, SWAP,    *)</span>
<span class="comment">(*  SYSTEM, TAB, TAN, TEXT, TIME$, TIMER, **TYPE, UBOUND, UCASE$,   *)</span>
<span class="comment">(*  VAL, VTAB, WEND, WHILE, WRITE, WRITE#                           *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/seed7_05.htm">seed7_05.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/stdio.htm">stdio.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/osfiles.htm">osfiles.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/scanfile.htm">scanfile.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/scanstri.htm">scanstri.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/chartype.htm">chartype.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/float.htm">float.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/console.htm">console.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/draw.htm">draw.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/graph_file.htm">graph_file.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/window.htm">window.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/keybd.htm">keybd.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/keydescr.htm">keydescr.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/echo.htm">echo.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/line.htm">line.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/time.htm">time.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/duration.htm">duration.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/math.htm">math.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/bin32.htm">bin32.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/bin64.htm">bin64.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/wildcard.htm">wildcard.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/logfile.htm">logfile.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/font8x8.htm">font8x8.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/pixmap_file.htm">pixmap_file.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/editline.htm">editline.s7i</a>"</span>;

<span class="keywd">const</span> <span class="type">integer</span>: MAX_LINENUM <span class="keywd">is</span> 2147483647;
<span class="keywd">const</span> <span class="type">integer</span>: TEXT_LINES <span class="keywd">is</span> 25;
<span class="keywd">const</span> <span class="type">integer</span>: TEXT_COLUMNS <span class="keywd">is</span> 80;

<span class="keywd">const</span> <span class="type">set</span> <span class="type">of</span> <span class="type">char</span>: basic_name_char <span class="keywd">is</span> alphanum_char | {<span class="stri">'.'</span>};
<span class="keywd">const</span> <span class="type">set</span> <span class="type">of</span> <span class="type">char</span>: number_suffix <span class="keywd">is</span> {<span class="stri">'%'</span>, <span class="stri">'!'</span>, <span class="stri">'#'</span>, <span class="stri">'&amp;'</span>};
<span class="keywd">const</span> <span class="type">set</span> <span class="type">of</span> <span class="type">char</span>: numeric_var_suffix <span class="keywd">is</span> {<span class="stri">'%'</span>, <span class="stri">'!'</span>, <span class="stri">'#'</span>};

<span class="keywd">const</span> <span class="type">type</span>: lineType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">string</span>: fileName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: fileLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: linenum <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: label <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: line <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">var</span> <span class="type">array</span> <span class="type">lineType</span>: prg <span class="keywd">is</span> 0 <span class="op">times</span> lineType.value;
<span class="keywd">var</span> <span class="type">string</span>: command_line <span class="keywd">is</span> <span class="stri">""</span>;

<span class="keywd">var</span> logFile: log <span class="keywd">is</span> STD_NULL;
<span class="keywd">var</span> <span class="type">file</span>: err <span class="keywd">is</span> STD_NULL;
<span class="keywd">var</span> <span class="type">text</span>: scr <span class="keywd">is</span> STD_NULL;
<span class="keywd">var</span> <span class="type">text</span>: win <span class="keywd">is</span> STD_NULL;

<span class="keywd">var</span> <span class="type">integer</span>: file_line_number <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">string</span>: statement_label <span class="keywd">is</span> <span class="stri">""</span>;
<span class="keywd">var</span> <span class="type">string</span>: on_error_label <span class="keywd">is</span> <span class="stri">""</span>;

<span class="keywd">var</span> <span class="type">integer</span>: error_code <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">string</span>: error_linenum <span class="keywd">is</span> <span class="stri">""</span>;

<span class="keywd">var</span> <span class="type">integer</span>: resume_next_line <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">integer</span>: resume_next_column <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">integer</span>: resume_same_line <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">integer</span>: resume_same_column <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">boolean</span>: in_error_handler <span class="keywd">is</span> FALSE;

<span class="keywd">const</span> <span class="type">type</span>: label_hash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">string</span><span class="type">]</span> <span class="type">integer</span>;
<span class="keywd">var</span> <span class="type">label_hash</span>: label <span class="keywd">is</span> label_hash.EMPTY_HASH;
<span class="keywd">var</span> <span class="type">label_hash</span>: subprogram <span class="keywd">is</span> label_hash.EMPTY_HASH;
<span class="keywd">var</span> <span class="type">label_hash</span>: subfunction <span class="keywd">is</span> label_hash.EMPTY_HASH;
<span class="keywd">var</span> <span class="type">label_hash</span>: sub_declared <span class="keywd">is</span> label_hash.EMPTY_HASH;

<span class="keywd">const</span> <span class="type">type</span>: stringSet <span class="keywd">is</span> <span class="type">set</span> <span class="type">of</span> <span class="type">string</span>;
enable_output(stringSet);
<span class="keywd">var</span> <span class="type">stringSet</span>: usedLabel <span class="keywd">is</span> stringSet.value;
<span class="keywd">var</span> <span class="type">stringSet</span>: usedAsStatement <span class="keywd">is</span> stringSet.value;

<span class="keywd">const</span> <span class="type">type</span>: fileLineList <span class="keywd">is</span> <span class="type">array</span> <span class="type">integer</span>;
<span class="keywd">const</span> <span class="type">type</span>: multipleDefinedType <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">string</span><span class="type">]</span> <span class="type">fileLineList</span>;
<span class="keywd">var</span> <span class="type">multipleDefinedType</span>: multipleDefinedLabel <span class="keywd">is</span> multipleDefinedType.value;

<span class="keywd">var</span> <span class="type">integer</span>: data_line_number <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">string</span>: data_line <span class="keywd">is</span> <span class="stri">""</span>;

<span class="keywd">var</span> <span class="type">string</span>: varseg_variable <span class="keywd">is</span> <span class="stri">""</span>;

<span class="keywd">var</span> <span class="type">set</span> <span class="type">of</span> <span class="type">char</span>: defstr_var <span class="keywd">is</span> (<span class="type">set</span> <span class="type">of</span> <span class="type">char</span>).EMPTY_SET;

<span class="keywd">const</span> <span class="type">type</span>: defFnType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">string</span>: name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: params <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: expression <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: def_fn_hash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">string</span><span class="type">]</span> <span class="type">defFnType</span>;
<span class="keywd">var</span> <span class="type">def_fn_hash</span>: def_fn_list <span class="keywd">is</span> def_fn_hash.EMPTY_HASH;

<span class="keywd">const</span> <span class="type">type</span>: numeric_hash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">string</span><span class="type">]</span> <span class="type">float</span>;
<span class="keywd">var</span> <span class="type">numeric_hash</span>: numeric_var <span class="keywd">is</span> numeric_hash.EMPTY_HASH;

<span class="keywd">const</span> <span class="type">type</span>: string_hash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">string</span><span class="type">]</span> <span class="type">string</span>;
<span class="keywd">var</span> <span class="type">string_hash</span>: string_var <span class="keywd">is</span> string_hash.EMPTY_HASH;
<span class="keywd">var</span> <span class="type">stringSet</span>: string_var_name <span class="keywd">is</span> stringSet.value;

<span class="keywd">const</span> <span class="type">type</span>: image_hash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">string</span><span class="type">]</span> <span class="type">PRIMITIVE_WINDOW</span>;
<span class="keywd">var</span> <span class="type">image_hash</span>: image_var <span class="keywd">is</span> image_hash.EMPTY_HASH;

<span class="keywd">const</span> <span class="type">type</span>: file_hash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">integer</span><span class="type">]</span> <span class="type">file</span>;
<span class="keywd">var</span> <span class="type">file_hash</span>: file_value <span class="keywd">is</span> file_hash.EMPTY_HASH;

<span class="keywd">const</span> <span class="type">type</span>: varptr_hash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">string</span><span class="type">]</span> <span class="type">integer</span>;
<span class="keywd">var</span> <span class="type">varptr_hash</span>: varptr_value <span class="keywd">is</span> varptr_hash.EMPTY_HASH;

<span class="keywd">const</span> <span class="type">type</span>: varname_hash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">integer</span><span class="type">]</span> <span class="type">string</span>;
<span class="keywd">var</span> <span class="type">varname_hash</span>: varname_value <span class="keywd">is</span> varname_hash.EMPTY_HASH;

<span class="keywd">const</span> <span class="type">type</span>: reclen_array <span class="keywd">is</span> <span class="type">array</span> <span class="type">integer</span>;
<span class="keywd">var</span> <span class="type">reclen_array</span>: reclen_value <span class="keywd">is</span> 256 <span class="op">times</span> 0;

<span class="keywd">const</span> <span class="type">type</span>: field_type <span class="keywd">is</span> <span class="type">array</span> <span class="type">string</span>;
<span class="keywd">const</span> <span class="type">type</span>: field_array <span class="keywd">is</span> <span class="type">array</span> <span class="type">field_type</span>;
<span class="keywd">var</span> <span class="type">field_array</span>: field_value <span class="keywd">is</span> 256 <span class="op">times</span> 0 <span class="op">times</span> <span class="stri">""</span>;

<span class="keywd">const</span> <span class="type">type</span>: forLoopDescrType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">string</span>: varName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: endValue <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: stepValue <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">integer</span>: bodyLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bodyColumn <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">var</span> <span class="type">array</span> <span class="type">forLoopDescrType</span>: forLoop <span class="keywd">is</span> 0 <span class="op">times</span> forLoopDescrType.value;

<span class="keywd">const</span> <span class="type">type</span>: whileLoopDescrType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: condLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: condColumn <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">var</span> <span class="type">array</span> <span class="type">whileLoopDescrType</span>: whileLoop <span class="keywd">is</span> 0 <span class="op">times</span> whileLoopDescrType.value;

<span class="keywd">const</span> <span class="type">type</span>: doLoopDescrType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: headLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: headColumn <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">var</span> <span class="type">array</span> <span class="type">doLoopDescrType</span>: doLoop <span class="keywd">is</span> 0 <span class="op">times</span> doLoopDescrType.value;

<span class="keywd">const</span> <span class="type">type</span>: doLoopHeaderInColumn <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">integer</span><span class="type">]</span> <span class="type">doLoopDescrType</span>;
<span class="keywd">const</span> <span class="type">type</span>: doLoopHeaderData <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">integer</span><span class="type">]</span> <span class="type">doLoopHeaderInColumn</span>;

<span class="keywd">var</span> <span class="type">doLoopHeaderData</span>: doLoopHeaders <span class="keywd">is</span> doLoopHeaderData.EMPTY_HASH;

<span class="keywd">const</span> <span class="type">type</span>: gosubReturnDescrType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: returnLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: returnColumn <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: subEntryLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: subName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: forLoopStackDepth <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: whileLoopStackDepth <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: doLoopStackDepth <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">var</span> <span class="type">array</span> <span class="type">gosubReturnDescrType</span>: gosubReturn <span class="keywd">is</span> 0 <span class="op">times</span> gosubReturnDescrType.value;

<span class="keywd">const</span> <span class="type">type</span>: boundsType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: lbound <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: ubound <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: dimensionType <span class="keywd">is</span> <span class="type">array</span> <span class="type">boundsType</span>;

<span class="keywd">var</span> <span class="type">float</span>: lastRandomNumber <span class="keywd">is</span> 0.0;
<span class="keywd">var</span> <span class="type">integer</span>: screenMode <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">integer</span>: currX <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">integer</span>: currY <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">integer</span>: foreground_color <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">integer</span>: background_color <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">bitmapFont</span>: currentFont <span class="keywd">is</span> bitmapFont.value;

<span class="keywd">var</span> <span class="type">set</span> <span class="type">of</span> <span class="type">string</span>: numeric_functions <span class="keywd">is</span> {
    <span class="stri">"ABS"</span>,      <span class="stri">"ASC"</span>,      <span class="stri">"ATN"</span>,      <span class="stri">"CDBL"</span>,     <span class="stri">"CINT"</span>,     <span class="stri">"CLNG"</span>,
    <span class="stri">"COS"</span>,      <span class="stri">"CSNG"</span>,     <span class="stri">"CSRLIN"</span>,   <span class="stri">"CVI"</span>,      <span class="stri">"CVL"</span>,      <span class="stri">"EOF"</span>,
    <span class="stri">"ERL"</span>,      <span class="stri">"ERR"</span>,      <span class="stri">"EXP"</span>,      <span class="stri">"FIX"</span>,      <span class="stri">"FRE"</span>,      <span class="stri">"FREEFILE"</span>,
    <span class="stri">"INP"</span>,      <span class="stri">"INSTR"</span>,    <span class="stri">"INT"</span>,      <span class="stri">"LBOUND"</span>,   <span class="stri">"LEN"</span>,      <span class="stri">"LOF"</span>,
    <span class="stri">"LOG"</span>,      <span class="stri">"PEEK"</span>,     <span class="stri">"POINT"</span>,    <span class="stri">"POS"</span>,      <span class="stri">"RND"</span>,      <span class="stri">"SCREEN"</span>,
    <span class="stri">"SGN"</span>,      <span class="stri">"SIN"</span>,      <span class="stri">"SQR"</span>,      <span class="stri">"STRIG"</span>,    <span class="stri">"TAN"</span>,      <span class="stri">"TIMER"</span>,
    <span class="stri">"UBOUND"</span>,   <span class="stri">"VAL"</span>,      <span class="stri">"VARPTR"</span>};

<span class="keywd">const</span> <span class="type">set</span> <span class="type">of</span> <span class="type">string</span>: not_allowed_as_label <span class="keywd">is</span> {
    <span class="stri">"BEEP"</span>,      <span class="stri">"CLEAR"</span>,     <span class="stri">"CLOSE"</span>,     <span class="stri">"CLS"</span>,       <span class="stri">"COLOR"</span>,     <span class="stri">"COMMON"</span>,
    <span class="stri">"CONST"</span>,     <span class="stri">"DATA"</span>,      <span class="stri">"DECLARE"</span>,   <span class="stri">"DEF"</span>,       <span class="stri">"DEFDBL"</span>,    <span class="stri">"DEFINT"</span>,
    <span class="stri">"DEFSNG"</span>,    <span class="stri">"DEFSTR"</span>,    <span class="stri">"DIM"</span>,       <span class="stri">"DO"</span>,        <span class="stri">"DRAW"</span>,      <span class="stri">"ELSE"</span>,
    <span class="stri">"ELSEIF"</span>,    <span class="stri">"END"</span>,       <span class="stri">"ERASE"</span>,     <span class="stri">"EXIT"</span>,      <span class="stri">"GET"</span>,       <span class="stri">"IF"</span>,
    <span class="stri">"INPUT"</span>,     <span class="stri">"KEY"</span>,       <span class="stri">"LET"</span>,       <span class="stri">"LOCATE"</span>,    <span class="stri">"LOOP"</span>,      <span class="stri">"LPRINT"</span>,
    <span class="stri">"NEXT"</span>,      <span class="stri">"OPEN"</span>,      <span class="stri">"OPTION"</span>,    <span class="stri">"OUT"</span>,       <span class="stri">"PAINT"</span>,     <span class="stri">"PALETTE"</span>,
    <span class="stri">"PLAY"</span>,      <span class="stri">"POKE"</span>,      <span class="stri">"PRINT"</span>,     <span class="stri">"PUT"</span>,       <span class="stri">"RANDOMIZE"</span>, <span class="stri">"READ"</span>,
    <span class="stri">"REDIM"</span>,     <span class="stri">"REM"</span>,       <span class="stri">"RESET"</span>,     <span class="stri">"RESTORE"</span>,   <span class="stri">"RESUME"</span>,    <span class="stri">"RETURN"</span>,
    <span class="stri">"RUN"</span>,       <span class="stri">"SCREEN"</span>,    <span class="stri">"SEEK"</span>,      <span class="stri">"SELECT"</span>,    <span class="stri">"SLEEP"</span>,     <span class="stri">"STOP"</span>,
    <span class="stri">"SUB"</span>,       <span class="stri">"SYSTEM"</span>,    <span class="stri">"WEND"</span>,      <span class="stri">"WRITE"</span>};

<span class="keywd">const</span> <span class="type">array</span> <span class="type">color</span>: loresColor <span class="keywd">is</span> [0] (
    black,
    color(16#9000, 16#1700, 16#4000), <span class="comment"># Deep Red</span>
    color(16#4000, 16#2c00, 16#a500), <span class="comment"># Dark Blue</span>
    color(16#d000, 16#4300, 16#e500), <span class="comment"># Purple</span>
    color(16#0000, 16#6900, 16#4000), <span class="comment"># Dark Green</span>
    color(16#8000, 16#8000, 16#8000), <span class="comment"># Gray 1</span>
    color(16#2f00, 16#9500, 16#e500), <span class="comment"># Medium Blue</span>
    color(16#bf00, 16#ab00, 16#ff00), <span class="comment"># Light Blue</span>
    color(16#4000, 16#2400, 16#0000), <span class="comment"># Brown</span>
    color(16#d000, 16#6a00, 16#1a00), <span class="comment"># Orange</span>
    color(16#8000, 16#8000, 16#8000), <span class="comment"># Gray 2</span>
    color(16#ff00, 16#9600, 16#bf00), <span class="comment"># Pink</span>
    color(16#2f00, 16#bc00, 16#1a00), <span class="comment"># Light Green</span>
    color(16#bf00, 16#d300, 16#5a00), <span class="comment"># Yellow</span>
    color(16#6f00, 16#e800, 16#bf00), <span class="comment"># Aquamarine</span>
    white);

<span class="keywd">const</span> <span class="type">array</span> <span class="type">color</span>: hiresColor <span class="keywd">is</span> [0] (
    black,                            <span class="comment"># Black 1</span>
    color(16#2f00, 16#bc00, 16#1a00), <span class="comment"># Green</span>
    color(16#d000, 16#4300, 16#e500), <span class="comment"># Violet</span>
    white,                            <span class="comment"># White 1</span>
    black,                            <span class="comment"># Black 2</span>
    color(16#d000, 16#6a00, 16#1a00), <span class="comment"># Orange</span>
    color(16#2f00, 16#9500, 16#e500), <span class="comment"># Medium Blue</span>
    white);                           <span class="comment"># White 2</span>


<span class="keywd">const</span> <span class="type">proc</span>: sleep (<span class="op">in</span> <span class="type">integer</span>: secs) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">time</span>: start_time <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    start_time := time(NOW);
    await(start_time + secs . SECONDS);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: delay (<span class="op">in</span> <span class="type">float</span>: secs) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">time</span>: start_time <span class="keywd">is</span> time.value;
    <span class="keywd">var</span> <span class="type">integer</span>: seconds <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: micro_seconds <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    start_time := time(NOW);
    seconds := trunc(secs);
    micro_seconds := round((secs - flt(seconds)) * 1000000.0);
    await(start_time + seconds . SECONDS + micro_seconds . MICRO_SECONDS);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: listProg (<span class="keywd">inout</span> <span class="type">file</span>: listFile, <span class="op">in</span> <span class="type">integer</span>: fromLine, <span class="op">in</span> <span class="type">integer</span>: toLine) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: doList <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    doList := fromLine = 0;
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> length(prg) <span class="keywd">do</span>
      <span class="keywd">if</span> prg[number].linenum &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        doList := integer(prg[number].linenum) >= fromLine <span class="op">and</span>
                  integer(prg[number].linenum) &lt;= toLine;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> doList <span class="op">and</span> (prg[number].line &lt;> <span class="stri">""</span> <span class="op">or</span> prg[number].linenum &lt;> <span class="stri">""</span> <span class="op">or</span>
          prg[number].label &lt;> <span class="stri">""</span>) <span class="keywd">then</span>
        <span class="comment"># write(listFile, ("(" &lt;&amp; number &lt;&amp; ")") lpad 5 &lt;&amp; " ");</span>
        <span class="keywd">if</span> prg[number].linenum &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          write(listFile, prg[number].linenum &lt;&amp; <span class="stri">" "</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> prg[number].label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          write(listFile, prg[number].label &lt;&amp; <span class="stri">": "</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        writeln(listFile, prg[number].line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> prg[number].linenum &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        doList := integer(prg[number].linenum) >= fromLine <span class="op">and</span>
                  integer(prg[number].linenum) &lt; toLine;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Reads a BASIC symbol from a 'string'.
 *  When the function is called it is assumed that 'line' is empty or
 *  line[1] contains the first character to be handled. When the
 *  function is left 'line' is empty or line[1] contains the character
 *  after the BASIC symbol. A BASIC symbol can be:
 *    - A name: A letter followed by letters, digits or '.'.
 *              Optionally a '$', '%', '!', '#' or '&amp;' can be added.
 *    - An integer number: A sequence of digits.
 *    - A float number: A sequence of digits which contains one
 *              decimal point. An optional exponent may follow. If
 *              an exponent is present the decimal point may be
 *              omitted. The exponent is introduced with 'E' or 'e'
 *              followed by an optional sign ('+' or '-') and a
 *              sequence of digits. If the float number does start
 *              with '.' a '0' is added in front of the returned
 *              symbol.
 *    - A hex literal: It starts with '&amp;H' or '&amp;h' followed by hex
 *              digits. A hex literal is converted to decimal and the
 *              decimal literal is returned.
 *    - An octal literal: It starts with '&amp;O' or '&amp;o' followed by
 *              octal digits. An octal literal is converted to decimal
 *              and the decimal literal is returned.
 *    - A string literal: A sequence of characters enclosed in double
 *              quotation marks. A string literal is returned with the
 *              introducing " but without the ending " .
 *    - A special symbol: The symbols '&lt;>', '&lt;=' and '>=' are special
 *              symbols consisting of two characters. There can be a
 *              spaces and tabs between the two characters. Such
 *              spaces and tabs are removed from the symbol.
 *              It is even possible that the two characters of a
 *              special symbol are interchanged. In this case the
 *              symbol is returned in the standardized form.
 *    - A one character symbol: If no other symbols can be
 *              recognized a symbol consisting of one character is
 *              created. E.g.: '=', '+', '-'.
 *  @return the BASIC symbol or "" at the end of the line.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: get_symbol (<span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: start <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    leng := length(line);
    <span class="keywd">if</span> leng > 0 <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        incr(start);
        <span class="keywd">if</span> start &lt;= leng <span class="keywd">then</span>
          ch := line[start];
        <span class="keywd">else</span>
          ch := <span class="stri">'\0;'</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> ch &lt;> <span class="stri">' '</span> <span class="op">and</span> ch &lt;> <span class="stri">'\t'</span>;
      index := start;
      <span class="keywd">case</span> ch <span class="keywd">of</span>
        <span class="keywd">when</span> letter_char:
          <span class="keywd">repeat</span>
            incr(index);
            <span class="keywd">if</span> index &lt;= leng <span class="keywd">then</span>
              ch := line[index];
            <span class="keywd">else</span>
              ch := <span class="stri">' '</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">until</span> ch <span class="op">not</span> <span class="op">in</span> basic_name_char;
          <span class="keywd">if</span> ch = <span class="stri">'$'</span> <span class="op">or</span> ch = <span class="stri">'%'</span> <span class="op">or</span> ch = <span class="stri">'!'</span> <span class="op">or</span> ch = <span class="stri">'#'</span> <span class="op">or</span> ch = <span class="stri">'&amp;'</span> <span class="keywd">then</span>
            incr(index);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          symbol := upper(line[start .. pred(index)]);
          line := line[index .. ];
        <span class="keywd">when</span> digit_char:
          <span class="keywd">repeat</span>
            incr(index);
            <span class="keywd">if</span> index &lt;= leng <span class="keywd">then</span>
              ch := line[index];
            <span class="keywd">else</span>
              ch := <span class="stri">' '</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">until</span> ch <span class="op">not</span> <span class="op">in</span> digit_char;
          <span class="keywd">if</span> ch = <span class="stri">'.'</span> <span class="keywd">then</span>
            incr(index);
            <span class="keywd">if</span> index &lt;= leng <span class="op">and</span> line[index] <span class="op">in</span> digit_char <span class="keywd">then</span>
              <span class="keywd">repeat</span>
                incr(index);
                <span class="keywd">if</span> index &lt;= leng <span class="keywd">then</span>
                  ch := line[index];
                <span class="keywd">else</span>
                  ch := <span class="stri">' '</span>;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">until</span> ch <span class="op">not</span> <span class="op">in</span> digit_char;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> ch = <span class="stri">'E'</span> <span class="op">or</span> ch = <span class="stri">'e'</span> <span class="keywd">then</span>
            incr(index);
            <span class="keywd">if</span> index &lt;= leng <span class="keywd">then</span>
              ch := line[index];
            <span class="keywd">else</span>
              ch := <span class="stri">' '</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> ch <span class="op">in</span> digit_char <span class="op">or</span> ch = <span class="stri">'+'</span> <span class="op">or</span> ch = <span class="stri">'-'</span> <span class="keywd">then</span>
              <span class="keywd">if</span> ch = <span class="stri">'+'</span> <span class="op">or</span> ch = <span class="stri">'-'</span> <span class="keywd">then</span>
                incr(index);
                <span class="keywd">if</span> index &lt;= leng <span class="keywd">then</span>
                  ch := line[index];
                <span class="keywd">else</span>
                  ch := <span class="stri">' '</span>;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">while</span> ch <span class="op">in</span> digit_char <span class="keywd">do</span>
                incr(index);
                <span class="keywd">if</span> index &lt;= leng <span class="keywd">then</span>
                  ch := line[index];
                <span class="keywd">else</span>
                  ch := <span class="stri">' '</span>;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">while</span>;
            <span class="keywd">else</span>
              decr(index);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> ch <span class="op">in</span> number_suffix <span class="keywd">then</span>
            incr(index);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          symbol := line[start .. pred(index)];
          line := line[index .. ];
        <span class="keywd">when</span> {<span class="stri">'.'</span>}:
          incr(index);
          <span class="keywd">if</span> index &lt;= leng <span class="op">and</span> line[index] <span class="op">in</span> digit_char <span class="keywd">then</span>
            <span class="keywd">repeat</span>
              incr(index);
              <span class="keywd">if</span> index &lt;= leng <span class="keywd">then</span>
                ch := line[index];
              <span class="keywd">else</span>
                ch := <span class="stri">' '</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">until</span> ch <span class="op">not</span> <span class="op">in</span> digit_char;
            <span class="keywd">if</span> ch = <span class="stri">'E'</span> <span class="op">or</span> ch = <span class="stri">'e'</span> <span class="keywd">then</span>
              incr(index);
              <span class="keywd">if</span> index &lt;= leng <span class="keywd">then</span>
                ch := line[index];
              <span class="keywd">else</span>
                ch := <span class="stri">' '</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> ch <span class="op">in</span> digit_char <span class="op">or</span> ch = <span class="stri">'+'</span> <span class="op">or</span> ch = <span class="stri">'-'</span> <span class="keywd">then</span>
                <span class="keywd">if</span> ch = <span class="stri">'+'</span> <span class="op">or</span> ch = <span class="stri">'-'</span> <span class="keywd">then</span>
                  incr(index);
                  <span class="keywd">if</span> index &lt;= leng <span class="keywd">then</span>
                    ch := line[index];
                  <span class="keywd">else</span>
                    ch := <span class="stri">' '</span>;
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                <span class="keywd">end</span> <span class="keywd">if</span>;
                <span class="keywd">while</span> ch <span class="op">in</span> digit_char <span class="keywd">do</span>
                  incr(index);
                  <span class="keywd">if</span> index &lt;= leng <span class="keywd">then</span>
                    ch := line[index];
                  <span class="keywd">else</span>
                    ch := <span class="stri">' '</span>;
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                <span class="keywd">end</span> <span class="keywd">while</span>;
              <span class="keywd">else</span>
                decr(index);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> ch <span class="op">in</span> number_suffix <span class="keywd">then</span>
              incr(index);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            symbol := <span class="stri">"0"</span> &amp; line[start .. pred(index)];
            line := line[index .. ];
          <span class="keywd">else</span>
            symbol := <span class="stri">"."</span>;
            line := line[index .. ];
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'&amp;'</span>}:
          incr(index);
          <span class="keywd">if</span> index &lt;= leng <span class="keywd">then</span>
            ch := line[index];
            <span class="keywd">if</span> ch = <span class="stri">'H'</span> <span class="op">or</span> ch = <span class="stri">'h'</span> <span class="keywd">then</span>
              incr(index);
              start := index;
              <span class="keywd">while</span> index &lt;= leng <span class="op">and</span> line[index] <span class="op">in</span> hexdigit_char <span class="keywd">do</span>
                incr(index);
              <span class="keywd">end</span> <span class="keywd">while</span>;
              <span class="keywd">if</span> index > start <span class="keywd">then</span>
                symbol := str(integer(line[start .. pred(index)], 16));
                <span class="keywd">if</span> index &lt;= leng <span class="op">and</span> line[index] <span class="op">in</span> number_suffix <span class="keywd">then</span>
                  symbol &amp;:= line[index len 1];
                  incr(index);
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">else</span>
                symbol := <span class="stri">"&amp;H"</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">elsif</span> ch = <span class="stri">'O'</span> <span class="op">or</span> ch = <span class="stri">'o'</span> <span class="keywd">then</span>
              incr(index);
              start := index;
              <span class="keywd">while</span> index &lt;= leng <span class="op">and</span> line[index] <span class="op">in</span> octdigit_char <span class="keywd">do</span>
                incr(index);
              <span class="keywd">end</span> <span class="keywd">while</span>;
              <span class="keywd">if</span> index > start <span class="keywd">then</span>
                symbol := str(integer(line[start .. pred(index)], 8));
                <span class="keywd">if</span> index &lt;= leng <span class="op">and</span> line[index] <span class="op">in</span> number_suffix <span class="keywd">then</span>
                  symbol &amp;:= line[index len 1];
                  incr(index);
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">else</span>
                symbol := <span class="stri">"&amp;O"</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">else</span>
              symbol := <span class="stri">"&amp;"</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            symbol := <span class="stri">"&amp;"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          line := line[index .. ];
        <span class="keywd">when</span> {<span class="stri">'"'</span>}:
          <span class="keywd">repeat</span>
            incr(index);
          <span class="keywd">until</span> index > leng <span class="op">or</span> line[index] = <span class="stri">'"'</span>;
          symbol := line[start .. pred(index)];
          line := line[succ(index) .. ];
        <span class="keywd">when</span> {<span class="stri">'&lt;'</span>}:
          <span class="comment"># Sometimes &lt;> or &lt;= are written as &lt; > or &lt; =</span>
          <span class="keywd">repeat</span>
            incr(index);
            <span class="keywd">if</span> index &lt;= leng <span class="keywd">then</span>
              ch := line[index];
            <span class="keywd">else</span>
              ch := <span class="stri">'\0;'</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">until</span> ch &lt;> <span class="stri">' '</span> <span class="op">and</span> ch &lt;> <span class="stri">'\t'</span>;
          <span class="keywd">if</span> ch = <span class="stri">'>'</span> <span class="keywd">then</span>
            incr(index);
            symbol := <span class="stri">"&lt;>"</span>;
          <span class="keywd">elsif</span> ch = <span class="stri">'='</span> <span class="keywd">then</span>
            incr(index);
            symbol := <span class="stri">"&lt;="</span>;
          <span class="keywd">else</span>
            symbol := <span class="stri">"&lt;"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          line := line[index .. ];
        <span class="keywd">when</span> {<span class="stri">'>'</span>}:
          <span class="comment"># Sometimes >= is written as > =</span>
          <span class="keywd">repeat</span>
            incr(index);
            <span class="keywd">if</span> index &lt;= leng <span class="keywd">then</span>
              ch := line[index];
            <span class="keywd">else</span>
              ch := <span class="stri">'\0;'</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">until</span> ch &lt;> <span class="stri">' '</span> <span class="op">and</span> ch &lt;> <span class="stri">'\t'</span>;
          <span class="keywd">if</span> ch = <span class="stri">'='</span> <span class="keywd">then</span>
            incr(index);
            symbol := <span class="stri">">="</span>;
          <span class="keywd">elsif</span> ch = <span class="stri">'&lt;'</span> <span class="keywd">then</span>
            <span class="comment"># Sometimes &lt;> is written as >&lt; or > &lt;</span>
            incr(index);
            symbol := <span class="stri">"&lt;>"</span>;
          <span class="keywd">else</span>
            symbol := <span class="stri">">"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          line := line[index .. ];
        <span class="keywd">when</span> {<span class="stri">'='</span>}:
          <span class="keywd">repeat</span>
            incr(index);
            <span class="keywd">if</span> index &lt;= leng <span class="keywd">then</span>
              ch := line[index];
            <span class="keywd">else</span>
              ch := <span class="stri">'\0;'</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">until</span> ch &lt;> <span class="stri">' '</span> <span class="op">and</span> ch &lt;> <span class="stri">'\t'</span>;
          <span class="keywd">if</span> ch = <span class="stri">'&lt;'</span> <span class="keywd">then</span>
            <span class="comment"># Sometimes &lt;= is written as =&lt; or = &lt;</span>
            incr(index);
            symbol := <span class="stri">"&lt;="</span>;
          <span class="keywd">elsif</span> ch = <span class="stri">'>'</span> <span class="keywd">then</span>
            <span class="comment"># Sometimes >= is written as => or = ></span>
            incr(index);
            symbol := <span class="stri">">="</span>;
          <span class="keywd">else</span>
            symbol := <span class="stri">"="</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          line := line[index .. ];
        <span class="keywd">when</span> {<span class="stri">'\r'</span>}:
          symbol := <span class="stri">""</span>;
          line := line[succ(index) .. ];
        <span class="keywd">otherwise</span>:
          symbol := line[index len 1];
          line := line[succ(index) .. ];
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="comment"># writeln(log, "SY=" &lt;&amp; literal(symbol));</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: endOfStatement (<span class="op">in</span> <span class="type">string</span>: symbol) <span class="keywd">is</span>
  <span class="keywd">return</span> symbol = <span class="stri">":"</span> <span class="op">or</span> symbol = <span class="stri">""</span> <span class="op">or</span> symbol = <span class="stri">"'"</span> <span class="op">or</span> symbol = <span class="stri">"REM"</span> <span class="op">or</span> symbol = <span class="stri">"ELSE"</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: ignoreRestOfLine (<span class="op">in</span> <span class="type">string</span>: symbol) <span class="keywd">is</span>
  <span class="keywd">return</span> symbol = <span class="stri">"'"</span> <span class="op">or</span> symbol = <span class="stri">"REM"</span> <span class="op">or</span> symbol = <span class="stri">"DATA"</span> <span class="op">or</span> symbol = <span class="stri">"DATA&amp;"</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isStringExpr (<span class="op">in</span> <span class="type">string</span>: symbol) <span class="keywd">is</span>
  <span class="keywd">return</span> symbol <span class="op">in</span> string_var_name <span class="op">or</span>
         symbol &lt;> <span class="stri">""</span> <span class="op">and</span>
        (symbol[length(symbol)] = <span class="stri">'$'</span> <span class="op">or</span> symbol[1] = <span class="stri">'\"'</span> <span class="op">or</span> symbol[1] <span class="op">in</span> defstr_var <span class="op">and</span>
         <span class="op">not</span> symbol[length(symbol)] <span class="op">in</span> numeric_var_suffix);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isStringVar (<span class="op">in</span> <span class="type">string</span>: symbol) <span class="keywd">is</span>
  <span class="keywd">return</span> symbol <span class="op">in</span> string_var_name <span class="op">or</span>
         symbol &lt;> <span class="stri">""</span> <span class="op">and</span>
        (symbol[length(symbol)] = <span class="stri">'$'</span> <span class="op">or</span> symbol[1] <span class="op">in</span> defstr_var <span class="op">and</span>
         <span class="op">not</span> symbol[length(symbol)] <span class="op">in</span> numeric_var_suffix);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isNumericVar (<span class="op">in</span> <span class="type">string</span>: symbol) <span class="keywd">is</span>
  <span class="keywd">return</span> symbol <span class="op">not</span> <span class="op">in</span> string_var_name <span class="op">or</span>
         symbol &lt;> <span class="stri">""</span> <span class="op">and</span>
        (symbol[1] <span class="op">in</span> letter_char - defstr_var <span class="op">or</span>
         symbol[length(symbol)] <span class="op">in</span> numeric_var_suffix);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: getNumericVar (<span class="op">in</span> <span class="type">string</span>: varName) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: numericValue <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> varName <span class="op">in</span> numeric_var <span class="keywd">then</span>
      numericValue := numeric_var[varName];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: setNumericVar (<span class="op">in</span> <span class="type">string</span>: varName, <span class="op">in</span> <span class="type">float</span>: number) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    numeric_var @:= [varName] number;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getStringVar (<span class="op">in</span> <span class="type">string</span>: varName) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stringValue <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> varName <span class="op">in</span> string_var <span class="keywd">then</span>
      stringValue := string_var[varName];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: setStringVar (<span class="op">in</span> <span class="type">string</span>: varName, <span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    string_var @:= [varName] stri;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: varptr (<span class="op">in</span> <span class="type">string</span>: variable_name) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: address <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> variable_name <span class="op">not</span> <span class="op">in</span> varptr_value <span class="keywd">then</span>
      varptr_value @:= [variable_name] succ(length(varptr_value));
    <span class="keywd">end</span> <span class="keywd">if</span>;
    address := varptr_value[variable_name];
    varname_value @:= [address] variable_name;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: varptrStri (<span class="op">in</span> <span class="type">string</span>: variable_name) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: addrStri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: address <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    address := varptr(variable_name);
    addrStri := <span class="stri">"\3;"</span> &amp; bytes(address, UNSIGNED, LE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: varname (<span class="op">in</span> <span class="type">integer</span>: address) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> address <span class="op">in</span> varname_value <span class="keywd">then</span>
      variable_name := varname_value[address];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">file</span>: getFileValue (<span class="op">in</span> <span class="type">integer</span>: file_number) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">file</span>: fileValue <span class="keywd">is</span> STD_NULL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> file_number <span class="op">in</span> file_value <span class="keywd">then</span>
      fileValue := file_value[file_number];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: setFileValue (<span class="op">in</span> <span class="type">integer</span>: file_number, <span class="op">in</span> <span class="type">file</span>: aFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    file_value @:= [file_number] aFile;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: closeAllFiles <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">file</span>: aFile <span class="keywd">is</span> STD_NULL;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> aFile <span class="keywd">range</span> file_value <span class="keywd">do</span>
      close(aFile);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    file_value := file_hash.EMPTY_HASH;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: addDoLoopHeader (<span class="op">in</span> <span class="type">integer</span>: tailLine, <span class="op">in</span> <span class="type">integer</span>: tailColumn,
    <span class="op">in</span> <span class="type">integer</span>: headLine, <span class="op">in</span> <span class="type">integer</span>: headColumn) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> tailLine <span class="op">in</span> doLoopHeaders <span class="keywd">then</span>
      <span class="keywd">if</span> tailColumn <span class="op">not</span> <span class="op">in</span> doLoopHeaders[tailLine] <span class="keywd">then</span>
        doLoopHeaders[tailLine] @:= [tailColumn] doLoopDescrType.value;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      doLoopHeaders @:= [tailLine] doLoopHeaderInColumn.value;
      doLoopHeaders[tailLine] @:= [tailColumn] doLoopDescrType.value;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    doLoopHeaders[tailLine][tailColumn].headLine := headLine;
    doLoopHeaders[tailLine][tailColumn].headColumn := headColumn;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: doLoopHeaderPresent (<span class="op">in</span> <span class="type">integer</span>: tailLine, <span class="op">in</span> <span class="type">integer</span>: tailColumn,
    <span class="keywd">inout</span> <span class="type">integer</span>: headLine, <span class="keywd">inout</span> <span class="type">integer</span>: headColumn) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: headerIsPresent <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> tailLine <span class="op">in</span> doLoopHeaders <span class="keywd">then</span>
      <span class="keywd">if</span> tailColumn <span class="op">in</span> doLoopHeaders[tailLine] <span class="keywd">then</span>
        headerIsPresent := TRUE;
        headLine := doLoopHeaders[tailLine][tailColumn].headLine;
        headColumn := doLoopHeaders[tailLine][tailColumn].headColumn;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: line_marker <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> statement_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      write(log, statement_label &lt;&amp; <span class="stri">" "</span>);
    <span class="keywd">elsif</span> file_line_number >= 1 <span class="op">and</span> file_line_number &lt;= length(prg) <span class="keywd">then</span>
      <span class="keywd">if</span> prg[file_line_number].fileName &lt;> prg[1].fileName <span class="keywd">then</span>
        write(log, prg[file_line_number].fileName);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      write(log, <span class="stri">"("</span> &lt;&amp; prg[file_line_number].fileLine &lt;&amp; <span class="stri">") "</span>);
    <span class="keywd">else</span>
      write(log, <span class="stri">"##### "</span> &lt;&amp; file_line_number &lt;&amp; <span class="stri">" ##### "</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: line_marker (<span class="op">in</span> <span class="type">integer</span>: line_number) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> line_number >= 1 <span class="op">and</span> line_number &lt;= length(prg) <span class="keywd">then</span>
      <span class="keywd">if</span> prg[line_number].label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        write(log, prg[line_number].label);
      <span class="keywd">elsif</span> prg[line_number].linenum &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        write(log, prg[line_number].linenum);
      <span class="keywd">else</span>
        <span class="keywd">if</span> prg[line_number].fileName &lt;> prg[1].fileName <span class="keywd">then</span>
          write(log, prg[line_number].fileName);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        write(log, <span class="stri">"("</span> &lt;&amp; prg[line_number].fileLine &lt;&amp; <span class="stri">")"</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      write(log, <span class="stri">"##### "</span> &lt;&amp; line_number &lt;&amp; <span class="stri">" ##### "</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: error_marker <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    write(err, <span class="stri">" ***** "</span>);
    <span class="keywd">if</span> statement_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      write(err, <span class="stri">"["</span> &lt;&amp; statement_label &lt;&amp; <span class="stri">"] "</span>);
    <span class="keywd">elsif</span> file_line_number >= 1 <span class="op">and</span> file_line_number &lt;= length(prg) <span class="keywd">then</span>
      <span class="keywd">if</span> prg[file_line_number].fileName &lt;> prg[1].fileName <span class="keywd">then</span>
        write(err, prg[file_line_number].fileName);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      write(err, <span class="stri">"("</span> &lt;&amp; prg[file_line_number].fileLine &lt;&amp; <span class="stri">") "</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: error_marker (<span class="op">in</span> <span class="type">string</span>: label) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    write(err, <span class="stri">" ***** ("</span> &lt;&amp; label &lt;&amp; <span class="stri">") "</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: error_expect (<span class="op">in</span> <span class="type">string</span>: expected_symbol, <span class="op">in</span> <span class="type">string</span>: symbol) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    error_marker;
    writeln(err, literal(expected_symbol) &lt;&amp;
        <span class="stri">" EXPECTED - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: error_expect2 (<span class="op">in</span> <span class="type">string</span>: expected_symbol1, <span class="op">in</span> <span class="type">string</span>: expected_symbol2, <span class="op">in</span> <span class="type">string</span>: symbol) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    error_marker;
    writeln(err, literal(expected_symbol1) &lt;&amp; <span class="stri">" OR "</span> &lt;&amp; literal(expected_symbol2) &lt;&amp;
        <span class="stri">" EXPECTED - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: error_expect3 (<span class="op">in</span> <span class="type">string</span>: expected_symbol1, <span class="op">in</span> <span class="type">string</span>: expected_symbol2,
    <span class="op">in</span> <span class="type">string</span>: expected_symbol3, <span class="op">in</span> <span class="type">string</span>: symbol) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    error_marker;
    writeln(err, literal(expected_symbol1) &lt;&amp; <span class="stri">", "</span> &lt;&amp; literal(expected_symbol2) &lt;&amp; <span class="stri">" OR "</span> &lt;&amp;
        literal(expected_symbol3) &lt;&amp;  <span class="stri">" EXPECTED - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: expect (<span class="op">in</span> <span class="type">string</span>: expected_symbol, <span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> symbol = expected_symbol <span class="keywd">then</span>
      symbol := get_symbol(line);
    <span class="keywd">else</span>
      error_expect(expected_symbol, symbol);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: label_or_linenum (<span class="op">in</span> <span class="type">string</span>: symbol) <span class="keywd">is</span>
  <span class="keywd">return</span> symbol <span class="op">in</span> label <span class="op">or</span> (symbol &lt;> <span class="stri">""</span> <span class="op">and</span> symbol[1] <span class="op">in</span> digit_char);


<span class="keywd">const</span> <span class="type">proc</span>: goto_label_or_linenum (<span class="op">in</span> <span class="type">string</span>: new_label) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: searched_linenum <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: matched_linenum <span class="keywd">is</span> MAX_LINENUM;
    <span class="keywd">var</span> <span class="type">integer</span>: linenum <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> new_label <span class="op">in</span> label <span class="keywd">then</span>
      statement_label := new_label;
      file_line_number := pred(label[statement_label]);
    <span class="keywd">elsif</span> new_label &lt;> <span class="stri">""</span> <span class="op">and</span> new_label[1] <span class="op">in</span> digit_char <span class="keywd">then</span>
      searched_linenum := integer(new_label);
      <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> length(prg) <span class="keywd">do</span>
        <span class="keywd">if</span> prg[number].linenum &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          linenum := integer(prg[number].linenum);
          <span class="keywd">if</span> linenum >= searched_linenum <span class="op">and</span>
              linenum &lt; matched_linenum <span class="keywd">then</span>
            matched_linenum := linenum;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">if</span> matched_linenum &lt;> MAX_LINENUM <span class="op">and</span>
          str(matched_linenum) <span class="op">in</span> label <span class="keywd">then</span>
        error_marker;
        writeln(err, <span class="stri">"LABEL "</span> &lt;&amp; new_label &lt;&amp;
            <span class="stri">" DOES NOT EXIST - USE "</span> &lt;&amp; matched_linenum &lt;&amp; <span class="stri">" INSTEAD"</span>);
        statement_label := str(matched_linenum);
        file_line_number := pred(label[statement_label]);
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"LABEL "</span> &lt;&amp; new_label &lt;&amp; <span class="stri">" DOES NOT EXIST"</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"LABEL "</span> &lt;&amp; new_label &lt;&amp; <span class="stri">" DOES NOT EXIST"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: set_return_position (<span class="op">in</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    column := length(prg[file_line_number].line) - length(line) + 1;
    gosubReturn := [] (gosubReturnDescrType.value) &amp; gosubReturn;
    gosubReturn[1].returnLine := file_line_number;
    gosubReturn[1].returnColumn := column;
    gosubReturn[1].forLoopStackDepth := length(forLoop);
    gosubReturn[1].whileLoopStackDepth := length(whileLoop);
    gosubReturn[1].doLoopStackDepth := length(doLoop);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: set_sub_entry_position <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    gosubReturn[1].subEntryLine := succ(file_line_number);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: check_loop_stacks_before_return (<span class="op">in</span> <span class="type">string</span>: returnStatementName) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(forLoop) > gosubReturn[1].forLoopStackDepth <span class="keywd">then</span>
      error_marker;
      writeln(err, returnStatementName &lt;&amp; <span class="stri">" - SOME FOR LOOPS WERE NOT LEFT"</span>);
      <span class="keywd">repeat</span>
        line_marker;
        write(log, <span class="stri">"LEAVE THE \"FOR "</span> &lt;&amp; forLoop[1].varName &lt;&amp;
            <span class="stri">"\" LOOP AT LINE "</span>);
        line_marker(forLoop[1].bodyLine);
        writeln(log);
        forLoop := forLoop[2 .. ];
      <span class="keywd">until</span> length(forLoop) &lt;= gosubReturn[1].forLoopStackDepth;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> length(whileLoop) > gosubReturn[1].whileLoopStackDepth <span class="keywd">then</span>
      error_marker;
      writeln(err, returnStatementName &lt;&amp; <span class="stri">" - SOME WHILE LOOPS WERE NOT LEFT"</span>);
      <span class="keywd">repeat</span>
        line_marker;
        write(log, <span class="stri">"LEAVE THE \"WHILE\" LOOP AT LINE "</span>);
        line_marker(whileLoop[1].condLine);
        writeln(log);
        whileLoop := whileLoop[2 .. ];
      <span class="keywd">until</span> length(whileLoop) &lt;= gosubReturn[1].whileLoopStackDepth;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> length(doLoop) > gosubReturn[1].doLoopStackDepth <span class="keywd">then</span>
      error_marker;
      writeln(err, returnStatementName &lt;&amp; <span class="stri">" - SOME DO LOOPS WERE NOT LEFT"</span>);
      <span class="keywd">repeat</span>
        line_marker;
        write(log, <span class="stri">"LEAVE THE \"DO\" LOOP AT LINE "</span>);
        line_marker(doLoop[1].headLine);
        writeln(log);
        doLoop := doLoop[2 .. ];
      <span class="keywd">until</span> length(doLoop) &lt;= gosubReturn[1].doLoopStackDepth;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: do_return (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    file_line_number := gosubReturn[1].returnLine;
    statement_label := prg[file_line_number].linenum;
    line := prg[file_line_number].line[gosubReturn[1].returnColumn .. ];
    symbol := get_symbol(line);
    gosubReturn := gosubReturn[2 .. ];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: goto_on_error (<span class="op">in</span> <span class="type">string</span>: on_error_label, <span class="op">in</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    error_linenum := prg[file_line_number].linenum;
    resume_next_line := file_line_number;
    resume_next_column :=
        length(prg[file_line_number].line) - length(line) + 1;
    in_error_handler := TRUE;
    goto_label_or_linenum(on_error_label);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: do_resume_next (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> resume_next_line &lt;> 0 <span class="keywd">then</span>
      file_line_number := resume_next_line;
      statement_label := prg[file_line_number].linenum;
      line := prg[file_line_number].line[resume_next_column .. ];
      symbol := get_symbol(line);
      in_error_handler := FALSE;
      resume_next_line := 0;
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"CANNOT RESUME NEXT"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: do_resume_same (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> resume_same_line &lt;> 0 <span class="keywd">then</span>
      file_line_number := resume_same_line;
      statement_label := prg[file_line_number].linenum;
      line := prg[file_line_number].line[resume_same_column .. ];
      symbol := get_symbol(line);
      in_error_handler := FALSE;
      resume_same_line := 0;
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"CANNOT RESUME 0"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">color</span>: color_num (<span class="op">in</span> <span class="type">integer</span>: col_num) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">color</span>: col <span class="keywd">is</span> black;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> col_num <span class="keywd">of</span>
      <span class="keywd">when</span> {0}: col := black;
      <span class="keywd">when</span> {1}: col := dark_blue;
      <span class="keywd">when</span> {2}: col := dark_green;
      <span class="keywd">when</span> {3}: col := dark_cyan;
      <span class="keywd">when</span> {4}: col := dark_red;
      <span class="keywd">when</span> {5}: col := dark_magenta;
      <span class="keywd">when</span> {6}: col := brown;
      <span class="keywd">when</span> {7}: col := light_gray;
      <span class="keywd">when</span> {8}: col := dark_gray;
      <span class="keywd">when</span> {9}: col := light_blue;
      <span class="keywd">when</span> {10}: col := light_green;
      <span class="keywd">when</span> {11}: col := light_cyan;
      <span class="keywd">when</span> {12}: col := light_red;
      <span class="keywd">when</span> {13}: col := light_magenta;
      <span class="keywd">when</span> {14}: col := yellow;
      <span class="keywd">when</span> {15}: col := white;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: get_data_line (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: data_line <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: searching <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">string</span>: data_symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> searching <span class="keywd">do</span>
      incr(data_line_number);
      <span class="keywd">if</span> data_line_number > length(prg) <span class="keywd">then</span>
        <span class="keywd">if</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          error_code := 4; <span class="comment"># Out of data</span>
          line_marker;
          writeln(log, error_code &lt;&amp; <span class="stri">" OUT OF DATA"</span> &lt;&amp;
              <span class="stri">" - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
          goto_on_error(on_error_label, line);
          symbol := <span class="stri">""</span>;
          line := <span class="stri">""</span>;
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"OUT OF DATA"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        data_line := <span class="stri">",,,,,,,,,,,,,,,,,,,,,,,,,"</span>;
        searching := FALSE;
      <span class="keywd">elsif</span> prg[data_line_number].line &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        data_line := prg[data_line_number].line;
        <span class="comment">(* writeln(data_line_number lpad 5 &lt;&amp; " " &lt;&amp;
            prg[data_line_number].line); *)</span>
        <span class="keywd">repeat</span>
          data_symbol := get_symbol(data_line);
        <span class="keywd">until</span> data_symbol = <span class="stri">""</span> <span class="op">or</span>
            data_symbol = <span class="stri">"DATA"</span> <span class="op">or</span> data_symbol = <span class="stri">"DATA&amp;"</span> <span class="op">or</span>
            data_symbol = <span class="stri">"'"</span> <span class="op">or</span> data_symbol = <span class="stri">"REM"</span>;
        <span class="keywd">if</span> data_symbol = <span class="stri">"DATA&amp;"</span> <span class="keywd">then</span>
          data_symbol := <span class="stri">"DATA"</span>;
          data_line := <span class="stri">"&amp;"</span> &amp; data_line;
          line_marker;
          writeln(log, <span class="stri">"DATA STATEMENT CORRECTED FROM "</span> &lt;&amp;
              literal(prg[data_line_number].line) &lt;&amp;
              <span class="stri">" TO "</span> &lt;&amp; literal(<span class="stri">"DATA "</span> &amp; data_line));
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> data_symbol = <span class="stri">"DATA"</span> <span class="keywd">then</span>
          searching := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: data_statement_in_line <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: data_symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    data_symbol := get_symbol(data_line);
    <span class="keywd">if</span> data_symbol = <span class="stri">"DATA&amp;"</span> <span class="keywd">then</span>
      data_symbol := <span class="stri">"DATA"</span>;
      data_line := <span class="stri">"&amp;"</span> &amp; data_line;
      line_marker;
      writeln(log, <span class="stri">"DATA STATEMENT CORRECTED FROM "</span> &lt;&amp;
          literal(prg[data_line_number].line) &lt;&amp;
          <span class="stri">" TO "</span> &lt;&amp; literal(<span class="stri">"DATA "</span> &amp; data_line));
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> data_symbol = <span class="stri">"'"</span> <span class="op">or</span> data_symbol = <span class="stri">"REM"</span> <span class="keywd">then</span>
      data_line := <span class="stri">""</span>;
    <span class="keywd">elsif</span> data_symbol &lt;> <span class="stri">""</span> <span class="op">and</span> data_symbol &lt;> <span class="stri">"DATA"</span> <span class="keywd">then</span>
      error_expect3(<span class="stri">"DATA"</span>, <span class="stri">"REM"</span>, <span class="stri">"'"</span>, data_symbol);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: get_data_field (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: data_field <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: comma_pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: quote_pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: colon_pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: data_symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> data_line = <span class="stri">""</span> <span class="keywd">then</span>
      data_line := get_data_line(symbol, line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="op">not</span> in_error_handler <span class="keywd">then</span>
      <span class="keywd">while</span> data_line &lt;> <span class="stri">""</span> <span class="op">and</span> data_line[1] = <span class="stri">' '</span> <span class="keywd">do</span>
        data_line := data_line[2 .. ];
      <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">if</span> data_line &lt;> <span class="stri">""</span> <span class="op">and</span> data_line[1] = <span class="stri">'"'</span> <span class="keywd">then</span>
        data_field := <span class="stri">""</span>;
        data_line := data_line[2 .. ];
        quote_pos := pos(data_line, <span class="stri">"\""</span>);
        <span class="keywd">while</span> quote_pos &lt;> 0 <span class="keywd">do</span>
          <span class="keywd">if</span> succ(quote_pos) &lt;= length(data_line) <span class="op">and</span>
              data_line[succ(quote_pos)] = <span class="stri">'"'</span> <span class="keywd">then</span>
            data_field &amp;:= data_line[ .. quote_pos];
            data_line := data_line[quote_pos + 2 .. ];
            quote_pos := pos(data_line, <span class="stri">"\""</span>);
          <span class="keywd">else</span>
            data_field &amp;:= data_line[ .. pred(quote_pos)];
            data_line := data_line[succ(quote_pos) .. ];
            quote_pos := 0;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">while</span> data_line &lt;> <span class="stri">""</span> <span class="op">and</span> data_line[1] = <span class="stri">' '</span> <span class="keywd">do</span>
          data_line := data_line[2 .. ];
        <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">if</span> data_line &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          <span class="keywd">if</span> data_line[1] = <span class="stri">':'</span> <span class="keywd">then</span>
            data_line := data_line[2 .. ];
            data_statement_in_line;
          <span class="keywd">elsif</span> data_line[1] = <span class="stri">','</span> <span class="keywd">then</span>
            data_line := data_line[2 .. ];
          <span class="keywd">else</span>
            data_symbol := get_symbol(data_line);
            <span class="keywd">if</span> data_symbol = <span class="stri">"'"</span> <span class="op">or</span> data_symbol = <span class="stri">"REM"</span> <span class="keywd">then</span>
              data_line := <span class="stri">""</span>;
            <span class="keywd">else</span>
              error_expect2(<span class="stri">","</span>, <span class="stri">":"</span>, data_symbol);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        comma_pos := pos(data_line, <span class="stri">","</span>);
        colon_pos := pos(data_line, <span class="stri">":"</span>);
        <span class="keywd">if</span> colon_pos &lt;> 0 <span class="keywd">then</span>
          <span class="keywd">if</span> comma_pos = 0 <span class="op">or</span> colon_pos &lt; comma_pos <span class="keywd">then</span>
            data_field := data_line[ .. pred(colon_pos)];
            data_line :=  data_line[succ(colon_pos) .. ];
            data_statement_in_line;
          <span class="keywd">else</span>
            data_field := data_line[ .. pred(comma_pos)];
            data_line :=  data_line[succ(comma_pos) .. ];
            <span class="keywd">if</span> data_line = <span class="stri">""</span> <span class="keywd">then</span>
              <span class="comment">(* A comma at the end of a DATA line is READ as an    *)</span>
              <span class="comment">(* empty string with the next call of get_data_field. *)</span>
              data_line := <span class="stri">" "</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          <span class="keywd">if</span> comma_pos &lt;> 0 <span class="keywd">then</span>
            data_field := data_line[ .. pred(comma_pos)];
            data_line :=  data_line[succ(comma_pos) .. ];
            <span class="keywd">if</span> data_line = <span class="stri">""</span> <span class="keywd">then</span>
              <span class="comment">(* A comma at the end of a DATA line is READ as an    *)</span>
              <span class="comment">(* empty string with the next call of get_data_field. *)</span>
              data_line := <span class="stri">" "</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            data_field := data_line;
            data_line := <span class="stri">""</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: skip_space_cr_lf (<span class="keywd">inout</span> <span class="type">file</span>: inFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    ch := inFile.bufferChar;
    <span class="keywd">while</span> ch = <span class="stri">' '</span> <span class="op">or</span> ch = <span class="stri">'\r'</span> <span class="op">or</span> ch = <span class="stri">'\n'</span> <span class="keywd">do</span>
      ch := getc(inFile);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    inFile.bufferChar := ch;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: read_input_string (<span class="keywd">inout</span> <span class="type">file</span>: inFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    ch := inFile.bufferChar;
    <span class="keywd">if</span> ch = <span class="stri">'"'</span> <span class="keywd">then</span>
      ch := getc(inFile);
      <span class="keywd">while</span> ch &lt;> <span class="stri">'"'</span> <span class="op">and</span> ch &lt;> <span class="stri">'\r'</span> <span class="op">and</span> ch &lt;> <span class="stri">'\n'</span> <span class="op">and</span> ch &lt;> EOF <span class="keywd">do</span>
        stri &amp;:= str(ch);
        ch := getc(inFile);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      ch := getc(inFile);
    <span class="keywd">else</span>
      <span class="keywd">while</span> ch &lt;> <span class="stri">','</span> <span class="op">and</span> ch &lt;> <span class="stri">'\r'</span> <span class="op">and</span> ch &lt;> <span class="stri">'\n'</span> <span class="op">and</span> ch &lt;> EOF <span class="keywd">do</span>
        stri &amp;:= str(ch);
        ch := getc(inFile);
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    inFile.bufferChar := ch;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: read_input_number (<span class="keywd">inout</span> <span class="type">file</span>: inFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: number <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    ch := inFile.bufferChar;
    <span class="keywd">if</span> ch = <span class="stri">'"'</span> <span class="keywd">then</span>
      ch := getc(inFile);
      <span class="keywd">while</span> ch &lt;> <span class="stri">'"'</span> <span class="op">and</span> ch &lt;> <span class="stri">'\r'</span> <span class="op">and</span> ch &lt;> <span class="stri">'\n'</span> <span class="op">and</span> ch &lt;> EOF <span class="keywd">do</span>
        number &amp;:= str(ch);
        ch := getc(inFile);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      ch := getc(inFile);
    <span class="keywd">else</span>
      <span class="keywd">while</span> ch &lt;> <span class="stri">','</span> <span class="op">and</span> ch &lt;> <span class="stri">' '</span> <span class="op">and</span> ch &lt;> <span class="stri">'\r'</span> <span class="op">and</span> ch &lt;> <span class="stri">'\n'</span> <span class="op">and</span> ch &lt;> EOF <span class="keywd">do</span>
        number &amp;:= str(ch);
        ch := getc(inFile);
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    inFile.bufferChar := ch;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: assign_input_number (<span class="op">in</span> <span class="type">string</span>: variable_name, <span class="op">in</span> <span class="type">string</span>: param1) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    <span class="keywd">block</span>
      num1 := float(param1);
      setNumericVar(variable_name, num1);
      line_marker;
      writeln(log, <span class="stri">"INPUT "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">" &lt;- "</span> &lt;&amp; num1);
    exception
      catch RANGE_ERROR:
        error_marker;
        writeln(err, <span class="stri">"NUMBER EXPECTED FOR INPUT OF "</span> &lt;&amp; variable_name &lt;&amp;
            <span class="stri">" FOUND "</span> &lt;&amp; literal(param1) &lt;&amp; <span class="stri">"."</span>);
    <span class="keywd">end</span> <span class="keywd">block</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: assign_input_string (<span class="op">in</span> <span class="type">string</span>: variable_name, <span class="op">in</span> <span class="type">string</span>: param1) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    setStringVar(variable_name, param1);
    line_marker;
    writeln(log, <span class="stri">"INPUT "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">" &lt;- "</span> &lt;&amp; literal(param1));
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: set_function (<span class="op">in</span> <span class="type">string</span>: name, <span class="op">in</span> <span class="type">string</span>: params, <span class="op">in</span> <span class="type">string</span>: expression) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">defFnType</span>: newDefFn <span class="keywd">is</span> defFnType.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> name <span class="op">not</span> <span class="op">in</span> def_fn_list <span class="keywd">then</span>
      newDefFn.name := name;
      newDefFn.params := params;
      newDefFn.expression := expression;
      def_fn_list @:= [name] (newDefFn);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: define_function (<span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: variable_name,
    <span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line, <span class="op">in</span> <span class="type">boolean</span>: doLog) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param2 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: func_end_pos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    <span class="keywd">if</span> variable_name = <span class="stri">"FN"</span> <span class="op">and</span> symbol &lt;> <span class="stri">""</span> <span class="op">and</span>
        symbol[1] >= <span class="stri">'A'</span> <span class="op">and</span> symbol[1] &lt;= <span class="stri">'Z'</span> <span class="keywd">then</span>
      variable_name &amp;:= symbol;
      symbol := get_symbol(line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    param1 := <span class="stri">""</span>;
    <span class="keywd">if</span> symbol = <span class="stri">"("</span> <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        symbol := get_symbol(line);
        <span class="keywd">if</span> symbol &lt;> <span class="stri">""</span> <span class="op">and</span> symbol[1] >= <span class="stri">'A'</span> <span class="op">and</span> symbol[1] &lt;= <span class="stri">'Z'</span> <span class="keywd">then</span>
          param1 &amp;:= symbol &amp; <span class="stri">" "</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        symbol := get_symbol(line);
      <span class="keywd">until</span> symbol &lt;> <span class="stri">","</span>;
      expect(<span class="stri">")"</span>, symbol, line);
      <span class="keywd">if</span> length(param1) >= 1 <span class="keywd">then</span>
        param1 := param1[.. pred(length(param1))];
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="keywd">then</span>
      param2 := line;
      <span class="keywd">repeat</span>
        func_end_pos := length(line);
        symbol := get_symbol(line);
      <span class="keywd">until</span> endOfStatement(symbol);
      param2 := param2[ .. length(param2) - func_end_pos];
      set_function(variable_name, param1, param2);
      <span class="keywd">if</span> doLog <span class="keywd">then</span>
        line_marker;
        writeln(log, <span class="stri">"DEF "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">"("</span> &lt;&amp; param1 &lt;&amp; <span class="stri">")="</span> &lt;&amp; param2);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      expect(<span class="stri">"="</span>, symbol, line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getBoundsFromIndexPart (<span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: indexPart, <span class="op">in</span> <span class="type">integer</span>: dimension,
    <span class="keywd">inout</span> <span class="type">boolean</span>: first, <span class="keywd">inout</span> <span class="type">integer</span>: lbound, <span class="keywd">inout</span> <span class="type">integer</span>: ubound) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: indexDimension <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: anIndex <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> indexPart &lt;> <span class="stri">""</span> <span class="op">and</span> (indexPart[1] = <span class="stri">'['</span> <span class="op">or</span> indexPart[1] = <span class="stri">'('</span>) <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        indexPart := indexPart[2 ..];
        anIndex := integer(getDigits(indexPart));
        incr(indexDimension);
      <span class="keywd">until</span> indexDimension = dimension;
      <span class="keywd">if</span> first <span class="keywd">then</span>
        lbound := anIndex;
        ubound := anIndex;
        first := FALSE;
      <span class="keywd">else</span>
        <span class="keywd">if</span> anIndex &lt; lbound <span class="keywd">then</span>
          lbound := anIndex;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> anIndex > ubound <span class="keywd">then</span>
          ubound := anIndex;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getBounds (<span class="op">in</span> <span class="type">string</span>: array_name, <span class="op">in</span> <span class="type">integer</span>: dimension,
    <span class="keywd">inout</span> <span class="type">integer</span>: lbound, <span class="keywd">inout</span> <span class="type">integer</span>: ubound) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: varName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: first <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> <span class="keywd">key</span> varName <span class="keywd">range</span> numeric_var <span class="keywd">do</span>
      <span class="keywd">if</span> startsWith(varName, array_name) <span class="keywd">then</span>
        getBoundsFromIndexPart(varName[succ(length(array_name)) ..],
            dimension, first, lbound, ubound);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> <span class="keywd">key</span> varName <span class="keywd">range</span> string_var <span class="keywd">do</span>
      <span class="keywd">if</span> startsWith(varName, array_name) <span class="keywd">then</span>
        getBoundsFromIndexPart(varName[succ(length(array_name)) ..],
            dimension, first, ubound, ubound);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: exec_lbound (<span class="op">in</span> <span class="type">string</span>: array_name, <span class="op">in</span> <span class="type">integer</span>: dimension) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: lbound <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: ubound <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    getBounds(array_name, dimension, lbound, ubound);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: exec_ubound (<span class="op">in</span> <span class="type">string</span>: array_name, <span class="op">in</span> <span class="type">integer</span>: dimension) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: ubound <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: lbound <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    getBounds(array_name, dimension, lbound, ubound);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getFirstIndex (<span class="op">in</span> <span class="type">string</span>: array_name,
    <span class="keywd">inout</span> <span class="type">string</span>: name_start, <span class="keywd">inout</span> <span class="type">string</span>: name_end) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: lbound <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: parenPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: commaPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: paren2Pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: indexString <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    parenPos := pos(array_name, <span class="stri">"("</span>);
    <span class="keywd">if</span> parenPos = 0 <span class="keywd">then</span>
      parenPos := pos(array_name, <span class="stri">"["</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> parenPos &lt;> 0 <span class="keywd">then</span>
      name_start := array_name[.. parenPos];
      commaPos := pos(array_name, <span class="stri">","</span>, succ(parenPos));
      <span class="keywd">if</span> commaPos &lt;> 0 <span class="keywd">then</span>
        name_end := array_name[commaPos ..];
        indexString := array_name[succ(parenPos) .. pred(commaPos)];
      <span class="keywd">else</span>
        paren2Pos := pos(array_name, <span class="stri">")"</span>, succ(parenPos));
        <span class="keywd">if</span> paren2Pos = 0 <span class="keywd">then</span>
          paren2Pos := pos(array_name, <span class="stri">"]"</span>, succ(parenPos));
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> paren2Pos &lt;> 0 <span class="keywd">then</span>
          name_end := array_name[paren2Pos ..];
          indexString := array_name[succ(parenPos) .. pred(paren2Pos)];
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      lbound := integer(indexString);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: exec_expr (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">proc</span>: append_index (<span class="keywd">inout</span> <span class="type">string</span>: name, <span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">float</span>: num <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> symbol = <span class="stri">"("</span> <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      num := exec_expr(symbol, line);
      name &amp;:= <span class="stri">"("</span> &amp; str(round(num));
      <span class="keywd">while</span> symbol = <span class="stri">","</span> <span class="keywd">do</span>
        symbol := get_symbol(line);
        num := exec_expr(symbol, line);
        name &amp;:= <span class="stri">","</span> &amp; str(round(num));
      <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">if</span> symbol &lt;> <span class="stri">")"</span> <span class="op">and</span> symbol &lt;> <span class="stri">"]"</span> <span class="keywd">then</span>
        error_expect2(<span class="stri">")"</span>, <span class="stri">"]"</span>, symbol);
      <span class="keywd">else</span>
        name &amp;:= <span class="stri">")"</span>;
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> symbol = <span class="stri">"."</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      name &amp;:= <span class="stri">"."</span> &amp; symbol;
      symbol := get_symbol(line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: get_name (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    name := symbol;
    symbol := get_symbol(line);
    append_index(name, symbol, line);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: skip_parenthesized_stri (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: close_symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> symbol = <span class="stri">"("</span> <span class="keywd">then</span>
      close_symbol := <span class="stri">")"</span>;
    <span class="keywd">elsif</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
      close_symbol := <span class="stri">"]"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    symbol := get_symbol(line);
    <span class="keywd">while</span> symbol &lt;> close_symbol <span class="op">and</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> symbol = <span class="stri">"("</span> <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
        skip_parenthesized_stri(symbol, line);
      <span class="keywd">else</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> symbol &lt;> close_symbol <span class="keywd">then</span>
      error_expect(close_symbol, symbol);
    <span class="keywd">else</span>
      symbol := get_symbol(line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: is_let_statement (<span class="op">in</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: is_let_statement <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: help_line <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    help_line := line;
    symbol := get_symbol(help_line);
    <span class="keywd">if</span> symbol = <span class="stri">"("</span> <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
      skip_parenthesized_stri(symbol, help_line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> symbol = <span class="stri">"."</span> <span class="keywd">then</span>
      symbol := get_symbol(help_line);
      symbol := get_symbol(help_line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    is_let_statement := symbol = <span class="stri">"="</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: exec_str_expr (
    <span class="keywd">inout</span> <span class="type">string</span>: symbol,
    <span class="keywd">inout</span> <span class="type">string</span>: line,
    <span class="keywd">inout</span> <span class="type">string</span>: variable_name) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: exec_str_function (<span class="op">in</span> <span class="type">defFnType</span>: defFn, <span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: exprResult <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: func_expr <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: func_symbol <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: formal_params <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: formal_param <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: str_value_backup <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">float</span>: num_value_backup <span class="keywd">is</span> 0 <span class="op">times</span> 0.0;
  <span class="keywd">begin</span>
    write(log, <span class="stri">"function "</span> &lt;&amp; defFn.name);
    formal_params := defFn.params;
    symbol := get_symbol(line);
    <span class="keywd">if</span> symbol = <span class="stri">"("</span> <span class="keywd">then</span>
      write(log, <span class="stri">"("</span>);
      <span class="keywd">repeat</span>
        symbol := get_symbol(line);
        formal_param := get_symbol(formal_params);
        <span class="keywd">if</span> formal_param[length(formal_param)] = <span class="stri">'$'</span> <span class="keywd">then</span>
          <span class="keywd">if</span> formal_param <span class="op">in</span> string_var <span class="keywd">then</span>
            str_value_backup &amp;:= [] (string_var[formal_param]);
          <span class="keywd">else</span>
            str_value_backup &amp;:= [] (<span class="stri">""</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          string_var @:= [formal_param] exec_str_expr(symbol, line, unused_name);
          write(log, string_var[formal_param]);
        <span class="keywd">else</span>
          <span class="keywd">if</span> formal_param <span class="op">in</span> numeric_var <span class="keywd">then</span>
            num_value_backup &amp;:= [] (numeric_var[formal_param]);
          <span class="keywd">else</span>
            num_value_backup &amp;:= [] (0.0);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          numeric_var @:= [formal_param] exec_expr(symbol, line);
          write(log, numeric_var[formal_param]);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        write(log, symbol);
      <span class="keywd">until</span> symbol &lt;> <span class="stri">","</span>;
      expect(<span class="stri">")"</span>, symbol, line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    func_expr := defFn.expression;
    writeln(log, <span class="stri">" = "</span> &lt;&amp; func_expr);
    func_symbol := get_symbol(func_expr);
    exprResult := exec_str_expr(func_symbol, func_expr, unused_name);
    formal_params := defFn.params;
    formal_param := get_symbol(formal_params);
    <span class="keywd">while</span> formal_param &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> formal_param[length(formal_param)] = <span class="stri">'$'</span> <span class="keywd">then</span>
        string_var @:= [formal_param] str_value_backup[1];
        str_value_backup := str_value_backup[2 ..];
      <span class="keywd">else</span>
        numeric_var @:= [formal_param] num_value_backup[1];
        num_value_backup := num_value_backup[2 ..];
      <span class="keywd">end</span> <span class="keywd">if</span>;
      formal_param := get_symbol(formal_params);
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: extendedKeyCode (<span class="op">in</span> <span class="type">char</span>: current_key) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: keyCode <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> current_key <span class="keywd">of</span>
      <span class="keywd">when</span> {KEY_NL}:        keyCode := <span class="stri">"\r"</span>;
      <span class="keywd">when</span> {KEY_ALT_A}:     keyCode := <span class="stri">"\0;\30;"</span>;
      <span class="keywd">when</span> {KEY_ALT_B}:     keyCode := <span class="stri">"\0;\48;"</span>;
      <span class="keywd">when</span> {KEY_ALT_C}:     keyCode := <span class="stri">"\0;\46;"</span>;
      <span class="keywd">when</span> {KEY_ALT_D}:     keyCode := <span class="stri">"\0;\32;"</span>;
      <span class="keywd">when</span> {KEY_ALT_E}:     keyCode := <span class="stri">"\0;\18;"</span>;
      <span class="keywd">when</span> {KEY_ALT_F}:     keyCode := <span class="stri">"\0;\33;"</span>;
      <span class="keywd">when</span> {KEY_ALT_G}:     keyCode := <span class="stri">"\0;\34;"</span>;
      <span class="keywd">when</span> {KEY_ALT_H}:     keyCode := <span class="stri">"\0;\35;"</span>;
      <span class="keywd">when</span> {KEY_ALT_I}:     keyCode := <span class="stri">"\0;\23;"</span>;
      <span class="keywd">when</span> {KEY_ALT_J}:     keyCode := <span class="stri">"\0;\36;"</span>;
      <span class="keywd">when</span> {KEY_ALT_K}:     keyCode := <span class="stri">"\0;\37;"</span>;
      <span class="keywd">when</span> {KEY_ALT_L}:     keyCode := <span class="stri">"\0;\38;"</span>;
      <span class="keywd">when</span> {KEY_ALT_M}:     keyCode := <span class="stri">"\0;\50;"</span>;
      <span class="keywd">when</span> {KEY_ALT_N}:     keyCode := <span class="stri">"\0;\49;"</span>;
      <span class="keywd">when</span> {KEY_ALT_O}:     keyCode := <span class="stri">"\0;\24;"</span>;
      <span class="keywd">when</span> {KEY_ALT_P}:     keyCode := <span class="stri">"\0;\25;"</span>;
      <span class="keywd">when</span> {KEY_ALT_Q}:     keyCode := <span class="stri">"\0;\16;"</span>;
      <span class="keywd">when</span> {KEY_ALT_R}:     keyCode := <span class="stri">"\0;\19;"</span>;
      <span class="keywd">when</span> {KEY_ALT_S}:     keyCode := <span class="stri">"\0;\31;"</span>;
      <span class="keywd">when</span> {KEY_ALT_T}:     keyCode := <span class="stri">"\0;\20;"</span>;
      <span class="keywd">when</span> {KEY_ALT_U}:     keyCode := <span class="stri">"\0;\22;"</span>;
      <span class="keywd">when</span> {KEY_ALT_V}:     keyCode := <span class="stri">"\0;\47;"</span>;
      <span class="keywd">when</span> {KEY_ALT_W}:     keyCode := <span class="stri">"\0;\17;"</span>;
      <span class="keywd">when</span> {KEY_ALT_X}:     keyCode := <span class="stri">"\0;\45;"</span>;
      <span class="keywd">when</span> {KEY_ALT_Y}:     keyCode := <span class="stri">"\0;\21;"</span>;
      <span class="keywd">when</span> {KEY_ALT_Z}:     keyCode := <span class="stri">"\0;\44;"</span>;
      <span class="keywd">when</span> {KEY_ALT_0}:     keyCode := <span class="stri">"\0;\120;"</span>;
      <span class="keywd">when</span> {KEY_ALT_1}:     keyCode := <span class="stri">"\0;\121;"</span>;
      <span class="keywd">when</span> {KEY_ALT_2}:     keyCode := <span class="stri">"\0;\122;"</span>;
      <span class="keywd">when</span> {KEY_ALT_3}:     keyCode := <span class="stri">"\0;\123;"</span>;
      <span class="keywd">when</span> {KEY_ALT_4}:     keyCode := <span class="stri">"\0;\124;"</span>;
      <span class="keywd">when</span> {KEY_ALT_5}:     keyCode := <span class="stri">"\0;\125;"</span>;
      <span class="keywd">when</span> {KEY_ALT_6}:     keyCode := <span class="stri">"\0;\126;"</span>;
      <span class="keywd">when</span> {KEY_ALT_7}:     keyCode := <span class="stri">"\0;\127;"</span>;
      <span class="keywd">when</span> {KEY_ALT_8}:     keyCode := <span class="stri">"\0;\128;"</span>;
      <span class="keywd">when</span> {KEY_ALT_9}:     keyCode := <span class="stri">"\0;\129;"</span>;
      <span class="keywd">when</span> {KEY_F1}:        keyCode := <span class="stri">"\0;;"</span>;
      <span class="keywd">when</span> {KEY_F2}:        keyCode := <span class="stri">"\0;&lt;"</span>;
      <span class="keywd">when</span> {KEY_F3}:        keyCode := <span class="stri">"\0;="</span>;
      <span class="keywd">when</span> {KEY_F4}:        keyCode := <span class="stri">"\0;>"</span>;
      <span class="keywd">when</span> {KEY_F5}:        keyCode := <span class="stri">"\0;?"</span>;
      <span class="keywd">when</span> {KEY_F6}:        keyCode := <span class="stri">"\0;@"</span>;
      <span class="keywd">when</span> {KEY_F7}:        keyCode := <span class="stri">"\0;A"</span>;
      <span class="keywd">when</span> {KEY_F8}:        keyCode := <span class="stri">"\0;B"</span>;
      <span class="keywd">when</span> {KEY_F9}:        keyCode := <span class="stri">"\0;C"</span>;
      <span class="keywd">when</span> {KEY_F10}:       keyCode := <span class="stri">"\0;D"</span>;
      <span class="keywd">when</span> {KEY_SFT_F1}:    keyCode := <span class="stri">"\0;T"</span>;
      <span class="keywd">when</span> {KEY_SFT_F2}:    keyCode := <span class="stri">"\0;U"</span>;
      <span class="keywd">when</span> {KEY_SFT_F3}:    keyCode := <span class="stri">"\0;V"</span>;
      <span class="keywd">when</span> {KEY_SFT_F4}:    keyCode := <span class="stri">"\0;W"</span>;
      <span class="keywd">when</span> {KEY_SFT_F5}:    keyCode := <span class="stri">"\0;X"</span>;
      <span class="keywd">when</span> {KEY_SFT_F6}:    keyCode := <span class="stri">"\0;Y"</span>;
      <span class="keywd">when</span> {KEY_SFT_F7}:    keyCode := <span class="stri">"\0;Z"</span>;
      <span class="keywd">when</span> {KEY_SFT_F8}:    keyCode := <span class="stri">"\0;["</span>;
      <span class="keywd">when</span> {KEY_SFT_F9}:    keyCode := <span class="stri">"\0;\\"</span>;
      <span class="keywd">when</span> {KEY_SFT_F10}:   keyCode := <span class="stri">"\0;]"</span>;
      <span class="keywd">when</span> {KEY_CTL_F1}:    keyCode := <span class="stri">"\0;^"</span>;
      <span class="keywd">when</span> {KEY_CTL_F2}:    keyCode := <span class="stri">"\0;_"</span>;
      <span class="keywd">when</span> {KEY_CTL_F3}:    keyCode := <span class="stri">"\0;`"</span>;
      <span class="keywd">when</span> {KEY_CTL_F4}:    keyCode := <span class="stri">"\0;a"</span>;
      <span class="keywd">when</span> {KEY_CTL_F5}:    keyCode := <span class="stri">"\0;b"</span>;
      <span class="keywd">when</span> {KEY_CTL_F6}:    keyCode := <span class="stri">"\0;c"</span>;
      <span class="keywd">when</span> {KEY_CTL_F7}:    keyCode := <span class="stri">"\0;d"</span>;
      <span class="keywd">when</span> {KEY_CTL_F8}:    keyCode := <span class="stri">"\0;e"</span>;
      <span class="keywd">when</span> {KEY_CTL_F9}:    keyCode := <span class="stri">"\0;f"</span>;
      <span class="keywd">when</span> {KEY_CTL_F10}:   keyCode := <span class="stri">"\0;g"</span>;
      <span class="keywd">when</span> {KEY_ALT_F1}:    keyCode := <span class="stri">"\0;h"</span>;
      <span class="keywd">when</span> {KEY_ALT_F2}:    keyCode := <span class="stri">"\0;i"</span>;
      <span class="keywd">when</span> {KEY_ALT_F3}:    keyCode := <span class="stri">"\0;j"</span>;
      <span class="keywd">when</span> {KEY_ALT_F4}:    keyCode := <span class="stri">"\0;k"</span>;
      <span class="keywd">when</span> {KEY_ALT_F5}:    keyCode := <span class="stri">"\0;l"</span>;
      <span class="keywd">when</span> {KEY_ALT_F6}:    keyCode := <span class="stri">"\0;m"</span>;
      <span class="keywd">when</span> {KEY_ALT_F7}:    keyCode := <span class="stri">"\0;n"</span>;
      <span class="keywd">when</span> {KEY_ALT_F8}:    keyCode := <span class="stri">"\0;o"</span>;
      <span class="keywd">when</span> {KEY_ALT_F9}:    keyCode := <span class="stri">"\0;p"</span>;
      <span class="keywd">when</span> {KEY_ALT_F10}:   keyCode := <span class="stri">"\0;q"</span>;
      <span class="keywd">when</span> {KEY_BACKTAB}:   keyCode := <span class="stri">"\0;\15;"</span>;
      <span class="keywd">when</span> {KEY_LEFT}:      keyCode := <span class="stri">"\0;K"</span>;
      <span class="keywd">when</span> {KEY_RIGHT}:     keyCode := <span class="stri">"\0;M"</span>;
      <span class="keywd">when</span> {KEY_UP}:        keyCode := <span class="stri">"\0;H"</span>;
      <span class="keywd">when</span> {KEY_DOWN}:      keyCode := <span class="stri">"\0;P"</span>;
      <span class="keywd">when</span> {KEY_HOME}:      keyCode := <span class="stri">"\0;G"</span>;
      <span class="keywd">when</span> {KEY_END}:       keyCode := <span class="stri">"\0;O"</span>;
      <span class="keywd">when</span> {KEY_PGUP}:      keyCode := <span class="stri">"\0;I"</span>;
      <span class="keywd">when</span> {KEY_PGDN}:      keyCode := <span class="stri">"\0;Q"</span>;
      <span class="keywd">when</span> {KEY_INS}:       keyCode := <span class="stri">"\0;R"</span>;
      <span class="keywd">when</span> {KEY_DEL}:       keyCode := <span class="stri">"\0;S"</span>;
      <span class="keywd">when</span> {KEY_CTL_LEFT}:  keyCode := <span class="stri">"\0;\115;"</span>;
      <span class="keywd">when</span> {KEY_CTL_RIGHT}: keyCode := <span class="stri">"\0;\116;"</span>;
      <span class="keywd">when</span> {KEY_CTL_HOME}:  keyCode := <span class="stri">"\0;\119;"</span>;
      <span class="keywd">when</span> {KEY_CTL_END}:   keyCode := <span class="stri">"\0;\117;"</span>;
      <span class="keywd">when</span> {KEY_CTL_PGUP}:  keyCode := <span class="stri">"\0;\132;"</span>;
      <span class="keywd">when</span> {KEY_CTL_PGDN}:  keyCode := <span class="stri">"\0;\118;"</span>;
      <span class="keywd">otherwise</span>:            keyCode := str(current_key);
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: keyboardScanCode (<span class="op">in</span> <span class="type">char</span>: current_key) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: scanCode <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> current_key <span class="keywd">of</span>
      <span class="keywd">when</span> {KEY_ESC}:                                        scanCode := 16#01;
      <span class="keywd">when</span> {<span class="stri">'!'</span> <span class="comment">(* At keypad: '1' *)</span> }:                      scanCode := 16#02;
      <span class="keywd">when</span> {<span class="stri">'@'</span> <span class="comment">(* At keypad: '2' *)</span> }:                      scanCode := 16#03;
      <span class="keywd">when</span> {<span class="stri">'#'</span> <span class="comment">(* At keypad: '3' *)</span> }:                      scanCode := 16#04;
      <span class="keywd">when</span> {<span class="stri">'$'</span> <span class="comment">(* At keypad: '4' *)</span> }:                      scanCode := 16#05;
      <span class="keywd">when</span> {<span class="stri">'%'</span> <span class="comment">(* At keypad: '5' *)</span> }:                      scanCode := 16#06;
      <span class="keywd">when</span> {<span class="stri">'^'</span> <span class="comment">(* At keypad: '6' *)</span> }:                      scanCode := 16#07;
      <span class="keywd">when</span> {<span class="stri">'&amp;'</span> <span class="comment">(* At keypad: '7' *)</span> }:                      scanCode := 16#08;
      <span class="keywd">when</span> {<span class="stri">'*'</span> <span class="comment">(* At keypad: '8' *)</span> }:                      scanCode := 16#09;
      <span class="keywd">when</span> {<span class="stri">'('</span> <span class="comment">(* At keypad: '9' *)</span> }:                      scanCode := 16#0a;
      <span class="keywd">when</span> {<span class="stri">')'</span> <span class="comment">(* At keypad: '0' *)</span> }:                      scanCode := 16#0b;
      <span class="keywd">when</span> {<span class="stri">'_'</span>, <span class="stri">'-'</span>}:                                       scanCode := 16#0c;
      <span class="keywd">when</span> {<span class="stri">'+'</span>, <span class="stri">'='</span>}:                                       scanCode := 16#0d;
      <span class="keywd">when</span> {KEY_BS}:                                         scanCode := 16#0e;
      <span class="keywd">when</span> {KEY_TAB}:                                        scanCode := 16#0f;
      <span class="keywd">when</span> {<span class="stri">'Q'</span>, <span class="stri">'q'</span>, KEY_ALT_Q, KEY_CTL_Q}:                 scanCode := 16#10;
      <span class="keywd">when</span> {<span class="stri">'W'</span>, <span class="stri">'w'</span>, KEY_ALT_W, KEY_CTL_W}:                 scanCode := 16#11;
      <span class="keywd">when</span> {<span class="stri">'E'</span>, <span class="stri">'e'</span>, KEY_ALT_E, KEY_CTL_E}:                 scanCode := 16#12;
      <span class="keywd">when</span> {<span class="stri">'R'</span>, <span class="stri">'r'</span>, KEY_ALT_R, KEY_CTL_R}:                 scanCode := 16#13;
      <span class="keywd">when</span> {<span class="stri">'T'</span>, <span class="stri">'t'</span>, KEY_ALT_T, KEY_CTL_T}:                 scanCode := 16#14;
      <span class="keywd">when</span> {<span class="stri">'Y'</span>, <span class="stri">'y'</span>, KEY_ALT_Y, KEY_CTL_Y}:                 scanCode := 16#15;
      <span class="keywd">when</span> {<span class="stri">'U'</span>, <span class="stri">'u'</span>, KEY_ALT_U, KEY_CTL_U}:                 scanCode := 16#16;
      <span class="keywd">when</span> {<span class="stri">'I'</span>, <span class="stri">'i'</span>, KEY_ALT_I  <span class="comment">(* KEY_TAB=KEY_CTL_I *)</span> }:  scanCode := 16#17;
      <span class="keywd">when</span> {<span class="stri">'O'</span>, <span class="stri">'o'</span>, KEY_ALT_O, KEY_CTL_O}:                 scanCode := 16#18;
      <span class="keywd">when</span> {<span class="stri">'P'</span>, <span class="stri">'p'</span>, KEY_ALT_P, KEY_CTL_P}:                 scanCode := 16#19;
      <span class="keywd">when</span> {<span class="stri">'{'</span>, <span class="stri">'['</span>}:                                       scanCode := 16#1a;
      <span class="keywd">when</span> {<span class="stri">'}'</span>, <span class="stri">']'</span>}:                                       scanCode := 16#1b;
      <span class="keywd">when</span> {KEY_NL}:                                         scanCode := 16#1c;
      <span class="comment">#     Not mapped: CTRL                                 scanCode := 16#1d;</span>
      <span class="keywd">when</span> {<span class="stri">'A'</span>, <span class="stri">'a'</span>, KEY_ALT_A, KEY_CTL_A}:                 scanCode := 16#1e;
      <span class="keywd">when</span> {<span class="stri">'S'</span>, <span class="stri">'s'</span>, KEY_ALT_S, KEY_CTL_S}:                 scanCode := 16#1f;
      <span class="keywd">when</span> {<span class="stri">'D'</span>, <span class="stri">'d'</span>, KEY_ALT_D, KEY_CTL_D}:                 scanCode := 16#20;
      <span class="keywd">when</span> {<span class="stri">'F'</span>, <span class="stri">'f'</span>, KEY_ALT_F, KEY_CTL_F}:                 scanCode := 16#21;
      <span class="keywd">when</span> {<span class="stri">'G'</span>, <span class="stri">'g'</span>, KEY_ALT_G, KEY_CTL_G}:                 scanCode := 16#22;
      <span class="keywd">when</span> {<span class="stri">'H'</span>, <span class="stri">'h'</span>, KEY_ALT_H  <span class="comment">(* KEY_BS=KEY_CTL_H *)</span> }:   scanCode := 16#23;
      <span class="keywd">when</span> {<span class="stri">'J'</span>, <span class="stri">'j'</span>, KEY_ALT_J  <span class="comment">(* KEY_NL=KEY_CTL_J *)</span> }:   scanCode := 16#24;
      <span class="keywd">when</span> {<span class="stri">'K'</span>, <span class="stri">'k'</span>, KEY_ALT_K, KEY_CTL_K}:                 scanCode := 16#25;
      <span class="keywd">when</span> {<span class="stri">'L'</span>, <span class="stri">'l'</span>, KEY_ALT_L, KEY_CTL_L}:                 scanCode := 16#26;
      <span class="keywd">when</span> {<span class="stri">':'</span>, <span class="stri">';'</span>}:                                       scanCode := 16#27;
      <span class="keywd">when</span> {<span class="stri">'"'</span>, <span class="stri">'\''</span>}:                                      scanCode := 16#28;
      <span class="keywd">when</span> {<span class="stri">'~'</span>, <span class="stri">'`'</span>}:                                       scanCode := 16#29;
      <span class="comment">#     Not mapped: LEFT SHIFT                           scanCode := 16#2a;</span>
      <span class="keywd">when</span> {<span class="stri">'|'</span>, <span class="stri">'\\'</span>}:                                      scanCode := 16#2b;
      <span class="keywd">when</span> {<span class="stri">'Z'</span>, <span class="stri">'z'</span>, KEY_ALT_Z, KEY_CTL_Z}:                 scanCode := 16#2c;
      <span class="keywd">when</span> {<span class="stri">'X'</span>, <span class="stri">'x'</span>, KEY_ALT_X, KEY_CTL_X}:                 scanCode := 16#2d;
      <span class="keywd">when</span> {<span class="stri">'C'</span>, <span class="stri">'c'</span>, KEY_ALT_C, KEY_CTL_C}:                 scanCode := 16#2e;
      <span class="keywd">when</span> {<span class="stri">'V'</span>, <span class="stri">'v'</span>, KEY_ALT_V, KEY_CTL_V}:                 scanCode := 16#2f;
      <span class="keywd">when</span> {<span class="stri">'B'</span>, <span class="stri">'b'</span>, KEY_ALT_B, KEY_CTL_B}:                 scanCode := 16#30;
      <span class="keywd">when</span> {<span class="stri">'N'</span>, <span class="stri">'n'</span>, KEY_ALT_N, KEY_CTL_N}:                 scanCode := 16#31;
      <span class="keywd">when</span> {<span class="stri">'M'</span>, <span class="stri">'m'</span>, KEY_ALT_M, KEY_CTL_M}:                 scanCode := 16#32;
      <span class="keywd">when</span> {<span class="stri">'&lt;'</span>, <span class="stri">','</span>}:                                       scanCode := 16#33;
      <span class="keywd">when</span> {<span class="stri">'>'</span>, <span class="stri">'.'</span>}:                                       scanCode := 16#34;
      <span class="keywd">when</span> {<span class="stri">'?'</span>, <span class="stri">'/'</span>}:                                       scanCode := 16#35;
      <span class="comment">#     Not mapped: RIGHT SHIFT                          scanCode := 16#36;</span>
      <span class="comment">#     Not mapped: PRTSC or *                           scanCode := 16#37;</span>
      <span class="comment">#     Not mapped: ALT                                  scanCode := 16#38;</span>
      <span class="keywd">when</span> {<span class="stri">' '</span>}:                                            scanCode := 16#39;
      <span class="comment">#     Not mapped: CAPSLOCK                             scanCode := 16#3a;</span>
      <span class="keywd">when</span> {KEY_F1,  KEY_SFT_F1,  KEY_CTL_F1,  KEY_ALT_F1}:  scanCode := 16#3b;
      <span class="keywd">when</span> {KEY_F2,  KEY_SFT_F2,  KEY_CTL_F2,  KEY_ALT_F2}:  scanCode := 16#3c;
      <span class="keywd">when</span> {KEY_F3,  KEY_SFT_F3,  KEY_CTL_F3,  KEY_ALT_F3}:  scanCode := 16#3d;
      <span class="keywd">when</span> {KEY_F4,  KEY_SFT_F4,  KEY_CTL_F4,  KEY_ALT_F4}:  scanCode := 16#3e;
      <span class="keywd">when</span> {KEY_F5,  KEY_SFT_F5,  KEY_CTL_F5,  KEY_ALT_F5}:  scanCode := 16#3f;
      <span class="keywd">when</span> {KEY_F6,  KEY_SFT_F6,  KEY_CTL_F6,  KEY_ALT_F6}:  scanCode := 16#40;
      <span class="keywd">when</span> {KEY_F7,  KEY_SFT_F7,  KEY_CTL_F7,  KEY_ALT_F7}:  scanCode := 16#41;
      <span class="keywd">when</span> {KEY_F8,  KEY_SFT_F8,  KEY_CTL_F8,  KEY_ALT_F8}:  scanCode := 16#42;
      <span class="keywd">when</span> {KEY_F9,  KEY_SFT_F9,  KEY_CTL_F9,  KEY_ALT_F9}:  scanCode := 16#43;
      <span class="keywd">when</span> {KEY_F10, KEY_SFT_F10, KEY_CTL_F10, KEY_ALT_F10}: scanCode := 16#44;
      <span class="comment">#     Not mapped: NUMLOCK                              scanCode := 16#45;</span>
      <span class="comment">#     Not mapped: SCROLL LOCK                          scanCode := 16#46;</span>
      <span class="keywd">when</span> {KEY_HOME,       KEY_CTL_HOME,  <span class="stri">'7'</span>}:             scanCode := 16#47;
      <span class="keywd">when</span> {KEY_UP,         KEY_CTL_UP,    <span class="stri">'8'</span>}:             scanCode := 16#48;
      <span class="keywd">when</span> {KEY_PGUP,       KEY_CTL_PGUP,  <span class="stri">'9'</span>}:             scanCode := 16#49;
      <span class="comment">#     Already mapped: '-'                              scanCode := 16#4a;</span>
      <span class="keywd">when</span> {KEY_LEFT,       KEY_CTL_LEFT,  <span class="stri">'4'</span>}:             scanCode := 16#4b;
      <span class="keywd">when</span> {KEY_PAD_CENTER,                <span class="stri">'5'</span>}:             scanCode := 16#4c;
      <span class="keywd">when</span> {KEY_RIGHT,      KEY_CTL_RIGHT, <span class="stri">'6'</span>}:             scanCode := 16#4d;
      <span class="comment">#     Already mapped: '+'                              scanCode := 16#4e;</span>
      <span class="keywd">when</span> {KEY_END,        KEY_CTL_END,   <span class="stri">'1'</span>}:             scanCode := 16#4f;
      <span class="keywd">when</span> {KEY_DOWN,       KEY_CTL_DOWN,  <span class="stri">'2'</span>}:             scanCode := 16#50;
      <span class="keywd">when</span> {KEY_PGDN,       KEY_CTL_PGDN,  <span class="stri">'3'</span>}:             scanCode := 16#51;
      <span class="keywd">when</span> {KEY_INS,        KEY_CTL_INS,   <span class="stri">'0'</span>}:             scanCode := 16#52;
      <span class="keywd">when</span> {KEY_DEL,        KEY_CTL_DEL    <span class="comment">(*  '.' *)</span> }:     scanCode := 16#53;
      <span class="keywd">otherwise</span>:                                             scanCode := 0;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: execLines <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: exec_str_primary (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line,
    <span class="keywd">inout</span> <span class="type">string</span>: variable_name) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: exprResult <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri2 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: num2 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">integer</span>: index1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">file</span>: aFile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">char</span>: current_key <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">string</span>: func_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    variable_name := <span class="stri">""</span>;
    <span class="keywd">case</span> symbol <span class="keywd">of</span>
      <span class="keywd">when</span> {<span class="stri">""</span>}:
        error_marker;
        writeln(err, <span class="stri">"EXPRESSION EXPECTED - FOUND END OF LINE."</span>);
      <span class="keywd">when</span> {<span class="stri">"CHR$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := str(chr(round(num1)));
        writeln(log, <span class="stri">"CHR$("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">when</span> {<span class="stri">"COMMAND$"</span>}:
        symbol := get_symbol(line);
        exprResult := command_line;
        writeln(log, <span class="stri">"COMMAND$ -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">when</span> {<span class="stri">"DATE$"</span>}:
        symbol := get_symbol(line);
        exprResult := str_mm_dd_yyyy(time(NOW), <span class="stri">"-"</span>);
        writeln(log, <span class="stri">"DATE$ -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">when</span> {<span class="stri">"HEX$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := round(num1) RADIX 16;
        writeln(log, <span class="stri">"HEX$("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">when</span> {<span class="stri">"INKEY$"</span>}:
        symbol := get_symbol(line);
        write(log, <span class="stri">"INKEY$ "</span>);
        flush(log);
        flush(win);
        <span class="keywd">if</span> keypressed(KEYBOARD) <span class="keywd">then</span>
          current_key := getc(KEYBOARD);
          exprResult := extendedKeyCode(current_key);
        <span class="keywd">else</span>
          exprResult := <span class="stri">""</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        write(log, <span class="stri">"-> "</span> &lt;&amp; literal(exprResult));
        <span class="keywd">if</span> exprResult &lt;> <span class="stri">""</span> <span class="op">and</span> current_key <span class="op">in</span> keyDescription <span class="keywd">then</span>
          write(log, <span class="stri">" ("</span> &lt;&amp; keyDescription[current_key] &lt;&amp; <span class="stri">")"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        writeln(log);
      <span class="keywd">when</span> {<span class="stri">"INPUT$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        index1 := round(exec_expr(symbol, line));
        <span class="keywd">if</span> index1 >= 0 <span class="keywd">then</span>
          <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            <span class="keywd">if</span> symbol = <span class="stri">"#"</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            index2 := round(exec_expr(symbol, line));
            expect(<span class="stri">")"</span>, symbol, line);
            aFile := getFileValue(index2);
            <span class="keywd">if</span> aFile &lt;> STD_NULL <span class="keywd">then</span>
              write(log, <span class="stri">"INPUT$("</span> &lt;&amp; index1 &lt;&amp; <span class="stri">", #"</span> &lt;&amp; index2 &lt;&amp; <span class="stri">") "</span>);
              flush(log);
              exprResult := gets(aFile, index1);
              writeln(log, <span class="stri">"-> "</span> &lt;&amp; literal(exprResult));
            <span class="keywd">else</span>
              error_marker;
              writeln(err, <span class="stri">"FILE #"</span> &lt;&amp; index2 &lt;&amp; <span class="stri">" NOT OPEN IN INPUT$."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            expect(<span class="stri">")"</span>, symbol, line);
            write(log, <span class="stri">"INPUT$("</span> &lt;&amp; index1 &lt;&amp; <span class="stri">") "</span>);
            flush(log);
            flush(win);
            exprResult := gets(KEYBOARD, index1);
            writeln(log, <span class="stri">"-> "</span> &lt;&amp; literal(exprResult));
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"INPUT$ WITH NEGATIVE NUMBER "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">"."</span>);
          <span class="keywd">while</span> symbol &lt;> <span class="stri">")"</span> <span class="keywd">do</span>
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">while</span>;
          symbol := get_symbol(line);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {<span class="stri">"LCASE$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        stri1 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := lower(stri1);
        writeln(log, <span class="stri">"LCASE$("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">when</span> {<span class="stri">"LEFT$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        stri1 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">","</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := stri1[ .. round(num1)];
        writeln(log, <span class="stri">"LEFT$("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">", "</span> &lt;&amp; num1 &lt;&amp;
            <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">when</span> {<span class="stri">"LTRIM$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        stri1 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">")"</span>, symbol, line);
        index1 := 1;
        <span class="keywd">while</span> index1 &lt;= length(stri1) <span class="op">and</span> stri1[index1] = <span class="stri">' '</span> <span class="keywd">do</span>
          incr(index1);
        <span class="keywd">end</span> <span class="keywd">while</span>;
        exprResult := stri1[index1 ..];
        writeln(log, <span class="stri">"LTRIM$("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">when</span> {<span class="stri">"MID$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        stri1 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">","</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          num2 := exec_expr(symbol, line);
          expect(<span class="stri">")"</span>, symbol, line);
          exprResult := stri1[round(num1) .. round(num1) + round(num2) - 1];
          write(log, <span class="stri">"MID$("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">", "</span> &lt;&amp; num1 &lt;&amp; <span class="stri">", "</span> &lt;&amp; num2);
        <span class="keywd">else</span>
          expect(<span class="stri">")"</span>, symbol, line);
          exprResult := stri1[round(num1) .. ];
          write(log, <span class="stri">"MID$("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">", "</span> &lt;&amp; num1);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        writeln(log, <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">when</span> {<span class="stri">"MKD$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := bytes(bin64(num1), LE, 8);
        writeln(log, <span class="stri">"MKD$("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">when</span> {<span class="stri">"MKDMBF$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        <span class="keywd">block</span>
          exprResult := bytes(float2MbfBits(num1, DOUBLE), LE, 8);
          writeln(log, <span class="stri">"MKDMBF$("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
        exception
          catch RANGE_ERROR:
            error_marker;
            writeln(err, <span class="stri">"MKDMBF$("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") FAILED"</span>);
        <span class="keywd">end</span> <span class="keywd">block</span>
      <span class="keywd">when</span> {<span class="stri">"MKI$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        index1 := round(exec_expr(symbol, line));
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := str(chr(index1          <span class="op">mod</span> 256)) &amp;
                      str(chr(index1 <span class="op">mdiv</span> 256 <span class="op">mod</span> 256));
        writeln(log, <span class="stri">"MKI$("</span> &lt;&amp; index1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">when</span> {<span class="stri">"MKL$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        index1 := round(exec_expr(symbol, line));
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := str(chr(index1               <span class="op">mod</span> 256)) &amp;
                      str(chr(index1 <span class="op">mdiv</span>      256 <span class="op">mod</span> 256)) &amp;
                      str(chr(index1 <span class="op">mdiv</span>    65536 <span class="op">mod</span> 256)) &amp;
                      str(chr(index1 <span class="op">mdiv</span> 16777216 <span class="op">mod</span> 256));
        writeln(log, <span class="stri">"MKL$("</span> &lt;&amp; index1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">when</span> {<span class="stri">"MKS$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := bytes(bin32(num1), LE, 4);
        writeln(log, <span class="stri">"MKS$("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">when</span> {<span class="stri">"MKSMBF$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        <span class="keywd">block</span>
          exprResult := bytes(float2MbfBits(num1, SINGLE), LE, 4);
        writeln(log, <span class="stri">"MKSMBF$("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
        exception
          catch RANGE_ERROR:
            error_marker;
            writeln(err, <span class="stri">"MKSMBF$("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") FAILED"</span>);
        <span class="keywd">end</span> <span class="keywd">block</span>
      <span class="keywd">when</span> {<span class="stri">"OCT$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := round(num1) RADIX 8;
        writeln(log, <span class="stri">"OCT$("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">when</span> {<span class="stri">"RIGHT$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        stri1 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">","</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := stri1[length(stri1) - round(num1) + 1 .. ];
        writeln(log, <span class="stri">"RIGHT$("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">", "</span> &lt;&amp; num1 &lt;&amp;
            <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">when</span> {<span class="stri">"RPT$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        stri1 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">","</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        index1 := round(num1);
        <span class="keywd">if</span> index1 >= 0 <span class="keywd">then</span>
          exprResult := stri1 <span class="op">mult</span> index1;
          writeln(log, <span class="stri">"RPT$("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">", "</span> &lt;&amp; num1 &lt;&amp;
              <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"RPT$("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">", "</span> &lt;&amp; num1 &lt;&amp;
              <span class="stri">") - REPEAT COUNT NEGATIVE"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {<span class="stri">"RTRIM$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        stri1 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">")"</span>, symbol, line);
        index1 := length(stri1);
        <span class="keywd">while</span> index1 >= 1 <span class="op">and</span> stri1[index1] = <span class="stri">' '</span> <span class="keywd">do</span>
          decr(index1);
        <span class="keywd">end</span> <span class="keywd">while</span>;
        exprResult := stri1[.. index1];
        writeln(log, <span class="stri">"RTRIM$("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">when</span> {<span class="stri">"SEG$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        stri1 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">","</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">","</span>, symbol, line);
        num2 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := stri1[round(num1) len round(num2)];
        write(log, <span class="stri">"SEG$("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">", "</span> &lt;&amp; num1 &lt;&amp; <span class="stri">", "</span> &lt;&amp; num2);
        writeln(log, <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">when</span> {<span class="stri">"SPACE$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        index1 := round(num1);
        <span class="keywd">if</span> index1 >= 0 <span class="keywd">then</span>
          exprResult := <span class="stri">" "</span> <span class="op">mult</span> index1;
          writeln(log, <span class="stri">"SPACE$("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"REPEAT COUNT "</span> &lt;&amp; num1 &lt;&amp; <span class="stri">" NEGATIVE IN SPACE$."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {<span class="stri">"STR$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := str(round(num1));
        <span class="keywd">if</span> exprResult[1] &lt;> <span class="stri">'-'</span> <span class="keywd">then</span>
          exprResult := <span class="stri">" "</span> &amp; exprResult;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> exprResult[length(exprResult) - 1 .. ] = <span class="stri">".0"</span> <span class="keywd">then</span>
          exprResult := exprResult[ .. length(exprResult) - 2];
        <span class="keywd">end</span> <span class="keywd">if</span>;
        writeln(log, <span class="stri">"STR$("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">when</span> {<span class="stri">"STRING$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">","</span>, symbol, line);
        index1 := round(num1);
        <span class="keywd">if</span> index1 >= 0 <span class="keywd">then</span>
          <span class="keywd">if</span> isStringExpr(symbol) <span class="keywd">then</span>
            stri1 := exec_str_expr(symbol, line, unused_name);
            exprResult := stri1 <span class="op">mult</span> index1;
            writeln(log, <span class="stri">"STRING$("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">", "</span> &lt;&amp; literal(stri1) &lt;&amp;
                <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
          <span class="keywd">else</span>
            num2 := exec_expr(symbol, line);
            exprResult := str(chr(round(num2))) <span class="op">mult</span> index1;
            writeln(log, <span class="stri">"STRING$("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">", "</span> &lt;&amp; num2 &lt;&amp;
                <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          expect(<span class="stri">")"</span>, symbol, line);
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"REPEAT COUNT "</span> &lt;&amp; num1 &lt;&amp; <span class="stri">" NEGATIVE IN STRING$."</span>);
          <span class="keywd">while</span> symbol &lt;> <span class="stri">")"</span> <span class="keywd">do</span>
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">while</span>;
          symbol := get_symbol(line);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {<span class="stri">"TIME$"</span>}:
        symbol := get_symbol(line);
        exprResult := strTime(truncToSecond(time(NOW)));
        writeln(log, <span class="stri">"TIME$ -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">when</span> {<span class="stri">"UCASE$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        stri1 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := upper(stri1);
        writeln(log, <span class="stri">"UCASE$("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">when</span> {<span class="stri">"VARPTR$"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        variable_name := get_name(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := varptrStri(variable_name);
        writeln(log, <span class="stri">"VARPTR$("</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; literal(exprResult));
      <span class="keywd">otherwise</span>:
        <span class="keywd">if</span> symbol[1] = <span class="stri">'"'</span> <span class="keywd">then</span>
          exprResult := symbol[2 .. ];
          symbol := get_symbol(line);
        <span class="keywd">elsif</span> symbol[1] >= <span class="stri">'A'</span> <span class="op">and</span> symbol[1] &lt;= <span class="stri">'Z'</span> <span class="keywd">then</span>
          <span class="keywd">if</span> symbol <span class="op">in</span> def_fn_list <span class="keywd">then</span>
            func_name := symbol;
            exprResult := exec_str_function(def_fn_list[func_name], symbol, line);
            writeln(log, <span class="stri">"function "</span> &lt;&amp; func_name &lt;&amp; <span class="stri">" is "</span> &lt;&amp; literal(exprResult));
          <span class="keywd">elsif</span> symbol <span class="op">in</span> subfunction <span class="keywd">then</span>
            func_name := symbol;
            line_marker;
            writeln(log, <span class="stri">"**CALL FUNCTION "</span> &lt;&amp; symbol);
            symbol := get_symbol(line);
            <span class="keywd">if</span> symbol = <span class="stri">"("</span> <span class="keywd">then</span>
              <span class="keywd">repeat</span>
                symbol := get_symbol(line);
              <span class="keywd">until</span> symbol = <span class="stri">")"</span>;
              symbol := get_symbol(line);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            set_return_position(line);
            gosubReturn[1].subName := func_name;
            file_line_number := subfunction[func_name];
            line_marker;
            writeln(log, <span class="stri">"EXECUTE FUNCTION "</span> &lt;&amp; func_name);
            incr(file_line_number);
            execLines;
            file_line_number := gosubReturn[1].returnLine;
            gosubReturn := gosubReturn[2 .. ];
            exprResult := getStringVar(func_name);
            line_marker;
            writeln(log, <span class="stri">"RETURN FROM FUNCTION "</span> &lt;&amp; func_name &lt;&amp; <span class="stri">" -> "</span> &lt;&amp; literal(exprResult));
          <span class="keywd">else</span>
            variable_name := get_name(symbol, line);
            exprResult := getStringVar(variable_name);
            writeln(log, variable_name &lt;&amp; <span class="stri">" is "</span> &lt;&amp; literal(exprResult));
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"UNEXPECTED SYMBOL "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: exec_str_mult (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line,
    <span class="keywd">inout</span> <span class="type">string</span>: variable_name) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: exprResult <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">integer</span>: factor <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    exprResult := exec_str_primary(symbol, line, variable_name);
    <span class="keywd">while</span> symbol = <span class="stri">"*"</span> <span class="keywd">do</span>
      variable_name := <span class="stri">""</span>;
      symbol := get_symbol(line);
      num1 := exec_expr(symbol, line);
      factor := round(num1);
      <span class="keywd">if</span> factor >= 0 <span class="keywd">then</span>
        exprResult := exprResult <span class="op">mult</span> factor;
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"REPEAT COUNT "</span> &lt;&amp; num1 &lt;&amp;
            <span class="stri">" NEGATIVE IN STRING MULTIPLICATION."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: exec_str_expr (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line,
    <span class="keywd">inout</span> <span class="type">string</span>: variable_name) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: exprResult <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    exprResult := exec_str_mult(symbol, line, variable_name);
    <span class="keywd">while</span> symbol = <span class="stri">"+"</span> <span class="op">or</span> symbol = <span class="stri">"&amp;"</span> <span class="keywd">do</span>
      variable_name := <span class="stri">""</span>;
      symbol := get_symbol(line);
      stri := exec_str_mult(symbol, line, unused_name);
      exprResult &amp;:= stri;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: exec_function (<span class="op">in</span> <span class="type">defFnType</span>: defFn, <span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: exprResult <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: func_expr <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: func_symbol <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: formal_params <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: formal_param <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: str_value_backup <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">float</span>: num_value_backup <span class="keywd">is</span> 0 <span class="op">times</span> 0.0;
  <span class="keywd">begin</span>
    write(log, <span class="stri">"function "</span> &lt;&amp; defFn.name);
    formal_params := defFn.params;
    symbol := get_symbol(line);
    <span class="keywd">if</span> symbol = <span class="stri">"("</span> <span class="keywd">then</span>
      write(log, <span class="stri">"("</span>);
      <span class="keywd">repeat</span>
        symbol := get_symbol(line);
        formal_param := get_symbol(formal_params);
        <span class="keywd">if</span> formal_param[length(formal_param)] = <span class="stri">'$'</span> <span class="keywd">then</span>
          <span class="keywd">if</span> formal_param <span class="op">in</span> string_var <span class="keywd">then</span>
            str_value_backup &amp;:= [] (string_var[formal_param]);
          <span class="keywd">else</span>
            str_value_backup &amp;:= [] (<span class="stri">""</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          string_var @:= [formal_param] exec_str_expr(symbol, line, unused_name);
          write(log, string_var[formal_param]);
        <span class="keywd">else</span>
          <span class="keywd">if</span> formal_param <span class="op">in</span> numeric_var <span class="keywd">then</span>
            num_value_backup &amp;:= [] (numeric_var[formal_param]);
          <span class="keywd">else</span>
            num_value_backup &amp;:= [] (0.0);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          numeric_var @:= [formal_param] exec_expr(symbol, line);
          write(log, numeric_var[formal_param]);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        write(log, symbol);
      <span class="keywd">until</span> symbol &lt;> <span class="stri">","</span>;
      expect(<span class="stri">")"</span>, symbol, line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    func_expr := defFn.expression;
    writeln(log, <span class="stri">" = "</span> &lt;&amp; func_expr);
    func_symbol := get_symbol(func_expr);
    exprResult := exec_expr(func_symbol, func_expr);
    formal_params := defFn.params;
    formal_param := get_symbol(formal_params);
    <span class="keywd">while</span> formal_param &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> formal_param[length(formal_param)] = <span class="stri">'$'</span> <span class="keywd">then</span>
        string_var @:= [formal_param] str_value_backup[1];
        str_value_backup := str_value_backup[2 ..];
      <span class="keywd">else</span>
        numeric_var @:= [formal_param] num_value_backup[1];
        num_value_backup := num_value_backup[2 ..];
      <span class="keywd">end</span> <span class="keywd">if</span>;
      formal_param := get_symbol(formal_params);
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: exec_primary (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: exprResult <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri2 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">integer</span>: index1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">char</span>: current_key <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">time</span>: time_now <span class="keywd">is</span> time.value;
    <span class="keywd">var</span> <span class="type">duration</span>: since_midnight <span class="keywd">is</span> duration.value;
    <span class="keywd">var</span> <span class="type">string</span>: func_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">file</span>: aFile <span class="keywd">is</span> STD_NULL;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> symbol <span class="keywd">of</span>
      <span class="keywd">when</span> {<span class="stri">""</span>}:
        error_marker;
        writeln(err, <span class="stri">"EXPRESSION EXPECTED - FOUND END OF LINE."</span>);
      <span class="keywd">when</span> {<span class="stri">"ABS"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := abs(num1);
        writeln(log, <span class="stri">"ABS("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"ASC"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        stri1 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">")"</span>, symbol, line);
        <span class="keywd">if</span> stri1 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          exprResult := flt(ord(stri1[1]));
          writeln(log, <span class="stri">"ASC("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"ASC(\"\") - ILLEGAL FUNCTION CALL"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {<span class="stri">"ATN"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := atan(num1);
        writeln(log, <span class="stri">"ATN("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"CDBL"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        exprResult := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        writeln(log, <span class="stri">"CDBL("</span> &lt;&amp; exprResult &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"CINT"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := flt(round(num1));
        writeln(log, <span class="stri">"CINT("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"CLNG"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := flt(round(num1));
        writeln(log, <span class="stri">"CLNG("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"COS"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := cos(num1);
        writeln(log, <span class="stri">"COS("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"CSNG"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        exprResult := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        writeln(log, <span class="stri">"CSNG("</span> &lt;&amp; exprResult &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"CSRLIN"</span>}:
        symbol := get_symbol(line);
        exprResult := flt(line(win));
        writeln(log, <span class="stri">"CSRLIN -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"CVD"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        stri1 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">")"</span>, symbol, line);
        <span class="keywd">if</span> length(stri1) >= 8 <span class="keywd">then</span>
          exprResult := float(bin64(stri1[.. 8], LE));
          writeln(log, <span class="stri">"CVD("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"CVD("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">") IS ILLEGAL."</span>);
          exprResult := 0.0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {<span class="stri">"CVDMBF"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        stri1 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">")"</span>, symbol, line);
        <span class="keywd">if</span> length(stri1) >= 8 <span class="keywd">then</span>
          exprResult := mbfBits2Float(bin64(stri1[.. 8], LE));
          writeln(log, <span class="stri">"CVDMBF("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"CVDMBF("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">") IS ILLEGAL."</span>);
          exprResult := 0.0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {<span class="stri">"CVI"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        stri1 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">")"</span>, symbol, line);
        <span class="keywd">if</span> length(stri1) >= 2 <span class="keywd">then</span>
          <span class="keywd">if</span> ord(stri1[2]) >= 128 <span class="keywd">then</span>
            exprResult := flt((ord(stri1[2]) - 256) * 256 + ord(stri1[1]));
          <span class="keywd">else</span>
            exprResult := flt(ord(stri1[2]) * 256 + ord(stri1[1]));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          writeln(log, <span class="stri">"CVI("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"CVI("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">") IS ILLEGAL."</span>);
          exprResult := 0.0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {<span class="stri">"CVL"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        stri1 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">")"</span>, symbol, line);
        <span class="keywd">if</span> length(stri1) >= 4 <span class="keywd">then</span>
          <span class="keywd">if</span> ord(stri1[4]) >= 128 <span class="keywd">then</span>
            exprResult := flt((((ord(stri1[4]) - 256)  * 256 + ord(stri1[3])) * 256 +
                ord(stri1[2])) * 256 + ord(stri1[1]));
          <span class="keywd">else</span>
            exprResult := flt(((ord(stri1[4]) * 256 + ord(stri1[3])) * 256 +
                ord(stri1[2])) * 256 + ord(stri1[1]));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          writeln(log, <span class="stri">"CVL("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"CVL("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">") IS ILLEGAL."</span>);
          exprResult := 0.0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {<span class="stri">"CVS"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        stri1 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">")"</span>, symbol, line);
        <span class="keywd">if</span> length(stri1) >= 4 <span class="keywd">then</span>
          exprResult := float(bin32(stri1[.. 4], LE));
          writeln(log, <span class="stri">"CVS("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"CVS("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">") IS ILLEGAL."</span>);
          exprResult := 0.0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {<span class="stri">"CVSMBF"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        stri1 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">")"</span>, symbol, line);
        <span class="keywd">if</span> length(stri1) >= 4 <span class="keywd">then</span>
          exprResult := mbfBits2Float(bin32(stri1[.. 4], LE));
          writeln(log, <span class="stri">"CVSMBF("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"CVSMBF("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">") IS ILLEGAL."</span>);
          exprResult := 0.0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {<span class="stri">"EOF"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        index1 := round(exec_expr(symbol, line));
        expect(<span class="stri">")"</span>, symbol, line);
        aFile := getFileValue(index1);
        <span class="keywd">if</span> aFile &lt;> STD_NULL <span class="keywd">then</span>
          <span class="keywd">if</span> hasNext(aFile) <span class="keywd">then</span>
            exprResult := 0.0;
          <span class="keywd">else</span>
            exprResult := -1.0;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          writeln(log, <span class="stri">"EOF("</span> &lt;&amp; index1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"FILE #"</span> &lt;&amp; index1 &lt;&amp; <span class="stri">" NOT OPEN IN EOF."</span>);
          exprResult := -1.0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {<span class="stri">"ERL"</span>}:
        symbol := get_symbol(line);
        <span class="keywd">if</span> error_linenum &lt;> <span class="stri">""</span> <span class="op">and</span> error_linenum[1] <span class="op">in</span> digit_char <span class="keywd">then</span>
          exprResult := flt(integer(error_linenum));
        <span class="keywd">else</span>
          exprResult := 0.0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        writeln(log, <span class="stri">"ERL -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"ERR"</span>}:
        symbol := get_symbol(line);
        exprResult := flt(error_code);
        writeln(log, <span class="stri">"ERR -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"EXP"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := <span class="op">exp</span>(num1);
        writeln(log, <span class="stri">"EXP("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"FIX"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := flt(trunc(num1));
        writeln(log, <span class="stri">"FIX("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"FN"</span>}:
        variable_name := get_name(symbol, line);
        <span class="keywd">if</span> variable_name &lt;> <span class="stri">"FN"</span> <span class="op">or</span> (<span class="stri">"FN"</span> &amp; symbol) <span class="op">not</span> <span class="op">in</span> def_fn_list <span class="keywd">then</span>
          exprResult := getNumericVar(variable_name);
          writeln(log, variable_name &lt;&amp; <span class="stri">" is "</span> &lt;&amp; exprResult);
        <span class="keywd">else</span>
          func_name := <span class="stri">"FN"</span> &amp; symbol;
          exprResult := exec_function(def_fn_list[func_name], symbol, line);
          writeln(log, <span class="stri">"function "</span> &lt;&amp; func_name &lt;&amp; <span class="stri">" is "</span> &lt;&amp; exprResult);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {<span class="stri">"FRE"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        <span class="keywd">if</span> isStringExpr(symbol) <span class="keywd">then</span>
          stri1 := exec_str_expr(symbol, line, unused_name);
        <span class="keywd">else</span>
          num1 := exec_expr(symbol, line);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := 32767.0;
        writeln(log, <span class="stri">"FRE -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"FREEFILE"</span>}:
        symbol := get_symbol(line);
        index1 := 1;
        <span class="keywd">while</span> getFileValue(index1) &lt;> STD_NULL <span class="keywd">do</span>
          incr(index1);
        <span class="keywd">end</span> <span class="keywd">while</span>;
        exprResult := flt(index1);
        writeln(log, <span class="stri">"FREEFILE -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"INP"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        index1 := round(exec_expr(symbol, line));
        expect(<span class="stri">")"</span>, symbol, line);
        <span class="keywd">case</span> index1 <span class="keywd">of</span>
          <span class="keywd">when</span> {16#60}:  <span class="comment"># &amp;H60/96    Get keyboard scan code</span>
            current_key := busy_getc(KEYBOARD);
            <span class="keywd">if</span> current_key = KEY_NONE <span class="keywd">then</span>
              exprResult := 128.0; <span class="comment"># This is a key release code</span>
            <span class="keywd">else</span>
              exprResult := flt(keyboardScanCode(current_key));
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">when</span> {16#3DA}: <span class="comment"># &amp;H3DA/986  Indicate vertical retrace</span>
            exprResult := flt(rand(0, 1) * 8);
          <span class="keywd">otherwise</span>:
            exprResult := 0.0;
        <span class="keywd">end</span> <span class="keywd">case</span>;
        writeln(log, <span class="stri">"**INP("</span> &lt;&amp; index1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"INSTR"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        <span class="keywd">if</span> isStringExpr(symbol) <span class="keywd">then</span>
          index1 := 1;
        <span class="keywd">else</span>
          index1 := round(exec_expr(symbol, line));
          expect(<span class="stri">","</span>, symbol, line);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        stri1 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">","</span>, symbol, line);
        stri2 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">")"</span>, symbol, line);
        <span class="keywd">if</span> index1 >= 1 <span class="keywd">then</span>
          exprResult := flt(pos(stri1, stri2, index1));
          write(log, <span class="stri">"INSTR("</span>);
          <span class="keywd">if</span> index1 &lt;> 1 <span class="keywd">then</span>
            write(log, index1 &lt;&amp; <span class="stri">", "</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          writeln(log, literal(stri1) &lt;&amp; <span class="stri">", "</span> &lt;&amp; literal(stri2) &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"INSTR("</span> &lt;&amp; index1 &lt;&amp; <span class="stri">", "</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">", "</span> &lt;&amp;
              literal(stri2) &lt;&amp; <span class="stri">") - ILLEGAL FUNCTION CALL"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {<span class="stri">"INT"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := floor(num1);
        writeln(log, <span class="stri">"INT("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"LBOUND"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        variable_name := symbol;
        symbol := get_symbol(line);
        <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          index1 := round(exec_expr(symbol, line));
        <span class="keywd">else</span>
          index1 := 1;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := flt(exec_lbound(variable_name, index1));
        writeln(log, <span class="stri">"LBOUND("</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">", "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"LEN"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        stri1 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := flt(length(stri1));
        writeln(log, <span class="stri">"LEN("</span> &lt;&amp; literal(stri1) &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"LOF"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        index1 := round(exec_expr(symbol, line));
        expect(<span class="stri">")"</span>, symbol, line);
        aFile := getFileValue(index1);
        <span class="keywd">if</span> aFile &lt;> STD_NULL <span class="keywd">then</span>
          exprResult := flt(length(aFile));
          writeln(log, <span class="stri">"LOF("</span> &lt;&amp; index1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"FILE #"</span> &lt;&amp; index1 &lt;&amp; <span class="stri">" NOT OPEN IN LOF."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {<span class="stri">"LOG"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        <span class="keywd">if</span> num1 > 0.0 <span class="keywd">then</span>
          exprResult := log(num1);
          writeln(log, <span class="stri">"LOG("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"LOG("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") - ILLEGAL FUNCTION CALL"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {<span class="stri">"PEEK"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        index1 := round(exec_expr(symbol, line));
        expect(<span class="stri">")"</span>, symbol, line);
        <span class="keywd">case</span> index1 <span class="keywd">of</span>
          <span class="keywd">when</span> {16}:    <span class="comment"># Is it a bw or color screen?</span>
            exprResult := 35.0;
          <span class="keywd">when</span> {1040}:  <span class="comment"># Is it a bw or color screen?</span>
            exprResult := 35.0;
          <span class="keywd">when</span> {16#6c}: <span class="comment"># &amp;H6c contains the low order tick count of 0-255</span>
            time_now := time(NOW);
            since_midnight := time_now - truncToDay(time_now);
            exprResult := 18.2 * (flt(toSeconds(since_midnight)) +
                flt(since_midnight.micro_second) / 1000000.0);
            exprResult -:= floor(exprResult / 256.0) * 256.0;
            index1 := round(exprResult);
            <span class="keywd">if</span> index1 &lt; 0 <span class="keywd">then</span>
              exprResult := 0.0;
            <span class="keywd">elsif</span> index1 > 255 <span class="keywd">then</span>
              exprResult := 255.0;
            <span class="keywd">else</span>
              exprResult := flt(index1);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">when</span> {49152, -16384}: <span class="comment"># Read keyboard</span>
            current_key := busy_getc(KEYBOARD);
            <span class="keywd">if</span> current_key = KEY_NONE <span class="keywd">then</span>
              exprResult := 0.0;
            <span class="keywd">else</span>
              <span class="keywd">if</span> current_key = KEY_NL <span class="keywd">then</span>
                current_key := KEY_CR;
              <span class="keywd">elsif</span> current_key >= <span class="stri">'\128;'</span> <span class="keywd">then</span>
                current_key := <span class="stri">'\0;'</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="comment"># Return value >= 128 if a key has been pressed.</span>
              exprResult := flt(ord(current_key) + 128);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">otherwise</span>:
            exprResult := 0.0;
        <span class="keywd">end</span> <span class="keywd">case</span>;
        writeln(log, <span class="stri">"**PEEK("</span> &lt;&amp; index1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"POINT"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        index1 := round(exec_expr(symbol, line));
        <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          index2 := round(exec_expr(symbol, line));
          expect(<span class="stri">")"</span>, symbol, line);
          exprResult := 0.0;
          writeln(log, <span class="stri">"**POINT("</span> &lt;&amp; index1 &lt;&amp; <span class="stri">", "</span> &lt;&amp; index2 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
        <span class="keywd">else</span>
          expect(<span class="stri">")"</span>, symbol, line);
          exprResult := 0.0;
          writeln(log, <span class="stri">"**POINT("</span> &lt;&amp; index1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {<span class="stri">"POS"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := flt(column(win));
        writeln(log, <span class="stri">"POS -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"RND"</span>}:
        symbol := get_symbol(line);
        <span class="keywd">if</span> symbol = <span class="stri">"("</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol &lt;> <span class="stri">")"</span> <span class="keywd">then</span>
            num1 := exec_expr(symbol, line);
            expect(<span class="stri">")"</span>, symbol, line);
            <span class="keywd">if</span> num1 &lt;> 0.0 <span class="keywd">then</span>
              lastRandomNumber := rand(0.0, 1.0);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            expect(<span class="stri">")"</span>, symbol, line);
            lastRandomNumber := rand(0.0, 1.0);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          lastRandomNumber := rand(0.0, 1.0);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        exprResult := lastRandomNumber;
        writeln(log, <span class="stri">"RND -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"SCREEN"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        index1 := round(exec_expr(symbol, line));
        expect(<span class="stri">","</span>, symbol, line);
        index2 := round(exec_expr(symbol, line));
        <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          num1 := exec_expr(symbol, line);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := 32.0;
        writeln(log, <span class="stri">"**SCREEN("</span> &lt;&amp; index1 &lt;&amp; <span class="stri">", "</span> &lt;&amp; index2 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"SGN"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        <span class="keywd">if</span> num1 > 0.0 <span class="keywd">then</span>
          exprResult := 1.0;
        <span class="keywd">elsif</span> num1 = 0.0 <span class="keywd">then</span>
          exprResult := 0.0;
        <span class="keywd">else</span>
          exprResult := -1.0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        writeln(log, <span class="stri">"SGN("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"SIN"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := sin(num1);
        writeln(log, <span class="stri">"SIN("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"SQR"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        <span class="keywd">if</span> num1 >= 0.0 <span class="keywd">then</span>
          exprResult := sqrt(num1);
          writeln(log, <span class="stri">"SQR("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"SQR("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") - ILLEGAL FUNCTION CALL"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {<span class="stri">"STRIG"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        index1 := round(exec_expr(symbol, line));
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := 0.0;
        current_key := busy_getc(KEYBOARD);
        <span class="keywd">case</span> index1 <span class="keywd">of</span>
          <span class="keywd">when</span> {0, 1}:
            <span class="keywd">if</span> current_key = KEY_MOUSE1 <span class="keywd">then</span>
              current_key := getc(KEYBOARD);
              exprResult := -1.0;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">when</span> {4, 5}:
            <span class="keywd">if</span> current_key = KEY_MOUSE3 <span class="keywd">then</span>
              current_key := getc(KEYBOARD);
              exprResult := -1.0;
            <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">case</span>;
        writeln(log, <span class="stri">"**STRIG("</span> &lt;&amp; index1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"TAN"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := tan(num1);
        writeln(log, <span class="stri">"TAN("</span> &lt;&amp; num1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"TIMER"</span>}:
        symbol := get_symbol(line);
        time_now := time(NOW);
        since_midnight := time_now - truncToDay(time_now);
        exprResult := flt(toSeconds(since_midnight)) +
            flt(since_midnight.micro_second) / 1000000.0;
        writeln(log, <span class="stri">"TIMER -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"UBOUND"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        variable_name := symbol;
        symbol := get_symbol(line);
        <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          index1 := round(exec_expr(symbol, line));
        <span class="keywd">else</span>
          index1 := 1;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := flt(exec_ubound(variable_name, index1));
        writeln(log, <span class="stri">"UBOUND("</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">", "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"VAL"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        stri1 := exec_str_expr(symbol, line, unused_name);
        expect(<span class="stri">")"</span>, symbol, line);
        stri2 := get_symbol(stri1);
        <span class="keywd">if</span> stri2 = <span class="stri">"-"</span> <span class="keywd">then</span>
          stri2 &amp;:= get_symbol(stri1);
        <span class="keywd">elsif</span> stri2 = <span class="stri">"+"</span> <span class="keywd">then</span>
          stri2 := get_symbol(stri1);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">block</span>
          exprResult := float(stri2);
        exception
          catch RANGE_ERROR:
            exprResult := 0.0;
        <span class="keywd">end</span> <span class="keywd">block</span>;
        writeln(log, <span class="stri">"VAL("</span> &lt;&amp; literal(stri2) &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"VARPTR"</span>}:
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        variable_name := get_name(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        exprResult := flt(varptr(variable_name));
        writeln(log, <span class="stri">"VARPTR("</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">") -> "</span> &lt;&amp; exprResult);
      <span class="keywd">when</span> {<span class="stri">"("</span>}:
        symbol := get_symbol(line);
        exprResult := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
      <span class="keywd">when</span> {<span class="stri">"%"</span>}:
        variable_name := <span class="stri">""</span>;
        <span class="keywd">repeat</span>
          variable_name &amp;:= symbol;
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol &lt;> <span class="stri">""</span> <span class="op">and</span> symbol[1] <span class="op">in</span> alphanum_char <span class="keywd">then</span>
            variable_name &amp;:= symbol;
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">until</span> symbol &lt;> <span class="stri">"_"</span>;
        append_index(variable_name, symbol, line);
        exprResult := getNumericVar(variable_name);
        writeln(log, variable_name &lt;&amp; <span class="stri">" is "</span> &lt;&amp; exprResult);
      <span class="keywd">otherwise</span>:
        <span class="keywd">if</span> symbol[1] <span class="op">in</span> digit_char <span class="keywd">then</span>
          <span class="keywd">if</span> symbol[length(symbol)] <span class="op">in</span> number_suffix <span class="keywd">then</span>
            symbol := symbol[.. pred(length(symbol))];
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">block</span>
            exprResult := float(symbol);
          exception
            catch RANGE_ERROR:
              error_marker;
              writeln(err, <span class="stri">"ERROR IN PARSE NUMBER "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
          <span class="keywd">end</span> <span class="keywd">block</span>;
          symbol := get_symbol(line);
        <span class="keywd">elsif</span> symbol[1] >= <span class="stri">'A'</span> <span class="op">and</span> symbol[1] &lt;= <span class="stri">'Z'</span> <span class="keywd">then</span>
          <span class="keywd">if</span> symbol <span class="op">in</span> def_fn_list <span class="keywd">then</span>
            func_name := symbol;
            exprResult := exec_function(def_fn_list[func_name], symbol, line);
            writeln(log, <span class="stri">"function "</span> &lt;&amp; func_name &lt;&amp; <span class="stri">" is "</span> &lt;&amp; exprResult);
          <span class="keywd">elsif</span> symbol <span class="op">in</span> subfunction <span class="keywd">then</span>
            func_name := symbol;
            line_marker;
            writeln(log, <span class="stri">"**CALL FUNCTION "</span> &lt;&amp; symbol);
            symbol := get_symbol(line);
            <span class="keywd">if</span> symbol = <span class="stri">"("</span> <span class="keywd">then</span>
              <span class="keywd">repeat</span>
                symbol := get_symbol(line);
              <span class="keywd">until</span> symbol = <span class="stri">")"</span>;
              symbol := get_symbol(line);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            set_return_position(line);
            gosubReturn[1].subName := func_name;
            file_line_number := subfunction[func_name];
            line_marker;
            writeln(log, <span class="stri">"EXECUTE FUNCTION "</span> &lt;&amp; func_name);
            incr(file_line_number);
            execLines;
            file_line_number := gosubReturn[1].returnLine;
            gosubReturn := gosubReturn[2 .. ];
            exprResult := getNumericVar(func_name);
            line_marker;
            writeln(log, <span class="stri">"RETURN FROM FUNCTION "</span> &lt;&amp; func_name &lt;&amp; <span class="stri">" -> "</span> &lt;&amp; exprResult);
          <span class="keywd">else</span>
            variable_name := get_name(symbol, line);
            exprResult := getNumericVar(variable_name);
            writeln(log, variable_name &lt;&amp; <span class="stri">" is "</span> &lt;&amp; exprResult);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"UNEXPECTED SYMBOL "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: exec_exponentation (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: exprResult <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">float</span>: num <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    exprResult := exec_primary(symbol, line);
    <span class="keywd">if</span> symbol = <span class="stri">"^"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      num := exec_primary(symbol, line);
      <span class="keywd">if</span> flt(round(num)) = num <span class="keywd">then</span>
        exprResult := exprResult ** round(num);
      <span class="keywd">else</span>
        exprResult := exprResult ** num;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: exec_negation (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: exprResult <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> symbol = <span class="stri">"-"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      exprResult := -exec_exponentation(symbol, line);
    <span class="keywd">elsif</span> symbol = <span class="stri">"+"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      exprResult := exec_exponentation(symbol, line);
    <span class="keywd">else</span>
      exprResult := exec_exponentation(symbol, line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: exec_multdiv (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: exprResult <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: op <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: num2 <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    exprResult := exec_negation(symbol, line);
    <span class="keywd">while</span> symbol = <span class="stri">"*"</span> <span class="op">or</span> symbol = <span class="stri">"/"</span> <span class="op">or</span> symbol = <span class="stri">"\\"</span> <span class="op">or</span> symbol = <span class="stri">"MOD"</span> <span class="keywd">do</span>
      op := symbol;
      symbol := get_symbol(line);
      num1 := exprResult;
      num2 := exec_negation(symbol, line);
      <span class="keywd">if</span> op = <span class="stri">"*"</span> <span class="keywd">then</span>
        exprResult := num1 * num2;
      <span class="keywd">else</span>
        <span class="keywd">block</span>
          <span class="keywd">if</span> op = <span class="stri">"/"</span> <span class="keywd">then</span>
            exprResult := num1 / num2;
            <span class="keywd">if</span> abs(exprResult) = Infinity <span class="op">or</span> isNaN(exprResult) <span class="keywd">then</span>
              raise NUMERIC_ERROR;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> op = <span class="stri">"\\"</span> <span class="keywd">then</span>
            exprResult := flt(round(num1) <span class="op">div</span> round(num2));
          <span class="keywd">elsif</span> op = <span class="stri">"MOD"</span> <span class="keywd">then</span>
            exprResult := flt(round(num1) <span class="op">rem</span> round(num2));
          <span class="keywd">end</span> <span class="keywd">if</span>;
        exception
          catch NUMERIC_ERROR:
            <span class="keywd">if</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
              error_code := 11; <span class="comment"># Division by zero</span>
              writeln(log);
              line_marker;
              writeln(log, error_code &lt;&amp; <span class="stri">" DIVISION BY ZERO ("</span> &lt;&amp;
                      num1 &lt;&amp; <span class="stri">" "</span> &lt;&amp; op &lt;&amp; <span class="stri">" "</span> &lt;&amp; num2 &lt;&amp; <span class="stri">")"</span> &lt;&amp;
                      <span class="stri">" - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
              goto_on_error(on_error_label, line);
              symbol := <span class="stri">""</span>;
              line := <span class="stri">""</span>;
            <span class="keywd">else</span>
              error_marker;
              writeln(err, <span class="stri">"DIVISION BY ZERO ("</span> &lt;&amp;
                      num1 &lt;&amp; <span class="stri">" "</span> &lt;&amp; op &lt;&amp; <span class="stri">" "</span> &lt;&amp; num2 &lt;&amp; <span class="stri">")"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> num1 >= 0.0 <span class="keywd">then</span>
              exprResult := Infinity;
            <span class="keywd">else</span>
              exprResult := -Infinity;
            <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">block</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: exec_addsub (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: exprResult <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: op <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    exprResult := exec_multdiv(symbol, line);
    <span class="keywd">while</span> symbol = <span class="stri">"+"</span> <span class="op">or</span> symbol = <span class="stri">"-"</span> <span class="keywd">do</span>
      op := symbol;
      symbol := get_symbol(line);
      num := exec_multdiv(symbol, line);
      <span class="keywd">if</span> op = <span class="stri">"+"</span> <span class="keywd">then</span>
         exprResult := exprResult + num;
      <span class="keywd">elsif</span> op = <span class="stri">"-"</span> <span class="keywd">then</span>
         exprResult := exprResult - num;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: exec_comparison (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: exprResult <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: op <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri2 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isStringExpr(symbol) <span class="op">and</span> symbol <span class="op">not</span> <span class="op">in</span> numeric_functions <span class="keywd">then</span>
      stri1 := exec_str_expr(symbol, line, unused_name);
      <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"&lt;>"</span> <span class="op">or</span>
          symbol = <span class="stri">"&lt;"</span> <span class="op">or</span> symbol = <span class="stri">">"</span> <span class="op">or</span>
          symbol = <span class="stri">"&lt;="</span> <span class="op">or</span> symbol = <span class="stri">">="</span> <span class="keywd">then</span>
        op := symbol;
        symbol := get_symbol(line);
        stri2 := exec_str_expr(symbol, line, unused_name);
        <span class="keywd">if</span> op = <span class="stri">"="</span> <span class="keywd">then</span>
           exprResult := flt(-ord(stri1 = stri2));
        <span class="keywd">elsif</span> op = <span class="stri">"&lt;>"</span> <span class="keywd">then</span>
           exprResult := flt(-ord(stri1 &lt;> stri2));
        <span class="keywd">elsif</span> op = <span class="stri">"&lt;"</span> <span class="keywd">then</span>
           exprResult := flt(-ord(stri1 &lt; stri2));
        <span class="keywd">elsif</span> op = <span class="stri">">"</span> <span class="keywd">then</span>
           exprResult := flt(-ord(stri1 > stri2));
        <span class="keywd">elsif</span> op = <span class="stri">"&lt;="</span> <span class="keywd">then</span>
           exprResult := flt(-ord(stri1 &lt;= stri2));
        <span class="keywd">elsif</span> op = <span class="stri">">="</span> <span class="keywd">then</span>
           exprResult := flt(-ord(stri1 >= stri2));
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"COMPARISON EXPECTED - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      exprResult := exec_addsub(symbol, line);
      <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"&lt;>"</span> <span class="op">or</span>
          symbol = <span class="stri">"&lt;"</span> <span class="op">or</span> symbol = <span class="stri">">"</span> <span class="op">or</span>
          symbol = <span class="stri">"&lt;="</span> <span class="op">or</span> symbol = <span class="stri">">="</span> <span class="keywd">then</span>
        op := symbol;
        symbol := get_symbol(line);
        num := exec_addsub(symbol, line);
        <span class="keywd">if</span> op = <span class="stri">"="</span> <span class="keywd">then</span>
           exprResult := flt(-ord(exprResult = num));
        <span class="keywd">elsif</span> op = <span class="stri">"&lt;>"</span> <span class="keywd">then</span>
           exprResult := flt(-ord(exprResult &lt;> num));
        <span class="keywd">elsif</span> op = <span class="stri">"&lt;"</span> <span class="keywd">then</span>
           exprResult := flt(-ord(exprResult &lt; num));
        <span class="keywd">elsif</span> op = <span class="stri">">"</span> <span class="keywd">then</span>
           exprResult := flt(-ord(exprResult > num));
        <span class="keywd">elsif</span> op = <span class="stri">"&lt;="</span> <span class="keywd">then</span>
           exprResult := flt(-ord(exprResult &lt;= num));
        <span class="keywd">elsif</span> op = <span class="stri">">="</span> <span class="keywd">then</span>
           exprResult := flt(-ord(exprResult >= num));
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: exec_cond_not (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: exprResult <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">float</span>: num <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> symbol = <span class="stri">"NOT"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      num := exec_comparison(symbol, line);
      exprResult := flt(-ord(num = 0.0));
    <span class="keywd">else</span>
      exprResult := exec_comparison(symbol, line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: binary_and (<span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: number1, <span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: number2) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: exprResult <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: count <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> count <span class="keywd">range</span> 0 <span class="keywd">to</span> 15 <span class="keywd">do</span>
      <span class="keywd">if</span> odd(number1) <span class="op">and</span> odd(number2) <span class="keywd">then</span>
        exprResult +:= 2 ** count;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      number1 := number1 <span class="op">div</span> 2;
      number2 := number2 <span class="op">div</span> 2;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: exec_cond_and (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: exprResult <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: number2 <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    exprResult := exec_cond_not(symbol, line);
    <span class="keywd">if</span> startsWith(symbol, <span class="stri">"AND"</span>) <span class="keywd">then</span>
      line := symbol[4 ..] &amp; line;
      symbol := <span class="stri">"AND"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">while</span> symbol = <span class="stri">"AND"</span> <span class="keywd">do</span>
      number1 := round(exprResult);
      symbol := get_symbol(line);
      number2 := round(exec_cond_not(symbol, line));
      exprResult := flt(binary_and(number1, number2));
      <span class="keywd">if</span> startsWith(symbol, <span class="stri">"AND"</span>) <span class="keywd">then</span>
        line := symbol[4 ..] &amp; line;
        symbol := <span class="stri">"AND"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: binary_or (<span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: number1, <span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: number2) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: exprResult <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: count <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> count <span class="keywd">range</span> 0 <span class="keywd">to</span> 15 <span class="keywd">do</span>
      <span class="keywd">if</span> odd(number1) <span class="op">or</span> odd(number2) <span class="keywd">then</span>
        exprResult +:= 2 ** count;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      number1 := number1 <span class="op">div</span> 2;
      number2 := number2 <span class="op">div</span> 2;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: binary_xor (<span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: number1, <span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: number2) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: exprResult <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: count <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> count <span class="keywd">range</span> 0 <span class="keywd">to</span> 15 <span class="keywd">do</span>
      <span class="keywd">if</span> odd(number1) &lt;> odd(number2) <span class="keywd">then</span>
        exprResult +:= 2 ** count;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      number1 := number1 <span class="op">div</span> 2;
      number2 := number2 <span class="op">div</span> 2;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: exec_cond_or (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: exprResult <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: op <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: number1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: number2 <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    exprResult := exec_cond_and(symbol, line);
    <span class="keywd">if</span> startsWith(symbol, <span class="stri">"OR"</span>) <span class="keywd">then</span>
      line := symbol[3 ..] &amp; line;
      symbol := <span class="stri">"OR"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">while</span> symbol = <span class="stri">"OR"</span> <span class="op">or</span> symbol = <span class="stri">"XOR"</span> <span class="keywd">do</span>
      number1 := round(exprResult);
      op := symbol;
      symbol := get_symbol(line);
      number2 := round(exec_cond_and(symbol, line));
      <span class="keywd">if</span> op = <span class="stri">"OR"</span> <span class="keywd">then</span>
        exprResult := flt(binary_or(number1, number2));
      <span class="keywd">elsif</span> op = <span class="stri">"XOR"</span> <span class="keywd">then</span>
        exprResult := flt(binary_xor(number1, number2));
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> startsWith(symbol, <span class="stri">"OR"</span>) <span class="keywd">then</span>
        line := symbol[3 ..] &amp; line;
        symbol := <span class="stri">"OR"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: binary_eqv (<span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: number1, <span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: number2) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: exprResult <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: count <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> count <span class="keywd">range</span> 0 <span class="keywd">to</span> 15 <span class="keywd">do</span>
      <span class="keywd">if</span> odd(number1) = odd(number2) <span class="keywd">then</span>
        exprResult +:= 2 ** count;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      number1 := number1 <span class="op">div</span> 2;
      number2 := number2 <span class="op">div</span> 2;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: exec_cond_eqv (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: exprResult <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: number2 <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    exprResult := exec_cond_or(symbol, line);
    <span class="keywd">while</span> symbol = <span class="stri">"EQV"</span> <span class="keywd">do</span>
      number1 := round(exprResult);
      symbol := get_symbol(line);
      number2 := round(exec_cond_or(symbol, line));
      exprResult := flt(binary_eqv(number1, number2));
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: binary_imp (<span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: number1, <span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: number2) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: exprResult <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: count <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> count <span class="keywd">range</span> 0 <span class="keywd">to</span> 15 <span class="keywd">do</span>
      <span class="keywd">if</span> odd(number1) &lt;= odd(number2) <span class="keywd">then</span>
        exprResult +:= 2 ** count;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      number1 := number1 <span class="op">div</span> 2;
      number2 := number2 <span class="op">div</span> 2;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: exec_expr (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: exprResult <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: number2 <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    exprResult := exec_cond_eqv(symbol, line);
    <span class="keywd">while</span> symbol = <span class="stri">"IMP"</span> <span class="keywd">do</span>
      number1 := round(exprResult);
      symbol := get_symbol(line);
      number2 := round(exec_cond_eqv(symbol, line));
      exprResult := flt(binary_imp(number1, number2));
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getNameList (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: nameList <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    nameList &amp;:= symbol;
    symbol := get_symbol(line);
    <span class="keywd">while</span> symbol = <span class="stri">","</span> <span class="keywd">do</span>
      symbol := get_symbol(line);
      <span class="keywd">if</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">then</span>
        nameList &amp;:= <span class="stri">","</span>;
        nameList &amp;:= symbol;
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: nameInList (<span class="op">in</span> <span class="type">string</span>: name, <span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: nameList) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: found <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      symbol := get_symbol(nameList);
      <span class="keywd">if</span> name = symbol <span class="keywd">then</span>
        found := TRUE;
      <span class="keywd">else</span>
        symbol := get_symbol(nameList);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> symbol &lt;> <span class="stri">","</span> <span class="op">or</span> found;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: removeNameFromList (<span class="op">in</span> <span class="type">string</span>: name, <span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: nameList) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: newNameList <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: found <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      symbol := get_symbol(nameList);
      <span class="keywd">if</span> name = symbol <span class="keywd">then</span>
        symbol := get_symbol(nameList);
        found := TRUE;
      <span class="keywd">else</span>
        <span class="keywd">if</span> newNameList &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          newNameList &amp;:= <span class="stri">","</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        newNameList &amp;:= symbol;
        symbol := get_symbol(nameList);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> symbol &lt;> <span class="stri">","</span> <span class="op">or</span> found;
    newNameList &amp;:= nameList;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Get the next BASIC symbol from the program.
 *  When the end of the line is reached the search for a symbol is
 *  continued in the next line.
 *  @return the BASIC symbol or "" at the end of the program.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: next_symbol (<span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      symbol := get_symbol(line);
      <span class="keywd">if</span> symbol = <span class="stri">""</span> <span class="keywd">then</span>
        incr(file_line_number);
        <span class="keywd">if</span> file_line_number &lt;= length(prg) <span class="keywd">then</span>
          statement_label := prg[file_line_number].linenum;
          line := prg[file_line_number].line;
          symbol := get_symbol(line);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> symbol &lt;> <span class="stri">""</span> <span class="op">or</span> file_line_number > length(prg);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Search for a THEN in the current line.
 *  @return "THEN" if a THEN was found, "" otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: find_then (<span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    <span class="keywd">while</span> symbol &lt;> <span class="stri">"THEN"</span> <span class="op">and</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      symbol := get_symbol(line);
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Search for an ELSE in the current line.
 *  If an IF is found a recursive call searches for a possible
 *  inner ELSE which would belong to the inner IF. Such an inner ELSE
 *  is skipped.
 *  @param symbol contains the current symbol. After the call it
 *         contains "ELSE" if a corresponding ELSE was found and
 *         "" otherwise.
 *  @param line contains the current line. After the call it contains
 *         the rest of the line after the ELSE or "" if no ELSE was
 *         found.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: find_else (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> startsWith(symbol, <span class="stri">"ELSE"</span>) <span class="op">and</span> <span class="op">not</span> is_let_statement(line) <span class="keywd">then</span>
      line := symbol[5 ..] &amp; line;
      symbol := <span class="stri">"ELSE"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">while</span> symbol &lt;> <span class="stri">"ELSE"</span> <span class="op">and</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> startsWith(symbol, <span class="stri">"IF"</span>) <span class="op">and</span> <span class="op">not</span> is_let_statement(line) <span class="keywd">then</span>
        line := symbol[3 ..] &amp; line;
        symbol := <span class="stri">"IF"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbol = <span class="stri">"IF"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        find_else(symbol, line);
      <span class="keywd">elsif</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      symbol := get_symbol(line);
      <span class="keywd">if</span> startsWith(symbol, <span class="stri">"ELSE"</span>) <span class="op">and</span> <span class="op">not</span> is_let_statement(line) <span class="keywd">then</span>
        line := symbol[5 ..] &amp; line;
        symbol := <span class="stri">"ELSE"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Search for a NEXT matching a "FOR varName" statement.
 *  If a FOR is found a recursive call searches for a possible
 *  inner NEXT which would belong to the inner FOR. Such an inner NEXT
 *  is skipped if it does not match a "FOR varName" statement.
 *  @param symbol contains the current symbol. After the call it
 *         contains the symbol behind the NEXT and the optional list
 *         of variable names. If no NEXT was found, the parameter
 *         contains "" after the call.
 *  @param nameList returns the list of variable names found after
 *         the NEXT or "" if no NEXT was found or no list list of
 *         variable names is present after the NEXT.
 *  @return TRUE if a corresponding NEXT was found, FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: find_next (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line,
    <span class="op">in</span> <span class="type">string</span>: varName, <span class="keywd">inout</span> <span class="type">string</span>: nameList) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: found <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: label <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: innerVarName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: innerNameList <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> <span class="op">not</span> found <span class="op">and</span> symbol &lt;> <span class="stri">"NEXT"</span> <span class="op">and</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> symbol = <span class="stri">"FOR"</span> <span class="keywd">then</span>
        symbol := next_symbol(line);
        innerVarName := symbol;
        label := statement_label;
        <span class="keywd">if</span> find_next(symbol, line, innerVarName, innerNameList) <span class="op">and</span>
            (innerNameList = <span class="stri">""</span> <span class="op">or</span> nameInList(innerVarName, innerNameList)) <span class="keywd">then</span>
          <span class="keywd">if</span> nameInList(varName, innerNameList) <span class="keywd">then</span>
            found := TRUE;
            nameList := innerNameList;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          error_marker(label);
          writeln(err, <span class="stri">"NO CORRESPONDING \"NEXT\" OR \"NEXT "</span> &lt;&amp; innerVarName &lt;&amp;
              <span class="stri">"\" FOUND FOR \"FOR "</span> &lt;&amp; innerVarName &lt;&amp; <span class="stri">"\""</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> symbol = <span class="stri">"EXIT"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
      <span class="keywd">elsif</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> <span class="op">not</span> found <span class="keywd">then</span>
        symbol := next_symbol(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> <span class="op">not</span> found <span class="op">and</span> symbol = <span class="stri">"NEXT"</span> <span class="keywd">then</span>
      found := TRUE;
      symbol := get_symbol(line);
      <span class="keywd">if</span> endOfStatement(symbol) <span class="keywd">then</span>
        nameList := <span class="stri">""</span>;
      <span class="keywd">else</span>
        nameList := getNameList(symbol, line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Search for a NEXT matching a "FOR varName" statement.
 *  If a FOR is found a recursive call searches for a possible
 *  inner NEXT which would belong to the inner FOR. Such an inner NEXT
 *  is skipped if it does not match a "FOR varName" statement.
 *  @param symbol contains the current symbol or "" if the next
 *         symbol should be read. After the call it contains the
 *         symbol behind the NEXT and the optional list of variable
 *         names. If no NEXT was found, the parameter contains ""
 *         after the call.
 *  @return TRUE if a corresponding NEXT was found, FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: find_next (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line,
    <span class="op">in</span> <span class="type">string</span>: varName) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: found <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: nameList <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> symbol = <span class="stri">""</span> <span class="keywd">then</span>
      symbol := next_symbol(line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    found := find_next(symbol, line, varName, nameList) <span class="op">and</span>
        (nameList = <span class="stri">""</span> <span class="op">or</span> nameInList(varName, nameList));
    <span class="keywd">if</span> found <span class="keywd">then</span>
      line_marker;
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      write(log, <span class="stri">"LEAVE \"FOR "</span> &lt;&amp; varName &lt;&amp; <span class="stri">"\" - CONTINUE AFTER \"NEXT"</span>);
      <span class="keywd">if</span> nameList &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        write(log, <span class="stri">" "</span> &lt;&amp; nameList);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      writeln(log, <span class="stri">"\""</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: find_wend (<span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    symbol := next_symbol(line);
    <span class="keywd">while</span> symbol &lt;> <span class="stri">"WEND"</span> <span class="op">and</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> symbol = <span class="stri">"WHILE"</span> <span class="keywd">then</span>
        symbol := find_wend(line);
      <span class="keywd">elsif</span> symbol = <span class="stri">"EXIT"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
      <span class="keywd">elsif</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      symbol := next_symbol(line);
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: find_do (<span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    symbol := next_symbol(line);
    <span class="keywd">while</span> symbol &lt;> <span class="stri">"DO"</span> <span class="op">and</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">else</span>
        <span class="keywd">repeat</span>
          symbol := get_symbol(line);
        <span class="keywd">until</span> endOfStatement(symbol) <span class="op">or</span> symbol = <span class="stri">"THEN"</span>;
        <span class="keywd">if</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
          line := <span class="stri">""</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      symbol := next_symbol(line);
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: find_loop (<span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    symbol := next_symbol(line);
    <span class="keywd">while</span> symbol &lt;> <span class="stri">"LOOP"</span> <span class="op">and</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> symbol = <span class="stri">"DO"</span> <span class="keywd">then</span>
        symbol := find_loop(line);
      <span class="keywd">elsif</span> symbol = <span class="stri">"EXIT"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
      <span class="keywd">elsif</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      symbol := next_symbol(line);
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: find_end_sub (<span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    symbol := next_symbol(line);
    <span class="keywd">while</span> symbol &lt;> <span class="stri">"END"</span> <span class="op">and</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> symbol = <span class="stri">"SUB"</span> <span class="keywd">then</span>
        symbol := find_end_sub(line);
      <span class="keywd">elsif</span> symbol = <span class="stri">"EXIT"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
      <span class="keywd">elsif</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      symbol := next_symbol(line);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> symbol = <span class="stri">"END"</span> <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        symbol := get_symbol(line);
      <span class="keywd">until</span> symbol &lt;> <span class="stri">"END"</span>;
      <span class="keywd">if</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbol &lt;> <span class="stri">"SUB"</span> <span class="keywd">then</span>
        symbol := find_end_sub(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: find_end_function (<span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    symbol := next_symbol(line);
    <span class="keywd">while</span> symbol &lt;> <span class="stri">"END"</span> <span class="op">and</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> symbol = <span class="stri">"FUNCTION"</span> <span class="keywd">then</span>
        symbol := find_end_function(line);
      <span class="keywd">elsif</span> symbol = <span class="stri">"EXIT"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
      <span class="keywd">elsif</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      symbol := next_symbol(line);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> symbol = <span class="stri">"END"</span> <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        symbol := get_symbol(line);
      <span class="keywd">until</span> symbol &lt;> <span class="stri">"END"</span>;
      <span class="keywd">if</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbol &lt;> <span class="stri">"FUNCTION"</span> <span class="keywd">then</span>
        symbol := find_end_function(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: find_end_select (<span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    symbol := next_symbol(line);
    <span class="keywd">while</span> symbol &lt;> <span class="stri">"END"</span> <span class="op">and</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> symbol = <span class="stri">"SELECT"</span> <span class="keywd">then</span>
        symbol := find_end_select(line);
      <span class="keywd">elsif</span> symbol = <span class="stri">"EXIT"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
      <span class="keywd">elsif</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      symbol := next_symbol(line);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> symbol = <span class="stri">"END"</span> <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        symbol := get_symbol(line);
      <span class="keywd">until</span> symbol &lt;> <span class="stri">"END"</span>;
      <span class="keywd">if</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbol &lt;> <span class="stri">"SELECT"</span> <span class="keywd">then</span>
        symbol := find_end_select(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: find_end_if (<span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    symbol := next_symbol(line);
    <span class="keywd">while</span> symbol &lt;> <span class="stri">"END"</span> <span class="op">and</span> symbol &lt;> <span class="stri">"ENDIF"</span> <span class="op">and</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> symbol = <span class="stri">"IF"</span> <span class="keywd">then</span>
        <span class="keywd">repeat</span>
          symbol := find_then(line);
          <span class="keywd">if</span> symbol = <span class="stri">"THEN"</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            <span class="keywd">if</span> symbol = <span class="stri">""</span>  <span class="op">or</span> symbol = <span class="stri">"'"</span> <span class="op">or</span> symbol = <span class="stri">"REM"</span> <span class="keywd">then</span>
              symbol := find_end_if(line);
              <span class="keywd">if</span> symbol = <span class="stri">"IF"</span> <span class="keywd">then</span>
                symbol := <span class="stri">""</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">else</span>
              symbol := <span class="stri">""</span>;
              line := <span class="stri">""</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">until</span> symbol &lt;> <span class="stri">"IF"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      symbol := next_symbol(line);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> symbol = <span class="stri">"END"</span> <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        symbol := get_symbol(line);
      <span class="keywd">until</span> symbol &lt;> <span class="stri">"END"</span>;
      <span class="keywd">if</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbol &lt;> <span class="stri">"IF"</span> <span class="keywd">then</span>
        symbol := find_end_if(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: find_else_elseif_or_end_if (<span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    symbol := next_symbol(line);
    <span class="keywd">while</span> symbol &lt;> <span class="stri">"ELSE"</span> <span class="op">and</span> symbol &lt;> <span class="stri">"ELSEIF"</span> <span class="op">and</span>
        symbol &lt;> <span class="stri">"END"</span> <span class="op">and</span> symbol &lt;> <span class="stri">"ENDIF"</span> <span class="op">and</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> symbol = <span class="stri">"IF"</span> <span class="keywd">then</span>
        <span class="keywd">repeat</span>
          symbol := find_then(line);
          <span class="keywd">if</span> symbol = <span class="stri">"THEN"</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            <span class="keywd">if</span> symbol = <span class="stri">""</span>  <span class="op">or</span> symbol = <span class="stri">"'"</span> <span class="op">or</span> symbol = <span class="stri">"REM"</span> <span class="keywd">then</span>
              symbol := find_end_if(line);
              <span class="keywd">if</span> symbol = <span class="stri">"IF"</span> <span class="keywd">then</span>
                symbol := <span class="stri">""</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">else</span>
              symbol := <span class="stri">""</span>;
              line := <span class="stri">""</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">until</span> symbol &lt;> <span class="stri">"IF"</span>;
      <span class="keywd">elsif</span> symbol = <span class="stri">"CASE"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      symbol := next_symbol(line);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> symbol = <span class="stri">"END"</span> <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        symbol := get_symbol(line);
      <span class="keywd">until</span> symbol &lt;> <span class="stri">"END"</span>;
      <span class="keywd">if</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbol &lt;> <span class="stri">"IF"</span> <span class="keywd">then</span>
        symbol := find_else_elseif_or_end_if(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: find_case_or_end_select (<span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    symbol := next_symbol(line);
    <span class="keywd">while</span> symbol &lt;> <span class="stri">"CASE"</span> <span class="op">and</span> symbol &lt;> <span class="stri">"END"</span> <span class="op">and</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> symbol = <span class="stri">"SELECT"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        <span class="keywd">if</span> symbol = <span class="stri">"CASE"</span> <span class="keywd">then</span>
          symbol := find_end_select(line);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> symbol = <span class="stri">"EXIT"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
      <span class="keywd">elsif</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      symbol := next_symbol(line);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> symbol = <span class="stri">"END"</span> <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        symbol := get_symbol(line);
      <span class="keywd">until</span> symbol &lt;> <span class="stri">"END"</span>;
      <span class="keywd">if</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbol &lt;> <span class="stri">"SELECT"</span> <span class="keywd">then</span>
        symbol := find_case_or_end_select(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_elseif_else_chain (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line,
    <span class="keywd">inout</span> <span class="type">boolean</span>: process_next) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">boolean</span>: leaveChain <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      symbol := find_else_elseif_or_end_if(line);
      <span class="keywd">if</span> symbol = <span class="stri">"ELSE"</span> <span class="keywd">then</span>
        <span class="keywd">if</span> upper(prg[file_line_number].line[.. 4]) &lt;> <span class="stri">"ELSE"</span> <span class="keywd">then</span>
          error_marker;
          writeln(err, <span class="stri">"ELSE NOT AT BEGINNING OF LINE"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        symbol := get_symbol(line);
        <span class="comment"># Execute the following statements until "ELSE", "ELSEIF" or "END" "IF".</span>
        line_marker;
        writeln(log, <span class="stri">"ELSE - EXECUTE STATEMENT BLOCK"</span>);
        <span class="keywd">if</span> symbol &lt;> <span class="stri">""</span> <span class="op">and</span> symbol &lt;> <span class="stri">"'"</span> <span class="op">and</span> symbol &lt;> <span class="stri">"REM"</span> <span class="keywd">then</span>
          error_marker;
          writeln(err, <span class="stri">"BLOCK STARTS DIRECTLY AFTER ELSE"</span>);
          process_next := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        leaveChain := TRUE;
      <span class="keywd">elsif</span> symbol = <span class="stri">"ELSEIF"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        num1 := exec_expr(symbol, line);
        <span class="keywd">if</span> num1 &lt;> 0.0 <span class="keywd">then</span>
          expect(<span class="stri">"THEN"</span>, symbol, line);
          <span class="comment"># Execute the following statements until "ELSE", "ELSEIF" or "END" "IF".</span>
          line_marker;
          writeln(log, <span class="stri">"ELSEIF "</span> &lt;&amp; num1 &lt;&amp; <span class="stri">" THEN - EXECUTE STATEMENT BLOCK"</span>);
          <span class="keywd">if</span> symbol &lt;> <span class="stri">""</span> <span class="op">and</span> symbol &lt;> <span class="stri">"'"</span> <span class="op">and</span> symbol &lt;> <span class="stri">"REM"</span> <span class="keywd">then</span>
            error_marker;
            writeln(err, <span class="stri">"BLOCK STARTS DIRECTLY AFTER THEN"</span>);
            process_next := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          leaveChain := TRUE;
        <span class="keywd">else</span>
          line_marker;
          writeln(log, <span class="stri">"ELSEIF "</span> &lt;&amp; num1 &lt;&amp; <span class="stri">" THEN - SKIP STATEMENT BLOCK"</span>);
          leaveChain := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> symbol = <span class="stri">"IF"</span> <span class="op">or</span> symbol = <span class="stri">"ENDIF"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        line_marker;
        writeln(log, <span class="stri">"END IF - NO \"THEN\" BLOCK WAS EXECUTED"</span>);
        leaveChain := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> leaveChain;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: advance_after_statement (<span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      length := length(line);
      symbol := get_symbol(line);
    <span class="keywd">until</span> endOfStatement(symbol);
    column := length(prg[file_line_number].line) - length + 1;
    line := prg[file_line_number].line[column ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_goto (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index2 <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    <span class="keywd">if</span> label_or_linenum(symbol) <span class="keywd">then</span>
      line_marker;
      writeln(log, <span class="stri">"GOTO "</span> &lt;&amp; symbol);
      goto_label_or_linenum(symbol);
      symbol := <span class="stri">""</span>;
      line := <span class="stri">""</span>;
    <span class="keywd">elsif</span> symbol <span class="op">in</span> multipleDefinedLabel <span class="keywd">then</span>
      error_marker;
      writeln(err, <span class="stri">"GOTO MULTIPLE DEFINED LABEL "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">"."</span>);
      symbol := get_symbol(line);
    <span class="keywd">else</span>
      index1 := round(exec_expr(symbol, line));
      expect(<span class="stri">"OF"</span>, symbol, line);
      <span class="keywd">if</span> index1 >= 1 <span class="keywd">then</span>
        index2 := 1;
        <span class="keywd">while</span> index2 &lt; index1 <span class="keywd">do</span>
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            incr(index2);
          <span class="keywd">else</span>
            index2 := succ(index1);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">if</span> index2 = index1 <span class="keywd">then</span>
          <span class="keywd">if</span> label_or_linenum(symbol) <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"GOTO "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">" OF "</span> &lt;&amp; symbol);
            goto_label_or_linenum(symbol);
            symbol := <span class="stri">""</span>;
            line := <span class="stri">""</span>;
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"UNDEFINED LABEL "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">" AFTER \"OF\"."</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          line_marker;
          writeln(log, <span class="stri">"GOTO "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">" OF NEXT STATEMENT"</span>);
          <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        line_marker;
        writeln(log, <span class="stri">"GOTO "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">" OF NEXT STATEMENT"</span>);
        <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
          symbol := get_symbol(line);
        <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_gosub (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index2 <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    <span class="keywd">if</span> label_or_linenum(symbol) <span class="keywd">then</span>
      line_marker;
      writeln(log, <span class="stri">"GOSUB "</span> &lt;&amp; symbol);
      set_return_position(line);
      goto_label_or_linenum(symbol);
      set_sub_entry_position;
      symbol := <span class="stri">""</span>;
      line := <span class="stri">""</span>;
    <span class="keywd">elsif</span> symbol <span class="op">in</span> multipleDefinedLabel <span class="keywd">then</span>
      error_marker;
      writeln(err, <span class="stri">"GOSUB TO MULTIPLE DEFINED LABEL "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">"."</span>);
      symbol := get_symbol(line);
    <span class="keywd">else</span>
      index1 := round(exec_expr(symbol, line));
      expect(<span class="stri">"OF"</span>, symbol, line);
      <span class="keywd">if</span> index1 >= 1 <span class="keywd">then</span>
        index2 := 1;
        <span class="keywd">while</span> index2 &lt; index1 <span class="keywd">do</span>
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            incr(index2);
          <span class="keywd">else</span>
            index2 := succ(index1);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">if</span> index2 = index1 <span class="keywd">then</span>
          <span class="keywd">if</span> label_or_linenum(symbol) <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"GOSUB "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">" OF "</span> &lt;&amp; symbol);
            advance_after_statement(line);
            set_return_position(line);
            goto_label_or_linenum(symbol);
            set_sub_entry_position;
            symbol := <span class="stri">""</span>;
            line := <span class="stri">""</span>;
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"UNDEFINED LABEL "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">" AFTER \"OF\"."</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          line_marker;
          writeln(log, <span class="stri">"GOSUB "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">" OF NEXT STATEMENT"</span>);
          <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        line_marker;
        writeln(log, <span class="stri">"GOSUB "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">" OF NEXT STATEMENT"</span>);
        <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
          symbol := get_symbol(line);
        <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_let (<span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: variable_name,
    <span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isStringVar(variable_name) <span class="keywd">then</span>
      append_index(variable_name, symbol, line);
      <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        param1 := exec_str_expr(symbol, line, unused_name);
        setStringVar(variable_name, param1);
        line_marker;
        writeln(log, <span class="stri">"LET "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">"="</span> &lt;&amp; literal(param1));
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"\"=\" EXPECTED AFTER "</span> &lt;&amp; literal(variable_name) &lt;&amp;
            <span class="stri">" - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> isNumericVar(variable_name) <span class="keywd">then</span>
      append_index(variable_name, symbol, line);
      <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        num1 := exec_expr(symbol, line);
        setNumericVar(variable_name, num1);
        line_marker;
        writeln(log, <span class="stri">"LET "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">"="</span> &lt;&amp; num1);
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"\"=\" EXPECTED AFTER "</span> &lt;&amp; literal(variable_name) &lt;&amp;
            <span class="stri">" - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"VARIABLE EXPECTED - FOUND "</span> &lt;&amp; literal(variable_name) &lt;&amp; <span class="stri">"."</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_mid_statement (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: var_value <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: position <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: requested_length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: with_length <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    expect(<span class="stri">"("</span>, symbol, line);
    <span class="keywd">if</span> isStringVar(symbol) <span class="keywd">then</span>
      variable_name := get_name(symbol, line);
      expect(<span class="stri">","</span>, symbol, line);
      position := round(exec_expr(symbol, line));
      <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
        with_length := TRUE;
        symbol := get_symbol(line);
        requested_length := round(exec_expr(symbol, line));
        length := requested_length;
        expect(<span class="stri">")"</span>, symbol, line);
        expect(<span class="stri">"="</span>, symbol, line);
        stri := exec_str_expr(symbol, line, unused_name);
        <span class="keywd">if</span> length > length(stri) <span class="keywd">then</span>
          length := length(stri);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        expect(<span class="stri">")"</span>, symbol, line);
        expect(<span class="stri">"="</span>, symbol, line);
        stri := exec_str_expr(symbol, line, unused_name);
        length := length(stri);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      var_value := getStringVar(variable_name);
      <span class="keywd">if</span> position &lt;= length(var_value) <span class="keywd">then</span>
        <span class="keywd">if</span> succ(length(var_value) - position) &lt; length <span class="keywd">then</span>
          length := succ(length(var_value) - position);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        var_value := var_value[ .. pred(position)] &amp; stri[ .. length] &amp;
            var_value[position + length ..];
        setStringVar(variable_name, var_value);
        write(log, <span class="stri">"MID$("</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">", "</span> &lt;&amp; position);
        <span class="keywd">if</span> with_length <span class="keywd">then</span>
          write(log, <span class="stri">", "</span> &lt;&amp; requested_length);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        writeln(log, <span class="stri">")="</span> &lt;&amp; literal(stri));
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"MID$ POSITION "</span> &lt;&amp; position &lt;&amp;
            <span class="stri">" LARGER THAN LENGTH OF "</span> &lt;&amp; literal(var_value));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"STRING VARIABLE EXPECTED - FOUND "</span> &lt;&amp; literal(symbol));
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_next_decision (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line,
    <span class="keywd">val</span> <span class="type">string</span>: variable_name, <span class="op">in</span> <span class="type">string</span>: nameList) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(forLoop) >= 1 <span class="op">and</span> variable_name = forLoop[1].varName <span class="keywd">then</span>
      num1 := getNumericVar(variable_name);
      <span class="keywd">if</span> (forLoop[1].stepValue > 0.0 <span class="op">and</span> num1 + forLoop[1].stepValue &lt;= forLoop[1].endValue) <span class="op">or</span>
         (forLoop[1].stepValue &lt; 0.0 <span class="op">and</span> num1 + forLoop[1].stepValue >= forLoop[1].endValue) <span class="keywd">then</span>
        line_marker;
        setNumericVar(variable_name, num1 + forLoop[1].stepValue);
        file_line_number := forLoop[1].bodyLine;
        statement_label := prg[file_line_number].linenum;
        line := prg[file_line_number].line[forLoop[1].bodyColumn .. ];
        <span class="keywd">if</span> line &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          symbol := <span class="stri">":"</span>;
        <span class="keywd">else</span>
          symbol := <span class="stri">""</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        write(log, <span class="stri">"NEXT "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">" = "</span> &lt;&amp; num1 + forLoop[1].stepValue &lt;&amp;
            <span class="stri">" CONTINUE THE \"FOR "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">"\" LOOP AT LINE "</span>);
        line_marker;
        writeln(log);
      <span class="keywd">else</span>
        line_marker;
        writeln(log, <span class="stri">"NEXT "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">" = "</span> &lt;&amp; num1 &lt;&amp; <span class="stri">" END FOR"</span>);
        forLoop := forLoop[2 .. ];
        <span class="keywd">if</span> length(forLoop) >= 1 <span class="op">and</span> forLoop[1].varName &lt;> variable_name <span class="op">and</span>
            nameInList(forLoop[1].varName, nameList) <span class="keywd">then</span>
          line_marker;
          write(log, <span class="stri">"THE \"FOR "</span> &lt;&amp; forLoop[1].varName &lt;&amp;
              <span class="stri">"\" LOOP AT LINE "</span>);
          line_marker(forLoop[1].bodyLine);
          writeln(log, <span class="stri">" IS ALSO HANDLED WITH THIS NEXT STATEMENT"</span>);
          exec_next_decision(symbol, line, forLoop[1].varName,
              removeNameFromList(variable_name, nameList));
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"\"NEXT "</span> &lt;&amp; forLoop[1].varName &lt;&amp;
          <span class="stri">"\" EXPECTED - FOUND \"NEXT "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">"\""</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_if (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line,
    <span class="keywd">inout</span> <span class="type">boolean</span>: process_next) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    num1 := exec_expr(symbol, line);
    <span class="keywd">if</span> startsWith(symbol, <span class="stri">"THEN"</span>) <span class="keywd">then</span>
      line := symbol[5 ..] &amp; line;
      symbol := <span class="stri">"THEN"</span>;
    <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"GOTO"</span>) <span class="keywd">then</span>
      line := symbol[5 ..] &amp; line;
      symbol := <span class="stri">"GOTO"</span>;
    <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"GOSUB"</span>) <span class="keywd">then</span>
      line := symbol[6 ..] &amp; line;
      symbol := <span class="stri">"GOSUB"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> num1 &lt;> 0.0 <span class="keywd">then</span>
      <span class="keywd">if</span> symbol = <span class="stri">"THEN"</span> <span class="keywd">then</span>
        line_marker;
        write(log, <span class="stri">"IF "</span> &lt;&amp; num1);
        symbol := get_symbol(line);
        <span class="keywd">if</span> symbol = <span class="stri">""</span> <span class="op">or</span> symbol = <span class="stri">"'"</span> <span class="op">or</span> symbol = <span class="stri">"REM"</span> <span class="keywd">then</span>
          <span class="comment"># Execute the following statements until "ELSE", "ELSEIF" or "END" "IF".</span>
          writeln(log, <span class="stri">" THEN - EXECUTE STATEMENT BLOCK"</span>);
        <span class="keywd">elsif</span> label_or_linenum(symbol) <span class="keywd">then</span>
          param1 := symbol;
          symbol := get_symbol(line);
          <span class="comment"># A label and a variable can share the same name</span>
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            <span class="comment"># A let statement is recognized: Write log and exec the let statement.</span>
            writeln(log, <span class="stri">" THEN - EXECUTE STATEMENTS IN LINE UNTIL \"ELSE\""</span>);
            exec_let(param1, symbol, line);
          <span class="keywd">else</span>
            writeln(log, <span class="stri">" THEN "</span> &lt;&amp; param1 &lt;&amp; <span class="stri">" - GOTO LINE"</span>);
            goto_label_or_linenum(param1);
            symbol := <span class="stri">""</span>;
            line := <span class="stri">""</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          writeln(log, <span class="stri">" THEN - EXECUTE STATEMENTS IN LINE UNTIL \"ELSE\""</span>);
          process_next := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> symbol = <span class="stri">"GOTO"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        line_marker;
        writeln(log, <span class="stri">"IF "</span> &lt;&amp; num1 &lt;&amp; <span class="stri">" GOTO "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">" - GOTO LINE"</span>);
        <span class="keywd">if</span> label_or_linenum(symbol) <span class="keywd">then</span>
          goto_label_or_linenum(symbol);
          symbol := <span class="stri">""</span>;
          line := <span class="stri">""</span>;
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"UNDEFINED LABEL "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">" AFTER \"GOTO\"."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> symbol = <span class="stri">"GOSUB"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        line_marker;
        writeln(log, <span class="stri">"IF "</span> &lt;&amp; num1 &lt;&amp; <span class="stri">" GOSUB "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">" - GOSUB LINE"</span>);
        <span class="keywd">if</span> label_or_linenum(symbol) <span class="keywd">then</span>
          set_return_position(line);
          goto_label_or_linenum(symbol);
          set_sub_entry_position;
          symbol := <span class="stri">""</span>;
          line := <span class="stri">""</span>;
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"UNDEFINED LABEL "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">" AFTER \"GOSUB\"."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        error_expect3(<span class="stri">"THEN"</span>, <span class="stri">"GOTO"</span>, <span class="stri">"GOSUB"</span>, symbol);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      <span class="keywd">if</span> symbol = <span class="stri">"THEN"</span> <span class="op">or</span> symbol = <span class="stri">"GOTO"</span> <span class="op">or</span> symbol = <span class="stri">"GOSUB"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
      <span class="keywd">else</span>
        error_expect3(<span class="stri">"THEN"</span>, <span class="stri">"GOTO"</span>, <span class="stri">"GOSUB"</span>, symbol);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      line_marker;
      write(log, <span class="stri">"IF "</span> &lt;&amp; num1);
      <span class="keywd">if</span> symbol = <span class="stri">""</span> <span class="op">or</span> symbol = <span class="stri">"'"</span> <span class="op">or</span> symbol = <span class="stri">"REM"</span> <span class="keywd">then</span>
        writeln(log, <span class="stri">" THEN - SKIP STATEMENT BLOCK"</span>);
        exec_elseif_else_chain(symbol, line, process_next);
      <span class="keywd">elsif</span> label_or_linenum(symbol) <span class="keywd">then</span>
        writeln(log, <span class="stri">" THEN "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">" - SKIP LABEL"</span>);
        symbol := get_symbol(line);
        <span class="keywd">if</span> startsWith(symbol, <span class="stri">"ELSE"</span>) <span class="op">and</span> <span class="op">not</span> is_let_statement(line) <span class="keywd">then</span>
          line := symbol[5 ..] &amp; line;
          symbol := <span class="stri">"ELSE"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> symbol = <span class="stri">"ELSE"</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          <span class="keywd">if</span> label_or_linenum(symbol) <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"ELSE "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">" - GOTO LINE"</span>);
            goto_label_or_linenum(symbol);
            symbol := <span class="stri">""</span>;
            line := <span class="stri">""</span>;
          <span class="keywd">else</span>
            line_marker;
            writeln(log, <span class="stri">"ELSE - EXECUTE STATEMENTS IN LINE"</span>);
            process_next := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          <span class="keywd">if</span> startsWith(symbol, <span class="stri">"ELSE"</span>) <span class="op">and</span> <span class="op">not</span> is_let_statement(line) <span class="keywd">then</span>
            line := symbol[5 ..] &amp; line;
            symbol := <span class="stri">"ELSE"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> symbol = <span class="stri">"ELSE"</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            <span class="keywd">if</span> label_or_linenum(symbol) <span class="keywd">then</span>
              line_marker;
              writeln(log, <span class="stri">"ELSE "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">" - GOTO LINE"</span>);
              goto_label_or_linenum(symbol);
              symbol := <span class="stri">""</span>;
              line := <span class="stri">""</span>;
            <span class="keywd">else</span>
              line_marker;
              writeln(log, <span class="stri">"ELSE - EXECUTE STATEMENTS IN LINE"</span>);
              process_next := TRUE;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            line_marker;
            writeln(log, <span class="stri">"NO ELSE - CONTINUE AFTER THE LABEL"</span>);
            process_next := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          line_marker;
          writeln(log, <span class="stri">"NO ELSE - CONTINUE AT NEXT LINE"</span>);
          symbol := <span class="stri">""</span>;
          line := <span class="stri">""</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        writeln(log, <span class="stri">" THEN - SKIP STATEMENTS IN LINE UNTIL \"ELSE\""</span>);
        find_else(symbol, line);
        <span class="keywd">if</span> symbol = <span class="stri">"ELSE"</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          <span class="keywd">if</span> label_or_linenum(symbol) <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"ELSE "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">" - GOTO LINE"</span>);
            goto_label_or_linenum(symbol);
            symbol := <span class="stri">""</span>;
            line := <span class="stri">""</span>;
          <span class="keywd">else</span>
            line_marker;
            writeln(log, <span class="stri">"ELSE - EXECUTE STATEMENTS IN LINE"</span>);
            process_next := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          line_marker;
          writeln(log, <span class="stri">"NO ELSE - CONTINUE AT NEXT LINE"</span>);
          symbol := <span class="stri">""</span>;
          line := <span class="stri">""</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_else (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    line_marker;
    writeln(log, <span class="stri">"ELSE - THE \"THEN\" BLOCK BEFORE WAS EXECUTED"</span>);
    <span class="keywd">if</span> upper(prg[file_line_number].line[.. 4]) = <span class="stri">"ELSE"</span> <span class="keywd">then</span>
      symbol := find_end_if(line);
      <span class="keywd">if</span> symbol = <span class="stri">"IF"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        line_marker;
        writeln(log, <span class="stri">"END IF"</span>);
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"ELSE - MISSING \"END IF\"."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      line := <span class="stri">""</span>;
      symbol := <span class="stri">""</span>;
      line_marker;
      writeln(log, <span class="stri">"SKIP ELSE PART - CONTINUE AT NEXT LINE"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_for (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: num2 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: num3 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">integer</span>: index1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: label <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    variable_name := get_symbol(line);
    symbol := get_symbol(line);
    expect(<span class="stri">"="</span>, symbol, line);
    num1 := exec_expr(symbol, line);
    setNumericVar(variable_name, num1);
    <span class="keywd">if</span> symbol = <span class="stri">"TO"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
    <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"TO"</span>) <span class="keywd">then</span>
      line := symbol[3 ..] &amp; line;
      symbol := get_symbol(line);
    <span class="keywd">else</span>
      error_expect(<span class="stri">"TO"</span>, symbol);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    num2 := exec_expr(symbol, line);
    <span class="keywd">if</span> symbol = <span class="stri">"STEP"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      num3 := exec_expr(symbol, line);
    <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"STEP"</span>) <span class="keywd">then</span>
      line := symbol[5 ..] &amp; line;
      symbol := get_symbol(line);
      num3 := exec_expr(symbol, line);
    <span class="keywd">else</span>
      num3 := 1.0;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> (num3 > 0.0 <span class="op">and</span> num1 &lt;= num2) <span class="op">or</span>
       (num3 &lt; 0.0 <span class="op">and</span> num1 >= num2) <span class="keywd">then</span>
      <span class="keywd">if</span> symbol = <span class="stri">"'"</span> <span class="op">or</span> symbol = <span class="stri">"REM"</span> <span class="keywd">then</span>
        index1 := succ(length(prg[file_line_number].line));
      <span class="keywd">else</span>
        index1 := length(prg[file_line_number].line) - length(line) + 1;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      forLoop := [] (forLoopDescrType.value) &amp; forLoop;
      forLoop[1].varName := variable_name;
      forLoop[1].endValue := num2;
      forLoop[1].stepValue := num3;
      forLoop[1].bodyLine := file_line_number;
      forLoop[1].bodyColumn := index1;
      line_marker;
      writeln(log, <span class="stri">"FOR "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">"="</span> &lt;&amp; num1 &lt;&amp;
          <span class="stri">" TO "</span> &lt;&amp; num2 &lt;&amp; <span class="stri">" STEP "</span> &lt;&amp; num3);
    <span class="keywd">else</span>
      line_marker;
      writeln(log, <span class="stri">"EMPTY FOR "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">"="</span> &lt;&amp; num1 &lt;&amp;
          <span class="stri">" TO "</span> &lt;&amp; num2 &lt;&amp; <span class="stri">" STEP "</span> &lt;&amp; num3);
      label := statement_label;
      <span class="keywd">if</span> <span class="op">not</span> find_next(symbol, line, variable_name) <span class="keywd">then</span>
        error_marker(label);
        writeln(err, <span class="stri">"NO CORRESPONDING \"NEXT\" OR \"NEXT "</span> &lt;&amp; variable_name &lt;&amp;
            <span class="stri">"\" FOUND FOR \"FOR "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">"\""</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_next (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: index1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index2 <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(forLoop) >= 1 <span class="keywd">then</span>
      symbol := get_symbol(line);
      <span class="keywd">if</span> endOfStatement(symbol) <span class="keywd">then</span>
        param1 := <span class="stri">""</span>;
        variable_name := forLoop[1].varName;
      <span class="keywd">else</span>
        param1 := getNameList(symbol, line);
        <span class="keywd">if</span> nameInList(forLoop[1].varName, param1) <span class="keywd">then</span>
          variable_name := forLoop[1].varName;
        <span class="keywd">else</span>
          index1 := 2;
          <span class="keywd">while</span> index1 &lt;= length(forLoop) <span class="op">and</span> <span class="op">not</span> nameInList(forLoop[index1].varName, param1) <span class="keywd">do</span>
            incr(index1)
          <span class="keywd">end</span> <span class="keywd">while</span>;
          <span class="keywd">if</span> index1 &lt;= length(forLoop) <span class="op">and</span> nameInList(forLoop[index1].varName, param1) <span class="keywd">then</span>
            <span class="keywd">for</span> index2 <span class="keywd">range</span> 1 <span class="keywd">to</span> pred(index1) <span class="keywd">do</span>
              line_marker;
              write(log, <span class="stri">"THE \"FOR "</span> &lt;&amp; forLoop[index2].varName &lt;&amp; <span class="stri">"\" LOOP AT LINE "</span>);
              line_marker(forLoop[index2].bodyLine);
              writeln(log, <span class="stri">" SEEMS TO HAVE BEEN LEFT"</span>);
            <span class="keywd">end</span> <span class="keywd">for</span>;
            forLoop := forLoop[index1 .. ];
            variable_name := forLoop[1].varName;
          <span class="keywd">elsif</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            error_code := 1; <span class="comment"># NEXT without FOR</span>
            line_marker;
            writeln(log, error_code &lt;&amp; <span class="stri">" NEXT WITHOUT FOR"</span> &lt;&amp;
                <span class="stri">" - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
            goto_on_error(on_error_label, line);
            symbol := <span class="stri">""</span>;
            line := <span class="stri">""</span>;
            variable_name := <span class="stri">""</span>;
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"NEXT "</span> &lt;&amp; param1 &lt;&amp; <span class="stri">" - NO MATCHING FOR FOUND"</span>);
            <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
              symbol := get_symbol(line);
            <span class="keywd">end</span> <span class="keywd">while</span>;
            variable_name := param1;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      exec_next_decision(symbol, line, variable_name, param1);
    <span class="keywd">elsif</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      error_code := 1; <span class="comment"># NEXT without FOR</span>
      line_marker;
      writeln(log, error_code &lt;&amp; <span class="stri">" NEXT "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">" WITHOUT FOR"</span> &lt;&amp;
          <span class="stri">" - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
      goto_on_error(on_error_label, line);
      symbol := <span class="stri">""</span>;
      line := <span class="stri">""</span>;
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"NEXT "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">" WITHOUT FOR"</span>);
      <span class="keywd">repeat</span>
        symbol := get_symbol(line);
      <span class="keywd">until</span> endOfStatement(symbol);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_on (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: index1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: keywordPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    <span class="keywd">if</span> symbol = <span class="stri">"ERROR"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      expect(<span class="stri">"GOTO"</span>, symbol, line);
      <span class="keywd">if</span> symbol = <span class="stri">"0"</span> <span class="keywd">then</span>
        on_error_label := <span class="stri">""</span>;
        line_marker;
        writeln(log, <span class="stri">"ON ERROR GOTO 0 - DISABLE ERROR HANDLING"</span>);
        symbol := get_symbol(line);
      <span class="keywd">elsif</span> label_or_linenum(symbol) <span class="keywd">then</span>
        on_error_label := symbol;
        line_marker;
        writeln(log, <span class="stri">"ON ERROR GOTO "</span> &lt;&amp; literal(symbol) &lt;&amp;
            <span class="stri">" LINE: "</span> &lt;&amp; label[symbol]);
        symbol := get_symbol(line);
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"ON ERROR GOTO NEEDS A LABEL NOT "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> symbol = <span class="stri">"KEY"</span> <span class="keywd">then</span>
      line_marker;
      writeln(log, <span class="stri">"**ON KEY "</span> &lt;&amp; line);
      <span class="keywd">repeat</span>
        symbol := get_symbol(line);
      <span class="keywd">until</span> endOfStatement(symbol);
    <span class="keywd">elsif</span> symbol = <span class="stri">"TIMER"</span> <span class="keywd">then</span>
      line_marker;
      writeln(log, <span class="stri">"**ON TIMER "</span> &lt;&amp; line);
      <span class="keywd">repeat</span>
        symbol := get_symbol(line);
      <span class="keywd">until</span> endOfStatement(symbol);
    <span class="keywd">else</span>
      <span class="keywd">if</span> symbol <span class="op">not</span> <span class="op">in</span> numeric_var <span class="op">and</span> symbol <span class="op">not</span> <span class="op">in</span> def_fn_list <span class="op">and</span>
          symbol <span class="op">not</span> <span class="op">in</span> subfunction <span class="keywd">then</span>
        keywordPos := pos(symbol, <span class="stri">"GOTO"</span>);
        <span class="keywd">if</span> keywordPos &lt;> 0 <span class="keywd">then</span>
          line := symbol[keywordPos ..] &amp; line;
          symbol := symbol[.. pred(keywordPos)];
        <span class="keywd">else</span>
          keywordPos := pos(symbol, <span class="stri">"GOSUB"</span>);
          <span class="keywd">if</span> keywordPos &lt;> 0 <span class="keywd">then</span>
            line := symbol[keywordPos ..] &amp; line;
            symbol := symbol[.. pred(keywordPos)];
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      index1 := round(exec_expr(symbol, line));
      <span class="keywd">if</span> startsWith(symbol, <span class="stri">"GOTO"</span>) <span class="keywd">then</span>
        line := symbol[5 ..] &amp; line;
        symbol := <span class="stri">"GOTO"</span>;
      <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"GOSUB"</span>) <span class="keywd">then</span>
        line := symbol[6 ..] &amp; line;
        symbol := <span class="stri">"GOSUB"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbol = <span class="stri">"GOTO"</span> <span class="op">or</span> symbol = <span class="stri">"GOSUB"</span> <span class="keywd">then</span>
        param1 := symbol;
        symbol := get_symbol(line);
        <span class="keywd">if</span> index1 >= 1 <span class="keywd">then</span>
          index2 := 1;
          <span class="keywd">while</span> index2 &lt; index1 <span class="keywd">do</span>
            symbol := get_symbol(line);
            <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
              incr(index2);
            <span class="keywd">else</span>
              index2 := succ(index1);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">while</span>;
          <span class="keywd">if</span> index2 = index1 <span class="keywd">then</span>
            <span class="keywd">if</span> label_or_linenum(symbol) <span class="keywd">then</span>
              line_marker;
              writeln(log, <span class="stri">"ON "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">" "</span> &lt;&amp; param1 &lt;&amp; <span class="stri">" "</span> &lt;&amp; symbol);
              <span class="keywd">if</span> param1 = <span class="stri">"GOSUB"</span> <span class="keywd">then</span>
                advance_after_statement(line);
                set_return_position(line);
                goto_label_or_linenum(symbol);
                set_sub_entry_position;
              <span class="keywd">else</span>
                goto_label_or_linenum(symbol);
              <span class="keywd">end</span> <span class="keywd">if</span>;
              symbol := <span class="stri">""</span>;
              line := <span class="stri">""</span>;
            <span class="keywd">else</span>
              error_marker;
              writeln(err, <span class="stri">"UNDEFINED LABEL "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">" AFTER \""</span> &lt;&amp;
                  <span class="stri">"ON "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">" "</span> &lt;&amp; param1 &lt;&amp; <span class="stri">"\"."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            line_marker;
            writeln(log, <span class="stri">"ON "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">" GOTO NEXT STATEMENT"</span>);
            <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
              symbol := get_symbol(line);
            <span class="keywd">end</span> <span class="keywd">while</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          line_marker;
          writeln(log, <span class="stri">"ON "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">" GOTO NEXT STATEMENT"</span>);
          <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        error_expect2(<span class="stri">"GOTO"</span>, <span class="stri">"GOSUB"</span>, symbol);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_do (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">string</span>: headLabel <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: headLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: headColumn <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    headLine := file_line_number;
    headColumn := length(prg[file_line_number].line) - length(line) + 1;
    symbol := get_symbol(line);
    <span class="keywd">if</span> symbol = <span class="stri">"WHILE"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      num1 := exec_expr(symbol, line);
      line_marker;
      writeln(log, <span class="stri">"DO WHILE "</span> &lt;&amp; num1);
      <span class="keywd">if</span> num1 &lt;> 0.0 <span class="keywd">then</span>
        doLoop := [] (doLoopDescrType.value) &amp; doLoop;
        doLoop[1].headLine := headLine;
        doLoop[1].headColumn := headColumn;
      <span class="keywd">else</span>
        line_marker;
        writeln(log, <span class="stri">"EMPTY \"DO WHILE\""</span>);
        <span class="keywd">if</span> symbol &lt;> <span class="stri">"LOOP"</span> <span class="keywd">then</span>
          headLabel := statement_label;
          symbol := find_loop(line);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> symbol = <span class="stri">"LOOP"</span> <span class="keywd">then</span>
          <span class="keywd">repeat</span>
            symbol := get_symbol(line);
          <span class="keywd">until</span> endOfStatement(symbol);
          line_marker;
          writeln(log, <span class="stri">"CONTINUE AFTER \"DO WHILE ... LOOP\""</span>);
        <span class="keywd">else</span>
          error_marker(headLabel);
          writeln(err, <span class="stri">"NO CORRESPONDING \"LOOP\" FOUND FOR \"DO WHILE\""</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> symbol = <span class="stri">"UNTIL"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      num1 := exec_expr(symbol, line);
      line_marker;
      writeln(log, <span class="stri">"DO UNTIL "</span> &lt;&amp; num1);
      <span class="keywd">if</span> num1 = 0.0 <span class="keywd">then</span>
        doLoop := [] (doLoopDescrType.value) &amp; doLoop;
        doLoop[1].headLine := headLine;
        doLoop[1].headColumn := headColumn;
      <span class="keywd">else</span>
        line_marker;
        writeln(log, <span class="stri">"EMPTY \"DO UNTIL\""</span>);
        <span class="keywd">if</span> symbol &lt;> <span class="stri">"LOOP"</span> <span class="keywd">then</span>
          headLabel := statement_label;
          symbol := find_loop(line);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> symbol = <span class="stri">"LOOP"</span> <span class="keywd">then</span>
          <span class="keywd">repeat</span>
            symbol := get_symbol(line);
          <span class="keywd">until</span> endOfStatement(symbol);
          line_marker;
          writeln(log, <span class="stri">"CONTINUE AFTER \"DO UNTIL ... LOOP\n"</span>);
        <span class="keywd">else</span>
          error_marker(headLabel);
          writeln(err, <span class="stri">"NO CORRESPONDING \"LOOP\" FOUND FOR \"DO UNTIL\""</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
      exec_let(<span class="stri">"DO"</span>, symbol, line);
    <span class="keywd">else</span>
      line_marker;
      writeln(log, <span class="stri">"DO ... LOOP"</span>);
      doLoop := [] (doLoopDescrType.value) &amp; doLoop;
      doLoop[1].headLine := headLine;
      doLoop[1].headColumn := headColumn;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_loop (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param2 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">integer</span>: headLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: headColumn <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: tailLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: tailColumn <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    tailLine := file_line_number;
    tailColumn := length(prg[file_line_number].line) - length(line) + 1;
    <span class="keywd">if</span> doLoopHeaderPresent(tailLine, tailColumn, headLine, headColumn) <span class="keywd">then</span>
      <span class="keywd">if</span> length(doLoop) >= 1 <span class="keywd">then</span>
        <span class="keywd">if</span> doLoop[1].headLine &lt;> headLine <span class="op">or</span>
            doLoop[1].headColumn &lt;> headColumn <span class="keywd">then</span>
          error_marker;
          writeln(err, <span class="stri">"LOOP - \"DO\" LOOP ENTERED BY A GOTO"</span>);
          doLoop := [] (doLoopDescrType.value) &amp; doLoop;
          doLoop[1].headLine := headLine;
          doLoop[1].headColumn := headColumn;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"LOOP - \"DO\" LOOP ENTERED BY A GOTO"</span>);
        doLoop := [] (doLoopDescrType.value) &amp; doLoop;
        doLoop[1].headLine := headLine;
        doLoop[1].headColumn := headColumn;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"LOOP - NO STATICALLY CORRESPONDING \"DO\" STATEMENT FOUND"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    symbol := get_symbol(line);
    <span class="keywd">if</span> symbol = <span class="stri">"WHILE"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      <span class="keywd">if</span> length(doLoop) >= 1 <span class="keywd">then</span>
        num1 := exec_expr(symbol, line);
        <span class="keywd">if</span> num1 &lt;> 0.0 <span class="keywd">then</span>
          line_marker;
          file_line_number := doLoop[1].headLine;
          statement_label := prg[file_line_number].linenum;
          line := prg[file_line_number].line[doLoop[1].headColumn .. ];
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol &lt;> <span class="stri">"WHILE"</span> <span class="op">and</span> symbol &lt;> <span class="stri">"UNTIL"</span> <span class="keywd">then</span>
            writeln(log, <span class="stri">"LOOP - CONTINUE \"DO ... LOOP WHILE\""</span>);
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"ILLEGAL - \"DO "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">" ... LOOP WHILE\""</span>);
            <span class="keywd">repeat</span>
              symbol := get_symbol(line);
            <span class="keywd">until</span> endOfStatement(symbol);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          doLoop := doLoop[2 .. ];
          line_marker;
          writeln(log, <span class="stri">"LOOP - LEAVE \"DO ... LOOP WHILE\""</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"UNEXPECTED \"LOOP WHILE\""</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> symbol = <span class="stri">"UNTIL"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      <span class="keywd">if</span> length(doLoop) >= 1 <span class="keywd">then</span>
        num1 := exec_expr(symbol, line);
        <span class="keywd">if</span> num1 = 0.0 <span class="keywd">then</span>
          line_marker;
          file_line_number := doLoop[1].headLine;
          statement_label := prg[file_line_number].linenum;
          line := prg[file_line_number].line[doLoop[1].headColumn .. ];
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol &lt;> <span class="stri">"WHILE"</span> <span class="op">and</span> symbol &lt;> <span class="stri">"UNTIL"</span> <span class="keywd">then</span>
            writeln(log, <span class="stri">"LOOP - CONTINUE \"DO ... LOOP UNTIL\""</span>);
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"ILLEGAL - \"DO "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">" .. LOOP UNTIL\""</span>);
            <span class="keywd">repeat</span>
              symbol := get_symbol(line);
            <span class="keywd">until</span> endOfStatement(symbol);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          doLoop := doLoop[2 .. ];
          line_marker;
          writeln(log, <span class="stri">"LOOP - LEAVE \"DO ... LOOP UNTIL\""</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"UNEXPECTED \"LOOP UNTIL\""</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      <span class="keywd">if</span> length(doLoop) >= 1 <span class="keywd">then</span>
        headLine := doLoop[1].headLine;
        param2 := prg[headLine].line[doLoop[1].headColumn .. ];
        param1 := get_symbol(param2);
        <span class="keywd">if</span> param1 = <span class="stri">"WHILE"</span> <span class="keywd">then</span>
          param1 := get_symbol(param2);
          num1 := exec_expr(param1, param2);
          <span class="keywd">if</span> num1 &lt;> 0.0 <span class="keywd">then</span>
            line_marker;
            file_line_number := headLine;
            statement_label := prg[file_line_number].linenum;
            symbol := param1;
            line := param2;
            writeln(log, <span class="stri">"LOOP - CONTINUE \"DO WHILE ... LOOP\""</span>);
          <span class="keywd">else</span>
            doLoop := doLoop[2 .. ];
            line_marker;
            writeln(log, <span class="stri">"LOOP - LEAVE \"DO WHILE ... LOOP\""</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> param1 = <span class="stri">"UNTIL"</span> <span class="keywd">then</span>
          param1 := get_symbol(param2);
          num1 := exec_expr(param1, param2);
          <span class="keywd">if</span> num1 = 0.0 <span class="keywd">then</span>
            line_marker;
            file_line_number := headLine;
            statement_label := prg[file_line_number].linenum;
            symbol := param1;
            line := param2;
            writeln(log, <span class="stri">"LOOP - CONTINUE \"DO UNTIL ... LOOP\""</span>);
          <span class="keywd">else</span>
            doLoop := doLoop[2 .. ];
            line_marker;
            writeln(log, <span class="stri">"LOOP - LEAVE \"DO UNTIL ... LOOP\""</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          line_marker;
          file_line_number := headLine;
          statement_label := prg[file_line_number].linenum;
          symbol := param1;
          line := param2;
          writeln(log, <span class="stri">"LOOP - CONTINUE \"DO ... LOOP\""</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"UNEXPECTED \"LOOP UNTIL\""</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_select (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param2 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param3 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: num2 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: num3 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">boolean</span>: found <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: end_select <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: end_case <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">string</span>: comparison <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    <span class="keywd">if</span> symbol = <span class="stri">"CASE"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      <span class="keywd">if</span> isStringExpr(symbol) <span class="keywd">then</span>
        param1 := exec_str_expr(symbol, line, unused_name);
        line_marker;
        writeln(log, <span class="stri">"SELECT CASE "</span> &lt;&amp; literal(param1));
        <span class="keywd">repeat</span>
          <span class="keywd">if</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
            line := <span class="stri">""</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          symbol := find_case_or_end_select(line);
          <span class="keywd">if</span> symbol = <span class="stri">"CASE"</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            <span class="keywd">if</span> symbol = <span class="stri">"ELSE"</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
              found := TRUE;
              line_marker;
              writeln(log, <span class="stri">"CASE ELSE - FOUND"</span>);
            <span class="keywd">else</span>
              end_case := FALSE;
              <span class="keywd">repeat</span>
                <span class="keywd">if</span> symbol = <span class="stri">"IS"</span> <span class="keywd">then</span>
                  symbol := get_symbol(line);
                <span class="keywd">end</span> <span class="keywd">if</span>;
                <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"&lt;>"</span> <span class="op">or</span>
                    symbol = <span class="stri">"&lt;"</span> <span class="op">or</span> symbol = <span class="stri">">"</span> <span class="op">or</span>
                    symbol = <span class="stri">"&lt;="</span> <span class="op">or</span> symbol = <span class="stri">">="</span> <span class="keywd">then</span>
                  comparison := symbol;
                  symbol := get_symbol(line);
                <span class="keywd">else</span>
                  comparison := <span class="stri">"="</span>;
                <span class="keywd">end</span> <span class="keywd">if</span>;
                param2 := exec_str_expr(symbol, line, unused_name);
                <span class="keywd">if</span> symbol = <span class="stri">"TO"</span> <span class="keywd">then</span>
                  symbol := get_symbol(line);
                  param3 := exec_str_expr(symbol, line, unused_name);
                  line_marker;
                  write(log, <span class="stri">"CASE "</span> &lt;&amp; literal(param2) &lt;&amp; <span class="stri">" TO "</span> &lt;&amp;
                      literal(param3));
                  <span class="keywd">if</span> param1 >= param2 <span class="op">and</span> param1 &lt;= param3 <span class="keywd">then</span>
                    found := TRUE;
                    write(log, <span class="stri">" - FOUND"</span>);
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                  writeln(log);
                <span class="keywd">else</span>
                  <span class="keywd">if</span> comparison = <span class="stri">"="</span> <span class="keywd">then</span>
                    found := param1 = param2;
                  <span class="keywd">elsif</span> comparison = <span class="stri">"&lt;>"</span> <span class="keywd">then</span>
                    found := param1 &lt;> param2;
                  <span class="keywd">elsif</span> comparison = <span class="stri">"&lt;"</span> <span class="keywd">then</span>
                    found := param1 &lt; param2;
                  <span class="keywd">elsif</span> comparison = <span class="stri">">"</span> <span class="keywd">then</span>
                    found := param1 > param2;
                  <span class="keywd">elsif</span> comparison = <span class="stri">"&lt;="</span> <span class="keywd">then</span>
                    found := param1 &lt;= param2;
                  <span class="keywd">elsif</span> comparison = <span class="stri">">="</span> <span class="keywd">then</span>
                    found := param1 >= param2;
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                  line_marker;
                  write(log, <span class="stri">"CASE IS "</span> &lt;&amp; comparison &lt;&amp; <span class="stri">" "</span> &lt;&amp;
                      literal(param2));
                  <span class="keywd">if</span> found <span class="keywd">then</span>
                    write(log, <span class="stri">" - FOUND"</span>);
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                  writeln(log);
                <span class="keywd">end</span> <span class="keywd">if</span>;
                <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
                  symbol := get_symbol(line);
                <span class="keywd">else</span>
                  end_case := TRUE;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">until</span> found <span class="op">or</span> end_case;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            end_select := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">until</span> found <span class="op">or</span> end_select;
        <span class="keywd">if</span> <span class="op">not</span> found <span class="keywd">then</span>
          line_marker;
          writeln(log, <span class="stri">"END SELECT - NO CASE FOUND FOR "</span> &lt;&amp; literal(param1));
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        num1 := exec_expr(symbol, line);
        line_marker;
        writeln(log, <span class="stri">"SELECT CASE "</span> &lt;&amp; num1);
        <span class="keywd">repeat</span>
          <span class="keywd">if</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
            line := <span class="stri">""</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          symbol := find_case_or_end_select(line);
          <span class="keywd">if</span> symbol = <span class="stri">"CASE"</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            <span class="keywd">if</span> symbol = <span class="stri">"ELSE"</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
              found := TRUE;
              line_marker;
              writeln(log, <span class="stri">"CASE ELSE - FOUND"</span>);
            <span class="keywd">else</span>
              end_case := FALSE;
              <span class="keywd">repeat</span>
                <span class="keywd">if</span> symbol = <span class="stri">"IS"</span> <span class="keywd">then</span>
                  symbol := get_symbol(line);
                <span class="keywd">end</span> <span class="keywd">if</span>;
                <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"&lt;>"</span> <span class="op">or</span>
                    symbol = <span class="stri">"&lt;"</span> <span class="op">or</span> symbol = <span class="stri">">"</span> <span class="op">or</span>
                    symbol = <span class="stri">"&lt;="</span> <span class="op">or</span> symbol = <span class="stri">">="</span> <span class="keywd">then</span>
                  comparison := symbol;
                  symbol := get_symbol(line);
                <span class="keywd">else</span>
                  comparison := <span class="stri">"="</span>;
                <span class="keywd">end</span> <span class="keywd">if</span>;
                num2 := exec_expr(symbol, line);
                <span class="keywd">if</span> symbol = <span class="stri">"TO"</span> <span class="keywd">then</span>
                  symbol := get_symbol(line);
                  num3 := exec_expr(symbol, line);
                  line_marker;
                  write(log, <span class="stri">"CASE "</span> &lt;&amp; num2 &lt;&amp; <span class="stri">" TO "</span> &lt;&amp; num3);
                  <span class="keywd">if</span> num1 >= num2 <span class="op">and</span> num1 &lt;= num3 <span class="keywd">then</span>
                    found := TRUE;
                    write(log, <span class="stri">" - FOUND"</span>);
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                  writeln(log);
                <span class="keywd">else</span>
                  <span class="keywd">if</span> comparison = <span class="stri">"="</span> <span class="keywd">then</span>
                    found := num1 = num2;
                  <span class="keywd">elsif</span> comparison = <span class="stri">"&lt;>"</span> <span class="keywd">then</span>
                    found := num1 &lt;> num2;
                  <span class="keywd">elsif</span> comparison = <span class="stri">"&lt;"</span> <span class="keywd">then</span>
                    found := num1 &lt; num2;
                  <span class="keywd">elsif</span> comparison = <span class="stri">">"</span> <span class="keywd">then</span>
                    found := num1 > num2;
                  <span class="keywd">elsif</span> comparison = <span class="stri">"&lt;="</span> <span class="keywd">then</span>
                    found := num1 &lt;= num2;
                  <span class="keywd">elsif</span> comparison = <span class="stri">">="</span> <span class="keywd">then</span>
                    found := num1 >= num2;
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                  line_marker;
                  write(log, <span class="stri">"CASE IS "</span> &lt;&amp; comparison &lt;&amp; <span class="stri">" "</span> &lt;&amp; num2);
                  <span class="keywd">if</span> found <span class="keywd">then</span>
                    write(log, <span class="stri">" - FOUND"</span>);
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                  writeln(log);
                <span class="keywd">end</span> <span class="keywd">if</span>;
                <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
                  symbol := get_symbol(line);
                <span class="keywd">else</span>
                  end_case := TRUE;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">until</span> found <span class="op">or</span> end_case;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            end_select := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">until</span> found <span class="op">or</span> end_select;
        <span class="keywd">if</span> <span class="op">not</span> found <span class="keywd">then</span>
          line_marker;
          writeln(log, <span class="stri">"END SELECT - NO CASE FOUND FOR "</span> &lt;&amp; num1);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"\"CASE\" EXPECTED AFTER \"SELECT\""</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: continueWithPrintStatement (<span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: continueWithPrintStatement <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      symbol := get_symbol(line);
    <span class="keywd">until</span> symbol &lt;> <span class="stri">":"</span>;
    <span class="keywd">if</span> symbol = <span class="stri">""</span> <span class="op">or</span> symbol[1] = <span class="stri">'\"'</span> <span class="op">or</span> symbol = <span class="stri">"TAB"</span> <span class="keywd">then</span>
      continueWithPrintStatement := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_print_using (<span class="keywd">inout</span> <span class="type">file</span>: outFile,
    <span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param2 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">integer</span>: index1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index3 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index4 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">char</span>: ch1 <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">char</span>: ch2 <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: implicit_semicolon_pos <span class="keywd">is</span> -1;
  <span class="keywd">begin</span>
    write(log, <span class="stri">"USING "</span>);
    symbol := get_symbol(line);
    <span class="keywd">if</span> isStringExpr(symbol) <span class="keywd">then</span>
      param1 := exec_str_expr(symbol, line, unused_name);
      writeln(log, literal(param1));
      expect(<span class="stri">";"</span>, symbol, line);
      <span class="keywd">repeat</span>
        index1 := 1;
        <span class="keywd">while</span> index1 &lt;= length(param1) <span class="keywd">do</span>
          ch1 := param1[index1];
          <span class="keywd">case</span> ch1 <span class="keywd">of</span>
            <span class="keywd">when</span> {<span class="stri">'!'</span>, <span class="stri">'\\'</span>, <span class="stri">'&amp;'</span>}:
              <span class="keywd">if</span> symbol = <span class="stri">";"</span> <span class="op">or</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
                symbol := get_symbol(line);
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> isStringExpr(symbol) <span class="keywd">then</span>
                param2 := exec_str_expr(symbol, line, unused_name);
                <span class="keywd">if</span> ch1 = <span class="stri">'!'</span> <span class="keywd">then</span>
                  param2 := param2[1 len 1] <span class="op">rpad</span> 1;
                  write(outFile, param2);
                  write(log, <span class="stri">" "</span> &lt;&amp; literal(param2));
                <span class="keywd">elsif</span> ch1 = <span class="stri">'\\'</span> <span class="keywd">then</span>
                  index2 := index1;
                  <span class="keywd">repeat</span>
                    incr(index1);
                    <span class="keywd">if</span> index1 &lt;= length(param1) <span class="keywd">then</span>
                      ch1 := param1[index1];
                    <span class="keywd">else</span>
                      ch1 := <span class="stri">'\0;'</span>;
                    <span class="keywd">end</span> <span class="keywd">if</span>;
                  <span class="keywd">until</span> ch1 &lt;> <span class="stri">' '</span>;
                  <span class="keywd">if</span> ch1 = <span class="stri">'\\'</span> <span class="keywd">then</span>
                    param2 := param2[1 len succ(index1 - index2)] <span class="op">rpad</span> succ(index1 - index2);
                    write(outFile, param2);
                    write(log, <span class="stri">" "</span> &lt;&amp; literal(param2));
                  <span class="keywd">else</span>
                    error_marker;
                    writeln(err, <span class="stri">"'\\' - FOUND "</span> &lt;&amp; literal(ch1) &lt;&amp; <span class="stri">"."</span>);
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                <span class="keywd">elsif</span> ch1 = <span class="stri">'&amp;'</span> <span class="keywd">then</span>
                  write(outFile, param2);
                  write(log, <span class="stri">" "</span> &lt;&amp; literal(param2));
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">else</span>
                error_marker;
                writeln(err, <span class="stri">"STRING EXPECTED - FOUND "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">"."</span>);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">'#'</span>, <span class="stri">'+'</span>, <span class="stri">'.'</span>}:
              <span class="keywd">if</span> index1 &lt; length(param1) <span class="keywd">then</span>
                ch2 := param1[succ(index1)];
              <span class="keywd">else</span>
                ch2 := <span class="stri">'\0;'</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> ch1 = <span class="stri">'#'</span> <span class="op">or</span>
                  ch1 = <span class="stri">'+'</span> <span class="op">and</span> ch2 <span class="op">in</span> {<span class="stri">'#'</span>, <span class="stri">'.'</span>} <span class="op">or</span>
                  ch1 = <span class="stri">'.'</span> <span class="op">and</span> ch2 = <span class="stri">'#'</span> <span class="keywd">then</span>
                <span class="keywd">if</span> symbol = <span class="stri">";"</span> <span class="op">or</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
                  symbol := get_symbol(line);
                <span class="keywd">end</span> <span class="keywd">if</span>;
                num1 := exec_expr(symbol, line);
                <span class="keywd">if</span> ch1 = <span class="stri">'+'</span> <span class="keywd">then</span>
                  <span class="keywd">if</span> num1 >= 0.0 <span class="keywd">then</span>
                    write(outFile, <span class="stri">'+'</span>);
                    write(log, <span class="stri">'+'</span>);
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                  ch1 := ch2;
                  incr(index1);
                <span class="keywd">end</span> <span class="keywd">if</span>;
                index2 := index1;
                index3 := 0;
                index4 := 0;
                <span class="keywd">while</span> ch1 = <span class="stri">'#'</span> <span class="keywd">do</span>
                  incr(index2);
                  incr(index3);
                  <span class="keywd">if</span> index2 &lt;= length(param1) <span class="keywd">then</span>
                    ch1 := param1[index2];
                  <span class="keywd">else</span>
                    ch1 := <span class="stri">'\0;'</span>;
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                  <span class="keywd">if</span> index2 &lt; length(param1) <span class="keywd">then</span>
                    ch2 := param1[succ(index2)];
                  <span class="keywd">else</span>
                    ch2 := <span class="stri">'\0;'</span>;
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                  <span class="keywd">if</span> ch1 = <span class="stri">','</span> <span class="op">and</span> ch2 = <span class="stri">'#'</span> <span class="keywd">then</span>
                    ch1 := ch2;
                    incr(index2);
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                <span class="keywd">end</span> <span class="keywd">while</span>;
                <span class="keywd">if</span> ch1 = <span class="stri">'.'</span> <span class="keywd">then</span>
                  incr(index2);
                  <span class="keywd">if</span> index2 &lt;= length(param1) <span class="keywd">then</span>
                    ch1 := param1[index2];
                  <span class="keywd">else</span>
                    ch1 := <span class="stri">'\0;'</span>;
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                  <span class="keywd">while</span> ch1 = <span class="stri">'#'</span> <span class="keywd">do</span>
                    incr(index2);
                    incr(index4);
                    <span class="keywd">if</span> index2 &lt;= length(param1) <span class="keywd">then</span>
                      ch1 := param1[index2];
                    <span class="keywd">else</span>
                      ch1 := <span class="stri">'\0;'</span>;
                    <span class="keywd">end</span> <span class="keywd">if</span>;
                    <span class="keywd">if</span> index2 &lt; length(param1) <span class="keywd">then</span>
                      ch2 := param1[succ(index2)];
                    <span class="keywd">else</span>
                      ch2 := <span class="stri">'\0;'</span>;
                    <span class="keywd">end</span> <span class="keywd">if</span>;
                    <span class="keywd">if</span> ch1 = <span class="stri">','</span> <span class="op">and</span> ch2 = <span class="stri">'#'</span> <span class="keywd">then</span>
                      ch1 := ch2;
                      incr(index2);
                    <span class="keywd">end</span> <span class="keywd">if</span>;
                  <span class="keywd">end</span> <span class="keywd">while</span>;
                <span class="keywd">end</span> <span class="keywd">if</span>;
                <span class="keywd">if</span> index4 = 0 <span class="keywd">then</span>
                  param2 := num1 <span class="op">digits</span> 0 <span class="op">lpad</span> index3;
                <span class="keywd">else</span>
                  param2 := num1 <span class="op">digits</span> index4 <span class="op">lpad</span> index3 + index4 + 1;
                <span class="keywd">end</span> <span class="keywd">if</span>;
                write(log, num1 &lt;&amp; <span class="stri">" "</span> &lt;&amp; <span class="stri">"#"</span> <span class="op">mult</span> index3 &lt;&amp; <span class="stri">"."</span> &lt;&amp;
                    <span class="stri">"#"</span> <span class="op">mult</span> index4 &lt;&amp; <span class="stri">" "</span> &lt;&amp; literal(param2));
                index3 := 1;
                <span class="keywd">while</span> index1 &lt; index2 <span class="keywd">do</span>
                  <span class="keywd">if</span> index1 &lt;= length(param1) <span class="keywd">then</span>
                    ch1 := param1[index1];
                  <span class="keywd">else</span>
                    ch1 := <span class="stri">'\0;'</span>;
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                  ch2 := param2[index3];
                  <span class="keywd">if</span> ch1 = <span class="stri">','</span> <span class="keywd">then</span>
                    <span class="keywd">if</span> index3 >= 2 <span class="op">and</span> param2[pred(index3)] <span class="op">in</span> digit_char <span class="keywd">then</span>
                      param2 := param2[.. pred(index3)] &amp; <span class="stri">","</span> &amp; param2[index3 ..];
                    <span class="keywd">else</span>
                      param2 := param2[.. pred(index3)] &amp; <span class="stri">" "</span> &amp; param2[index3 ..];
                    <span class="keywd">end</span> <span class="keywd">if</span>;
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                  incr(index1);
                  incr(index3);
                <span class="keywd">end</span> <span class="keywd">while</span>;
                write(outFile, param2);
                write(log, <span class="stri">" "</span> &lt;&amp; literal(param2));
                index1 := pred(index2);
              <span class="keywd">else</span>
                write(outFile, ch1);
                write(log, ch1);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">'*'</span>}:
              noop;
            <span class="keywd">when</span> {<span class="stri">'$'</span>}:
              noop;
            <span class="keywd">when</span> {<span class="stri">'_'</span>}:
              incr(index1);
              <span class="keywd">if</span> index1 &lt;= length(param1) <span class="keywd">then</span>
                ch1 := param1[index1];
                write(outFile, ch1);
                write(log, ch1);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">otherwise</span>:
              write(outFile, ch1);
              write(log, ch1);
          <span class="keywd">end</span> <span class="keywd">case</span>;
          incr(index1);
        <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">if</span> endOfStatement(symbol) <span class="keywd">then</span>
          writeln(outFile);
          <span class="keywd">if</span> symbol = <span class="stri">":"</span> <span class="keywd">then</span>
            <span class="comment"># A colon can be a statement separator or it encodes a line break.</span>
            <span class="keywd">if</span> continueWithPrintStatement(line) <span class="keywd">then</span>
              <span class="comment"># The PRINT statement continues after the line break (:).</span>
              symbol := get_symbol(line);
              write(log, <span class="stri">":"</span>);
              <span class="keywd">while</span> symbol = <span class="stri">":"</span> <span class="keywd">do</span>
                writeln(win);
                symbol := get_symbol(line);
                write(log, <span class="stri">":"</span>);
              <span class="keywd">end</span> <span class="keywd">while</span>;
            <span class="keywd">else</span>
              <span class="comment"># After the statement separator (:) comes the next statement.</span>
              symbol := <span class="stri">":"</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> symbol = <span class="stri">";"</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
        <span class="keywd">elsif</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
        <span class="keywd">else</span>
          <span class="comment"># This is the next thing to be printed.</span>
          <span class="keywd">if</span> implicit_semicolon_pos &lt;> length(line) <span class="keywd">then</span>
            implicit_semicolon_pos := length(line);
            write(log, <span class="stri">" (;) "</span>);
          <span class="keywd">else</span>
            writeln(log);
            error_marker;
            writeln(err, <span class="stri">"IGNORE "</span> &lt;&amp; literal(symbol));
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> endOfStatement(symbol);
      writeln(log);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_print (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">integer</span>: implicit_semicolon_pos <span class="keywd">is</span> -1;
  <span class="keywd">begin</span>
    line_marker;
    write(log, <span class="stri">"PRINT "</span>);
    <span class="keywd">repeat</span>
      <span class="keywd">if</span> isStringExpr(symbol) <span class="keywd">then</span>
        param1 := exec_str_expr(symbol, line, unused_name);
        write(win, param1);
        write(log, literal(param1));
      <span class="keywd">elsif</span> symbol = <span class="stri">"TAB"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        <span class="keywd">if</span> column(win) &lt; round(num1) <span class="keywd">then</span>
          write(win, <span class="stri">""</span> <span class="op">rpad</span> round(num1) - column(win));
        <span class="keywd">end</span> <span class="keywd">if</span>;
        write(log, <span class="stri">"TAB("</span> &lt;&amp; round(num1) &lt;&amp; <span class="stri">")"</span>);
      <span class="keywd">elsif</span> symbol = <span class="stri">"SPC"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        expect(<span class="stri">"("</span>, symbol, line);
        num1 := exec_expr(symbol, line);
        expect(<span class="stri">")"</span>, symbol, line);
        write(win, <span class="stri">""</span> <span class="op">rpad</span> round(num1));
        write(log, <span class="stri">"SPC("</span> &lt;&amp; round(num1) &lt;&amp; <span class="stri">")"</span>);
      <span class="keywd">elsif</span> symbol = <span class="stri">"USING"</span> <span class="keywd">then</span>
        exec_print_using(win, symbol, line);
      <span class="keywd">elsif</span> symbol &lt;> <span class="stri">";"</span> <span class="op">and</span> symbol &lt;> <span class="stri">","</span> <span class="op">and</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">then</span>
        write(win, <span class="stri">" "</span>);
        write(log, <span class="stri">" "</span>);
        num1 := exec_expr(symbol, line);
        param1 := str(num1);
        <span class="keywd">if</span> param1[length(param1) - 1 .. ] = <span class="stri">".0"</span> <span class="keywd">then</span>
          param1 := param1[ .. length(param1) - 2];
        <span class="keywd">end</span> <span class="keywd">if</span>;
        write(win, param1);
        write(log, num1);
        <span class="keywd">if</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">then</span>
          write(win, <span class="stri">" "</span>);
          write(log, <span class="stri">" "</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> endOfStatement(symbol) <span class="keywd">then</span>
        writeln(win);
        <span class="keywd">if</span> symbol = <span class="stri">":"</span> <span class="keywd">then</span>
          <span class="comment"># A colon can be a statement separator or it encodes a line break.</span>
          <span class="keywd">if</span> continueWithPrintStatement(line) <span class="keywd">then</span>
            <span class="comment"># The PRINT statement continues after the line break (:).</span>
            symbol := get_symbol(line);
            write(log, <span class="stri">":"</span>);
            <span class="keywd">while</span> symbol = <span class="stri">":"</span> <span class="keywd">do</span>
              writeln(win);
              symbol := get_symbol(line);
              write(log, <span class="stri">":"</span>);
            <span class="keywd">end</span> <span class="keywd">while</span>;
          <span class="keywd">else</span>
            <span class="comment"># After the statement separator (:) comes the next statement.</span>
            symbol := <span class="stri">":"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> symbol = <span class="stri">";"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        write(log, <span class="stri">"; "</span>);
      <span class="keywd">elsif</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        write(win, <span class="stri">""</span> <span class="op">rpad</span> 15 - column(win) <span class="op">rem</span> 14);
        write(log, <span class="stri">", "</span>);
      <span class="keywd">else</span>
        <span class="comment"># This is the next thing to be printed.</span>
        <span class="keywd">if</span> implicit_semicolon_pos &lt;> length(line) <span class="keywd">then</span>
          implicit_semicolon_pos := length(line);
          write(log, <span class="stri">" (;) "</span>);
        <span class="keywd">else</span>
          writeln(log);
          error_marker;
          writeln(err, <span class="stri">"IGNORE "</span> &lt;&amp; literal(symbol));
          symbol := get_symbol(line);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> endOfStatement(symbol);
    flush(win);
    writeln(log);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_print (<span class="keywd">inout</span> <span class="type">file</span>: outFile,
    <span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">integer</span>: implicit_semicolon_pos <span class="keywd">is</span> -1;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> endOfStatement(symbol) <span class="keywd">then</span>
      writeln(outFile);
    <span class="keywd">else</span>
      <span class="keywd">repeat</span>
        <span class="keywd">if</span> isStringExpr(symbol) <span class="keywd">then</span>
          param1 := exec_str_expr(symbol, line, unused_name);
          write(outFile, param1);
          write(log, literal(param1));
        <span class="keywd">elsif</span> symbol = <span class="stri">"TAB"</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          expect(<span class="stri">"("</span>, symbol, line);
          num1 := exec_expr(symbol, line);
          expect(<span class="stri">")"</span>, symbol, line);
          write(outFile, <span class="stri">"  "</span>);
          write(log, <span class="stri">"TAB("</span> &lt;&amp; round(num1) &lt;&amp; <span class="stri">")"</span>);
        <span class="keywd">elsif</span> symbol = <span class="stri">"SPC"</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          expect(<span class="stri">"("</span>, symbol, line);
          num1 := exec_expr(symbol, line);
          expect(<span class="stri">")"</span>, symbol, line);
          write(outFile, <span class="stri">""</span> <span class="op">rpad</span> round(num1));
          write(log, <span class="stri">"SPC("</span> &lt;&amp; round(num1) &lt;&amp; <span class="stri">")"</span>);
        <span class="keywd">else</span>
          write(outFile, <span class="stri">" "</span>);
          write(log, <span class="stri">" "</span>);
          num1 := exec_expr(symbol, line);
          param1 := str(num1);
          <span class="keywd">if</span> param1[length(param1) - 1 .. ] = <span class="stri">".0"</span> <span class="keywd">then</span>
            param1 := param1[ .. length(param1) - 2];
          <span class="keywd">end</span> <span class="keywd">if</span>;
          write(outFile, param1);
          write(log, num1);
          <span class="keywd">if</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">then</span>
            write(outFile, <span class="stri">" "</span>);
            write(log, <span class="stri">" "</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> endOfStatement(symbol) <span class="keywd">then</span>
          writeln(outFile);
        <span class="keywd">elsif</span> symbol = <span class="stri">";"</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          write(log, <span class="stri">"; "</span>);
        <span class="keywd">elsif</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          write(outFile, <span class="stri">"  "</span>);
          write(log, <span class="stri">", "</span>);
        <span class="keywd">else</span>
          <span class="comment"># This is the next thing to be printed.</span>
          <span class="keywd">if</span> implicit_semicolon_pos &lt;> length(line) <span class="keywd">then</span>
            implicit_semicolon_pos := length(line);
            write(log, <span class="stri">" (;) "</span>);
          <span class="keywd">else</span>
            writeln(log);
            error_marker;
            writeln(err, <span class="stri">"IGNORE "</span> &lt;&amp; literal(symbol));
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> endOfStatement(symbol);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    flush(outFile);
    writeln(log);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_print_to_file (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: file_number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">file</span>: aFile <span class="keywd">is</span> STD_NULL;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    file_number := round(exec_expr(symbol, line));
    aFile := getFileValue(file_number);
    expect(<span class="stri">","</span>, symbol, line);
    <span class="keywd">if</span> aFile &lt;> STD_NULL <span class="keywd">then</span>
      line_marker;
      write(log, <span class="stri">"PRINT #"</span> &lt;&amp; file_number &lt;&amp; <span class="stri">", "</span>);
      <span class="keywd">if</span> symbol = <span class="stri">"USING"</span> <span class="keywd">then</span>
        exec_print_using(aFile, symbol, line);
      <span class="keywd">else</span>
        exec_print(aFile, symbol, line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      error_code := 52; <span class="comment"># Bad file number</span>
      line_marker;
      writeln(log, error_code &lt;&amp; <span class="stri">" BAD FILE NUMBER #"</span> &lt;&amp; file_number &lt;&amp;
          <span class="stri">" - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      goto_on_error(on_error_label, line);
      symbol := <span class="stri">""</span>;
      line := <span class="stri">""</span>;
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"BAD FILE NUMBER #"</span> &lt;&amp; file_number &lt;&amp; <span class="stri">" IN PRINT."</span>);
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_write_to_file (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: file_number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">file</span>: aFile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    file_number := round(exec_expr(symbol, line));
    aFile := getFileValue(file_number);
    <span class="keywd">if</span> aFile &lt;> STD_NULL <span class="keywd">then</span>
      <span class="keywd">while</span> symbol = <span class="stri">","</span> <span class="keywd">do</span>
        symbol := get_symbol(line);
        <span class="keywd">if</span> isStringExpr(symbol) <span class="keywd">then</span>
          param1 := exec_str_expr(symbol, line, variable_name);
          write(aFile, literal(param1));
          line_marker;
          writeln(log, <span class="stri">"WRITE #"</span> &lt;&amp; file_number &lt;&amp; <span class="stri">", "</span> &lt;&amp; literal(param1));
        <span class="keywd">else</span>
          num1 := exec_expr(symbol, line);
          write(aFile, num1);
          line_marker;
          writeln(log, <span class="stri">"WRITE #"</span> &lt;&amp; file_number &lt;&amp; <span class="stri">", "</span> &lt;&amp; num1);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
          write(aFile, <span class="stri">", "</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">while</span>;
      writeln(aFile);
      flush(aFile);
    <span class="keywd">elsif</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      error_code := 52; <span class="comment"># Bad file number</span>
      line_marker;
      writeln(log, error_code &lt;&amp; <span class="stri">" BAD FILE NUMBER #"</span> &lt;&amp; file_number &lt;&amp;
          <span class="stri">" - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      goto_on_error(on_error_label, line);
      symbol := <span class="stri">""</span>;
      line := <span class="stri">""</span>;
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"BAD FILE NUMBER #"</span> &lt;&amp; file_number &lt;&amp; <span class="stri">" IN WRITE."</span>);
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_write (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">boolean</span>: finished <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> endOfStatement(symbol) <span class="keywd">then</span>
      writeln(win);
      flush(win);
      writeln(log, <span class="stri">"WRITE"</span>);
    <span class="keywd">else</span>
      <span class="keywd">repeat</span>
        <span class="keywd">if</span> isStringExpr(symbol) <span class="keywd">then</span>
          param1 := exec_str_expr(symbol, line, variable_name);
          write(win, literal(param1));
          line_marker;
          writeln(log, <span class="stri">"WRITE "</span> &lt;&amp; literal(param1));
        <span class="keywd">else</span>
          num1 := exec_expr(symbol, line);
          write(win, num1);
          line_marker;
          writeln(log, <span class="stri">"WRITE "</span> &lt;&amp; num1);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          write(win, <span class="stri">", "</span>);
        <span class="keywd">else</span>
          finished := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> finished;
      writeln(win);
      flush(win);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_read (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: data_elem <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      symbol := get_symbol(line);
      <span class="keywd">if</span> isStringVar(symbol) <span class="keywd">then</span>
        variable_name := get_name(symbol, line);
        param1 := get_data_field(symbol, line);
        <span class="keywd">if</span> <span class="op">not</span> in_error_handler <span class="keywd">then</span>
          setStringVar(variable_name, param1);
          line_marker;
          write(log, <span class="stri">"READ "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">" "</span> &lt;&amp; literal(param1) &lt;&amp;
              <span class="stri">" IN DATA LINE "</span>);
          line_marker(data_line_number);
          writeln(log);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> isNumericVar(symbol) <span class="keywd">then</span>
        variable_name := get_name(symbol, line);
        data_elem := trim(get_data_field(symbol, line));
        <span class="keywd">if</span> <span class="op">not</span> in_error_handler <span class="keywd">then</span>
          <span class="keywd">if</span> data_elem = <span class="stri">""</span> <span class="keywd">then</span>
            <span class="comment"># Empty DATA fields can be read as 0.0.</span>
            setNumericVar(variable_name, 0.0);
            line_marker;
            write(log, <span class="stri">"READ "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">" 0.0 IN DATA LINE "</span>);
            line_marker(data_line_number);
            writeln(log);
          <span class="keywd">else</span>
            param1 := get_symbol(data_elem);
            <span class="keywd">if</span> param1 = <span class="stri">"-"</span> <span class="keywd">then</span>
              param1 &amp;:= get_symbol(data_elem);
            <span class="keywd">elsif</span> param1 = <span class="stri">"+"</span> <span class="keywd">then</span>
              param1 := get_symbol(data_elem);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">block</span>
              num1 := float(param1);
              setNumericVar(variable_name, num1);
              line_marker;
              write(log, <span class="stri">"READ "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">" "</span> &lt;&amp; num1 &lt;&amp; <span class="stri">" IN DATA LINE "</span>);
              line_marker(data_line_number);
              writeln(log);
            exception
              catch RANGE_ERROR:
                error_marker;
                write(err, <span class="stri">"NUMBER EXPECTED IN READ FOUND "</span> &lt;&amp; literal(param1) &lt;&amp;
                    <span class="stri">" IN DATA LINE "</span>);
                line_marker(data_line_number);
                writeln(err, <span class="stri">"."</span>);
            <span class="keywd">end</span> <span class="keywd">block</span>;
            <span class="keywd">if</span> data_elem &lt;> <span class="stri">""</span> <span class="keywd">then</span>
              error_marker;
              write(err, <span class="stri">"FOUND "</span> &lt;&amp; literal(data_elem) &lt;&amp; <span class="stri">" AFTER "</span> &lt;&amp;
                  literal(param1) &lt;&amp; <span class="stri">" IN DATA LINE "</span>);
              line_marker(data_line_number);
              writeln(err, <span class="stri">"."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"VARIABLE EXPECTED - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> symbol &lt;> <span class="stri">","</span> <span class="op">or</span> in_error_handler;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_input_from_file (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: file_number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">file</span>: aFile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    file_number := round(exec_expr(symbol, line));
    aFile := getFileValue(file_number);
    <span class="keywd">if</span> aFile &lt;> STD_NULL <span class="keywd">then</span>
      <span class="keywd">if</span> eof(aFile) <span class="keywd">then</span>
        aFile.bufferChar := EOF;
      <span class="keywd">elsif</span> aFile.bufferChar = EOF <span class="keywd">then</span>
        <span class="comment"># Not eof() and buffer = EOF means the buffer is empty.</span>
        aFile.bufferChar := getc(aFile);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">while</span> symbol = <span class="stri">","</span> <span class="keywd">do</span>
        symbol := get_symbol(line);
        skip_space_cr_lf(aFile);
        <span class="keywd">if</span> isStringVar(symbol) <span class="keywd">then</span>
          variable_name := get_name(symbol, line);
          param1 := read_input_string(aFile);
          setStringVar(variable_name, param1);
          line_marker;
          writeln(log, <span class="stri">"INPUT #"</span> &lt;&amp; file_number &lt;&amp; <span class="stri">", "</span> &lt;&amp; variable_name &lt;&amp;
              <span class="stri">" "</span> &lt;&amp; literal(param1));
        <span class="keywd">elsif</span> isNumericVar(symbol) <span class="keywd">then</span>
          variable_name := get_name(symbol, line);
          param1 := read_input_number(aFile);
          <span class="keywd">block</span>
            num1 := float(param1);
            setNumericVar(variable_name, num1);
            line_marker;
            writeln(log, <span class="stri">"INPUT #"</span> &lt;&amp; file_number &lt;&amp; <span class="stri">", "</span> &lt;&amp; variable_name &lt;&amp;
                <span class="stri">" "</span> &lt;&amp; num1);
          exception
            catch RANGE_ERROR:
              error_marker;
              writeln(err, <span class="stri">"NUMBER EXPECTED FOR INPUT OF "</span> &lt;&amp; variable_name &lt;&amp;
                  <span class="stri">" FOUND "</span> &lt;&amp; literal(param1) &lt;&amp; <span class="stri">"."</span>);
          <span class="keywd">end</span> <span class="keywd">block</span>;
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"VARIABLE EXPECTED - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        skipSpace(aFile);
        <span class="keywd">if</span> aFile.bufferChar = <span class="stri">','</span> <span class="op">or</span> aFile.bufferChar = <span class="stri">'\r'</span> <span class="keywd">then</span>
          aFile.bufferChar := getc(aFile);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">elsif</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      error_code := 52; <span class="comment"># Bad file number</span>
      line_marker;
      writeln(log, error_code &lt;&amp; <span class="stri">" BAD FILE NUMBER #"</span> &lt;&amp; file_number &lt;&amp;
          <span class="stri">" - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      goto_on_error(on_error_label, line);
      symbol := <span class="stri">""</span>;
      line := <span class="stri">""</span>;
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"BAD FILE NUMBER #"</span> &lt;&amp; file_number &lt;&amp; <span class="stri">" IN INPUT."</span>);
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: read_input (<span class="keywd">inout</span> <span class="type">file</span>: inFile,
    <span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> symbol = <span class="stri">","</span> <span class="keywd">do</span>
      symbol := get_symbol(line);
      skipSpace(inFile);
      <span class="keywd">if</span> isStringVar(symbol) <span class="keywd">then</span>
        variable_name := get_name(symbol, line);
        param1 := read_input_string(inFile);
        assign_input_string(variable_name, param1);
      <span class="keywd">elsif</span> isNumericVar(symbol) <span class="keywd">then</span>
        variable_name := get_name(symbol, line);
        param1 := read_input_number(inFile);
        assign_input_number(variable_name, param1);
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"VARIABLE EXPECTED - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> inFile.bufferChar = <span class="stri">','</span> <span class="keywd">then</span>
        inFile.bufferChar := getc(inFile);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_input (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param2 <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> symbol = <span class="stri">";"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> isStringExpr(symbol) <span class="keywd">then</span>
      param1 := exec_str_expr(symbol, line, variable_name);
      <span class="keywd">if</span> symbol = <span class="stri">";"</span> <span class="op">or</span> (variable_name = <span class="stri">""</span> <span class="op">and</span> (symbol = <span class="stri">","</span> <span class="op">or</span> symbol = <span class="stri">":"</span>)) <span class="keywd">then</span>
        write(win, param1);
        line_marker;
        write(log, <span class="stri">"INPUT "</span> &lt;&amp; literal(param1));
        <span class="keywd">if</span> symbol = <span class="stri">";"</span> <span class="op">or</span> symbol = <span class="stri">":"</span> <span class="keywd">then</span>
          <span class="keywd">if</span> symbol = <span class="stri">";"</span> <span class="keywd">then</span>
            <span class="comment"># Comma or colon are used to suppress the question mark.</span>
            write(win, <span class="stri">"? "</span>);
            write(log, <span class="stri">"? "</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          symbol := <span class="stri">","</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        flush(win);
        writeln(log);
        IN.bufferChar := getc(IN);
        read_input(IN, symbol, line);
      <span class="keywd">elsif</span> variable_name &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        write(win, <span class="stri">"? "</span>);
        flush(win);
        line_marker;
        writeln(log, <span class="stri">"INPUT ? "</span> &lt;&amp; variable_name);
        IN.bufferChar := getc(IN);
        skipSpace(IN);
        param2 := read_input_string(IN);
        assign_input_string(variable_name, param2);
        <span class="keywd">if</span> IN.bufferChar = <span class="stri">','</span> <span class="keywd">then</span>
          IN.bufferChar := getc(IN);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        read_input(IN, symbol, line);
      <span class="keywd">else</span>
        error_expect2(<span class="stri">";"</span>, <span class="stri">","</span>, symbol);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> isNumericVar(symbol) <span class="keywd">then</span>
      variable_name := get_name(symbol, line);
      write(win, <span class="stri">"? "</span>);
      flush(win);
      line_marker;
      writeln(log, <span class="stri">"INPUT ? "</span> &lt;&amp; variable_name);
      IN.bufferChar := getc(IN);
      skipSpace(IN);
      param1 := read_input_number(IN);
      assign_input_number(variable_name, param1);
      <span class="keywd">if</span> IN.bufferChar = <span class="stri">','</span> <span class="keywd">then</span>
        IN.bufferChar := getc(IN);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      read_input(IN, symbol, line);
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"VARIABLE OR STRING EXPECTED - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_line_input_from_file (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: file_number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">file</span>: aFile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    file_number := round(exec_expr(symbol, line));
    aFile := getFileValue(file_number);
    <span class="keywd">if</span> aFile &lt;> STD_NULL <span class="keywd">then</span>
      expect(<span class="stri">","</span>, symbol, line);
      <span class="keywd">if</span> isStringVar(symbol) <span class="keywd">then</span>
        variable_name := get_name(symbol, line);
        param1 := getln(aFile);
        setStringVar(variable_name, param1);
        line_marker;
        writeln(log, <span class="stri">"LINE INPUT #"</span> &lt;&amp; file_number &lt;&amp; <span class="stri">", "</span> &lt;&amp; variable_name &lt;&amp;
            <span class="stri">" "</span> &lt;&amp; literal(param1));
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"STRING VARIABLE EXPECTED IN LINE INPUT FOUND "</span> &lt;&amp;
            literal(symbol) &lt;&amp; <span class="stri">"."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      error_code := 52; <span class="comment"># Bad file number</span>
      line_marker;
      writeln(log, error_code &lt;&amp; <span class="stri">" BAD FILE NUMBER #"</span> &lt;&amp; file_number &lt;&amp;
          <span class="stri">" - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      goto_on_error(on_error_label, line);
      symbol := <span class="stri">""</span>;
      line := <span class="stri">""</span>;
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"BAD FILE NUMBER #"</span> &lt;&amp; file_number &lt;&amp; <span class="stri">" IN LINE INPUT."</span>);
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_line_input (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param2 <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> symbol = <span class="stri">";"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> isStringExpr(symbol) <span class="keywd">then</span>
      param1 := exec_str_expr(symbol, line, variable_name);
      <span class="keywd">if</span> symbol = <span class="stri">";"</span> <span class="op">or</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        write(win, param1);
        flush(win);
        <span class="keywd">if</span> isStringVar(symbol) <span class="keywd">then</span>
          variable_name := get_name(symbol, line);
          line_marker;
          write(log, <span class="stri">"LINE INPUT "</span> &lt;&amp; literal(param1) &lt;&amp; <span class="stri">"; "</span> &lt;&amp; variable_name);
          flush(log);
          readln(param2);
          writeln(win);
          flush(win);
          setStringVar(variable_name, param2);
          writeln(log, <span class="stri">" &lt;- "</span> &lt;&amp; literal(param2));
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"STRING VARIABLE EXPECTED FOR LINE INPUT - FOUND "</span> &lt;&amp;
              symbol &lt;&amp; <span class="stri">"."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> variable_name &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        write(win, <span class="stri">"? "</span>);
        flush(win);
        line_marker;
        write(log, <span class="stri">"LINE INPUT "</span> &lt;&amp; variable_name);
        flush(log);
        readln(param2);
        writeln(win);
        flush(win);
        setStringVar(variable_name, param2);
        writeln(log, <span class="stri">" &lt;- "</span> &lt;&amp; literal(param2));
      <span class="keywd">else</span>
        error_expect2(<span class="stri">";"</span>, <span class="stri">","</span>, symbol);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"STRING EXPECTED FOR LINE INPUT - FOUND "</span> &lt;&amp;
          symbol &lt;&amp; <span class="stri">"."</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_linput_from_file (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: file_number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">file</span>: aFile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    file_number := round(exec_expr(symbol, line));
    aFile := getFileValue(file_number);
    <span class="keywd">if</span> aFile &lt;> STD_NULL <span class="keywd">then</span>
      expect(<span class="stri">":"</span>, symbol, line);
      <span class="keywd">if</span> isStringVar(symbol) <span class="keywd">then</span>
        variable_name := get_name(symbol, line);
        param1 := getln(aFile);
        setStringVar(variable_name, param1);
        line_marker;
        writeln(log, <span class="stri">"LINPUT #"</span> &lt;&amp; file_number &lt;&amp; <span class="stri">": "</span> &lt;&amp; variable_name &lt;&amp;
            <span class="stri">" "</span> &lt;&amp; literal(param1));
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"STRING VARIABLE EXPECTED IN LINPUT FOUND "</span> &lt;&amp;
            literal(symbol) &lt;&amp; <span class="stri">"."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      error_code := 52; <span class="comment"># Bad file number</span>
      line_marker;
      writeln(log, error_code &lt;&amp; <span class="stri">" BAD FILE NUMBER #"</span> &lt;&amp; file_number &lt;&amp;
          <span class="stri">" - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      goto_on_error(on_error_label, line);
      symbol := <span class="stri">""</span>;
      line := <span class="stri">""</span>;
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"BAD FILE NUMBER #"</span> &lt;&amp; file_number &lt;&amp; <span class="stri">" IN LINPUT."</span>);
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_linput (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param2 <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isStringExpr(symbol) <span class="keywd">then</span>
      param1 := exec_str_expr(symbol, line, variable_name);
      <span class="keywd">if</span> symbol = <span class="stri">":"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        write(win, param1);
        flush(win);
        <span class="keywd">if</span> isStringVar(symbol) <span class="keywd">then</span>
          variable_name := get_name(symbol, line);
          line_marker;
          write(log, <span class="stri">"LINPUT "</span> &lt;&amp; literal(param1) &lt;&amp; <span class="stri">": "</span> &lt;&amp; variable_name);
          flush(log);
          readln(param2);
          writeln(win);
          flush(win);
          setStringVar(variable_name, param2);
          writeln(log, <span class="stri">" &lt;- "</span> &lt;&amp; literal(param2));
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"STRING VARIABLE EXPECTED FOR LINPUT - FOUND "</span> &lt;&amp;
              symbol &lt;&amp; <span class="stri">"."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> variable_name &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        write(win, <span class="stri">"? "</span>);
        flush(win);
        line_marker;
        write(log, <span class="stri">"LINPUT "</span> &lt;&amp; variable_name);
        flush(log);
        readln(param2);
        writeln(win);
        flush(win);
        setStringVar(variable_name, param2);
        writeln(log, <span class="stri">" &lt;- "</span> &lt;&amp; literal(param2));
      <span class="keywd">else</span>
        error_expect(<span class="stri">":"</span>, symbol);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"STRING EXPECTED FOR LINPUT - FOUND "</span> &lt;&amp;
          symbol &lt;&amp; <span class="stri">"."</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_display (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">set</span> <span class="type">of</span> <span class="type">string</span>: display_keywords <span class="keywd">is</span> {<span class="stri">"AT"</span>, <span class="stri">"BEEP"</span>, <span class="stri">"ERASE"</span>, <span class="stri">"SIZE"</span>};
    <span class="keywd">var</span> <span class="type">integer</span>: row <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: count <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">boolean</span>: finished <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    line_marker;
    write(log, <span class="stri">"DISPLAY "</span>);
    <span class="keywd">if</span> symbol <span class="op">in</span> display_keywords <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        <span class="keywd">if</span> symbol = <span class="stri">"AT"</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          expect(<span class="stri">"("</span>, symbol, line);
          row := round(exec_expr(symbol, line));
          expect(<span class="stri">","</span>, symbol, line);
          column := round(exec_expr(symbol, line));
          expect(<span class="stri">")"</span>, symbol, line);
          write(log, <span class="stri">"AT("</span> &lt;&amp; row &lt;&amp; <span class="stri">", "</span> &lt;&amp; column &lt;&amp; <span class="stri">") "</span>);
          setPos(win, row, column);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> symbol = <span class="stri">"BEEP"</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          write(log, <span class="stri">"DISPLAY **BEEP "</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> symbol = <span class="stri">"ERASE"</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          expect(<span class="stri">"ALL"</span>, symbol, line);
          clear(win);
          write(log, <span class="stri">"ERASE ALL "</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> symbol = <span class="stri">"SIZE"</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          expect(<span class="stri">"("</span>, symbol, line);
          count := round(exec_expr(symbol, line));
          expect(<span class="stri">")"</span>, symbol, line);
          write(win, <span class="stri">" "</span> <span class="op">mult</span> count);
          write(win, <span class="stri">"\b"</span> <span class="op">mult</span> count);
          write(log, <span class="stri">"SIZE("</span> &lt;&amp; count &lt;&amp; <span class="stri">") "</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> symbol <span class="op">not</span> <span class="op">in</span> display_keywords;
      expect(<span class="stri">":"</span>, symbol, line);
      write(log, <span class="stri">": "</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">repeat</span>
      <span class="keywd">if</span> isStringExpr(symbol) <span class="keywd">then</span>
        param1 := exec_str_expr(symbol, line, unused_name);
        write(win, literal(param1));
        write(log, literal(param1));
      <span class="keywd">else</span>
        num1 := exec_expr(symbol, line);
        write(win, num1);
        write(log, num1);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        write(log, <span class="stri">", "</span>);
      <span class="keywd">elsif</span> symbol = <span class="stri">";"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        write(log, <span class="stri">"; "</span>);
      <span class="keywd">else</span>
        finished := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> finished;
    writeln(log);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">file</span>: basicOpen (<span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: filePath, <span class="op">in</span> <span class="type">string</span>: access) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">file</span>: fileOpened <span class="keywd">is</span> STD_NULL;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: pathElems <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: startElem <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: directoryContent <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: directoryElement <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: foundTwice <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">string</span>: foundElement <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: path_okay <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">string</span>: path <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("basicOpen(\"" &lt;&amp; filePath &lt;&amp; "\")");</span>
    <span class="keywd">if</span> filePath &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      filePath := convDosPath(filePath);
      pathElems := split(filePath, <span class="stri">'/'</span>);
      <span class="keywd">if</span> length(pathElems) >= 1 <span class="op">and</span> pathElems[1] = <span class="stri">""</span> <span class="keywd">then</span>
        <span class="comment"># absolute path</span>
        path := <span class="stri">"/"</span>;
        startElem := 2;
      <span class="keywd">else</span>
        <span class="comment"># relative path</span>
        path := getcwd;
        startElem := 1;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">for</span> number <span class="keywd">range</span> startElem <span class="keywd">to</span> length(pathElems) <span class="keywd">do</span>
        <span class="comment"># writeln(log, literal(path) &lt;&amp; " " &lt;&amp; literal(pathElems[number]));</span>
        <span class="keywd">if</span> fileType(path &amp; <span class="stri">"/"</span> &amp; pathElems[number]) &lt;> FILE_ABSENT <span class="keywd">then</span>
          path &amp;:= <span class="stri">"/"</span> &amp; pathElems[number];
        <span class="keywd">elsif</span> fileType(path) = FILE_DIR <span class="keywd">then</span>
          directoryContent := readDir(path);
          foundTwice := FALSE;
          foundElement := <span class="stri">""</span>;
          <span class="keywd">for</span> directoryElement <span class="keywd">range</span> directoryContent <span class="keywd">do</span>
            <span class="keywd">if</span> upper(pathElems[number]) = upper(directoryElement) <span class="keywd">then</span>
              <span class="keywd">if</span> foundElement = <span class="stri">""</span> <span class="keywd">then</span>
                foundElement := directoryElement;
              <span class="keywd">else</span>
                foundTwice := TRUE;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">for</span>;
          <span class="keywd">if</span> foundElement &lt;> <span class="stri">""</span> <span class="op">and</span> <span class="op">not</span> foundTwice <span class="op">and</span>
              fileType(path &amp; <span class="stri">"/"</span> &amp; foundElement) &lt;> FILE_ABSENT <span class="keywd">then</span>
            path &amp;:= <span class="stri">"/"</span> &amp; foundElement;
          <span class="keywd">elsif</span> access[1 len 1] &lt;> <span class="stri">"r"</span> <span class="keywd">then</span>
            path &amp;:= <span class="stri">"/"</span> &amp; pathElems[number];
          <span class="keywd">else</span>
            path_okay := FALSE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          path_okay := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">else</span>
      path_okay := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> path_okay <span class="keywd">then</span>
      fileOpened := open(path, access);
      <span class="comment"># Set buffer to empty:</span>
      fileOpened.bufferChar := EOF;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_open (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param2 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param_for <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param_access <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: mode <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: file_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: index1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">file</span>: aFile <span class="keywd">is</span> STD_NULL;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    param1 := exec_str_expr(symbol, line, unused_name);
    <span class="keywd">if</span> symbol = <span class="stri">"FOR"</span> <span class="keywd">then</span>
      param_for := get_symbol(line);
      <span class="keywd">if</span> param_for = <span class="stri">"INPUT"</span> <span class="keywd">then</span>
        mode := <span class="stri">"r"</span>;
      <span class="keywd">elsif</span> param_for = <span class="stri">"OUTPUT"</span> <span class="keywd">then</span>
        mode := <span class="stri">"w"</span>;
      <span class="keywd">elsif</span> param_for = <span class="stri">"APPEND"</span> <span class="keywd">then</span>
        mode := <span class="stri">"a"</span>;
      <span class="keywd">elsif</span> param_for = <span class="stri">"RANDOM"</span> <span class="keywd">then</span>
        mode := <span class="stri">"r+"</span>;
      <span class="keywd">elsif</span> param_for = <span class="stri">"BINARY"</span> <span class="keywd">then</span>
        mode := <span class="stri">"r+"</span>;
      <span class="keywd">else</span>
        mode := <span class="stri">"r"</span>;
        error_marker;
        writeln(err, <span class="stri">"ILLEGAL - OPEN FOR "</span> &lt;&amp; param_for);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      symbol := get_symbol(line);
    <span class="keywd">else</span>
      mode := <span class="stri">"r+"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> symbol = <span class="stri">"ACCESS"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      <span class="keywd">if</span> symbol = <span class="stri">"READ"</span> <span class="keywd">then</span>
        param_access := symbol;
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbol = <span class="stri">"WRITE"</span> <span class="keywd">then</span>
        <span class="keywd">if</span> param_access &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          param_access &amp;:= <span class="stri">" "</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        param_access &amp;:= symbol;
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> symbol = <span class="stri">"SHARED"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
    <span class="keywd">elsif</span> symbol = <span class="stri">"LOCK"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      <span class="keywd">if</span> symbol = <span class="stri">"READ"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbol = <span class="stri">"WRITE"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> symbol = <span class="stri">"AS"</span> <span class="op">or</span> symbol = <span class="stri">"AS#"</span> <span class="keywd">then</span>
      <span class="keywd">if</span> symbol = <span class="stri">"AS#"</span> <span class="keywd">then</span>
        symbol := <span class="stri">"#"</span>;
      <span class="keywd">else</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbol = <span class="stri">"#"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      index1 := round(exec_expr(symbol, line));
      <span class="keywd">if</span> symbol = <span class="stri">"LEN"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        expect(<span class="stri">"="</span>, symbol, line);
        reclen_value[index1] := round(exec_expr(symbol, line));
      <span class="keywd">else</span>
        reclen_value[index1] := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      file_name := param1;
      aFile := basicOpen(file_name, mode);
      <span class="keywd">if</span> aFile = STD_NULL <span class="op">and</span> param_access = <span class="stri">""</span> <span class="op">and</span>
          (param_for = <span class="stri">""</span> <span class="op">or</span> param_for = <span class="stri">"RANDOM"</span> <span class="op">or</span> param_for = <span class="stri">"BINARY"</span>) <span class="keywd">then</span>
        mode := <span class="stri">"w+"</span>;     <span class="comment"># Try to open a new file with read/write mode</span>
        aFile := basicOpen(file_name, mode);
        <span class="keywd">if</span> aFile = STD_NULL <span class="keywd">then</span>
          mode := <span class="stri">"w"</span>;    <span class="comment"># Try to open a new file with write-only mode</span>
          aFile := basicOpen(file_name, mode);
          <span class="keywd">if</span> aFile = STD_NULL <span class="keywd">then</span>
            mode := <span class="stri">"r"</span>;  <span class="comment"># Try to open a new file with read-only mode</span>
            aFile := basicOpen(file_name, mode);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> aFile &lt;> STD_NULL <span class="keywd">then</span>
        setFileValue(index1, aFile);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      line_marker;
      write(log, <span class="stri">"OPEN "</span> &lt;&amp; param1);
      <span class="keywd">if</span> param_for &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        write(log, <span class="stri">" FOR "</span> &lt;&amp; param_for);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> param_access &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        write(log, <span class="stri">" ACCESS "</span> &lt;&amp; param_access);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      writeln(log, <span class="stri">" AS #"</span> &lt;&amp; index1 &lt;&amp;
          <span class="stri">" - open("</span> &lt;&amp; literal(file_name) &lt;&amp; <span class="stri">", "</span> &lt;&amp; literal(mode) &lt;&amp; <span class="stri">")"</span>);
    <span class="keywd">else</span>
      <span class="keywd">if</span> param1 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        <span class="keywd">if</span> param1[.. 1] = <span class="stri">"I"</span> <span class="keywd">then</span>
          mode := <span class="stri">"r"</span>;
        <span class="keywd">elsif</span> param1[.. 1] = <span class="stri">"O"</span> <span class="keywd">then</span>
          mode := <span class="stri">"w"</span>;
        <span class="keywd">elsif</span> param1[.. 1] = <span class="stri">"R"</span> <span class="keywd">then</span>
          mode := <span class="stri">"r+"</span>;
        <span class="keywd">elsif</span> param1[.. 1] = <span class="stri">"B"</span> <span class="keywd">then</span>
          mode := <span class="stri">"r+"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> mode = <span class="stri">""</span> <span class="keywd">then</span>
        mode := <span class="stri">"r"</span>;
        error_marker;
        writeln(err, <span class="stri">"ILLEGAL - OPEN "</span> &lt;&amp; param1);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      expect(<span class="stri">","</span>, symbol, line);
      <span class="keywd">if</span> symbol = <span class="stri">"#"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      index1 := round(exec_expr(symbol, line));
      expect(<span class="stri">","</span>, symbol, line);
      param2 := exec_str_expr(symbol, line, unused_name);
      file_name := param2;
      line_marker;
      aFile := basicOpen(file_name, mode);
      <span class="keywd">if</span> aFile &lt;> STD_NULL <span class="keywd">then</span>
        setFileValue(index1, aFile);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        reclen_value[index1] := round(exec_expr(symbol, line));
      <span class="keywd">else</span>
        reclen_value[index1] := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      line_marker;
      write(log, <span class="stri">"OPEN "</span> &lt;&amp; literal(param1) &lt;&amp; <span class="stri">", #"</span> &lt;&amp; index1 &lt;&amp;
          <span class="stri">", "</span> &lt;&amp; literal(param2));
      writeln(log, <span class="stri">" - open("</span> &lt;&amp; literal(file_name) &lt;&amp; <span class="stri">", "</span> &lt;&amp; literal(mode) &lt;&amp; <span class="stri">")"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> aFile = STD_NULL <span class="keywd">then</span>
      <span class="keywd">if</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        error_code := 53; <span class="comment"># File not found</span>
        line_marker;
        writeln(log, error_code &lt;&amp; <span class="stri">" FILE NOT FOUND "</span> &lt;&amp; literal(file_name) &lt;&amp;
            <span class="stri">" - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
        goto_on_error(on_error_label, line);
        symbol := <span class="stri">""</span>;
        line := <span class="stri">""</span>;
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"FILE NOT FOUND "</span> &lt;&amp; literal(file_name));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_close (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: file_number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">file</span>: aFile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> symbol = <span class="stri">"CLOSE#"</span> <span class="keywd">then</span>
      symbol := <span class="stri">"#"</span>;
    <span class="keywd">else</span>
      symbol := get_symbol(line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> endOfStatement(symbol) <span class="keywd">then</span>
      closeAllFiles;
      line_marker;
      writeln(log, <span class="stri">"CLOSE"</span>);
    <span class="keywd">else</span>
      <span class="keywd">repeat</span>
        <span class="keywd">if</span> symbol = <span class="stri">"#"</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        file_number := round(exec_expr(symbol, line));
        aFile := getFileValue(file_number);
        <span class="keywd">if</span> aFile &lt;> STD_NULL <span class="keywd">then</span>
          close(aFile);
          setFileValue(file_number, STD_NULL);
          line_marker;
          writeln(log, <span class="stri">"CLOSE #"</span> &lt;&amp; file_number);
        <span class="keywd">else</span>
          line_marker;
          writeln(log, <span class="stri">"CLOSE #"</span> &lt;&amp; file_number &lt;&amp; <span class="stri">" - FILE ALREADY CLOSED."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
        <span class="keywd">else</span>
          okay := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> okay;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_file_put (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: file_number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">file</span>: outFile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">integer</span>: position <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: with_position <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: reclen <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: field <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> symbol = <span class="stri">"#"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    file_number := round(exec_expr(symbol, line));
    outFile := getFileValue(file_number);
    <span class="keywd">if</span> outFile &lt;> STD_NULL <span class="keywd">then</span>
      <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        <span class="keywd">if</span> symbol &lt;> <span class="stri">","</span> <span class="op">and</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">then</span>
          position := round(exec_expr(symbol, line));
          with_position := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          <span class="keywd">if</span> isStringVar(symbol) <span class="keywd">then</span>
            variable_name := get_name(symbol, line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> with_position <span class="keywd">then</span>
        <span class="keywd">if</span> position >= 1 <span class="keywd">then</span>
          <span class="keywd">if</span> reclen_value[file_number] &lt;> 0 <span class="keywd">then</span>
            reclen := reclen_value[file_number];
          <span class="keywd">else</span>
            <span class="keywd">if</span> length(field_value[file_number]) >= 1 <span class="keywd">then</span>
              reclen := 0;
              <span class="keywd">for</span> field <span class="keywd">range</span> field_value[file_number] <span class="keywd">do</span>
                reclen +:= length(getStringVar(field));
              <span class="keywd">end</span> <span class="keywd">for</span>;
              error_marker;
              writeln(err, <span class="stri">"PUT #"</span> &lt;&amp; file_number &lt;&amp;
                  <span class="stri">" FILE HAS NO RECORD LENGTH SPECIFIED - USE THE FIELD SIZE: "</span> &lt;&amp; reclen);
            <span class="keywd">elsif</span> variable_name &lt;> <span class="stri">""</span> <span class="keywd">then</span>
              reclen := length(getStringVar(variable_name));
              error_marker;
              writeln(err, <span class="stri">"PUT #"</span> &lt;&amp; file_number &lt;&amp;
                  <span class="stri">" FILE HAS NO RECORD LENGTH SPECIFIED - USE THE SIZE OF THE VARIABLE: "</span> &lt;&amp; reclen);
            <span class="keywd">else</span>
              reclen := 0;
              error_marker;
              writeln(err, <span class="stri">"PUT #"</span> &lt;&amp; file_number &lt;&amp;
                  <span class="stri">" FILE HAS NO RECORD LENGTH SPECIFIED - POSITION IGNORED"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> reclen &lt;> 0 <span class="keywd">then</span>
            seek(outFile, succ(pred(position) * reclen));
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"PUT #"</span> &lt;&amp; file_number &lt;&amp;
              <span class="stri">" WITH A RECORD NUMBER OF "</span> &lt;&amp; position);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> length(field_value[file_number]) >= 1 <span class="keywd">then</span>
        <span class="keywd">for</span> field <span class="keywd">range</span> field_value[file_number] <span class="keywd">do</span>
          write(outFile, getStringVar(field));
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">elsif</span> variable_name &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        write(outFile, getStringVar(variable_name));
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"PUT #"</span> &lt;&amp; file_number &lt;&amp;
            <span class="stri">" - NO STRING VARIABLE PRESENT"</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      line_marker;
      write(log, <span class="stri">"PUT #"</span> &lt;&amp; file_number &lt;&amp; <span class="stri">", "</span>);
      <span class="keywd">if</span> with_position <span class="keywd">then</span>
        write(log, position);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> length(field_value[file_number]) >= 1 <span class="keywd">then</span>
        <span class="keywd">for</span> field <span class="keywd">range</span> field_value[file_number] <span class="keywd">do</span>
          write(log, <span class="stri">", "</span> &lt;&amp; field &lt;&amp; <span class="stri">"="</span> &lt;&amp;
              literal(getStringVar(field)));
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">elsif</span> variable_name &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        write(log, <span class="stri">", "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">"="</span> &lt;&amp;
            literal(getStringVar(variable_name)));
      <span class="keywd">end</span> <span class="keywd">if</span>;
      writeln(log);
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>
    <span class="keywd">elsif</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      error_code := 52; <span class="comment"># Bad file number</span>
      line_marker;
      writeln(log, error_code &lt;&amp; <span class="stri">" BAD FILE NUMBER #"</span> &lt;&amp; file_number &lt;&amp;
          <span class="stri">" - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      goto_on_error(on_error_label, line);
      symbol := <span class="stri">""</span>;
      line := <span class="stri">""</span>;
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"BAD FILE NUMBER #"</span> &lt;&amp; file_number &lt;&amp; <span class="stri">" IN PUT."</span>);
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_file_get (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: file_number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">file</span>: inFile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">integer</span>: position <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: with_position <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: reclen <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: field <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> symbol = <span class="stri">"#"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    file_number := round(exec_expr(symbol, line));
    inFile := getFileValue(file_number);
    <span class="keywd">if</span> inFile &lt;> STD_NULL <span class="keywd">then</span>
      <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        <span class="keywd">if</span> symbol &lt;> <span class="stri">","</span> <span class="op">and</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">then</span>
          position := round(exec_expr(symbol, line));
          with_position := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          <span class="keywd">if</span> isStringVar(symbol) <span class="keywd">then</span>
            variable_name := get_name(symbol, line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> with_position <span class="keywd">then</span>
        <span class="keywd">if</span> position >= 1 <span class="keywd">then</span>
          <span class="keywd">if</span> reclen_value[file_number] &lt;> 0 <span class="keywd">then</span>
            reclen := reclen_value[file_number];
          <span class="keywd">else</span>
            <span class="keywd">if</span> length(field_value[file_number]) >= 1 <span class="keywd">then</span>
              reclen := 0;
              <span class="keywd">for</span> field <span class="keywd">range</span> field_value[file_number] <span class="keywd">do</span>
                reclen +:= length(getStringVar(field));
              <span class="keywd">end</span> <span class="keywd">for</span>;
              error_marker;
              writeln(err, <span class="stri">"GET #"</span> &lt;&amp; file_number &lt;&amp;
                  <span class="stri">" FILE HAS NO RECORD LENGTH SPECIFIED - USE THE FIELD SIZE: "</span> &lt;&amp; reclen);
            <span class="keywd">elsif</span> variable_name &lt;> <span class="stri">""</span> <span class="keywd">then</span>
              reclen := length(getStringVar(variable_name));
              error_marker;
              writeln(err, <span class="stri">"GET #"</span> &lt;&amp; file_number &lt;&amp;
                  <span class="stri">" FILE HAS NO RECORD LENGTH SPECIFIED - USE THE SIZE OF THE VARIABLE: "</span> &lt;&amp; reclen);
            <span class="keywd">else</span>
              reclen := 0;
              error_marker;
              writeln(err, <span class="stri">"GET #"</span> &lt;&amp; file_number &lt;&amp;
                  <span class="stri">" FILE HAS NO RECORD LENGTH SPECIFIED - POSITION IGNORED"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> reclen &lt;> 0 <span class="keywd">then</span>
            <span class="comment"># writeln(log, "seek(succ(prd(" &lt;&amp; position &lt;&amp; ") * " &lt;&amp; reclen &lt;&amp; ")) " &lt;&amp;</span>
            <span class="comment">#         succ(pred(position) * reclen));</span>
            seek(inFile, succ(pred(position) * reclen));
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"GET #"</span> &lt;&amp; file_number &lt;&amp;
              <span class="stri">" WITH A RECORD NUMBER OF "</span> &lt;&amp; position);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> length(field_value[file_number]) >= 1 <span class="keywd">then</span>
        <span class="keywd">for</span> field <span class="keywd">range</span> field_value[file_number] <span class="keywd">do</span>
          setStringVar(field, gets(inFile, length(getStringVar(field))));
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">elsif</span> variable_name &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        setStringVar(variable_name, gets(inFile,
            length(getStringVar(variable_name))));
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"GET #"</span> &lt;&amp; file_number &lt;&amp;
            <span class="stri">" - NO STRING VARIABLE PRESENT"</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      line_marker;
      write(log, <span class="stri">"GET #"</span> &lt;&amp; file_number &lt;&amp; <span class="stri">", "</span>);
      <span class="keywd">if</span> with_position <span class="keywd">then</span>
        write(log, position);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> length(field_value[file_number]) >= 1 <span class="keywd">then</span>
        <span class="keywd">for</span> field <span class="keywd">range</span> field_value[file_number] <span class="keywd">do</span>
          write(log, <span class="stri">", "</span> &lt;&amp; field &lt;&amp; <span class="stri">"="</span> &lt;&amp; literal(getStringVar(field)));
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">elsif</span> variable_name &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        write(log, <span class="stri">", "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">"="</span> &lt;&amp; literal(getStringVar(variable_name)));
      <span class="keywd">end</span> <span class="keywd">if</span>;
      writeln(log);
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>
    <span class="keywd">elsif</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      error_code := 52; <span class="comment"># Bad file number</span>
      line_marker;
      writeln(log, error_code &lt;&amp; <span class="stri">" BAD FILE NUMBER #"</span> &lt;&amp; file_number &lt;&amp;
          <span class="stri">" - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      goto_on_error(on_error_label, line);
      symbol := <span class="stri">""</span>;
      line := <span class="stri">""</span>;
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"BAD FILE NUMBER #"</span> &lt;&amp; file_number &lt;&amp; <span class="stri">" IN GET."</span>);
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_seek (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: file_number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">file</span>: aFile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">integer</span>: position <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> symbol = <span class="stri">"SEEK#"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
    <span class="keywd">else</span>
      symbol := get_symbol(line);
      <span class="keywd">if</span> symbol = <span class="stri">"#"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    file_number := round(exec_expr(symbol, line));
    aFile := getFileValue(file_number);
    <span class="keywd">if</span> aFile &lt;> STD_NULL <span class="keywd">then</span>
      expect(<span class="stri">","</span>, symbol, line);
      position := round(exec_expr(symbol, line));
      seek(aFile, position);
      <span class="comment"># Set buffer to empty:</span>
      aFile.bufferChar := EOF;
      line_marker;
      writeln(log, <span class="stri">"SEEK #"</span> &lt;&amp; file_number &lt;&amp; <span class="stri">", "</span> &lt;&amp; position);
    <span class="keywd">elsif</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      error_code := 52; <span class="comment"># Bad file number</span>
      line_marker;
      writeln(log, error_code &lt;&amp; <span class="stri">" BAD FILE NUMBER #"</span> &lt;&amp; file_number &lt;&amp;
          <span class="stri">" - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      goto_on_error(on_error_label, line);
      symbol := <span class="stri">""</span>;
      line := <span class="stri">""</span>;
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"BAD FILE NUMBER #"</span> &lt;&amp; file_number &lt;&amp; <span class="stri">" IN SEEK."</span>);
      <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: clearProgram <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    closeAllFiles;
    numeric_var := numeric_hash.EMPTY_HASH;
    string_var := string_hash.EMPTY_HASH;
    image_var := image_hash.EMPTY_HASH;
    def_fn_list := def_fn_hash.EMPTY_HASH;
    defstr_var := (<span class="type">set</span> <span class="type">of</span> <span class="type">char</span>).EMPTY_SET;
    data_line_number := 0;
    data_line := <span class="stri">""</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_clear (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    clearProgram;
    line_marker;
    writeln(log, <span class="stri">"CLEAR "</span> &lt;&amp; symbol);
    <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
      symbol := get_symbol(line);
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: parseType (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: typeName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    typeName := get_symbol(line);
    <span class="keywd">if</span> typeName = <span class="stri">"SHARED"</span> <span class="keywd">then</span>
      typeName := get_symbol(line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    symbol := get_symbol(line);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: initArray (<span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: arrayName, <span class="op">in</span> <span class="type">boolean</span>: isStringVar,
    <span class="op">in</span> <span class="type">integer</span>: dimension, <span class="op">in</span> <span class="type">dimensionType</span>: dimensionBounds) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> dimension &lt;= length(dimensionBounds) <span class="keywd">then</span>
      <span class="keywd">if</span> dimension = 1 <span class="keywd">then</span>
        arrayName &amp;:= <span class="stri">"("</span>;
      <span class="keywd">else</span>
        arrayName &amp;:= <span class="stri">","</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">for</span> index <span class="keywd">range</span> dimensionBounds[dimension].lbound <span class="keywd">to</span> dimensionBounds[dimension].ubound <span class="keywd">do</span>
        <span class="keywd">if</span> dimension = length(dimensionBounds) <span class="keywd">then</span>
          <span class="keywd">if</span> isStringVar <span class="keywd">then</span>
            setStringVar(arrayName &amp; str(index) &amp; <span class="stri">")"</span>, <span class="stri">""</span>);
          <span class="keywd">else</span>
            setNumericVar(arrayName &amp; str(index) &amp; <span class="stri">")"</span>, 0.0);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          initArray(arrayName &amp; str(index), isStringVar, succ(dimension), dimensionBounds);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_dim (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: variableName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">dimensionType</span>: dimensionBounds <span class="keywd">is</span> 0 <span class="op">times</span> boundsType.value;
    <span class="keywd">var</span> <span class="type">boundsType</span>: bounds <span class="keywd">is</span> boundsType.value;
    <span class="keywd">var</span> <span class="type">string</span>: typeName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: dimension <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: finished <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    <span class="keywd">if</span> symbol = <span class="stri">"SHARED"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">repeat</span>
      <span class="keywd">if</span> symbol[1] >= <span class="stri">'A'</span> <span class="op">and</span> symbol[1] &lt;= <span class="stri">'Z'</span> <span class="keywd">then</span>
        variableName := symbol;
        symbol := get_symbol(line);
        <span class="keywd">if</span> symbol = <span class="stri">"("</span> <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
          dimensionBounds := 0 <span class="op">times</span> boundsType.value;
          <span class="keywd">repeat</span>
            symbol := get_symbol(line);
            bounds.ubound := round(exec_expr(symbol, line));
            <span class="keywd">if</span> symbol = <span class="stri">"TO"</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
              bounds.lbound := bounds.ubound;
              bounds.ubound := round(exec_expr(symbol, line));
            <span class="keywd">else</span>
              bounds.lbound := 0;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            dimensionBounds &amp;:= [] (bounds);
          <span class="keywd">until</span> symbol &lt;> <span class="stri">","</span>;
          <span class="keywd">if</span> symbol =<span class="stri">")"</span> <span class="op">or</span> symbol = <span class="stri">"]"</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            <span class="keywd">if</span> symbol = <span class="stri">"AS"</span> <span class="keywd">then</span>
              typeName := parseType(symbol, line);
              <span class="keywd">if</span> typeName = <span class="stri">"STRING"</span> <span class="keywd">then</span>
                incl(string_var_name, variableName);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">else</span>
              typeName := <span class="stri">""</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            initArray(variableName, isStringVar(variableName), 1, dimensionBounds);
            <span class="comment"># writeln(log, "addr=" &lt;&amp; varptr(variableName) &lt;&amp; " name=" &lt;&amp; variableName);</span>
            ignore(varptr(variableName));
            line_marker;
            write(log, <span class="stri">"DIM "</span> &lt;&amp; variableName &lt;&amp; <span class="stri">"("</span>);
            <span class="keywd">for</span> dimension <span class="keywd">range</span> 1 <span class="keywd">to</span> length(dimensionBounds) <span class="keywd">do</span>
              <span class="keywd">if</span> dimension &lt;> 1 <span class="keywd">then</span>
                write(log, <span class="stri">", "</span>);
              <span class="keywd">end</span> <span class="keywd">if</span>;
              write(log, dimensionBounds[dimension].lbound &lt;&amp; <span class="stri">" TO "</span> &lt;&amp;
                  dimensionBounds[dimension].ubound);
            <span class="keywd">end</span> <span class="keywd">for</span>;
            write(log, <span class="stri">")"</span>);
            <span class="keywd">if</span> typeName &lt;> <span class="stri">""</span> <span class="keywd">then</span>
              write(log, <span class="stri">" AS "</span> &lt;&amp; typeName);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            writeln(log);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          <span class="keywd">if</span> symbol = <span class="stri">"AS"</span> <span class="keywd">then</span>
            typeName := parseType(symbol, line);
            <span class="keywd">if</span> typeName = <span class="stri">"STRING"</span> <span class="keywd">then</span>
              incl(string_var_name, variableName);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            typeName := <span class="stri">""</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          line_marker;
          write(log, <span class="stri">"DIM "</span> &lt;&amp; variableName);
          <span class="keywd">if</span> typeName &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            write(log, <span class="stri">" AS "</span> &lt;&amp; typeName);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          writeln(log);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
      <span class="keywd">else</span>
        finished := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> finished;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_defType_numeric (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: statement <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param2 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">char</span>: ch1 <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    statement := symbol;
    symbol := get_symbol(line);
    okay := FALSE;
    <span class="keywd">repeat</span>
      <span class="keywd">if</span> length(symbol) = 1 <span class="op">and</span> symbol >= <span class="stri">"A"</span> <span class="op">and</span> symbol &lt;= <span class="stri">"Z"</span> <span class="keywd">then</span>
        param1 := symbol;
        symbol := get_symbol(line);
        <span class="keywd">if</span> symbol = <span class="stri">"-"</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          <span class="keywd">if</span> length(symbol) = 1 <span class="op">and</span> symbol >= param1 <span class="op">and</span> symbol &lt;= <span class="stri">"Z"</span> <span class="keywd">then</span>
            param2 := symbol;
            symbol := get_symbol(line);
            <span class="keywd">for</span> ch1 <span class="keywd">range</span> param1[1] <span class="keywd">to</span> param2[1] <span class="keywd">do</span>
              excl(defstr_var, ch1);
            <span class="keywd">end</span> <span class="keywd">for</span>;
            line_marker;
            writeln(log, statement &lt;&amp; <span class="stri">" "</span> &lt;&amp; param1 &lt;&amp; <span class="stri">"-"</span> &lt;&amp; param2);
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"ILLEGAL "</span> &lt;&amp; statement &lt;&amp; <span class="stri">" "</span> &lt;&amp; param1 &lt;&amp; <span class="stri">"-"</span> &lt;&amp; symbol);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          excl(defstr_var, param1[1]);
          line_marker;
          writeln(log, statement &lt;&amp; <span class="stri">" "</span> &lt;&amp; param1);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"ILLEGAL "</span> &lt;&amp; statement &lt;&amp; <span class="stri">" "</span> &lt;&amp; symbol);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
      <span class="keywd">else</span>
        okay := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> okay;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_defstr (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param2 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">char</span>: ch1 <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    defstr_var := (<span class="type">set</span> <span class="type">of</span> <span class="type">char</span>).EMPTY_SET;
    okay := FALSE;
    <span class="keywd">repeat</span>
      <span class="keywd">if</span> length(symbol) = 1 <span class="op">and</span> symbol >= <span class="stri">"A"</span> <span class="op">and</span> symbol &lt;= <span class="stri">"Z"</span> <span class="keywd">then</span>
        param1 := symbol;
        symbol := get_symbol(line);
        <span class="keywd">if</span> symbol = <span class="stri">"-"</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          <span class="keywd">if</span> length(symbol) = 1 <span class="op">and</span> symbol >= param1 <span class="op">and</span> symbol &lt;= <span class="stri">"Z"</span> <span class="keywd">then</span>
            param2 := symbol;
            symbol := get_symbol(line);
            <span class="keywd">for</span> ch1 <span class="keywd">range</span> param1[1] <span class="keywd">to</span> param2[1] <span class="keywd">do</span>
              incl(defstr_var, ch1);
            <span class="keywd">end</span> <span class="keywd">for</span>;
            line_marker;
            writeln(log, <span class="stri">"DEFSTR "</span> &lt;&amp; param1 &lt;&amp; <span class="stri">"-"</span> &lt;&amp; param2);
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"ILLEGAL DEFSTR "</span> &lt;&amp; param1 &lt;&amp; <span class="stri">"-"</span> &lt;&amp; symbol);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          incl(defstr_var, param1[1]);
          line_marker;
          writeln(log, <span class="stri">"DEFSTR "</span> &lt;&amp; param1);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"ILLEGAL DEFSTR "</span> &lt;&amp; symbol);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
      <span class="keywd">else</span>
        okay := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> okay;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_type (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    symbol := next_symbol(line);
    line_marker;
    writeln(log, <span class="stri">"**TYPE "</span> &lt;&amp; symbol);
    <span class="keywd">while</span> symbol &lt;> <span class="stri">"END"</span> <span class="op">and</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      symbol := next_symbol(line);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> symbol = <span class="stri">"END"</span> <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        symbol := get_symbol(line);
      <span class="keywd">until</span> symbol &lt;> <span class="stri">"END"</span>;
      <span class="keywd">if</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
        line := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbol &lt;> <span class="stri">"TYPE"</span> <span class="keywd">then</span>
        exec_type(symbol, line);
      <span class="keywd">else</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: readVarNameFromBloadFile (<span class="keywd">inout</span> <span class="type">file</span>: aFile, <span class="keywd">inout</span> <span class="type">integer</span>: byteIndex) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: bloadName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: twoTimes <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: count <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> twoTimes <span class="keywd">range</span> 1 <span class="keywd">to</span> 2 <span class="keywd">do</span>
      number := ord(getc(aFile));
      <span class="keywd">for</span> count <span class="keywd">range</span> 1 <span class="keywd">to</span> number <span class="keywd">do</span>
        ch := getc(aFile);
        incr(byteIndex);
        <span class="keywd">if</span> ch >= <span class="stri">'\128;'</span> <span class="keywd">then</span>
          ch := chr(ord(ch) - 128);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        bloadName &amp;:= str(ch);
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_bload (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: file_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: arrayName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: bloadName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: address <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">file</span>: aFile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">integer</span>: sizeInBytes <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: byteIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: name_start <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: name_end <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: lbound <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: ubound <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: intIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    file_name := exec_str_expr(symbol, line, unused_name);
    <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      address := round(exec_expr(symbol, line));
      variable_name := varname(address);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> variable_name = <span class="stri">""</span> <span class="keywd">then</span>
      variable_name := varseg_variable;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> variable_name &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      lbound := getFirstIndex(variable_name, name_start, name_end);
      <span class="keywd">if</span> name_start = <span class="stri">""</span> <span class="keywd">then</span>
        arrayName := variable_name;
        lbound := exec_lbound(arrayName, 1);
        ubound := exec_ubound(arrayName, 1);
        name_start := arrayName &amp; <span class="stri">"("</span>;
        name_end := <span class="stri">")"</span>;
      <span class="keywd">else</span>
        arrayName := name_start[ .. pred(length(name_start))];
        ubound := exec_ubound(arrayName, 1);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      intIndex := lbound;
      <span class="comment"># writeln(log, "arrayName=" &lt;&amp; arrayName);</span>
      <span class="comment"># writeln(log, "lbound=" &lt;&amp; lbound);</span>
      <span class="comment"># writeln(log, "ubound=" &lt;&amp; ubound);</span>
      <span class="comment"># writeln(log, "name_start=" &lt;&amp; name_start);</span>
      <span class="comment"># writeln(log, "name_end=" &lt;&amp; name_end);</span>
      aFile := basicOpen(file_name, <span class="stri">"r"</span>);
      <span class="keywd">if</span> aFile &lt;> STD_NULL <span class="keywd">then</span>
        <span class="keywd">if</span> getc(aFile) = <span class="stri">'\16#FD;'</span> <span class="keywd">then</span>
          ignore(gets(aFile, 4));
          sizeInBytes := ord(getc(aFile)) + 256 * ord(getc(aFile));
          writeln(log, <span class="stri">"sizeInBytes="</span> &lt;&amp; sizeInBytes);
          <span class="keywd">for</span> byteIndex <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(sizeInBytes) step 2 <span class="keywd">do</span>
            <span class="keywd">if</span> intIndex > ubound <span class="keywd">then</span>
              <span class="comment"># writeln(log, "varptr(arrayName)=" &lt;&amp; varptr(arrayName));</span>
              arrayName := varname(succ(varptr(arrayName)));
              lbound := exec_lbound(arrayName, 1);
              ubound := exec_ubound(arrayName, 1);
              name_start := arrayName &amp; <span class="stri">"("</span>;
              name_end := <span class="stri">")"</span>;
              intIndex := lbound;
              <span class="comment"># writeln(log, "arrayName=" &lt;&amp; arrayName);</span>
              <span class="comment"># writeln(log, "lbound=" &lt;&amp; lbound);</span>
              <span class="comment"># writeln(log, "ubound=" &lt;&amp; ubound);</span>
              <span class="comment"># writeln(log, "name_start=" &lt;&amp; name_start);</span>
              <span class="comment"># writeln(log, "name_end=" &lt;&amp; name_end);</span>
              <span class="comment"># writeln(log, "byteIndex=" &lt;&amp; byteIndex);</span>
              bloadName := readVarNameFromBloadFile(aFile, byteIndex);
              <span class="comment"># writeln(log, literal(gets(aFile, 5)));</span>
              ignore(literal(gets(aFile, 5)));
              byteIndex +:= 5;
              <span class="keywd">if</span> bloadName &lt;> arrayName <span class="keywd">then</span>
                byteIndex := sizeInBytes;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            number := ord(getc(aFile)) + 256 * ord(getc(aFile));
            setNumericVar(name_start &amp; str(intIndex) &amp; name_end, flt(number));
            <span class="comment"># writeln(log, name_start &amp; str(intIndex) &amp; name_end &lt;&amp; "=" &lt;&amp; flt(number));</span>
            incr(intIndex);
          <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        close(aFile);
      <span class="keywd">else</span>
        <span class="keywd">if</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          error_code := 53; <span class="comment"># File not found</span>
          line_marker;
          writeln(log, error_code &lt;&amp; <span class="stri">" FILE NOT FOUND "</span> &lt;&amp; literal(file_name) &lt;&amp;
              <span class="stri">" - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
          goto_on_error(on_error_label, line);
          symbol := <span class="stri">""</span>;
          line := <span class="stri">""</span>;
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"FILE NOT FOUND "</span> &lt;&amp; literal(file_name));
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    line_marker;
    writeln(log, <span class="stri">"BLOAD "</span> &lt;&amp; literal(file_name) &lt;&amp; <span class="stri">", VARPTR("</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">")"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_files (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: filespec <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: fileName <span class="keywd">is</span> <span class="stri">""</span>
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    <span class="keywd">if</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      filespec := exec_str_expr(symbol, line, unused_name);
      <span class="keywd">for</span> fileName <span class="keywd">range</span> findMatchingFiles(convDosPath(filespec)) <span class="keywd">do</span>
        writeln(fileName);
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">else</span>
      <span class="keywd">for</span> fileName <span class="keywd">range</span> readDir(<span class="stri">"."</span>) <span class="keywd">do</span>
        writeln(fileName);
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(log, <span class="stri">"FILES "</span> &lt;&amp; filespec);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">PRIMITIVE_WINDOW</span>: getCga2ImageFromBytes (<span class="op">in</span> <span class="type">string</span>: bytes) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: image <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: width <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: height <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bytesPerLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: lineStartByte <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: byteIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: imageByte <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: colorNum <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> bytes &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      width := bytes2Int(bytes[1 len 2], UNSIGNED, LE);
      height := bytes2Int(bytes[3 len 2], UNSIGNED, LE);
      <span class="comment"># writeln(log, "width=" &lt;&amp; width &lt;&amp; " height=" &lt;&amp; height);</span>
      image := newPixmap(width, height);
      bytesPerLine := pred(width) <span class="op">mdiv</span> 8 + 1;
      <span class="keywd">for</span> yPos <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(height) <span class="keywd">do</span>
        lineStartByte := yPos * bytesPerLine;
        <span class="keywd">for</span> xPos <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(width) <span class="keywd">do</span>
          colorNum := 0;
          byteIndex := lineStartByte + xPos <span class="op">mdiv</span> 8;
          imageByte := ord(bytes[5 + byteIndex]);
          <span class="keywd">if</span> (imageByte >> (7 - xPos <span class="op">mod</span> 8)) <span class="op">mod</span> 2 = 1 <span class="keywd">then</span>
            point(image, xPos, yPos, white);
          <span class="keywd">else</span>
            point(image, xPos, yPos, black);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">PRIMITIVE_WINDOW</span>: getCga4ImageFromBytes (<span class="op">in</span> <span class="type">string</span>: bytes) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: image <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: width <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: height <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bytesPerLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: lineStartByte <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: byteIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: imageByte <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: colorNum <span class="keywd">is</span> 0;
    <span class="keywd">const</span> <span class="type">array</span> <span class="type">color</span>: palette1 <span class="keywd">is</span> [] (black, light_green, light_red, brown);
  <span class="keywd">begin</span>
    <span class="keywd">if</span> bytes &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      width := bytes2Int(bytes[1 len 2], UNSIGNED, LE);
      height := bytes2Int(bytes[3 len 2], UNSIGNED, LE);
      <span class="comment"># writeln(log, "width=" &lt;&amp; width &lt;&amp; " height=" &lt;&amp; height);</span>
      width := width <span class="op">div</span> 2;
      image := newPixmap(width, height);
      bytesPerLine := pred(width) <span class="op">mdiv</span> 4 + 1;
      <span class="keywd">for</span> yPos <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(height) <span class="keywd">do</span>
        lineStartByte := yPos * bytesPerLine;
        <span class="keywd">for</span> xPos <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(width) <span class="keywd">do</span>
          colorNum := 0;
          byteIndex := lineStartByte + xPos <span class="op">mdiv</span> 4;
          imageByte := ord(bytes[5 + byteIndex]);
          colorNum := (imageByte >> (6 - xPos <span class="op">mod</span> 4 * 2)) <span class="op">mod</span> 4;
          point(image, xPos, yPos, palette1[succ(colorNum)]);
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">PRIMITIVE_WINDOW</span>: getEgaImageFromBytes (<span class="op">in</span> <span class="type">string</span>: bytes) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: image <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: width <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: height <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bytesPerLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: lineStartByte <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: colorBitNum <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: byteIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: imageByte <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: colorNum <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> bytes &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      width := bytes2Int(bytes[1 len 2], UNSIGNED, LE);
      height := bytes2Int(bytes[3 len 2], UNSIGNED, LE);
      <span class="comment"># writeln(log, "width=" &lt;&amp; width &lt;&amp; " height=" &lt;&amp; height);</span>
      image := newPixmap(width, height);
      bytesPerLine := pred(width) <span class="op">mdiv</span> 8 + 1;
      <span class="keywd">for</span> yPos <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(height) <span class="keywd">do</span>
        lineStartByte := yPos * 4 * bytesPerLine;
        <span class="keywd">for</span> xPos <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(width) <span class="keywd">do</span>
          colorNum := 0;
          <span class="keywd">for</span> colorBitNum <span class="keywd">range</span> 0 <span class="keywd">to</span> 3 <span class="keywd">do</span>
            byteIndex := lineStartByte + colorBitNum * bytesPerLine + xPos <span class="op">mdiv</span> 8;
            imageByte := ord(bytes[5 + byteIndex]);
            colorNum +:= ((imageByte >> (7 - xPos <span class="op">mod</span> 8)) <span class="op">mod</span> 2) &lt;&lt; colorBitNum;
          <span class="keywd">end</span> <span class="keywd">for</span>;
          point(image, xPos, yPos, color_num(colorNum));
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">PRIMITIVE_WINDOW</span>: getVgaImageFromBytes (<span class="op">in</span> <span class="type">string</span>: bytes) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: image <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: width <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: height <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bytesPerLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: lineStartByte <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: byteIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: imageByte <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> bytes &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      width := bytes2Int(bytes[1 len 2], UNSIGNED, LE) <span class="op">div</span> 8;
      height := bytes2Int(bytes[3 len 2], UNSIGNED, LE);
      <span class="comment"># writeln(log, "width=" &lt;&amp; width &lt;&amp; " height=" &lt;&amp; height);</span>
      image := newPixmap(width, height);
      bytesPerLine := width;
      <span class="keywd">for</span> yPos <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(height) <span class="keywd">do</span>
        lineStartByte := yPos * bytesPerLine;
        <span class="keywd">for</span> xPos <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(width) <span class="keywd">do</span>
          byteIndex := lineStartByte + xPos;
          imageByte := ord(bytes[5 + byteIndex]);
          point(image, xPos, yPos, color_num(imageByte));
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getBytesFromArray (<span class="op">in</span> <span class="type">string</span>: name_start,
    <span class="op">in</span> <span class="type">string</span>: name_end, <span class="op">in</span> <span class="type">integer</span>: lbound, <span class="op">in</span> <span class="type">integer</span>: ubound) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: bytes <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">float</span>: element <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">string</span>: bytesFromInt2 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: bytesFromFlt4 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: bytesFromDbl8 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: allInteger <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">boolean</span>: allFloat <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="comment"># writeln(log, "getBytesFromArray(" &lt;&amp; literal(name_start) &lt;&amp; ", " &lt;&amp;</span>
    <span class="comment">#         literal(name_end) &lt;&amp; ", " &lt;&amp; lbound &lt;&amp; ", " &lt;&amp; ubound &lt;&amp; ")");</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> lbound <span class="keywd">to</span> ubound <span class="keywd">do</span>
      element := getNumericVar(name_start &amp; str(index) &amp; name_end);
      <span class="keywd">if</span> element >= -32768.0 <span class="op">and</span> element &lt;= 65535.0 <span class="keywd">then</span>
        bytesFromInt2 &amp;:= bytes(round(element) <span class="op">mod</span> 65536, UNSIGNED, LE, 2);
      <span class="keywd">else</span>
        allInteger := FALSE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> element >= -3.4028235e38 <span class="op">and</span> element &lt;= 3.4028235e38 <span class="op">or</span>
          abs(element) = Infinity <span class="op">or</span> isNaN(element) <span class="keywd">then</span>
        bytesFromFlt4 &amp;:= bytes(bin32(element), LE, 4);
      <span class="keywd">else</span>
        allFloat := FALSE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      bytesFromDbl8 &amp;:= bytes(bin64(element), LE, 8);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> allInteger <span class="keywd">then</span>
      bytes := bytesFromInt2;
    <span class="keywd">elsif</span> allFloat <span class="keywd">then</span>
      bytes := bytesFromFlt4;
    <span class="keywd">else</span>
      bytes := bytesFromDbl8;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="comment"># writeln(log, "getBytesFromArray -> " &lt;&amp; literal(bytes));</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">PRIMITIVE_WINDOW</span>: getImageFromArray (<span class="op">in</span> <span class="type">string</span>: name_start,
    <span class="op">in</span> <span class="type">string</span>: name_end, <span class="op">in</span> <span class="type">integer</span>: lbound, <span class="op">in</span> <span class="type">integer</span>: ubound) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: image <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
  <span class="keywd">begin</span>
    <span class="comment"># writeln(log, "getImageFromArray: " &lt;&amp; screenMode);</span>
    <span class="keywd">case</span> screenMode <span class="keywd">of</span>
      <span class="keywd">when</span> {1}:
        image := getCga4ImageFromBytes(
            getBytesFromArray(name_start, name_end, lbound, ubound));
      <span class="keywd">when</span> {2, 3}:
        image := getCga2ImageFromBytes(
            getBytesFromArray(name_start, name_end, lbound, ubound));
      <span class="keywd">when</span> {4, 7, 8}:
        image := getEgaImageFromBytes(
            getBytesFromArray(name_start, name_end, lbound, ubound));
      <span class="keywd">when</span> {13}:
        image := getVgaImageFromBytes(
            getBytesFromArray(name_start, name_end, lbound, ubound));
      <span class="keywd">otherwise</span>:
        error_marker;
        writeln(err, <span class="stri">"CANNOT GET IMAGE FOR MODE: "</span> &lt;&amp; screenMode);
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">PRIMITIVE_WINDOW</span>: getImageFromArray (<span class="op">in</span> <span class="type">string</span>: variable_name) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: image <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: name_start <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: name_end <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: lbound <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: ubound <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    lbound := getFirstIndex(variable_name, name_start, name_end);
    <span class="keywd">if</span> name_start = <span class="stri">""</span> <span class="keywd">then</span>
      lbound := exec_lbound(variable_name, 1);
      ubound := exec_ubound(variable_name, 1);
      image := getImageFromArray(variable_name &amp; <span class="stri">"("</span>, <span class="stri">")"</span>, lbound, ubound);
    <span class="keywd">else</span>
      ubound := exec_ubound(name_start[ .. pred(length(name_start))], 1);
      <span class="comment"># writeln(log, "name_start=" &lt;&amp; literal(name_start) &lt;&amp; " name_end=" &lt;&amp; literal(name_end) &lt;&amp;</span>
      <span class="comment">#              " lbound=" &lt;&amp; lbound &lt;&amp; " ubound=" &lt;&amp; ubound);</span>
      image := getImageFromArray(name_start, name_end, lbound, ubound);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_screen (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: newScreenMode <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: colorswitch <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: active <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: visible <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    newScreenMode := round(exec_expr(symbol, line));
    <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      <span class="keywd">if</span> symbol &lt;> <span class="stri">","</span> <span class="keywd">then</span>
        colorswitch := round(exec_expr(symbol, line));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      <span class="keywd">if</span> symbol &lt;> <span class="stri">","</span> <span class="keywd">then</span>
        active := round(exec_expr(symbol, line));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      <span class="keywd">if</span> symbol &lt;> <span class="stri">","</span> <span class="keywd">then</span>
        visible := round(exec_expr(symbol, line));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> newScreenMode &lt;> screenMode <span class="keywd">then</span>
      <span class="keywd">case</span> newScreenMode <span class="keywd">of</span>
        <span class="keywd">when</span>  {0}: <span class="comment"># Text mode</span>
          <span class="comment"># Some programs set screen to 0 and draw...</span>
          <span class="comment"># curr_win := PRIMITIVE_WINDOW.value;</span>
          scr := open(CONSOLE);
          win := openWindow(scr, 1, 1, TEXT_LINES, TEXT_COLUMNS);
          KEYBOARD := CONSOLE_KEYBOARD;
          OUT := win;
          IN := openEcho(KEYBOARD, OUT);
          IN := openLine(IN);
          screenMode := newScreenMode;

        <span class="keywd">when</span>  {1}:          <span class="comment"># 320 x 200 pixel, 40 x 25 text, 8 x 8 chars</span>
          screen(320, 200);
          win := open(curr_win, 8);
          screenMode := newScreenMode;

        <span class="keywd">when</span>  {2}:          <span class="comment"># 640 x 200 pixel, 80 x 25 text, 8 x 8 chars</span>
          screen(640, 200);
          win := open(curr_win, 8);
          screenMode := newScreenMode;

        <span class="keywd">when</span>  {7}:          <span class="comment"># 320 x 200 pixel, 40 x 25 text, 8 x 8 chars</span>
          screen(320, 200);
          win := open(curr_win, 8);
          screenMode := newScreenMode;

        <span class="keywd">when</span>  {8}:          <span class="comment"># 640 x 200 pixel, 80 x 25 text, 8 x 8 chars</span>
          screen(640, 200);
          win := open(curr_win, 8);
          screenMode := newScreenMode;

        <span class="keywd">when</span>  {9}:          <span class="comment"># 640 x 350 pixel, 80 x 25 text, 8 x 14 chars</span>
          screen(640, 350);
          win := open(curr_win, 14);
          screenMode := newScreenMode;

        <span class="keywd">when</span> {10}:          <span class="comment"># 640 x 350 pixel, 80 x 25 text, 8 x 14 chars</span>
          screen(640, 350);
          win := open(curr_win, 14);
          screenMode := newScreenMode;

        <span class="keywd">when</span> {11}:          <span class="comment"># 640 x 480 pixel, 80 x 30 text, 8 x 16 chars</span>
          screen(640, 480);
          win := open(curr_win, 16);
          screenMode := newScreenMode;

        <span class="keywd">when</span> {12}:          <span class="comment"># 640 x 480 pixel, 80 x 30 text, 8 x 16 chars</span>
          screen(640, 480);
          win := open(curr_win, 16);
          screenMode := newScreenMode;

        <span class="keywd">when</span> {13}:          <span class="comment"># 320 x 200 pixel, 40 x 25 text, 8 x 8 chars</span>
          screen(320, 200);
          win := open(curr_win, 16);
          screenMode := newScreenMode;

        <span class="keywd">otherwise</span>:
          error_marker;
          writeln(err, <span class="stri">"ILLEGAL SCREEN NUMBER: "</span> &lt;&amp; newScreenMode);
      <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">if</span> screenMode &lt;> 0 <span class="op">and</span> curr_win &lt;> PRIMITIVE_WINDOW.value <span class="keywd">then</span>
        clear(curr_win, white);
        color(white, black);
        scr := open(curr_win);
        KEYBOARD := GRAPH_KEYBOARD;
        OUT := win;
        IN := openEcho(KEYBOARD, OUT);
        IN := openLine(IN);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    line_marker;
    writeln(log, <span class="stri">"SCREEN "</span> &lt;&amp; newScreenMode &lt;&amp; <span class="stri">", "</span> &lt;&amp;
        colorswitch &lt;&amp; <span class="stri">", "</span> &lt;&amp; active &lt;&amp; <span class="stri">", "</span> &lt;&amp; visible);
    <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
      symbol := get_symbol(line);
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_pset (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: col <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    <span class="keywd">if</span> symbol = <span class="stri">"STEP"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      expect(<span class="stri">"("</span>, symbol, line);
      currX +:= round(exec_expr(symbol, line));
      expect(<span class="stri">","</span>, symbol, line);
      currY +:= round(exec_expr(symbol, line));
      expect(<span class="stri">")"</span>, symbol, line);
    <span class="keywd">else</span>
      expect(<span class="stri">"("</span>, symbol, line);
      currX := round(exec_expr(symbol, line));
      expect(<span class="stri">","</span>, symbol, line);
      currY := round(exec_expr(symbol, line));
      expect(<span class="stri">")"</span>, symbol, line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      col := round(exec_expr(symbol, line));
    <span class="keywd">else</span>
      col := foreground_color;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    point(currX, currY, color_num(col));
    flushGraphic;
    line_marker;
    writeln(log, <span class="stri">"PSET ("</span> &lt;&amp; currX &lt;&amp; <span class="stri">", "</span> &lt;&amp; currY &lt;&amp; <span class="stri">"), "</span> &lt;&amp; col);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_preset (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: col <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    <span class="keywd">if</span> symbol = <span class="stri">"STEP"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      expect(<span class="stri">"("</span>, symbol, line);
      currX +:= round(exec_expr(symbol, line));
      expect(<span class="stri">","</span>, symbol, line);
      currY +:= round(exec_expr(symbol, line));
      expect(<span class="stri">")"</span>, symbol, line);
    <span class="keywd">else</span>
      expect(<span class="stri">"("</span>, symbol, line);
      currX := round(exec_expr(symbol, line));
      expect(<span class="stri">","</span>, symbol, line);
      currY := round(exec_expr(symbol, line));
      expect(<span class="stri">")"</span>, symbol, line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      col := round(exec_expr(symbol, line));
    <span class="keywd">else</span>
      col := background_color;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    point(currX, currY, color_num(col));
    flushGraphic;
    line_marker;
    writeln(log, <span class="stri">"PRESET ("</span> &lt;&amp; currX &lt;&amp; <span class="stri">", "</span> &lt;&amp; currY &lt;&amp; <span class="stri">"), "</span> &lt;&amp; col);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_line (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: x1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: y1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: col <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: style_present <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: style <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> symbol = <span class="stri">"STEP"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      expect(<span class="stri">"("</span>, symbol, line);
      x1 := currX + round(exec_expr(symbol, line));
      expect(<span class="stri">","</span>, symbol, line);
      y1 := currY + round(exec_expr(symbol, line));
      expect(<span class="stri">")"</span>, symbol, line);
    <span class="keywd">elsif</span> symbol = <span class="stri">"-"</span> <span class="keywd">then</span>
      x1 := currX;
      y1 := currY;
    <span class="keywd">else</span>
      expect(<span class="stri">"("</span>, symbol, line);
      x1 := round(exec_expr(symbol, line));
      expect(<span class="stri">","</span>, symbol, line);
      y1 := round(exec_expr(symbol, line));
      expect(<span class="stri">")"</span>, symbol, line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    expect(<span class="stri">"-"</span>, symbol, line);
    <span class="keywd">if</span> symbol = <span class="stri">"STEP"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      expect(<span class="stri">"("</span>, symbol, line);
      currX := x1 + round(exec_expr(symbol, line));
      expect(<span class="stri">","</span>, symbol, line);
      currY := y1 + round(exec_expr(symbol, line));
    <span class="keywd">else</span>
      expect(<span class="stri">"("</span>, symbol, line);
      currX := round(exec_expr(symbol, line));
      expect(<span class="stri">","</span>, symbol, line);
      currY := round(exec_expr(symbol, line));
    <span class="keywd">end</span> <span class="keywd">if</span>;
    expect(<span class="stri">")"</span>, symbol, line);
    col := foreground_color;
    <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      <span class="keywd">if</span> symbol &lt;> <span class="stri">","</span> <span class="keywd">then</span>
        col := round(exec_expr(symbol, line));
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        <span class="keywd">if</span> symbol &lt;> <span class="stri">","</span> <span class="keywd">then</span>
          param1 := symbol;
          symbol := get_symbol(line);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          style := round(exec_expr(symbol, line));
          style_present := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> param1 = <span class="stri">"BF"</span> <span class="keywd">then</span>
      rectTo(x1, y1, currX, currY, color_num(col));
    <span class="keywd">elsif</span> param1 = <span class="stri">"B"</span> <span class="keywd">then</span>
      boxTo(x1, y1, currX, currY, color_num(col));
    <span class="keywd">else</span>
      lineTo(x1, y1, currX, currY, color_num(col));
    <span class="keywd">end</span> <span class="keywd">if</span>;
    flushGraphic;
    line_marker;
    write(log, <span class="stri">"LINE ("</span> &lt;&amp; x1 &lt;&amp; <span class="stri">", "</span> &lt;&amp; y1 &lt;&amp;
        <span class="stri">") - ("</span> &lt;&amp; currX &lt;&amp; <span class="stri">", "</span> &lt;&amp; currY &lt;&amp; <span class="stri">"), "</span> &lt;&amp; col);
    <span class="keywd">if</span> param1 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      write(log, <span class="stri">", "</span> &lt;&amp; param1);
    <span class="keywd">elsif</span> style_present <span class="keywd">then</span>
      write(log, <span class="stri">", "</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> style_present <span class="keywd">then</span>
      write(log, <span class="stri">", "</span> &lt;&amp; style);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(log);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_circle (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: radius <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: col <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: start <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: stop <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: aspect <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    <span class="keywd">if</span> symbol = <span class="stri">"STEP"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      expect(<span class="stri">"("</span>, symbol, line);
      currX +:= round(exec_expr(symbol, line));
      expect(<span class="stri">","</span>, symbol, line);
      currY +:= round(exec_expr(symbol, line));
    <span class="keywd">else</span>
      expect(<span class="stri">"("</span>, symbol, line);
      currX := round(exec_expr(symbol, line));
      expect(<span class="stri">","</span>, symbol, line);
      currY := round(exec_expr(symbol, line));
    <span class="keywd">end</span> <span class="keywd">if</span>;
    expect(<span class="stri">")"</span>, symbol, line);
    expect(<span class="stri">","</span>, symbol, line);
    radius := round(exec_expr(symbol, line));
    col := foreground_color;
    <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      <span class="keywd">if</span> symbol &lt;> <span class="stri">","</span> <span class="keywd">then</span>
        col := round(exec_expr(symbol, line));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      <span class="keywd">if</span> symbol &lt;> <span class="stri">","</span> <span class="keywd">then</span>
        start := round(exec_expr(symbol, line));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      <span class="keywd">if</span> symbol &lt;> <span class="stri">","</span> <span class="keywd">then</span>
        stop := round(exec_expr(symbol, line));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      <span class="keywd">if</span> symbol &lt;> <span class="stri">","</span> <span class="keywd">then</span>
        aspect := round(exec_expr(symbol, line));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    circle(currX, currY, radius, color_num(col));
    flushGraphic;
    line_marker;
    writeln(log, <span class="stri">"CIRCLE ("</span> &lt;&amp; currX &lt;&amp; <span class="stri">", "</span> &lt;&amp; currY &lt;&amp; <span class="stri">"), "</span> &lt;&amp;
        radius &lt;&amp; <span class="stri">", "</span> &lt;&amp; col);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_put (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: x1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: y1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: image <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
  <span class="keywd">begin</span>
    expect(<span class="stri">"("</span>, symbol, line);
    x1 := round(exec_expr(symbol, line));
    expect(<span class="stri">","</span>, symbol, line);
    y1 := round(exec_expr(symbol, line));
    expect(<span class="stri">")"</span>, symbol, line);
    expect(<span class="stri">","</span>, symbol, line);
    variable_name := get_name(symbol, line);
    <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      symbol := get_symbol(line);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> variable_name <span class="op">in</span> image_var <span class="keywd">then</span>
      image := image_var[variable_name];
    <span class="keywd">else</span>
      image := getImageFromArray(variable_name);
      <span class="keywd">if</span> image &lt;> PRIMITIVE_WINDOW.value <span class="keywd">then</span>
        line_marker;
        writeln(log, <span class="stri">"LOAD IMAGE VARIABLE FROM ARRAY "</span> &lt;&amp; literal(variable_name));
        image_var @:= [variable_name] image;
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"CANNOT LOAD IMAGE VARIABLE FROM ARRAY "</span> &lt;&amp; literal(variable_name));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> image &lt;> PRIMITIVE_WINDOW.value <span class="keywd">then</span>
      line_marker;
      writeln(log, <span class="stri">"PUT ("</span> &lt;&amp; x1 &lt;&amp; <span class="stri">", "</span> &lt;&amp; y1 &lt;&amp; <span class="stri">"), "</span> &lt;&amp; variable_name);
      put(x1, y1, image);
    <span class="keywd">else</span>
      error_marker;
      writeln(err, <span class="stri">"UNDEFINED IMAGE VARIABLE "</span> &lt;&amp; literal(variable_name));
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_get (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: x1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: y1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: x2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: y2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: help <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: image <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
  <span class="keywd">begin</span>
    expect(<span class="stri">"("</span>, symbol, line);
    x1 := round(exec_expr(symbol, line));
    expect(<span class="stri">","</span>, symbol, line);
    y1 := round(exec_expr(symbol, line));
    expect(<span class="stri">")"</span>, symbol, line);
    expect(<span class="stri">"-"</span>, symbol, line);
    <span class="keywd">if</span> symbol = <span class="stri">"STEP"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      expect(<span class="stri">"("</span>, symbol, line);
      x2 := x1 + round(exec_expr(symbol, line));
      expect(<span class="stri">","</span>, symbol, line);
      y2 := y1 + round(exec_expr(symbol, line));
    <span class="keywd">else</span>
      expect(<span class="stri">"("</span>, symbol, line);
      x2 := round(exec_expr(symbol, line));
      expect(<span class="stri">","</span>, symbol, line);
      y2 := round(exec_expr(symbol, line));
    <span class="keywd">end</span> <span class="keywd">if</span>;
    expect(<span class="stri">")"</span>, symbol, line);
    expect(<span class="stri">","</span>, symbol, line);
    variable_name := get_name(symbol, line);
    <span class="keywd">if</span> x1 > x2 <span class="op">or</span> y1 > y2 <span class="keywd">then</span>
      error_marker;
      write(err, <span class="stri">"GET ("</span> &lt;&amp; x1 &lt;&amp; <span class="stri">", "</span> &lt;&amp; y1 &lt;&amp;
          <span class="stri">") - ("</span> &lt;&amp; x2 &lt;&amp; <span class="stri">", "</span> &lt;&amp; y2 &lt;&amp; <span class="stri">") = "</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> x1 > x2 <span class="op">and</span> y1 > y2 <span class="keywd">then</span>
      writeln(err, <span class="stri">"GET (LOWER RIGHT) - (UPPER LEFT)"</span>);
      help := x1;
      x1 := x2;
      x2 := help;
      help := y1;
      y1 := y2;
      y2 := help;
    <span class="keywd">elsif</span> x1 > x2 <span class="keywd">then</span>
      writeln(err, <span class="stri">"GET (UPPER RIGHT) - (LOWER LEFT)"</span>);
      help := x1;
      x1 := x2;
      x2 := help;
    <span class="keywd">elsif</span> y1 > y2 <span class="keywd">then</span>
      writeln(err, <span class="stri">"GET (LOWER LEFT) - (UPPER RIGHT)"</span>);
      help := y1;
      y1 := y2;
      y2 := help;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    image := getPixmap(x1, y1, x2 - x1 + 1, y2 - y1 + 1);
    image_var @:= [variable_name] image;
    line_marker;
    writeln(log, <span class="stri">"GET ("</span> &lt;&amp; x1 &lt;&amp; <span class="stri">", "</span> &lt;&amp; y1 &lt;&amp;
        <span class="stri">") - ("</span> &lt;&amp; x2 &lt;&amp; <span class="stri">", "</span> &lt;&amp; y2 &lt;&amp; <span class="stri">"), "</span> &lt;&amp; variable_name);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getChar (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    symbol := stri[1 len 1];
    stri := stri[2 ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getSign (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    symbol := stri[1 len 1];
    <span class="keywd">if</span> symbol = <span class="stri">"+"</span> <span class="op">or</span> symbol = <span class="stri">"-"</span> <span class="keywd">then</span>
      stri := stri[2 ..];
    <span class="keywd">else</span>
      symbol := <span class="stri">""</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_draw (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: cmdStri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: xOld <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: yOld <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">char</span>: currCmd <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: sign <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: num1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: num2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: pen_down <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">boolean</span>: move_back <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: scale_factor <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: turn_factor <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    cmdStri := exec_str_expr(symbol, line, unused_name);
    line_marker;
    writeln(log, <span class="stri">"**DRAW "</span> &lt;&amp; literal(cmdStri));
    skipWhiteSpace(cmdStri);
    <span class="keywd">while</span> cmdStri &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      currCmd := upper(getChar(cmdStri)[1]);
      skipWhiteSpace(cmdStri);
      <span class="keywd">if</span> currCmd = <span class="stri">'B'</span> <span class="keywd">then</span>
        pen_down := FALSE;
        writeln(log, <span class="stri">"B - PEN UP"</span>);
        <span class="keywd">if</span> cmdStri &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          currCmd := upper(getChar(cmdStri)[1]);
        <span class="keywd">else</span>
          currCmd := <span class="stri">' '</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        skipWhiteSpace(cmdStri);
      <span class="keywd">elsif</span> currCmd = <span class="stri">'N'</span> <span class="keywd">then</span>
        move_back := TRUE;
        <span class="keywd">if</span> cmdStri &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          currCmd := upper(getChar(cmdStri)[1]);
        <span class="keywd">else</span>
          currCmd := <span class="stri">' '</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        skipWhiteSpace(cmdStri);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      xOld := xPos;
      yOld := yPos;
      <span class="keywd">case</span> currCmd <span class="keywd">of</span>
        <span class="keywd">when</span> {<span class="stri">' '</span>}:
          noop;
        <span class="keywd">when</span> {<span class="stri">'U'</span>}:
          param1 := getDigits(cmdStri);
          <span class="keywd">if</span> param1 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            yPos -:= scale_factor * integer(param1);
            <span class="keywd">if</span> pen_down <span class="keywd">then</span>
              lineTo(xOld, yOld, xPos, yPos, color_num(foreground_color));
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'D'</span>}:
          param1 := getDigits(cmdStri);
          <span class="keywd">if</span> param1 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            yPos +:= scale_factor * integer(param1);
            <span class="keywd">if</span> pen_down <span class="keywd">then</span>
              lineTo(xOld, yOld, xPos, yPos, color_num(foreground_color));
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'L'</span>}:
          param1 := getDigits(cmdStri);
          <span class="keywd">if</span> param1 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            xPos -:= scale_factor * integer(param1);
            <span class="keywd">if</span> pen_down <span class="keywd">then</span>
              lineTo(xOld, yOld, xPos, yPos, color_num(foreground_color));
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'R'</span>}:
          param1 := getDigits(cmdStri);
          <span class="keywd">if</span> param1 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            xPos +:= scale_factor * integer(param1);
            <span class="keywd">if</span> pen_down <span class="keywd">then</span>
              lineTo(xOld, yOld, xPos, yPos, color_num(foreground_color));
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'E'</span>}:
          param1 := getDigits(cmdStri);
          <span class="keywd">if</span> param1 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            num1 := integer(param1);
            xPos +:= scale_factor * num1;
            yPos -:= scale_factor * num1;
            <span class="keywd">if</span> pen_down <span class="keywd">then</span>
              lineTo(xOld, yOld, xPos, yPos, color_num(foreground_color));
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'F'</span>}:
          param1 := getDigits(cmdStri);
          <span class="keywd">if</span> param1 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            num1 := integer(param1);
            xPos +:= scale_factor * num1;
            yPos +:= scale_factor * num1;
            <span class="keywd">if</span> pen_down <span class="keywd">then</span>
              lineTo(xOld, yOld, xPos, yPos, color_num(foreground_color));
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'G'</span>}:
          param1 := getDigits(cmdStri);
          <span class="keywd">if</span> param1 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            num1 := integer(param1);
            xPos -:= scale_factor * num1;
            yPos +:= scale_factor * num1;
            <span class="keywd">if</span> pen_down <span class="keywd">then</span>
              lineTo(xOld, yOld, xPos, yPos, color_num(foreground_color));
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'H'</span>}:
          param1 := getDigits(cmdStri);
          <span class="keywd">if</span> param1 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            num1 := integer(param1);
            xPos -:= scale_factor * num1;
            yPos -:= scale_factor * num1;
            <span class="keywd">if</span> pen_down <span class="keywd">then</span>
              lineTo(xOld, yOld, xPos, yPos, color_num(foreground_color));
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'M'</span>}:
          skipWhiteSpace(cmdStri);
          sign := getSign(cmdStri);
          param1 := getDigits(cmdStri);
          <span class="keywd">if</span> param1 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            num1 := integer(param1);
            <span class="keywd">if</span> sign = <span class="stri">""</span> <span class="keywd">then</span>
              xPos := scale_factor * num1;
            <span class="keywd">else</span>
              xPos -:= scale_factor * num1;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            skipWhiteSpace(cmdStri);
            param1 := getChar(cmdStri);
            <span class="keywd">if</span> param1 = <span class="stri">","</span> <span class="keywd">then</span>
              skipWhiteSpace(cmdStri);
              sign := getSign(cmdStri);
              param1 := getDigits(cmdStri);
              <span class="keywd">if</span> param1 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
                num2 := integer(param1);
                <span class="keywd">if</span> sign = <span class="stri">""</span> <span class="keywd">then</span>
                  yPos := scale_factor * num2;
                <span class="keywd">else</span>
                  yPos -:= scale_factor * num2;
                <span class="keywd">end</span> <span class="keywd">if</span>;
                <span class="keywd">if</span> pen_down <span class="keywd">then</span>
                  lineTo(xOld, yOld, xPos, yPos, color_num(foreground_color));
                <span class="keywd">end</span> <span class="keywd">if</span>;
                writeln(log, <span class="stri">"MOVE"</span>);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'C'</span>}:
          param1 := getDigits(cmdStri);
          <span class="keywd">if</span> param1 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            foreground_color := integer(param1);
            writeln(log, <span class="stri">"COLOR "</span> &lt;&amp; foreground_color);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'S'</span>}:
          param1 := getDigits(cmdStri);
          <span class="keywd">if</span> param1 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            scale_factor := integer(param1);
            writeln(log, <span class="stri">"SCALE "</span> &lt;&amp; scale_factor);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'T'</span>}:
          currCmd := upper(getChar(cmdStri)[1]);
          <span class="keywd">if</span> currCmd = <span class="stri">'A'</span> <span class="keywd">then</span>
            param1 := getDigits(cmdStri);
            <span class="keywd">if</span> param1 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
              turn_factor := integer(param1);
              writeln(log, <span class="stri">"TURN ANGLE "</span> &lt;&amp; turn_factor);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'\3;'</span>}:
          num1 := bytes2Int(cmdStri[1 len 2], UNSIGNED, LE);
          param1 := varname(num1);
          cmdStri := getStringVar(param1) &amp; cmdStri[3 ..];
          writeln(log, <span class="stri">"VARPTR$("</span> &lt;&amp; param1 &lt;&amp; <span class="stri">")"</span>);
      <span class="keywd">end</span> <span class="keywd">case</span>;
      pen_down := TRUE;
      move_back := FALSE;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_plot (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: currX <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: currY <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: col <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    currX := round(exec_expr(symbol, line));
    expect(<span class="stri">","</span>, symbol, line);
    currY := round(exec_expr(symbol, line));
    col := round(getNumericVar(<span class="stri">"COLOR"</span>));
    point(currX, currY, loresColor[col <span class="op">mod</span> length(loresColor)]);
    flushGraphic;
    line_marker;
    writeln(log, <span class="stri">"PLOT "</span> &lt;&amp; currX &lt;&amp; <span class="stri">", "</span> &lt;&amp; currY);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_hplot (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: col <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: currX <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: currY <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: destX <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: destY <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    col := round(getNumericVar(<span class="stri">"HCOLOR"</span>));
    currX := round(exec_expr(symbol, line));
    expect(<span class="stri">","</span>, symbol, line);
    currY := round(exec_expr(symbol, line));
    <span class="keywd">if</span> symbol = <span class="stri">"TO"</span> <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        symbol := get_symbol(line);
        destX := round(exec_expr(symbol, line));
        expect(<span class="stri">","</span>, symbol, line);
        destY := round(exec_expr(symbol, line));
        lineTo(currX, currY, destX, destY,
               hiresColor[col <span class="op">mod</span> length(hiresColor)]);
        flushGraphic;
        line_marker;
        writeln(log, <span class="stri">"HPLOT "</span> &lt;&amp; currX &lt;&amp; <span class="stri">", "</span> &lt;&amp; currY &lt;&amp;
                <span class="stri">" TO "</span> &lt;&amp; destX &lt;&amp; <span class="stri">", "</span> &lt;&amp; destY);
        currX := destX;
        currY := destY;
      <span class="keywd">until</span> symbol &lt;> <span class="stri">"TO"</span>;
    <span class="keywd">else</span>
      point(currX, currY, hiresColor[col <span class="op">mod</span> length(hiresColor)]);
      flushGraphic;
      line_marker;
      writeln(log, <span class="stri">"HPLOT "</span> &lt;&amp; currX &lt;&amp; <span class="stri">", "</span> &lt;&amp; currY);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: setup_graphic <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> screenMode &lt;> -1 <span class="keywd">then</span>
      screen(1024, 768);
      clear(curr_win, light_cyan);
      win := openPixmapFontFile(curr_win);
      color(win, black, light_cyan);
      KEYBOARD := GRAPH_KEYBOARD;
      OUT := win;
      IN := openEcho(KEYBOARD, win);
      IN := openLine(IN);
      scale(win, 4);
      currentFont := font8x8;
      setFont(win, currentFont);
      screenMode := -1;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_call_char (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: character_code <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: patternArgument <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: charPicture <span class="keywd">is</span> 8 <span class="op">times</span> <span class="stri">" "</span> <span class="op">mult</span> 8;
    <span class="keywd">var</span> <span class="type">integer</span>: patternStartPos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">char</span>: patternChar <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">string</span>: pattern <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: patternLine <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">boolean</span>: right <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bit <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    setup_graphic;
    symbol := get_symbol(line);
    expect(<span class="stri">"("</span>, symbol, line);
    character_code := round(exec_expr(symbol, line));
    expect(<span class="stri">","</span>, symbol, line);
    patternArgument := exec_str_expr(symbol, line, unused_name);
    expect(<span class="stri">")"</span>, symbol, line);
    patternChar := chr(character_code);
    <span class="keywd">repeat</span>
      pattern := patternArgument[patternStartPos len 16];
      patternLine := 1;
      <span class="keywd">for</span> pos <span class="keywd">range</span> 1 <span class="keywd">to</span> length(pattern) <span class="keywd">do</span>
        number := integer(pattern[pos len 1], 16);
        <span class="keywd">for</span> bit <span class="keywd">range</span> 1 <span class="keywd">to</span> 4 <span class="keywd">do</span>
          <span class="keywd">if</span> odd(number) <span class="keywd">then</span>
            charPicture[patternLine] @:= [ord(right) * 4 + 5 - bit] <span class="stri">'X'</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          number >>:= 1;
        <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">if</span> right <span class="keywd">then</span>
          incr(patternLine);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        right := <span class="op">not</span> right;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      currentFont.fontPictures @:= [patternChar] charPicture;
      setFont(win, currentFont);
      patternStartPos +:= 16;
      incr(patternChar);
    <span class="keywd">until</span> patternStartPos > length(patternArgument);
    line_marker;
    writeln(log, <span class="stri">"CALL CHAR("</span> &lt;&amp; character_code &lt;&amp; <span class="stri">", "</span> &lt;&amp; literal(patternArgument) &lt;&amp; <span class="stri">")"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_call_clear (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    setup_graphic;
    symbol := get_symbol(line);
    clear(curr_win, light_cyan);
    line_marker;
    writeln(log, <span class="stri">"CALL CLEAR"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_call_color (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: character_set <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: foreground <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: background <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: done <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    setup_graphic;
    symbol := get_symbol(line);
    expect(<span class="stri">"("</span>, symbol, line);
    <span class="keywd">if</span> symbol = <span class="stri">"#"</span> <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        symbol := get_symbol(line);
        character_set := round(exec_expr(symbol, line));
        expect(<span class="stri">","</span>, symbol, line);
        foreground := round(exec_expr(symbol, line));
        line_marker;
        writeln(log, <span class="stri">"CALL COLOR(#"</span> &lt;&amp; character_set &lt;&amp; <span class="stri">", "</span> &lt;&amp;
                foreground &lt;&amp; <span class="stri">")"</span>);
      <span class="keywd">until</span> symbol &lt;> <span class="stri">","</span>;
    <span class="keywd">else</span>
      <span class="keywd">repeat</span>
        character_set := round(exec_expr(symbol, line));
        expect(<span class="stri">","</span>, symbol, line);
        foreground := round(exec_expr(symbol, line));
        expect(<span class="stri">","</span>, symbol, line);
        background := round(exec_expr(symbol, line));
        line_marker;
        writeln(log, <span class="stri">"CALL COLOR("</span> &lt;&amp; character_set &lt;&amp; <span class="stri">", "</span> &lt;&amp;
                foreground &lt;&amp; <span class="stri">", "</span> &lt;&amp; background &lt;&amp; <span class="stri">")"</span>);
        <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
        <span class="keywd">else</span>
          done := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> done;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    expect(<span class="stri">")"</span>, symbol, line);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_call_hchar (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: row <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: character_code <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: repetition <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    setup_graphic;
    symbol := get_symbol(line);
    expect(<span class="stri">"("</span>, symbol, line);
    row := round(exec_expr(symbol, line));
    expect(<span class="stri">","</span>, symbol, line);
    column := round(exec_expr(symbol, line));
    expect(<span class="stri">","</span>, symbol, line);
    character_code := round(exec_expr(symbol, line));
    <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      repetition := round(exec_expr(symbol, line));
    <span class="keywd">end</span> <span class="keywd">if</span>;
    expect(<span class="stri">")"</span>, symbol, line);
    <span class="keywd">for</span> repetition <span class="keywd">do</span>
      setPos(win, row, column);
      write(win, chr(character_code));
      <span class="keywd">if</span> column &lt; 32 <span class="keywd">then</span>
        incr(column);
      <span class="keywd">else</span>
        incr(row);
        column := 1;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    line_marker;
    writeln(log, <span class="stri">"CALL HCHAR("</span> &lt;&amp; row &lt;&amp; <span class="stri">", "</span> &lt;&amp; column &lt;&amp; <span class="stri">", "</span> &lt;&amp;
            character_code &lt;&amp; <span class="stri">", "</span> &lt;&amp; repetition &lt;&amp; <span class="stri">")"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_call_key (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: key_unit <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: return_variable <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: status_variable <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">char</span>: current_key <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    setup_graphic;
    symbol := get_symbol(line);
    expect(<span class="stri">"("</span>, symbol, line);
    key_unit := round(exec_expr(symbol, line));
    expect(<span class="stri">","</span>, symbol, line);
    return_variable := get_name(symbol, line);
    expect(<span class="stri">","</span>, symbol, line);
    status_variable := get_name(symbol, line);
    expect(<span class="stri">")"</span>, symbol, line);
    current_key := busy_getc(KEYBOARD);
    <span class="keywd">if</span> current_key = KEY_NONE <span class="keywd">then</span>
      setNumericVar(return_variable, -1.0);
      setNumericVar(status_variable, 0.0);
    <span class="keywd">else</span>
      setNumericVar(return_variable, flt(ord(current_key)));
      setNumericVar(status_variable, 1.0);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    line_marker;
    writeln(log, <span class="stri">"CALL KEY("</span> &lt;&amp; key_unit &lt;&amp; <span class="stri">", "</span> &lt;&amp; return_variable &lt;&amp; <span class="stri">", "</span> &lt;&amp; status_variable &lt;&amp; <span class="stri">")"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_call_screen (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: color_code <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    setup_graphic;
    symbol := get_symbol(line);
    expect(<span class="stri">"("</span>, symbol, line);
    color_code := round(exec_expr(symbol, line));
    expect(<span class="stri">")"</span>, symbol, line);
    line_marker;
    writeln(log, <span class="stri">"CALL SCREEN("</span> &lt;&amp; color_code &lt;&amp; <span class="stri">")"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_call_sound (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">float</span>: duration <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">integer</span>: frequency <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: volume <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    expect(<span class="stri">"("</span>, symbol, line);
    duration := exec_expr(symbol, line);
    expect(<span class="stri">","</span>, symbol, line);
    frequency := round(exec_expr(symbol, line));
    expect(<span class="stri">","</span>, symbol, line);
    volume := round(exec_expr(symbol, line));
    expect(<span class="stri">")"</span>, symbol, line);
    line_marker;
    writeln(log, <span class="stri">"CALL SOUND("</span> &lt;&amp; duration &lt;&amp; <span class="stri">", "</span> &lt;&amp; frequency &lt;&amp; <span class="stri">", "</span> &lt;&amp; volume &lt;&amp; <span class="stri">")"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_call_vchar (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: row <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: character_code <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: repetition <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    setup_graphic;
    symbol := get_symbol(line);
    expect(<span class="stri">"("</span>, symbol, line);
    row := round(exec_expr(symbol, line));
    expect(<span class="stri">","</span>, symbol, line);
    column := round(exec_expr(symbol, line));
    expect(<span class="stri">","</span>, symbol, line);
    character_code := round(exec_expr(symbol, line));
    <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
      repetition := round(exec_expr(symbol, line));
    <span class="keywd">end</span> <span class="keywd">if</span>;
    expect(<span class="stri">")"</span>, symbol, line);
    <span class="keywd">for</span> repetition <span class="keywd">do</span>
      setPos(win, row, column);
      write(win, chr(character_code));
      <span class="keywd">if</span> row &lt; 24 <span class="keywd">then</span>
        incr(row);
      <span class="keywd">else</span>
        incr(column);
        row := 1;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    line_marker;
    writeln(log, <span class="stri">"CALL VCHAR("</span> &lt;&amp; row &lt;&amp; <span class="stri">", "</span> &lt;&amp; column &lt;&amp; <span class="stri">", "</span> &lt;&amp;
            character_code &lt;&amp; <span class="stri">", "</span> &lt;&amp; repetition &lt;&amp; <span class="stri">")"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: exec_let (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line,
    <span class="keywd">inout</span> <span class="type">boolean</span>: process_next) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: is_let_statement <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: backup_line <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> symbol = <span class="stri">"LET"</span> <span class="keywd">then</span>
      symbol := get_symbol(line);
    <span class="keywd">elsif</span> <span class="op">not</span> is_let_statement(line) <span class="keywd">then</span>
      <span class="comment"># If no "=" follows it is probably a statement</span>
      <span class="comment"># which is not separated with a space</span>
      is_let_statement := FALSE;
      <span class="keywd">if</span> startsWith(symbol, <span class="stri">"REM"</span>) <span class="keywd">then</span>
        line_marker;
        writeln(log, <span class="stri">"REM "</span> &lt;&amp; symbol &lt;&amp; line);
        symbol := <span class="stri">""</span>;
      <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"IF"</span>) <span class="keywd">then</span>
        line := symbol[3 ..] &amp; line;
        exec_if(symbol, line, process_next);
      <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"GOTO"</span>) <span class="keywd">then</span>
        line := symbol[5 ..] &amp; line;
        exec_goto(symbol, line);
      <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"GOSUB"</span>) <span class="keywd">then</span>
        line := symbol[6 ..] &amp; line;
        exec_gosub(symbol, line);
      <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"ELSE"</span>) <span class="op">and</span> <span class="op">not</span> startsWith(symbol, <span class="stri">"ELSEIF"</span>) <span class="keywd">then</span>
        line := symbol[5 ..] &amp; line;
        exec_else(symbol, line);
      <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"NEXT"</span>) <span class="keywd">then</span>
        line := symbol[5 ..] &amp; line;
        exec_next(symbol, line);
      <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"ON"</span>) <span class="keywd">then</span>
        line := symbol[3 ..] &amp; line;
        exec_on(symbol, line);
      <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"PRINT"</span>) <span class="keywd">then</span>
        line := symbol[6 ..] &amp; line;
        symbol := get_symbol(line);
        exec_print(symbol, line);
      <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"LPRINT"</span>) <span class="keywd">then</span>
        line := symbol[7 ..] &amp; line;
        symbol := get_symbol(line);
        exec_print(symbol, line);
      <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"INPUT"</span>) <span class="keywd">then</span>
        line := symbol[6 ..] &amp; line;
        symbol := get_symbol(line);
        exec_input(symbol, line);
      <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"READ"</span>) <span class="keywd">then</span>
        line := symbol[5 ..] &amp; line;
        exec_read(symbol, line);
      <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"CLEAR"</span>) <span class="keywd">then</span>
        line := symbol[6 ..] &amp; line;
        exec_clear(symbol, line);
      <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"DIM"</span>) <span class="keywd">then</span>
        line := symbol[4 ..] &amp; line;
        exec_dim(symbol, line);
      <span class="keywd">elsif</span> symbol <span class="op">in</span> label <span class="keywd">then</span>
        param1 := symbol;
        symbol := get_symbol(line);
        <span class="keywd">if</span> symbol = <span class="stri">":"</span> <span class="keywd">then</span>
          line_marker;
          writeln(log, <span class="stri">"SKIP LABEL: "</span> &lt;&amp; param1);
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"COLON EXPECTED AFTER LABEL "</span> &lt;&amp; param1 &lt;&amp;
                  <span class="stri">" - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> symbol <span class="op">in</span> usedLabel <span class="op">and</span> symbol <span class="op">in</span> multipleDefinedLabel <span class="keywd">then</span>
        param1 := symbol;
        symbol := get_symbol(line);
        <span class="keywd">if</span> symbol = <span class="stri">":"</span> <span class="keywd">then</span>
          line_marker;
          writeln(log, <span class="stri">"SKIP MULTIPLE DEFINED LABEL: "</span> &lt;&amp; param1);
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"COLON EXPECTED AFTER LABEL "</span> &lt;&amp; param1 &lt;&amp;
                  <span class="stri">" - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        is_let_statement := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> is_let_statement <span class="keywd">then</span>
      <span class="keywd">if</span> isStringVar(symbol) <span class="keywd">then</span>
        backup_line := symbol &amp; line;
        variable_name := get_name(symbol, line);
        backup_line := backup_line[.. length(backup_line) - length(line)];
        <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          param1 := exec_str_expr(symbol, line, unused_name);
          <span class="keywd">if</span> startsWith(variable_name, <span class="stri">"IF"</span>) <span class="op">and</span> startsWith(symbol, <span class="stri">"THEN"</span>) <span class="keywd">then</span>
            line := backup_line[3 ..] &amp; <span class="stri">"\""</span> &amp; param1 &amp; <span class="stri">"\""</span> &amp; symbol &amp; line;
            line_marker;
            writeln(log, <span class="stri">"IF RECOGNIZED: IF "</span> &lt;&amp; literal(line));
            exec_if(symbol, line, process_next);
          <span class="keywd">else</span>
            setStringVar(variable_name, param1);
            line_marker;
            writeln(log, <span class="stri">"LET "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">"="</span> &lt;&amp; literal(param1));
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"\"=\" EXPECTED AFTER "</span> &lt;&amp; literal(variable_name) &lt;&amp;
              <span class="stri">" - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> isNumericVar(symbol) <span class="keywd">then</span>
        variable_name := get_name(symbol, line);
        <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          num1 := exec_expr(symbol, line);
          <span class="keywd">if</span> startsWith(variable_name, <span class="stri">"IF"</span>) <span class="op">and</span> startsWith(symbol, <span class="stri">"THEN"</span>) <span class="keywd">then</span>
            line := variable_name[3 ..] &amp; <span class="stri">"="</span> &amp; str(num1) &amp; symbol &amp; line;
            line_marker;
            writeln(log, <span class="stri">"IF RECOGNIZED: IF "</span> &lt;&amp; literal(line));
            exec_if(symbol, line, process_next);
          <span class="keywd">elsif</span> startsWith(variable_name, <span class="stri">"FOR"</span>) <span class="op">and</span> startsWith(symbol, <span class="stri">"TO"</span>) <span class="keywd">then</span>
            line := variable_name[4 ..] &amp; <span class="stri">"="</span> &amp; str(num1) &amp; symbol &amp; line;
            line_marker;
            writeln(log, <span class="stri">"FOR RECOGNIZED: FOR "</span> &lt;&amp; literal(line));
            exec_for(symbol, line);
          <span class="keywd">else</span>
            setNumericVar(variable_name, num1);
            line_marker;
            writeln(log, <span class="stri">"LET "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">"="</span> &lt;&amp; num1);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          error_marker;
          writeln(err, <span class="stri">"\"=\" EXPECTED AFTER "</span> &lt;&amp; literal(variable_name) &lt;&amp;
              <span class="stri">" - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        error_marker;
        writeln(err, <span class="stri">"VARIABLE EXPECTED - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: runOrChain (<span class="op">in</span> <span class="type">string</span>: cmd, <span class="op">in</span> <span class="type">string</span>: name) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: execCmd (<span class="keywd">inout</span> <span class="type">string</span>: symbol, <span class="keywd">inout</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: running <span class="keywd">is</span> TRUE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: variable2_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: unused_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param2 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param3 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: num1 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: num2 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">integer</span>: index1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index3 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">char</span>: current_key <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: process_next <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="comment"># writeln(log, literal(symbol));</span>
    <span class="keywd">repeat</span>
      process_next := FALSE;
      <span class="keywd">case</span> symbol <span class="keywd">of</span>
        <span class="keywd">when</span> {<span class="stri">""</span>}:
          noop;
        <span class="keywd">when</span> {<span class="stri">"BEEP"</span>}:
          symbol := get_symbol(line);
          line_marker;
          writeln(log, <span class="stri">"**BEEP"</span>);
        <span class="keywd">when</span> {<span class="stri">"BLOAD"</span>}:
          exec_bload(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"CALL"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol <span class="op">in</span> subprogram <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"CALL "</span> &lt;&amp; symbol);
            advance_after_statement(line);
            set_return_position(line);
            gosubReturn[1].subName := symbol;
            file_line_number := subprogram[symbol];
            statement_label := prg[file_line_number].label;
            line := prg[file_line_number].line;
            symbol := get_symbol(line);
            symbol := get_symbol(line);
            set_sub_entry_position;
            line_marker;
            writeln(log, <span class="stri">"EXECUTE SUB "</span> &lt;&amp; symbol);
          <span class="keywd">elsif</span> symbol <span class="op">in</span> sub_declared <span class="keywd">then</span>
            error_marker;
            writeln(err, <span class="stri">"CALL DECLARED BUT UNDEFINED SUB "</span> &lt;&amp; symbol);
            <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
              symbol := get_symbol(line);
            <span class="keywd">end</span> <span class="keywd">while</span>;
          <span class="keywd">elsif</span> symbol = <span class="stri">"+"</span> <span class="op">or</span> symbol = <span class="stri">"-"</span> <span class="op">or</span>
              symbol &lt;> <span class="stri">""</span> <span class="op">and</span> symbol[1] <span class="op">in</span> digit_char <span class="keywd">then</span>
            index1 := round(exec_expr(symbol, line));
            error_marker;
            writeln(err, <span class="stri">"CALL UNDEFINED SUB "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">"."</span>);
          <span class="keywd">elsif</span> symbol = <span class="stri">"CHAR"</span> <span class="keywd">then</span>
            exec_call_char(symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">"CLEAR"</span> <span class="keywd">then</span>
            exec_call_clear(symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">"COLOR"</span> <span class="keywd">then</span>
            exec_call_color(symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">"HCHAR"</span> <span class="keywd">then</span>
            exec_call_hchar(symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">"KEY"</span> <span class="keywd">then</span>
            exec_call_key(symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">"SCREEN"</span> <span class="keywd">then</span>
            exec_call_screen(symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">"SOUND"</span> <span class="keywd">then</span>
            exec_call_sound(symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">"VCHAR"</span> <span class="keywd">then</span>
            exec_call_vchar(symbol, line);
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"CALL UNDEFINED SUB "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">when</span> {<span class="stri">"CASE"</span>}:
          line_marker;
          writeln(log, <span class="stri">"CASE - SKIP TO \"END SELECT\""</span>);
          symbol := find_end_select(line);
          <span class="keywd">if</span> symbol = <span class="stri">"SELECT"</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            line_marker;
            writeln(log, <span class="stri">"END SELECT"</span>);
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"NO CORRESPONDING \"END SELECT\" FOUND"</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"CHAIN"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> isStringExpr(symbol) <span class="keywd">then</span>
            param1 := exec_str_expr(symbol, line, variable_name);
            <span class="keywd">if</span> runOrChain(<span class="stri">"CHAIN"</span>, param1) <span class="keywd">then</span>
              writeln(log, <span class="stri">"load program finished"</span>);
              line_marker;
              writeln(log, <span class="stri">"CHAIN "</span> &lt;&amp; literal(param1) &lt;&amp; <span class="stri">" - "</span> &lt;&amp;
                  length(prg) &lt;&amp; <span class="stri">" LINES"</span>);
              file_line_number := 0;
              data_line_number := 0;
              symbol := <span class="stri">""</span>;
              line := <span class="stri">""</span>;
            <span class="keywd">elsif</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
              error_code := 53; <span class="comment"># File not found</span>
              line_marker;
              writeln(log, error_code &lt;&amp; <span class="stri">" CHAIN "</span> &lt;&amp; literal(param1) &lt;&amp;
                  <span class="stri">" - FILE NOT FOUND - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
              goto_on_error(on_error_label, line);
              symbol := <span class="stri">""</span>;
              line := <span class="stri">""</span>;
            <span class="keywd">else</span>
              error_marker;
              writeln(err, <span class="stri">"CHAIN "</span> &lt;&amp; literal(param1) &lt;&amp; <span class="stri">" - FILE NOT FOUND."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"STRING EXPECTED FOR CHAIN - FOUND "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">"."</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"CIRCLE"</span>}:
          exec_circle(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"CLEAR"</span>}:
          exec_clear(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"CLOSE"</span>, <span class="stri">"CLOSE#"</span>}:
          exec_close(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"CLS"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"0"</span> <span class="op">or</span> symbol = <span class="stri">"1"</span> <span class="op">or</span> symbol = <span class="stri">"2"</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          clear(win);
          setPos(win, 1, 1);
          line_marker;
          writeln(log, <span class="stri">"CLS"</span>);
        <span class="keywd">when</span> {<span class="stri">"COLOR"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            exec_let(<span class="stri">"COLOR"</span>, symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"COLOR"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"SKIP LABEL: COLOR"</span>);
          <span class="keywd">else</span>
            <span class="keywd">if</span> symbol &lt;> <span class="stri">","</span> <span class="keywd">then</span>
              foreground_color := round(exec_expr(symbol, line));
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
              background_color := round(exec_expr(symbol, line));
              <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
                symbol := get_symbol(line);
                index1 := round(exec_expr(symbol, line));
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            line_marker;
            writeln(log, <span class="stri">"**COLOR "</span> &lt;&amp; foreground_color &lt;&amp; <span class="stri">","</span> &lt;&amp; background_color);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"COMMON"</span>}:
          line_marker;
          writeln(log, <span class="stri">"**COMMON "</span> &lt;&amp; line);
          <span class="keywd">repeat</span>
            symbol := get_symbol(line);
          <span class="keywd">until</span> endOfStatement(symbol);
        <span class="keywd">when</span> {<span class="stri">"CONST"</span>}:
          <span class="keywd">repeat</span>
            symbol := get_symbol(line);
            <span class="keywd">if</span> isStringVar(symbol) <span class="keywd">then</span>
              variable_name := get_name(symbol, line);
              <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="keywd">then</span>
                symbol := get_symbol(line);
                param3 := exec_str_expr(symbol, line, unused_name);
                setStringVar(variable_name, param3);
                line_marker;
                writeln(log, <span class="stri">"CONST "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">"="</span> &lt;&amp; literal(param3));
              <span class="keywd">else</span>
                error_marker;
                writeln(err, <span class="stri">"\"=\" EXPECTED AFTER "</span> &lt;&amp; literal(variable_name) &lt;&amp;
                    <span class="stri">" - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">elsif</span> isNumericVar(symbol) <span class="keywd">then</span>
              variable_name := get_name(symbol, line);
              <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="keywd">then</span>
                symbol := get_symbol(line);
                num1 := exec_expr(symbol, line);
                setNumericVar(variable_name, num1);
                line_marker;
                writeln(log, <span class="stri">"CONST "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">"="</span> &lt;&amp; num1);
              <span class="keywd">else</span>
                error_marker;
                writeln(err, <span class="stri">"\"=\" EXPECTED AFTER "</span> &lt;&amp; literal(variable_name) &lt;&amp;
                    <span class="stri">" - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">else</span>
              error_marker;
              writeln(err, <span class="stri">"VARIABLE EXPECTED - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">until</span> symbol &lt;> <span class="stri">","</span>;
        <span class="keywd">when</span> {<span class="stri">"DATA"</span>, <span class="stri">"DATA&amp;"</span>}:
          symbol := <span class="stri">""</span>;
          line_marker;
          writeln(log, <span class="stri">"DATA"</span>);
        <span class="keywd">when</span> {<span class="stri">"DECLARE"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"SUB"</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            sub_declared @:= [symbol] file_line_number;
            line_marker;
            writeln(log, <span class="stri">"**DECLARE SUB "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">" "</span> &lt;&amp; line);
            <span class="keywd">repeat</span>
              symbol := get_symbol(line);
            <span class="keywd">until</span> endOfStatement(symbol);
          <span class="keywd">elsif</span> symbol = <span class="stri">"FUNCTION"</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            line_marker;
            writeln(log, <span class="stri">"**DECLARE FUNCTION "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">" "</span> &lt;&amp; line);
            <span class="keywd">repeat</span>
              symbol := get_symbol(line);
            <span class="keywd">until</span> endOfStatement(symbol);
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"ILLEGAL DECLARE "</span> &lt;&amp; symbol);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"DECR"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            exec_let(<span class="stri">"DECR"</span>, symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"DECR"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"SKIP LABEL: DECR"</span>);
          <span class="keywd">else</span>
            variable_name := get_name(symbol, line);
            <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
              num1 := exec_expr(symbol, line);
            <span class="keywd">else</span>
              num1 := 1.0;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            setNumericVar(variable_name, getNumericVar(variable_name) - num1);
            line_marker;
            writeln(log, <span class="stri">"DECR "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">" BY "</span> &lt;&amp; num1);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"DEF"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"SEG"</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
              <span class="keywd">if</span> symbol = <span class="stri">"VARSEG"</span> <span class="keywd">then</span>
                symbol := get_symbol(line);
                expect(<span class="stri">"("</span>, symbol, line);
                varseg_variable := get_name(symbol, line);
                expect(<span class="stri">")"</span>, symbol, line);
                line_marker;
                writeln(log, <span class="stri">"**DEF SEG = VARSEG("</span> &lt;&amp; varseg_variable &lt;&amp; <span class="stri">")"</span>);
              <span class="keywd">else</span>
                index1 := round(exec_expr(symbol, line));
                line_marker;
                writeln(log, <span class="stri">"**DEF SEG = "</span> &lt;&amp; index1);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">else</span>
              line_marker;
              writeln(log, <span class="stri">"**DEF SEG"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            variable_name := symbol;
            <span class="keywd">if</span> variable_name[1] >= <span class="stri">'A'</span> <span class="op">and</span> variable_name[1] &lt;= <span class="stri">'Z'</span> <span class="keywd">then</span>
              define_function(variable_name, symbol, line, TRUE);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"DEFDBL"</span>}:
          exec_defType_numeric(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"DEFINT"</span>}:
          exec_defType_numeric(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"DEFLNG"</span>}:
          exec_defType_numeric(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"DEFSNG"</span>}:
          exec_defType_numeric(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"DEFSTR"</span>}:
          exec_defstr(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"DELAY"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            exec_let(<span class="stri">"DELAY"</span>, symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"DELAY"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"SKIP LABEL: DELAY"</span>);
          <span class="keywd">else</span>
            num1 := exec_expr(symbol, line);
            flush(win);
            delay(num1);
            line_marker;
            writeln(log, <span class="stri">"DELAY "</span> &lt;&amp; num1);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"DIM"</span>}:
          exec_dim(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"DISPLAY"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            exec_let(<span class="stri">"DISPLAY"</span>, symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"DISPLAY"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"SKIP LABEL: DISPLAY"</span>);
          <span class="keywd">else</span>
            exec_display(symbol, line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"DO"</span>}:
          exec_do(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"DRAW"</span>}:
          exec_draw(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"ELSE"</span>}:
          exec_else(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"ELSEIF"</span>}:
          line_marker;
          writeln(log, <span class="stri">"ELSEIF - THE \"THEN\" BLOCK BEFORE WAS EXECUTED"</span>);
          symbol := find_end_if(line);
          <span class="keywd">if</span> symbol = <span class="stri">"IF"</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            line_marker;
            writeln(log, <span class="stri">"END IF"</span>);
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"ELSEIF - MISSING \"END IF\"."</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"ENDIF"</span>}:
          symbol := get_symbol(line);
          line_marker;
          writeln(log, <span class="stri">"END IF - THE \"THEN\" OR \"ELSE\" BLOCK BEFORE WAS EXECUTED"</span>);
        <span class="keywd">when</span> {<span class="stri">"END"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"IF"</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            line_marker;
            writeln(log, <span class="stri">"END IF - THE \"THEN\" OR \"ELSE\" BLOCK BEFORE WAS EXECUTED"</span>);
          <span class="keywd">elsif</span> symbol = <span class="stri">"SELECT"</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            line_marker;
            writeln(log, <span class="stri">"END SELECT"</span>);
          <span class="keywd">elsif</span> symbol = <span class="stri">"SUB"</span> <span class="keywd">then</span>
            <span class="keywd">if</span> length(gosubReturn) >= 1 <span class="keywd">then</span>
              check_loop_stacks_before_return(<span class="stri">"END SUB "</span> &amp; gosubReturn[1].subName);
              line_marker;
              write(log, <span class="stri">"END SUB "</span> &lt;&amp; gosubReturn[1].subName &lt;&amp; <span class="stri">" - RETURN TO "</span>);
              do_return(symbol, line);
              line_marker;
              writeln(log);
            <span class="keywd">else</span>
              symbol := get_symbol(line);
              error_marker;
              writeln(err, <span class="stri">"END SUB - RETURN WITHOUT CALL."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> symbol = <span class="stri">"FUNCTION"</span> <span class="keywd">then</span>
            <span class="keywd">if</span> length(gosubReturn) >= 1 <span class="keywd">then</span>
              check_loop_stacks_before_return(<span class="stri">"END FUNCTION "</span> &amp; gosubReturn[1].subName);
              line_marker;
              writeln(log, <span class="stri">"END FUNCTION "</span> &lt;&amp; gosubReturn[1].subName);
              symbol := <span class="stri">""</span>;
              running := FALSE;
            <span class="keywd">else</span>
              symbol := get_symbol(line);
              error_marker;
              writeln(err, <span class="stri">"END FUNCTION - RETURN WITHOUT CALL."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> endOfStatement(symbol) <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"END"</span>);
            symbol := <span class="stri">""</span>;
            running := FALSE;
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"UNEXPECTED SYMBOL AFTER END "</span> &lt;&amp; literal(symbol));
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"ERASE"</span>}:
          line_marker;
          writeln(log, <span class="stri">"**ERASE "</span> &lt;&amp; line);
          <span class="keywd">repeat</span>
            symbol := get_symbol(line);
          <span class="keywd">until</span> endOfStatement(symbol);
        <span class="keywd">when</span> {<span class="stri">"ERROR"</span>}:
          symbol := get_symbol(line);
          error_code := round(exec_expr(symbol, line));
          <span class="keywd">if</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"ERROR "</span> &lt;&amp; error_code &lt;&amp;
                <span class="stri">" - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
            goto_on_error(on_error_label, line);
            symbol := <span class="stri">""</span>;
            line := <span class="stri">""</span>;
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"ERROR "</span> &lt;&amp; error_code &lt;&amp; <span class="stri">" WITHOUT ON ERROR HANDLER."</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"EXIT"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"FOR"</span> <span class="keywd">then</span>
            <span class="keywd">if</span> length(forLoop) = 0 <span class="keywd">then</span>
              error_marker;
              write(err, <span class="stri">"EXIT FOR - NOT INSIDE \"FOR\" LOOP"</span>);
            <span class="keywd">else</span>
              line_marker;
              writeln(log, <span class="stri">"EXIT FOR "</span> &lt;&amp; forLoop[1].varName);
              param1 := statement_label;
              symbol := <span class="stri">""</span>;
              <span class="keywd">if</span> find_next(symbol, line, forLoop[1].varName) <span class="keywd">then</span>
                forLoop := forLoop[2 .. ];
              <span class="keywd">else</span>
                error_marker(param1);
                writeln(err, <span class="stri">"NO CORRESPONDING \"NEXT\" OR \"NEXT "</span> &lt;&amp;
                    forLoop[1].varName &lt;&amp; <span class="stri">"\" FOUND FOR \"EXIT FOR\""</span>);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> symbol = <span class="stri">"DO"</span> <span class="op">or</span> symbol = <span class="stri">"LOOP"</span> <span class="keywd">then</span>
            param1 := statement_label;
            symbol := find_loop(line);
            <span class="keywd">if</span> symbol = <span class="stri">"LOOP"</span> <span class="keywd">then</span>
              doLoop := doLoop[2 .. ];
              line_marker;
              <span class="keywd">repeat</span>
                symbol := get_symbol(line);
              <span class="keywd">until</span> endOfStatement(symbol);
              writeln(log, <span class="stri">"EXIT DO"</span>);
            <span class="keywd">else</span>
              error_marker(param1);
              writeln(err, <span class="stri">"NO CORRESPONDING \"LOOP\" FOUND FOR \"EXIT DO\""</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> symbol = <span class="stri">"SELECT"</span> <span class="keywd">then</span>
            param1 := statement_label;
            symbol := find_end_select(line);
            <span class="keywd">if</span> symbol = <span class="stri">"SELECT"</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
              line_marker;
              writeln(log, <span class="stri">"EXIT SELECT"</span>);
            <span class="keywd">else</span>
              error_marker(param1);
              writeln(err, <span class="stri">"NO \"END SELECT\" FOUND"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> symbol = <span class="stri">"SUB"</span> <span class="keywd">then</span>
            <span class="keywd">if</span> length(gosubReturn) >= 1 <span class="keywd">then</span>
              check_loop_stacks_before_return(<span class="stri">"EXIT SUB "</span> &amp; gosubReturn[1].subName);
              line_marker;
              write(log, <span class="stri">"EXIT SUB "</span> &lt;&amp; gosubReturn[1].subName &lt;&amp; <span class="stri">" - RETURN TO "</span>);
              do_return(symbol, line);
              line_marker;
              writeln(log);
            <span class="keywd">else</span>
              symbol := get_symbol(line);
              error_marker;
              writeln(err, <span class="stri">"EXIT SUB - RETURN WITHOUT CALL."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> symbol = <span class="stri">"FUNCTION"</span> <span class="keywd">then</span>
            <span class="keywd">if</span> length(gosubReturn) >= 1 <span class="keywd">then</span>
              check_loop_stacks_before_return(<span class="stri">"EXIT FUNCTION "</span> &amp; gosubReturn[1].subName);
              line_marker;
              write(log, <span class="stri">"EXIT FUNCTION "</span> &lt;&amp; gosubReturn[1].subName &lt;&amp; <span class="stri">" - RETURN TO "</span>);
              do_return(symbol, line);
              line_marker;
              writeln(log);
            <span class="keywd">else</span>
              symbol := get_symbol(line);
              error_marker;
              writeln(err, <span class="stri">"EXIT FUNCTION - RETURN WITHOUT CALL."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"ILLEGAL STATEMENT \"EXIT "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">"\""</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"FIELD"</span>, <span class="stri">"FIELD#"</span>}:
          <span class="keywd">if</span> symbol = <span class="stri">"FIELD#"</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
          <span class="keywd">else</span>
            symbol := get_symbol(line);
            <span class="keywd">if</span> symbol = <span class="stri">"#"</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          index1 := round(exec_expr(symbol, line));
          field_value[index1] := 0 <span class="op">times</span> <span class="stri">""</span>;
          <span class="keywd">while</span> symbol = <span class="stri">","</span> <span class="keywd">do</span>
            symbol := get_symbol(line);
            index2 := round(exec_expr(symbol, line));
            <span class="keywd">if</span> symbol = <span class="stri">"AS"</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
            <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"AS"</span>) <span class="keywd">then</span>
              symbol := symbol[3 ..];
            <span class="keywd">else</span>
              error_expect(<span class="stri">"AS"</span>, symbol);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> isStringVar(symbol) <span class="keywd">then</span>
              variable_name := get_name(symbol, line);
              setStringVar(variable_name, <span class="stri">""</span> <span class="op">lpad</span> index2);
              field_value[index1] &amp;:= [] (variable_name);
              line_marker;
              writeln(log, <span class="stri">"FIELD #"</span> &lt;&amp; index1 &lt;&amp; <span class="stri">", "</span> &lt;&amp; index2 &lt;&amp;
                  <span class="stri">" AS "</span> &lt;&amp; variable_name);
            <span class="keywd">else</span>
              error_marker;
              writeln(err, <span class="stri">"STRING VARIABLE EXPECTED AS FIELD - FOUND "</span> &lt;&amp;
                  literal(symbol) &lt;&amp; <span class="stri">"."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">when</span> {<span class="stri">"FILES"</span>}:
          exec_files(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"FLASH"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            exec_let(<span class="stri">"FLASH"</span>, symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"FLASH"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"SKIP LABEL: FLASH"</span>);
          <span class="keywd">else</span>
            line_marker;
            writeln(log, <span class="stri">"**FLASH"</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"FOR"</span>}:
          exec_for(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"FUNCTION"</span>}:
          symbol := get_symbol(line);
          line_marker;
          writeln(log, <span class="stri">"SKIP FUNCTION "</span> &lt;&amp; symbol);
          symbol := find_end_function(line);
          symbol := get_symbol(line);
          line_marker;
          writeln(log, <span class="stri">"END SKIP FUNCTION "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">" "</span> &lt;&amp; line);
        <span class="keywd">when</span> {<span class="stri">"GET"</span>, <span class="stri">"GET#"</span>}:
          <span class="keywd">if</span> symbol = <span class="stri">"GET#"</span> <span class="keywd">then</span>
            symbol := <span class="stri">"#"</span>;
          <span class="keywd">else</span>
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> symbol = <span class="stri">"("</span> <span class="op">or</span> symbol = <span class="stri">"STEP"</span> <span class="keywd">then</span>
            exec_get(symbol, line);
          <span class="keywd">elsif</span> isStringVar(symbol) <span class="keywd">then</span>
            variable_name := get_name(symbol, line);
            line_marker;
            write(log, <span class="stri">"GET "</span> &lt;&amp; variable_name);
            flush(log);
            flush(win);
            current_key := getc(KEYBOARD);
            setStringVar(variable_name, str(current_key));
            <span class="keywd">if</span> current_key <span class="op">in</span> keyDescription <span class="keywd">then</span>
              write(log, <span class="stri">" ("</span> &lt;&amp; keyDescription[current_key] &lt;&amp; <span class="stri">")"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            writeln(log);
          <span class="keywd">else</span>
            exec_file_get(symbol, line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"GO"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"TO"</span> <span class="keywd">then</span>
            exec_goto(symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            exec_let(<span class="stri">"GO"</span>, symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"GO"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"SKIP LABEL: GO"</span>);
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"UNEXPECTED SYMBOL \"GO\"."</span>);
            <span class="keywd">repeat</span>
              symbol := get_symbol(line);
            <span class="keywd">until</span> endOfStatement(symbol);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"GOSUB"</span>}:
          exec_gosub(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"GOTO"</span>}:
          exec_goto(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"GR"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            exec_let(<span class="stri">"GR"</span>, symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"GR"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"SKIP LABEL: GR"</span>);
          <span class="keywd">else</span>
            <span class="comment"># Lo-Res Graphics</span>
            screen(320, 200);
            win := open(curr_win, 8);
            <span class="keywd">if</span> curr_win &lt;> PRIMITIVE_WINDOW.value <span class="keywd">then</span>
              clear(curr_win, black);
              color(white, black);
              scr := open(curr_win);
              KEYBOARD := GRAPH_KEYBOARD;
              OUT := win;
              IN := openEcho(KEYBOARD, OUT);
              IN := openLine(IN);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            line_marker;
            writeln(log, <span class="stri">"GR"</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"HGR"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            exec_let(<span class="stri">"HGR"</span>, symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"HGR"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"SKIP LABEL: HGR"</span>);
          <span class="keywd">else</span>
            <span class="comment"># Hi-Res Graphics</span>
            screen(320, 200);
            win := open(curr_win, 8);
            <span class="keywd">if</span> curr_win &lt;> PRIMITIVE_WINDOW.value <span class="keywd">then</span>
              clear(curr_win, black);
              color(white, black);
              scr := open(curr_win);
              KEYBOARD := GRAPH_KEYBOARD;
              OUT := win;
              IN := openEcho(KEYBOARD, OUT);
              IN := openLine(IN);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            line_marker;
            writeln(log, <span class="stri">"HGR"</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"HOME"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            exec_let(<span class="stri">"HOME"</span>, symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"HOME"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"SKIP LABEL: HOME"</span>);
          <span class="keywd">else</span>
            clear(win);
            setPos(win, 1, 1);
            line_marker;
            writeln(log, <span class="stri">"HOME"</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"HPLOT"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            exec_let(<span class="stri">"HPLOT"</span>, symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"HPLOT"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"SKIP LABEL: HPLOT"</span>);
          <span class="keywd">else</span>
            exec_hplot(symbol, line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"HTAB"</span>}:
          <span class="keywd">if</span> is_let_statement(line) <span class="keywd">then</span>
            symbol := get_symbol(line);
            exec_let(<span class="stri">"HTAB"</span>, symbol, line);
          <span class="keywd">else</span>
            symbol := get_symbol(line);
            <span class="keywd">if</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"HTAB"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
              line_marker;
              writeln(log, <span class="stri">"SKIP LABEL: HTAB"</span>);
            <span class="keywd">else</span>
              index1 := line(win);
              index2 := round(exec_expr(symbol, line));
              setPos(win, index1, index2);
              line_marker;
              writeln(log, <span class="stri">"HTAB "</span> &lt;&amp; index2);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"IF"</span>}:
          exec_if(symbol, line, process_next);
        <span class="keywd">when</span> {<span class="stri">"INCR"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            exec_let(<span class="stri">"INCR"</span>, symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"INCR"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"SKIP LABEL: INCR"</span>);
          <span class="keywd">else</span>
            variable_name := get_name(symbol, line);
            <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
              num1 := exec_expr(symbol, line);
            <span class="keywd">else</span>
              num1 := 1.0;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            setNumericVar(variable_name, getNumericVar(variable_name) + num1);
            line_marker;
            writeln(log, <span class="stri">"INCR "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">" BY "</span> &lt;&amp; num1);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"INP"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            exec_let(<span class="stri">"INP"</span>, symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"INP"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"SKIP LABEL: INP"</span>);
          <span class="keywd">else</span>
            exec_input(symbol, line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"INPUT"</span>, <span class="stri">"INPUT#"</span>}:
          <span class="keywd">if</span> symbol = <span class="stri">"INPUT#"</span> <span class="keywd">then</span>
            symbol := <span class="stri">"#"</span>;
          <span class="keywd">else</span>
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> symbol = <span class="stri">"#"</span> <span class="keywd">then</span>
            exec_input_from_file(symbol, line);
          <span class="keywd">else</span>
            exec_input(symbol, line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"INVERSE"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            exec_let(<span class="stri">"INVERSE"</span>, symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"INVERSE"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"SKIP LABEL: INVERSE"</span>);
          <span class="keywd">else</span>
            line_marker;
            writeln(log, <span class="stri">"**INVERSE"</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"KEY"</span>}:
          line_marker;
          writeln(log, <span class="stri">"**KEY "</span> &lt;&amp; line);
          <span class="keywd">repeat</span>
            symbol := get_symbol(line);
          <span class="keywd">until</span> endOfStatement(symbol);
        <span class="keywd">when</span> {<span class="stri">"LINE"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"INPUT"</span> <span class="op">or</span> symbol = <span class="stri">"INPUT#"</span> <span class="keywd">then</span>
            <span class="keywd">if</span> symbol = <span class="stri">"INPUT#"</span> <span class="keywd">then</span>
              symbol := <span class="stri">"#"</span>;
            <span class="keywd">else</span>
              symbol := get_symbol(line);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> symbol = <span class="stri">"#"</span> <span class="keywd">then</span>
              exec_line_input_from_file(symbol, line);
            <span class="keywd">else</span>
              exec_line_input(symbol, line);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> symbol = <span class="stri">"("</span> <span class="op">or</span> symbol = <span class="stri">"-"</span> <span class="op">or</span> symbol = <span class="stri">"STEP"</span> <span class="keywd">then</span>
            exec_line(symbol, line);
          <span class="keywd">else</span>
            expect(<span class="stri">"INPUT"</span>, symbol, line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"LINPUT"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"#"</span> <span class="keywd">then</span>
            exec_linput_from_file(symbol, line);
          <span class="keywd">else</span>
            exec_linput(symbol, line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"LINPUT#"</span>}:
          exec_linput_from_file(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"LIST"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol &lt;> <span class="stri">""</span> <span class="op">and</span> symbol[1] <span class="op">in</span> digit_char <span class="keywd">then</span>
            index1 := integer(symbol);
            symbol := get_symbol(line);
            <span class="keywd">if</span> symbol = <span class="stri">"-"</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
              <span class="keywd">if</span> symbol &lt;> <span class="stri">""</span> <span class="op">and</span> symbol[1] <span class="op">in</span> digit_char <span class="keywd">then</span>
                index2 := integer(symbol);
                symbol := get_symbol(line);
              <span class="keywd">else</span>
                index2 := MAX_LINENUM;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">else</span>
              index2 := index1;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            index1 := 0;
            <span class="keywd">if</span> symbol = <span class="stri">"-"</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
              <span class="keywd">if</span> symbol &lt;> <span class="stri">""</span> <span class="op">and</span> symbol[1] <span class="op">in</span> digit_char <span class="keywd">then</span>
                index2 := integer(symbol);
                symbol := get_symbol(line);
              <span class="keywd">else</span>
                index2 := MAX_LINENUM;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">else</span>
              index2 := MAX_LINENUM;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          writeln(log, <span class="stri">"LIST "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">"-"</span> &lt;&amp; index2);
          listProg(win, index1, index2);
        <span class="keywd">when</span> {<span class="stri">"LOAD"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> isStringExpr(symbol) <span class="keywd">then</span>
            param1 := exec_str_expr(symbol, line, variable_name);
            clearProgram;
            <span class="keywd">if</span> runOrChain(<span class="stri">"LOAD"</span>, param1) <span class="keywd">then</span>
              writeln(log, <span class="stri">"load program finished"</span>);
              line_marker;
              writeln(log, <span class="stri">"LOAD "</span> &lt;&amp; literal(param1) &lt;&amp; <span class="stri">" - "</span> &lt;&amp;
                  length(prg) &lt;&amp; <span class="stri">" LINES"</span>);
              file_line_number := 0;
              symbol := <span class="stri">""</span>;
              line := <span class="stri">""</span>;
            <span class="keywd">elsif</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
              error_code := 53; <span class="comment"># File not found</span>
              line_marker;
              writeln(log, error_code &lt;&amp; <span class="stri">" LOAD "</span> &lt;&amp; literal(param1) &lt;&amp;
                  <span class="stri">" - FILE NOT FOUND - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
              goto_on_error(on_error_label, line);
              symbol := <span class="stri">""</span>;
              line := <span class="stri">""</span>;
            <span class="keywd">else</span>
              error_marker;
              writeln(err, <span class="stri">"LOAD "</span> &lt;&amp; literal(param1) &lt;&amp; <span class="stri">" - FILE NOT FOUND."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"STRING EXPECTED FOR LOAD - FOUND "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">"."</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"LOCATE"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="op">or</span> endOfStatement(symbol) <span class="keywd">then</span>
            index1 := line(win);
          <span class="keywd">else</span>
            index1 := round(exec_expr(symbol, line));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="op">or</span> endOfStatement(symbol) <span class="keywd">then</span>
            index2 := column(win);
          <span class="keywd">else</span>
            index2 := round(exec_expr(symbol, line));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="op">or</span> endOfStatement(symbol) <span class="keywd">then</span>
            okay := FALSE;
          <span class="keywd">else</span>
            okay := TRUE;
            num1 := exec_expr(symbol, line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> symbol &lt;> <span class="stri">","</span> <span class="op">and</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">then</span>
            ignore(exec_expr(symbol, line));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">then</span>
            ignore(exec_expr(symbol, line));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          setPos(win, index1, index2);
          <span class="keywd">if</span> okay <span class="keywd">then</span>
            <span class="keywd">if</span> round(num1) = 0 <span class="keywd">then</span>
              cursor(scr, FALSE);
            <span class="keywd">else</span>
              cursor(scr, TRUE);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          line_marker;
          write(log, <span class="stri">"LOCATE "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">", "</span> &lt;&amp; index2);
          <span class="keywd">if</span> okay <span class="keywd">then</span>
            write(log, <span class="stri">", "</span> &lt;&amp; num1);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          writeln(log);
        <span class="keywd">when</span> {<span class="stri">"LOOP"</span>}:
          exec_loop(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"LPRINT"</span>}:
          symbol := get_symbol(line);
          exec_print(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"LSET"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> isStringVar(symbol) <span class="keywd">then</span>
            variable_name := get_name(symbol, line);
            <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
              param3 := exec_str_expr(symbol, line, unused_name);
              index1 := length(getStringVar(variable_name));
              <span class="keywd">if</span> length(param3) &lt;= index1 <span class="keywd">then</span>
                param3 := param3 <span class="op">rpad</span> index1;
              <span class="keywd">else</span>
                param3 := param3[.. index1];
              <span class="keywd">end</span> <span class="keywd">if</span>;
              setStringVar(variable_name, param3);
              line_marker;
              writeln(log, <span class="stri">"LSET "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">"="</span> &lt;&amp; literal(param3));
            <span class="keywd">else</span>
              error_marker;
              writeln(err, <span class="stri">"\"=\" EXPECTED AFTER \"LSET "</span> &lt;&amp; variable_name &lt;&amp;
                  <span class="stri">"\" - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"STRING VARIABLE EXPECTED AFTER LSET - FOUND "</span> &lt;&amp;
                literal(symbol) &lt;&amp; <span class="stri">"."</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"MID$"</span>}:
          exec_mid_statement(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"MID"</span>}:
          line_marker;
          writeln(log, <span class="stri">"ASSUMING A MID$ STATEMENT"</span>);
          exec_mid_statement(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"NEXT"</span>}:
          exec_next(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"NORMAL"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            exec_let(<span class="stri">"NORMAL"</span>, symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"NORMAL"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"SKIP LABEL: NORMAL"</span>);
          <span class="keywd">else</span>
            line_marker;
            writeln(log, <span class="stri">"**NORMAL"</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"ON"</span>}:
          exec_on(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"OPEN"</span>}:
          exec_open(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"OPTION"</span>}:
          line_marker;
          writeln(log, <span class="stri">"OPTION "</span> &lt;&amp; line);
          <span class="keywd">repeat</span>
            symbol := get_symbol(line);
          <span class="keywd">until</span> endOfStatement(symbol);
        <span class="keywd">when</span> {<span class="stri">"OUT"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            exec_let(<span class="stri">"OUT"</span>, symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"OUT"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"SKIP LABEL: OUT"</span>);
          <span class="keywd">else</span>
            symbol := get_symbol(line);
            index1 := round(exec_expr(symbol, line));
            expect(<span class="stri">","</span>, symbol, line);
            index2 := round(exec_expr(symbol, line));
            line_marker;
            writeln(log, <span class="stri">"**OUT "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">", "</span> &lt;&amp; index2);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"PAINT"</span>}:
          line_marker;
          writeln(log, <span class="stri">"**PAINT "</span> &lt;&amp; line);
          <span class="keywd">repeat</span>
            symbol := get_symbol(line);
          <span class="keywd">until</span> endOfStatement(symbol);
        <span class="keywd">when</span> {<span class="stri">"PALETTE"</span>}:
          line_marker;
          writeln(log, <span class="stri">"**PALETTE "</span> &lt;&amp; line);
          <span class="keywd">repeat</span>
            symbol := get_symbol(line);
          <span class="keywd">until</span> endOfStatement(symbol);
        <span class="keywd">when</span> {<span class="stri">"PLAY"</span>}:
          symbol := get_symbol(line);
          line_marker;
          writeln(log, <span class="stri">"**PLAY "</span> &lt;&amp; line);
          <span class="keywd">repeat</span>
            symbol := get_symbol(line);
          <span class="keywd">until</span> endOfStatement(symbol);
        <span class="keywd">when</span> {<span class="stri">"PLOT"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            exec_let(<span class="stri">"PLOT"</span>, symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"PLOT"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"SKIP LABEL: PLOT"</span>);
          <span class="keywd">else</span>
            exec_plot(symbol, line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"POKE"</span>}:
          symbol := get_symbol(line);
          index1 := round(exec_expr(symbol, line));
          expect(<span class="stri">","</span>, symbol, line);
          index2 := round(exec_expr(symbol, line));
          line_marker;
          writeln(log, <span class="stri">"**POKE "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">", "</span> &lt;&amp; index2);
        <span class="keywd">when</span> {<span class="stri">"PR"</span>, <span class="stri">"PR#"</span>}:
          <span class="keywd">if</span> symbol = <span class="stri">"PR#"</span> <span class="keywd">then</span>
            symbol := <span class="stri">"#"</span>;
          <span class="keywd">else</span>
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            exec_let(<span class="stri">"PR"</span>, symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"PR"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"SKIP LABEL: PR"</span>);
          <span class="keywd">elsif</span> symbol = <span class="stri">"#"</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
              exec_let(<span class="stri">"PR#"</span>, symbol, line);
            <span class="keywd">else</span>
              index1 := round(exec_expr(symbol, line));
              line_marker;
              writeln(log, <span class="stri">"**PR#"</span> &lt;&amp; index1);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"\"=\" EXPECTED AFTER \"PR\" - FOUND "</span> &lt;&amp;
                    literal(symbol) &lt;&amp; <span class="stri">"."</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"PRESET"</span>}:
          exec_preset(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"PRI"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            exec_let(<span class="stri">"PRI"</span>, symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"PRI"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"SKIP LABEL: PRI"</span>);
          <span class="keywd">else</span>
            exec_print(symbol, line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"PRINT"</span>, <span class="stri">"PRINT#"</span>, <span class="stri">"?"</span>}:
          <span class="keywd">if</span> symbol = <span class="stri">"PRINT#"</span> <span class="keywd">then</span>
            symbol := <span class="stri">"#"</span>;
          <span class="keywd">else</span>
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> symbol = <span class="stri">"#"</span> <span class="keywd">then</span>
            exec_print_to_file(symbol, line);
          <span class="keywd">else</span>
            <span class="keywd">if</span> symbol = <span class="stri">"USING"</span> <span class="keywd">then</span>
              line_marker;
              write(log, <span class="stri">"PRINT "</span>);
              exec_print_using(win, symbol, line);
            <span class="keywd">else</span>
              exec_print(symbol, line);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"PSET"</span>}:
          exec_pset(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"PUT"</span>, <span class="stri">"PUT#"</span>}:
          <span class="keywd">if</span> symbol = <span class="stri">"PUT#"</span> <span class="keywd">then</span>
            symbol := <span class="stri">"#"</span>;
          <span class="keywd">else</span>
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> symbol = <span class="stri">"("</span> <span class="op">or</span> symbol = <span class="stri">"STEP"</span> <span class="keywd">then</span>
            exec_put(symbol, line);
          <span class="keywd">else</span>
            exec_file_put(symbol, line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"RANDOMIZE"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">then</span>
            num1 := exec_expr(symbol, line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          line_marker;
          writeln(log, <span class="stri">"RANDOMIZE"</span>);
        <span class="keywd">when</span> {<span class="stri">"READ"</span>}:
          exec_read(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"REDIM"</span>}:
          line_marker;
          writeln(log, <span class="stri">"REDIM "</span> &lt;&amp; line);
          <span class="keywd">repeat</span>
            symbol := get_symbol(line);
          <span class="keywd">until</span> endOfStatement(symbol);
        <span class="keywd">when</span> {<span class="stri">"REM"</span>}:
          symbol := <span class="stri">""</span>;
          line_marker;
          writeln(log, <span class="stri">"REM "</span> &lt;&amp; line);
        <span class="keywd">when</span> {<span class="stri">"RESET"</span>}:
          symbol := get_symbol(line);
          closeAllFiles;
          line_marker;
          writeln(log, <span class="stri">"RESET"</span>);
        <span class="keywd">when</span> {<span class="stri">"RESTORE"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> label_or_linenum(symbol) <span class="keywd">then</span>
            data_line_number := label[symbol];
            decr(data_line_number);
            data_line := <span class="stri">""</span>;
            line_marker;
            writeln(log, <span class="stri">"RESTORE "</span> &lt;&amp; symbol);
            symbol := get_symbol(line);
          <span class="keywd">else</span>
            data_line_number := 0;
            data_line := <span class="stri">""</span>;
            line_marker;
            writeln(log, <span class="stri">"RESTORE"</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"RESUME"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"NEXT"</span> <span class="keywd">then</span>
            <span class="keywd">if</span> in_error_handler <span class="keywd">then</span>
              line_marker;
              writeln(log, <span class="stri">"RESUME NEXT"</span>);
              do_resume_next(symbol, line);
              <span class="keywd">if</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">then</span>
                process_next := TRUE;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">elsif</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
              error_code := 20; <span class="comment"># RESUME without error</span>
              line_marker;
              writeln(log, error_code &lt;&amp; <span class="stri">" RESUME NEXT WITHOUT ERROR"</span> &lt;&amp;
                  <span class="stri">" - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
              goto_on_error(on_error_label, line);
              symbol := <span class="stri">""</span>;
              line := <span class="stri">""</span>;
            <span class="keywd">else</span>
              error_marker;
              writeln(err, <span class="stri">"RESUME NEXT - NOT IN ERROR HANDLER."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> label_or_linenum(symbol) <span class="keywd">then</span>
            <span class="keywd">if</span> in_error_handler <span class="keywd">then</span>
              line_marker;
              writeln(log, <span class="stri">"RESUME "</span> &lt;&amp; symbol);
              goto_label_or_linenum(symbol);
              in_error_handler := FALSE;
              symbol := <span class="stri">""</span>;
              line := <span class="stri">""</span>;
            <span class="keywd">elsif</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
              param1 := symbol;
              symbol := get_symbol(line);
              error_code := 20; <span class="comment"># RESUME without error</span>
              line_marker;
              writeln(log, error_code &lt;&amp; <span class="stri">" RESUME "</span> &lt;&amp; param1 &lt;&amp; <span class="stri">" WITHOUT ERROR"</span> &lt;&amp;
                  <span class="stri">" - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
              goto_on_error(on_error_label, line);
              symbol := <span class="stri">""</span>;
              line := <span class="stri">""</span>;
            <span class="keywd">else</span>
              error_marker;
              writeln(err, <span class="stri">"RESUME "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">" - NOT IN ERROR HANDLER."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> symbol = <span class="stri">"0"</span> <span class="op">or</span> endOfStatement(symbol) <span class="keywd">then</span>
            <span class="keywd">if</span> in_error_handler <span class="keywd">then</span>
              do_resume_same(symbol, line);
            <span class="keywd">elsif</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
              <span class="keywd">if</span> symbol = <span class="stri">"0"</span> <span class="keywd">then</span>
                symbol := get_symbol(line);
              <span class="keywd">end</span> <span class="keywd">if</span>;
              error_code := 20; <span class="comment"># RESUME without error</span>
              line_marker;
              writeln(log, error_code &lt;&amp; <span class="stri">" RESUME 0 WITHOUT ERROR"</span> &lt;&amp;
                  <span class="stri">" - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
              goto_on_error(on_error_label, line);
              symbol := <span class="stri">""</span>;
              line := <span class="stri">""</span>;
            <span class="keywd">else</span>
              error_marker;
              writeln(err, <span class="stri">"RESUME 0 - NOT IN ERROR HANDLER."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"RESUME "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">" - UNDEFINED RESUME."</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"RETURN"</span>}:
          <span class="keywd">if</span> length(gosubReturn) >= 1 <span class="keywd">then</span>
            check_loop_stacks_before_return(<span class="stri">"RETURN"</span>);
            line_marker;
            write(log, <span class="stri">"RETURN FROM \"GOSUB "</span>);
            line_marker(gosubReturn[1].subEntryLine);
            write(log, <span class="stri">"\""</span>);
            do_return(symbol, line);
            write(log, <span class="stri">" AT LINE "</span>);
            line_marker;
            writeln(log);
          <span class="keywd">elsif</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            error_code := 3; <span class="comment"># RETURN without GOSUB</span>
            line_marker;
            writeln(log, error_code &lt;&amp; <span class="stri">" RETURN WITHOUT GOSUB"</span> &lt;&amp;
                <span class="stri">" - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
            goto_on_error(on_error_label, line);
            symbol := <span class="stri">""</span>;
            line := <span class="stri">""</span>;
          <span class="keywd">else</span>
            symbol := get_symbol(line);
            error_marker;
            writeln(err, <span class="stri">"RETURN WITHOUT GOSUB."</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"RSET"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> isStringVar(symbol) <span class="keywd">then</span>
            variable_name := get_name(symbol, line);
            <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
              param3 := exec_str_expr(symbol, line, unused_name);
              index1 := length(getStringVar(variable_name));
              <span class="keywd">if</span> length(param3) &lt;= index1 <span class="keywd">then</span>
                param3 := param3 <span class="op">lpad</span> index1;
              <span class="keywd">else</span>
                param3 := param3[.. index1];
              <span class="keywd">end</span> <span class="keywd">if</span>;
              setStringVar(variable_name, param3);
              line_marker;
              writeln(log, <span class="stri">"RSET "</span> &lt;&amp; variable_name &lt;&amp; <span class="stri">"="</span> &lt;&amp; literal(param3));
            <span class="keywd">else</span>
              error_marker;
              writeln(err, <span class="stri">"\"=\" EXPECTED AFTER \"RSET "</span> &lt;&amp; variable_name &lt;&amp;
                  <span class="stri">"\" - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"STRING VARIABLE EXPECTED AFTER RSET - FOUND "</span> &lt;&amp;
                literal(symbol) &lt;&amp; <span class="stri">"."</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"RUN"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> isStringExpr(symbol) <span class="keywd">then</span>
            param1 := exec_str_expr(symbol, line, variable_name);
            clearProgram;
            <span class="keywd">if</span> runOrChain(<span class="stri">"RUN"</span>, param1) <span class="keywd">then</span>
              writeln(log, <span class="stri">"load program finished"</span>);
              line_marker;
              writeln(log, <span class="stri">"RUN "</span> &lt;&amp; literal(param1) &lt;&amp; <span class="stri">" - "</span> &lt;&amp;
                  length(prg) &lt;&amp; <span class="stri">" LINES"</span>);
              file_line_number := 0;
              symbol := <span class="stri">""</span>;
              line := <span class="stri">""</span>;
            <span class="keywd">elsif</span> on_error_label &lt;> <span class="stri">""</span> <span class="keywd">then</span>
              symbol := get_symbol(line);
              error_code := 53; <span class="comment"># File not found</span>
              line_marker;
              writeln(log, error_code &lt;&amp; <span class="stri">" RUN "</span> &lt;&amp; literal(param1) &lt;&amp;
                  <span class="stri">" - FILE NOT FOUND - ON ERROR GOTO "</span> &lt;&amp; on_error_label);
              goto_on_error(on_error_label, line);
              symbol := <span class="stri">""</span>;
              line := <span class="stri">""</span>;
            <span class="keywd">else</span>
              error_marker;
              writeln(err, <span class="stri">"RUN "</span> &lt;&amp; literal(param1) &lt;&amp; <span class="stri">" - FILE NOT FOUND."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> label_or_linenum(symbol) <span class="keywd">then</span>
            clearProgram;
            line_marker;
            writeln(log, <span class="stri">"RUN "</span> &lt;&amp; symbol);
            goto_label_or_linenum(symbol);
            symbol := <span class="stri">""</span>;
            line := <span class="stri">""</span>;
          <span class="keywd">else</span>
            clearProgram;
            line_marker;
            writeln(log, <span class="stri">"RUN"</span>);
            file_line_number := 0;
            symbol := <span class="stri">""</span>;
            line := <span class="stri">""</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"SCREEN"</span>}:
          exec_screen(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"SEEK"</span>, <span class="stri">"SEEK#"</span>}:
          exec_seek(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"SELECT"</span>}:
          exec_select(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"SHARED"</span>}:
          line_marker;
          writeln(log, <span class="stri">"SHARED "</span> &lt;&amp; line);
          <span class="keywd">repeat</span>
            symbol := get_symbol(line);
          <span class="keywd">until</span> endOfStatement(symbol);
        <span class="keywd">when</span> {<span class="stri">"SLEEP"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> endOfStatement(symbol) <span class="keywd">then</span>
            index1 := 1;
          <span class="keywd">else</span>
            index1 := round(exec_expr(symbol, line));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          flush(win);
          sleep(index1);
          line_marker;
          writeln(log, <span class="stri">"SLEEP "</span> &lt;&amp; index1);
        <span class="keywd">when</span> {<span class="stri">"SOUND"</span>}:
          symbol := get_symbol(line);
          num1 := exec_expr(symbol, line);
          expect(<span class="stri">","</span>, symbol, line);
          num2 := exec_expr(symbol, line);
          line_marker;
          writeln(log, <span class="stri">"**SOUND "</span> &lt;&amp; symbol);
        <span class="keywd">when</span> {<span class="stri">"STOP"</span>, <span class="stri">"SYSTEM"</span>}:
          line_marker;
          writeln(log, symbol);
          symbol := <span class="stri">""</span>;
          running := FALSE;
        <span class="keywd">when</span> {<span class="stri">"SWAP"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> isStringVar(symbol) <span class="keywd">then</span>
            variable_name := get_name(symbol, line);
            expect(<span class="stri">","</span>, symbol, line);
            <span class="keywd">if</span> isStringVar(symbol) <span class="keywd">then</span>
              variable2_name := get_name(symbol, line);
              param1 := getStringVar(variable_name);
              param2 := getStringVar(variable2_name);
              setStringVar(variable_name, param2);
              setStringVar(variable2_name, param1);
            <span class="keywd">else</span>
              error_marker;
              writeln(err, <span class="stri">"STRING VARIABLE EXPECTED - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> isNumericVar(symbol) <span class="keywd">then</span>
            variable_name := get_name(symbol, line);
            expect(<span class="stri">","</span>, symbol, line);
            <span class="keywd">if</span> isNumericVar(symbol) <span class="keywd">then</span>
              variable2_name := get_name(symbol, line);
              num1 := getNumericVar(variable_name);
              num2 := getNumericVar(variable2_name);
              setNumericVar(variable_name, num2);
              setNumericVar(variable2_name, num1);
            <span class="keywd">else</span>
              error_marker;
              writeln(err, <span class="stri">"NUMERIC VARIABLE EXPECTED - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"VARIABLE EXPECTED - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"SUB"</span>}:
          symbol := get_symbol(line);
          line_marker;
          writeln(log, <span class="stri">"SKIP SUB "</span> &lt;&amp; symbol);
          symbol := find_end_sub(line);
          symbol := get_symbol(line);
          line_marker;
          writeln(log, <span class="stri">"END SKIP SUB "</span> &lt;&amp; symbol &lt;&amp; <span class="stri">" "</span> &lt;&amp; line);
        <span class="keywd">when</span> {<span class="stri">"TEXT"</span>}:
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
            exec_let(<span class="stri">"TEXT"</span>, symbol, line);
          <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"TEXT"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"SKIP LABEL: TEXT"</span>);
          <span class="keywd">else</span>
            scr := open(CONSOLE);
            win := openWindow(scr, 1, 1, TEXT_LINES, TEXT_COLUMNS);
            KEYBOARD := CONSOLE_KEYBOARD;
            OUT := win;
            IN := openEcho(KEYBOARD, OUT);
            IN := openLine(IN);
            line_marker;
            writeln(log, <span class="stri">"TEXT"</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"TYPE"</span>}:
          exec_type(symbol, line);
        <span class="keywd">when</span> {<span class="stri">"VTAB"</span>}:
          <span class="keywd">if</span> is_let_statement(line) <span class="keywd">then</span>
            symbol := get_symbol(line);
            exec_let(<span class="stri">"VTAB"</span>, symbol, line);
          <span class="keywd">else</span>
            symbol := get_symbol(line);
            <span class="keywd">if</span> symbol = <span class="stri">":"</span> <span class="op">and</span> <span class="stri">"VTAB"</span> <span class="op">in</span> usedLabel <span class="keywd">then</span>
              line_marker;
              writeln(log, <span class="stri">"SKIP LABEL: VTAB"</span>);
            <span class="keywd">else</span>
              index1 := round(exec_expr(symbol, line));
              index2 := column(win);
              setPos(win, index1, index2);
              line_marker;
              writeln(log, <span class="stri">"VTAB "</span> &lt;&amp; index1);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"WAIT"</span>}:
          symbol := get_symbol(line);
          index1 := round(exec_expr(symbol, line));
          expect(<span class="stri">","</span>, symbol, line);
          index2 := round(exec_expr(symbol, line));
          <span class="keywd">if</span> symbol = <span class="stri">","</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            index3 := round(exec_expr(symbol, line));
          <span class="keywd">else</span>
            index3 := 0;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          line_marker;
          <span class="keywd">case</span> index1 <span class="keywd">of</span>
            <span class="keywd">when</span> {16#3DA}: <span class="comment"># &amp;H3DA/986  Wait for vertical retrace</span>
              writeln(log, <span class="stri">"WAIT "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">", "</span> &lt;&amp; index2 &lt;&amp; <span class="stri">", "</span> &lt;&amp; index3 &lt;&amp;
                  <span class="stri">" - Wait for vertical retrace"</span>);
            <span class="keywd">otherwise</span>:
              writeln(log, <span class="stri">"**WAIT "</span> &lt;&amp; index1 &lt;&amp; <span class="stri">", "</span> &lt;&amp; index2 &lt;&amp; <span class="stri">", "</span> &lt;&amp; index3);
          <span class="keywd">end</span> <span class="keywd">case</span>;
        <span class="keywd">when</span> {<span class="stri">"WEND"</span>}:
          <span class="keywd">if</span> length(whileLoop) >= 1 <span class="keywd">then</span>
            index1 := whileLoop[1].condLine;
            param2 := prg[index1].line[whileLoop[1].condColumn .. ];
            param1 := get_symbol(param2);
            num1 := exec_expr(param1, param2);
            <span class="keywd">if</span> num1 &lt;> 0.0 <span class="keywd">then</span>
              line_marker;
              file_line_number := index1;
              statement_label := prg[file_line_number].linenum;
              symbol := param1;
              line := param2;
              writeln(log, <span class="stri">"WEND - CONTINUE WHILE"</span>);
            <span class="keywd">else</span>
              symbol := get_symbol(line);
              whileLoop := whileLoop[2 .. ];
              line_marker;
              writeln(log, <span class="stri">"WEND - END WHILE"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"UNEXPECTED \"WEND\""</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"WHILE"</span>}:
          index1 := file_line_number;
          index2 := length(prg[file_line_number].line) - length(line) + 1;
          symbol := get_symbol(line);
          num1 := exec_expr(symbol, line);
          line_marker;
          writeln(log, <span class="stri">"WHILE "</span> &lt;&amp; num1);
          <span class="keywd">if</span> num1 &lt;> 0.0 <span class="keywd">then</span>
            whileLoop := [] (whileLoopDescrType.value) &amp; whileLoop;
            whileLoop[1].condLine := index1;
            whileLoop[1].condColumn := index2;
          <span class="keywd">else</span>
            line_marker;
            writeln(log, <span class="stri">"EMPTY WHILE"</span>);
            <span class="keywd">if</span> symbol &lt;> <span class="stri">"WEND"</span> <span class="keywd">then</span>
              param1 := statement_label;
              symbol := find_wend(line);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> symbol = <span class="stri">"WEND"</span> <span class="keywd">then</span>
              <span class="keywd">repeat</span>
                symbol := get_symbol(line);
              <span class="keywd">until</span> endOfStatement(symbol);
              line_marker;
              writeln(log, <span class="stri">"CONTINUE AFTER WEND"</span>);
            <span class="keywd">else</span>
              error_marker(param1);
              writeln(err, <span class="stri">"NO CORRESPONDING \"WEND\" FOUND FOR \"WHILE\""</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"WIDTH"</span>}:
          line_marker;
          writeln(log, <span class="stri">"**WIDTH "</span> &lt;&amp; line);
          <span class="keywd">repeat</span>
            symbol := get_symbol(line);
          <span class="keywd">until</span> endOfStatement(symbol);
        <span class="keywd">when</span> {<span class="stri">"WRITE"</span>, <span class="stri">"WRITE#"</span>}:
          <span class="keywd">if</span> symbol = <span class="stri">"WRITE#"</span> <span class="keywd">then</span>
            symbol := <span class="stri">"#"</span>;
          <span class="keywd">else</span>
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> symbol = <span class="stri">"#"</span> <span class="keywd">then</span>
            exec_write_to_file(symbol, line);
          <span class="keywd">else</span>
            exec_write(symbol, line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">"'"</span>}:
          symbol := <span class="stri">""</span>;
          line_marker;
          writeln(log, <span class="stri">"'"</span> &lt;&amp; line);
        <span class="keywd">when</span> {<span class="stri">"%"</span>}:
          variable_name := <span class="stri">""</span>;
          <span class="keywd">repeat</span>
            variable_name &amp;:= symbol;
            symbol := get_symbol(line);
            <span class="keywd">if</span> symbol &lt;> <span class="stri">""</span> <span class="op">and</span> symbol[1] <span class="op">in</span> alphanum_char <span class="keywd">then</span>
              variable_name &amp;:= symbol;
              symbol := get_symbol(line);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">until</span> symbol &lt;> <span class="stri">"_"</span>;
          append_index(variable_name, symbol, line);
          <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="keywd">then</span>
            symbol := get_symbol(line);
            num1 := exec_expr(symbol, line);
            setNumericVar(variable_name, num1);
            line_marker;
            writeln(log, variable_name &lt;&amp; <span class="stri">"="</span> &lt;&amp; num1);
          <span class="keywd">else</span>
            error_marker;
            writeln(err, <span class="stri">"\"=\" EXPECTED AFTER "</span> &lt;&amp; literal(variable_name) &lt;&amp;
                <span class="stri">" - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">":"</span>}:
          error_marker;
          writeln(err, <span class="stri">"UNEXPECTED \":\" - IGNORED."</span>);
        <span class="keywd">otherwise</span>:
          <span class="keywd">if</span> symbol <span class="op">in</span> subprogram <span class="keywd">then</span>
            line_marker;
            writeln(log, <span class="stri">"CALL "</span> &lt;&amp; symbol);
            advance_after_statement(line);
            set_return_position(line);
            gosubReturn[1].subName := symbol;
            file_line_number := subprogram[symbol];
            statement_label := prg[file_line_number].label;
            line := prg[file_line_number].line;
            symbol := get_symbol(line);
            symbol := get_symbol(line);
            set_sub_entry_position;
            line_marker;
            writeln(log, <span class="stri">"EXECUTE SUB "</span> &lt;&amp; symbol);
            <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
              symbol := get_symbol(line);
            <span class="keywd">end</span> <span class="keywd">while</span>;
          <span class="keywd">elsif</span> symbol <span class="op">in</span> sub_declared <span class="keywd">then</span>
            error_marker;
            writeln(err, <span class="stri">"CALL DECLARED BUT UNDEFINED SUB "</span> &lt;&amp; symbol);
            <span class="keywd">while</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
              symbol := get_symbol(line);
            <span class="keywd">end</span> <span class="keywd">while</span>;
          <span class="keywd">elsif</span> symbol <span class="op">in</span> usedLabel <span class="keywd">then</span>
            param1 := symbol;
            symbol := get_symbol(line);
            <span class="keywd">if</span> symbol = <span class="stri">"="</span> <span class="op">or</span> symbol = <span class="stri">"("</span>  <span class="op">or</span> symbol = <span class="stri">"["</span> <span class="keywd">then</span>
              exec_let(param1, symbol, line);
            <span class="keywd">elsif</span> symbol = <span class="stri">":"</span> <span class="keywd">then</span>
              line_marker;
              writeln(log, <span class="stri">"SKIP LABEL: "</span> &lt;&amp; param1);
            <span class="keywd">else</span>
              error_marker;
              writeln(err, <span class="stri">"COLON EXPECTED AFTER LABEL "</span> &lt;&amp; param1 &lt;&amp;
                      <span class="stri">" - FOUND "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            exec_let(symbol, line, process_next);
          <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">if</span> symbol = <span class="stri">":"</span> <span class="keywd">then</span>
          symbol := get_symbol(line);
          <span class="keywd">if</span> symbol = <span class="stri">":"</span> <span class="keywd">then</span>
            <span class="comment"># Allow :: as statement separator.</span>
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          process_next := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> <span class="op">not</span> process_next;
    <span class="keywd">if</span> symbol = <span class="stri">"REM"</span> <span class="keywd">then</span>
      line_marker;
      writeln(log, <span class="stri">"REM "</span> &lt;&amp; line);
    <span class="keywd">elsif</span> symbol = <span class="stri">"'"</span> <span class="keywd">then</span>
      line_marker;
      writeln(log, <span class="stri">"'"</span> &lt;&amp; line);
    <span class="keywd">elsif</span> symbol = <span class="stri">"ELSE"</span> <span class="keywd">then</span>
      line_marker;
      writeln(log, <span class="stri">"SKIP ELSE PART - CONTINUE AT NEXT LINE"</span>);
    <span class="keywd">elsif</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      error_marker;
      writeln(err, <span class="stri">"UNEXPECTED SYMBOL "</span> &lt;&amp; literal(symbol) &lt;&amp; <span class="stri">"."</span>);
      <span class="keywd">repeat</span>
        symbol := get_symbol(line);
      <span class="keywd">until</span> endOfStatement(symbol);
      <span class="keywd">if</span> symbol = <span class="stri">":"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        running := execCmd(symbol, line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: execLines <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: running <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: line <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> running <span class="keywd">do</span>
      <span class="keywd">if</span> file_line_number > length(prg) <span class="keywd">then</span>
        writeln(log, <span class="stri">"END OF PROGRAM REACHED"</span>);
        running := FALSE;
      <span class="keywd">elsif</span> prg[file_line_number].line &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        statement_label := prg[file_line_number].linenum;
        line := prg[file_line_number].line;
        <span class="comment">(* writeln(file_line_number lpad 5 &lt;&amp; " " &lt;&amp;
            prg[file_line_number].line); *)</span>
        symbol := get_symbol(line);
        running := execCmd(symbol, line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      incr(file_line_number);
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: runProg <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    file_line_number := 1;
    execLines;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: logLine (<span class="op">in</span> <span class="type">lineType</span>: aLine) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> aLine.linenum &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      write(log, aLine.linenum <span class="op">lpad</span> 5 &lt;&amp; <span class="stri">" "</span>);
    <span class="keywd">else</span>
      write(log, <span class="stri">""</span> <span class="op">lpad</span> 5 &lt;&amp; <span class="stri">" "</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(log, aLine.line);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: prepareLoops <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: processing <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: line <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: headLabel <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: headLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: headColumn <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: tailLine <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: tailColumn <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    file_line_number := 1;
    <span class="keywd">while</span> processing <span class="keywd">do</span>
      <span class="keywd">if</span> file_line_number > length(prg) <span class="keywd">then</span>
        processing := FALSE;
      <span class="keywd">elsif</span> prg[file_line_number].line &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        statement_label := prg[file_line_number].linenum;
        line := prg[file_line_number].line;
        <span class="keywd">repeat</span>
          symbol := get_symbol(line);
          <span class="comment"># line_marker;</span>
          <span class="comment"># writeln(log, literal(symbol));</span>
          <span class="keywd">if</span> symbol = <span class="stri">"DO"</span> <span class="keywd">then</span>
            headLabel := statement_label;
            headLine := file_line_number;
            headColumn := length(prg[file_line_number].line) - length(line) + 1;
            symbol := find_loop(line);
            <span class="keywd">if</span> symbol = <span class="stri">"LOOP"</span> <span class="keywd">then</span>
              tailLine := file_line_number;
              tailColumn := length(prg[file_line_number].line) - length(line) + 1;
              <span class="comment"># writeln(log, "LOOP[" &lt;&amp; tailLine &lt;&amp; "," &lt;&amp; tailColumn &lt;&amp;</span>
              <span class="comment">#              "]->DO[" &lt;&amp; headLine &lt;&amp; "," &lt;&amp; headColumn &lt;&amp; "]");</span>
              addDoLoopHeader(tailLine, tailColumn, headLine, headColumn);
              file_line_number := headLine;
              line := prg[file_line_number].line[headColumn .. ];
              symbol := get_symbol(line);
            <span class="keywd">else</span>
              file_line_number := headLine;
              line := prg[file_line_number].line[headColumn .. ];
              symbol := get_symbol(line);
              <span class="keywd">if</span> symbol &lt;> <span class="stri">"="</span> <span class="keywd">then</span>
                error_marker(headLabel);
                writeln(err, <span class="stri">"DO - NO STATICALLY CORRESPONDING \"LOOP\" STATEMENT FOUND "</span>);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> symbol = <span class="stri">"LOOP"</span> <span class="keywd">then</span>
            tailLine := file_line_number;
            tailColumn := length(prg[file_line_number].line) - length(line) + 1;
            <span class="keywd">if</span> <span class="op">not</span> doLoopHeaderPresent(tailLine, tailColumn, headLine, headColumn) <span class="keywd">then</span>
              error_marker;
              writeln(err, <span class="stri">"LOOP - NO STATICALLY CORRESPONDING \"DO\" STATEMENT FOUND"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
            line := <span class="stri">""</span>;
            symbol := <span class="stri">""</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">while</span> symbol &lt;> <span class="stri">"THEN"</span> <span class="op">and</span> <span class="op">not</span> endOfStatement(symbol) <span class="keywd">do</span>
            symbol := get_symbol(line);
          <span class="keywd">end</span> <span class="keywd">while</span>;
          <span class="keywd">if</span> ignoreRestOfLine(symbol) <span class="keywd">then</span>
            line := <span class="stri">""</span>;
            symbol := <span class="stri">""</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">until</span> symbol = <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      incr(file_line_number);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    file_line_number := 1;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: preprocessLine (<span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: label <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    symbol := get_symbol(line);
    <span class="keywd">while</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> symbol = <span class="stri">"GOTO"</span> <span class="op">or</span> symbol = <span class="stri">"GOSUB"</span> <span class="op">or</span>
          symbol = <span class="stri">"THEN"</span> <span class="op">or</span> symbol = <span class="stri">"ELSE"</span> <span class="op">or</span>
          symbol = <span class="stri">"RESTORE"</span> <span class="op">or</span> symbol = <span class="stri">"RUN"</span> <span class="keywd">then</span>
        label := get_symbol(line);
        symbol := get_symbol(line);
        <span class="keywd">if</span> endOfStatement(symbol) <span class="op">and</span>
            label <span class="op">not</span> <span class="op">in</span> not_allowed_as_label <span class="op">and</span>
            label &lt;> <span class="stri">""</span> <span class="op">and</span> label[1] <span class="op">in</span> letter_char <span class="keywd">then</span>
          incl(usedLabel, label);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> symbol = <span class="stri">"REM"</span> <span class="op">or</span> symbol = <span class="stri">"'"</span> <span class="keywd">then</span>
        symbol := <span class="stri">""</span>;
      <span class="keywd">else</span>
        symbol := get_symbol(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> symbol = <span class="stri">":"</span> <span class="keywd">then</span>
        symbol := get_symbol(line);
        incl(usedAsStatement, symbol);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: checkLabels <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: aLabel <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: first <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> <span class="keywd">key</span> aLabel <span class="keywd">range</span> multipleDefinedLabel <span class="keywd">do</span>
      <span class="keywd">if</span> aLabel <span class="op">in</span> usedLabel <span class="keywd">then</span>
        write(err, <span class="stri">" ***** LABEL "</span> &lt;&amp; aLabel &lt;&amp;
              <span class="stri">" DEFINED IN MULTIPLE LINES: "</span>);
        <span class="keywd">for</span> number <span class="keywd">range</span> multipleDefinedLabel[aLabel] <span class="keywd">do</span>
          <span class="keywd">if</span> first <span class="keywd">then</span>
            first := FALSE;
          <span class="keywd">else</span>
            write(log, <span class="stri">", "</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> number &lt;= length(prg) <span class="op">and</span> prg[number].linenum &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            write(err, prg[number].linenum);
          <span class="keywd">else</span>
            write(err, <span class="stri">"("</span> &lt;&amp; number &lt;&amp; <span class="stri">")"</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
        writeln(err);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> <span class="keywd">key</span> aLabel <span class="keywd">range</span> subprogram <span class="keywd">do</span>
      excl(usedLabel, aLabel);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    usedLabel := usedLabel - usedAsStatement;
    <span class="keywd">for</span> aLabel <span class="keywd">range</span> usedAsStatement <span class="keywd">do</span>
      excl(label, aLabel);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> aLabel <span class="keywd">range</span> usedLabel <span class="keywd">do</span>
      <span class="keywd">if</span> aLabel <span class="op">not</span> <span class="op">in</span> label <span class="keywd">then</span>
        <span class="keywd">if</span> aLabel <span class="op">in</span> multipleDefinedLabel <span class="keywd">then</span>
          writeln(err, <span class="stri">" ***** LABEL "</span> &lt;&amp; aLabel &lt;&amp;
                  <span class="stri">" USED BUT DEFINED MULTIPLE TIMES."</span>);
        <span class="keywd">else</span>
          writeln(err, <span class="stri">" ***** LABEL "</span> &lt;&amp; aLabel &lt;&amp;
                  <span class="stri">" USED BUT NOT DEFINED."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: loadProg (<span class="op">in</span> <span class="type">string</span>: name) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">proc</span>: loadProg (<span class="op">in</span> <span class="type">string</span>: name, <span class="keywd">inout</span> <span class="type">file</span>: infile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: file_line_number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: line_number <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: line_label <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: line <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: help_line <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: variable_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: control_z <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: continuation_line <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: line_number_incr <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      line := getln(infile);
      <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> pred(line_number_incr) <span class="keywd">do</span>
        prg &amp;:= [] (lineType.value);
        writeln(log);
      <span class="keywd">end</span> <span class="keywd">for</span>;
      file_line_number +:= line_number_incr;
      line_number_incr := 1;
      <span class="keywd">repeat</span>
        <span class="keywd">if</span> pos(line, <span class="stri">"\Z"</span>) &lt;> 0 <span class="keywd">then</span>
          <span class="comment"># Control-Z is used sometimes as end of file marker.</span>
          line := line[.. pred(pos(line, <span class="stri">"\Z"</span>))];
          control_z := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        line := trim(line);
        <span class="keywd">if</span> length(line) >= 2 <span class="op">and</span> line[pred(length(line)) ..] = <span class="stri">" _"</span> <span class="keywd">then</span>
          continuation_line := TRUE;
          line := line[.. pred(length(line))] &amp; getln(infile);
          incr(line_number_incr);
        <span class="keywd">else</span>
          continuation_line := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> <span class="op">not</span> continuation_line;
      <span class="keywd">if</span> line &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        <span class="keywd">if</span> line[1] <span class="op">in</span> digit_char <span class="keywd">then</span>
          line_number := getDigits(line);
          <span class="keywd">if</span> line &lt;> <span class="stri">""</span> <span class="op">and</span> line[1] = <span class="stri">'.'</span> <span class="keywd">then</span>
            <span class="comment"># Accept line numbers with decimal point</span>
            line_number &amp;:= <span class="stri">"."</span>;
            line := line[2 .. ];
            line_number &amp;:= getDigits(line);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">while</span> line &lt;> <span class="stri">""</span> <span class="op">and</span> line[1] = <span class="stri">' '</span> <span class="keywd">do</span>
            line := line[2 .. ];
          <span class="keywd">end</span> <span class="keywd">while</span>;
          <span class="keywd">if</span> line_number <span class="op">in</span> label <span class="keywd">then</span>
            writeln(err, <span class="stri">" ***** LINE NUMBER "</span> &lt;&amp; line_number &lt;&amp;
                <span class="stri">" ALREADY DEFINED AS "</span> &lt;&amp; name &lt;&amp;
                <span class="stri">"("</span> &lt;&amp; label[line_number] &lt;&amp; <span class="stri">")"</span>);
          <span class="keywd">else</span>
            label @:= [line_number] succ(length(prg));
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          line_number := <span class="stri">""</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        help_line := line;
        symbol := get_symbol(help_line);
        <span class="keywd">if</span> symbol = <span class="stri">"'"</span> <span class="op">or</span> symbol = <span class="stri">"REM"</span> <span class="keywd">then</span>
          <span class="keywd">repeat</span>
            symbol := get_symbol(help_line);
          <span class="keywd">until</span> symbol = <span class="stri">""</span> <span class="op">or</span> symbol = <span class="stri">"$"</span>;
          symbol := get_symbol(help_line);
          <span class="keywd">if</span> symbol = <span class="stri">"INCLUDE"</span> <span class="keywd">then</span>
            symbol := get_symbol(help_line);
            <span class="keywd">if</span> symbol = <span class="stri">":"</span> <span class="keywd">then</span>
              symbol := get_symbol(help_line);
              <span class="keywd">if</span> symbol = <span class="stri">"'"</span> <span class="keywd">then</span>
                symbol := help_line[.. pred(pos(help_line, <span class="stri">'\''</span>))];
                <span class="keywd">if</span> symbol &lt;> <span class="stri">""</span> <span class="keywd">then</span>
                  prg &amp;:= [] (lineType.value);
                  prg[length(prg)].fileName := name;
                  prg[length(prg)].fileLine := file_line_number;
                  prg[length(prg)].linenum := line_number;
                  prg[length(prg)].label := line_label;
                  prg[length(prg)].line := line;
                  logLine(prg[length(prg)]);
                  <span class="keywd">if</span> <span class="op">not</span> loadProg(symbol) <span class="keywd">then</span>
                    writeln(err, <span class="stri">" ***** INCLUDE FILE "</span> &lt;&amp; literal(symbol) &lt;&amp;
                        <span class="stri">" NOT FOUND."</span>);
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                  writeln(log, <span class="stri">"---------- END INCLUDE ----------"</span>);
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> symbol = <span class="stri">"#"</span> <span class="op">or</span> symbol = <span class="stri">"$"</span> <span class="keywd">then</span>
          symbol := get_symbol(help_line);
          <span class="keywd">if</span> symbol = <span class="stri">"INCLUDE"</span> <span class="keywd">then</span>
            symbol := get_symbol(help_line);
            <span class="keywd">if</span> symbol &lt;> <span class="stri">""</span> <span class="op">and</span> symbol[1] = <span class="stri">'"'</span> <span class="keywd">then</span>
              symbol := symbol[2 ..];
              prg &amp;:= [] (lineType.value);
              prg[length(prg)].fileName := name;
              prg[length(prg)].fileLine := file_line_number;
              prg[length(prg)].linenum := line_number;
              prg[length(prg)].label := line_label;
              prg[length(prg)].line := line;
              logLine(prg[length(prg)]);
              <span class="keywd">if</span> <span class="op">not</span> loadProg(symbol) <span class="keywd">then</span>
                writeln(err, <span class="stri">" ***** INCLUDE FILE "</span> &lt;&amp; literal(symbol) &lt;&amp;
                    <span class="stri">" NOT FOUND."</span>);
              <span class="keywd">end</span> <span class="keywd">if</span>;
              writeln(log, <span class="stri">"---------- END INCLUDE ----------"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> symbol = <span class="stri">"SUB"</span> <span class="keywd">then</span>
          symbol := get_symbol(help_line);
          <span class="keywd">if</span> symbol <span class="op">in</span> subprogram <span class="keywd">then</span>
            writeln(err, <span class="stri">" ***** SUB "</span> &lt;&amp; symbol &lt;&amp;
                <span class="stri">" ALREADY DEFINED AS "</span> &lt;&amp; name &lt;&amp;
                <span class="stri">"("</span> &lt;&amp; subprogram[symbol] &lt;&amp; <span class="stri">")"</span>);
          <span class="keywd">else</span>
            subprogram @:= [symbol] succ(length(prg));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          line_label := <span class="stri">""</span>;
        <span class="keywd">elsif</span> symbol = <span class="stri">"FUNCTION"</span> <span class="keywd">then</span>
          symbol := get_symbol(help_line);
          <span class="keywd">if</span> symbol <span class="op">in</span> subfunction <span class="keywd">then</span>
            writeln(err, <span class="stri">" ***** FUNCTION "</span> &lt;&amp; symbol &lt;&amp;
                <span class="stri">" ALREADY DEFINED AS "</span> &lt;&amp; name &lt;&amp;
                <span class="stri">"("</span> &lt;&amp; subfunction[symbol] &lt;&amp; <span class="stri">")"</span>);
          <span class="keywd">else</span>
            subfunction @:= [symbol] succ(length(prg));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          line_label := <span class="stri">""</span>;
<span class="comment">(*
        elsif symbol = "DEF" then
          symbol := get_symbol(help_line);
          if symbol = "SEG" then
            noop;
          else
            variable_name := symbol;
            if variable_name[1] >= 'A' and variable_name[1] &lt;= 'Z' then
              define_function(variable_name, symbol, help_line, FALSE);
            end if;
          end if;
*)</span>
        <span class="keywd">elsif</span> symbol = <span class="stri">""</span> <span class="op">or</span> symbol <span class="op">in</span> not_allowed_as_label <span class="op">or</span>
            symbol <span class="op">in</span> sub_declared <span class="keywd">then</span>
          line_label := <span class="stri">""</span>;
        <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"NEXT"</span>) <span class="op">and</span> length(symbol) = 5 <span class="op">and</span>
            symbol[5] <span class="op">in</span> letter_char <span class="keywd">then</span>
          line_label := <span class="stri">""</span>;
        <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"READ"</span>) <span class="op">and</span> length(symbol) = 5 <span class="op">and</span>
            symbol[5] <span class="op">in</span> letter_char <span class="keywd">then</span>
          line_label := <span class="stri">""</span>;
        <span class="keywd">elsif</span> startsWith(symbol, <span class="stri">"GOTO"</span>) <span class="op">and</span> isDigitString(symbol[5 ..]) <span class="op">or</span>
            startsWith(symbol, <span class="stri">"GOSUB"</span>) <span class="op">and</span> isDigitString(symbol[6 ..]) <span class="keywd">then</span>
          line_label := <span class="stri">""</span>;
        <span class="keywd">else</span>
          line_label := symbol;
          symbol := get_symbol(help_line);
          <span class="keywd">if</span> line_label[1] <span class="op">in</span> letter_char <span class="op">and</span> symbol = <span class="stri">":"</span> <span class="keywd">then</span>
            <span class="keywd">if</span> line_label <span class="op">in</span> multipleDefinedLabel <span class="keywd">then</span>
              multipleDefinedLabel[line_label] &amp;:= succ(length(prg));
              line_label := <span class="stri">""</span>;
            <span class="keywd">elsif</span> line_label <span class="op">in</span> label <span class="keywd">then</span>
              multipleDefinedLabel @:= [line_label] [] (label[line_label], succ(length(prg)));
              excl(label, line_label);
              line_label := <span class="stri">""</span>;
            <span class="keywd">else</span>
              label @:= [line_label] succ(length(prg));
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            line_label := <span class="stri">""</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        preprocessLine(line);
        prg &amp;:= [] (lineType.value);
        prg[length(prg)].fileName := name;
        prg[length(prg)].fileLine := file_line_number;
        prg[length(prg)].linenum := line_number;
        prg[length(prg)].label := line_label;
        prg[length(prg)].line := line;
        logLine(prg[length(prg)]);
      <span class="keywd">else</span>
        prg &amp;:= [] (lineType.value);
        writeln(log);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> eof(infile) <span class="op">or</span> control_z;
    checkLabels;
    <span class="keywd">if</span> length(label) &lt;> 0 <span class="keywd">then</span>
      writeln(log, <span class="stri">"Labels:"</span>);
      <span class="keywd">for</span> number <span class="keywd">key</span> line_label <span class="keywd">range</span> label <span class="keywd">do</span>
        <span class="keywd">if</span> line_label[1] <span class="op">not</span> <span class="op">in</span> digit_char <span class="keywd">then</span>
          write(log, line_label &lt;&amp; <span class="stri">": "</span>);
          <span class="keywd">if</span> number &lt;= length(prg) <span class="keywd">then</span>
            <span class="keywd">if</span> prg[number].linenum &lt;> <span class="stri">""</span> <span class="keywd">then</span>
              write(log, prg[number].linenum);
            <span class="keywd">else</span>
              <span class="keywd">if</span> prg[number].fileName &lt;> prg[1].fileName <span class="keywd">then</span>
                write(log, prg[number].fileName);
              <span class="keywd">end</span> <span class="keywd">if</span>;
              write(log, <span class="stri">"("</span> &lt;&amp; prg[number].fileLine &lt;&amp; <span class="stri">")"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          writeln(log);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(log, <span class="stri">"usedLabels: "</span> &lt;&amp; usedLabel);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: runOrChain (<span class="op">in</span> <span class="type">string</span>: cmd, <span class="op">in</span> <span class="type">string</span>: name) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: successful <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">file</span>: infile <span class="keywd">is</span> STD_NULL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> lower(name[length(name) - 3 ..]) &lt;> <span class="stri">".bas"</span> <span class="keywd">then</span>
      infile := basicOpen(name &amp; <span class="stri">".bas"</span>, <span class="stri">"r"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> infile = STD_NULL <span class="keywd">then</span>
      infile := basicOpen(name, <span class="stri">"r"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> infile &lt;> STD_NULL <span class="keywd">then</span>
      line_marker;
      writeln(log, cmd &lt;&amp; <span class="stri">" "</span> &lt;&amp; literal(name));
      prg := 0 <span class="op">times</span> lineType.value;
      label := label_hash.EMPTY_HASH;
      subprogram := label_hash.EMPTY_HASH;
      subfunction := label_hash.EMPTY_HASH;
      sub_declared := label_hash.EMPTY_HASH;
      usedLabel := stringSet.value;
      usedAsStatement := stringSet.value;
      multipleDefinedLabel := multipleDefinedType.value;
      loadProg(name, infile);
      prepareLoops;
      close(infile);
      successful := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: loadProg (<span class="op">in</span> <span class="type">string</span>: name) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: successful <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">file</span>: infile <span class="keywd">is</span> STD_NULL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> lower(name[length(name) - 3 ..]) &lt;> <span class="stri">".bas"</span> <span class="keywd">then</span>
      infile := basicOpen(name &amp; <span class="stri">".bas"</span>, <span class="stri">"r"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> infile = STD_NULL <span class="keywd">then</span>
      infile := basicOpen(name, <span class="stri">"r"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> infile &lt;> STD_NULL <span class="keywd">then</span>
      loadProg(name, infile);
      close(infile);
      successful := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: interactiveMode <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">file</span>: commandFile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: line <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: running <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    scr := open(CONSOLE);
    cursor(scr, TRUE);
    win := openWindow(scr, 1, 1, TEXT_LINES, TEXT_COLUMNS);
    OUT := win;
    IN := openEcho(KEYBOARD, OUT);
    IN := openLine(IN);
    err := OUT;
    commandFile := openEditLine(KEYBOARD, OUT);
    writeln(<span class="stri">"Type END to exit direct mode."</span>);
    <span class="keywd">repeat</span>
      write(<span class="stri">"] "</span>);
      readln(commandFile, line);
      symbol := get_symbol(line);
      running := execCmd(symbol, line);
    <span class="keywd">until</span> <span class="op">not</span> running;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: arg_v <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: argumentIndex <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">boolean</span>: doPauseAtEnd <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: doLog <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: interactive <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    arg_v := argv(PROGRAM);
    <span class="keywd">if</span> length(arg_v) >= 1 <span class="keywd">then</span>
      <span class="keywd">while</span> argumentIndex &lt;= length(arg_v) <span class="op">and</span>
          startsWith(arg_v[argumentIndex], <span class="stri">"-"</span>) <span class="keywd">do</span>
        <span class="keywd">if</span> arg_v[argumentIndex] = <span class="stri">"-p"</span> <span class="keywd">then</span>
          doPauseAtEnd := TRUE;
        <span class="keywd">elsif</span> arg_v[argumentIndex] = <span class="stri">"-l"</span> <span class="keywd">then</span>
          doLog := TRUE;
        <span class="keywd">elsif</span> arg_v[argumentIndex] = <span class="stri">"-i"</span> <span class="keywd">then</span>
          interactive := TRUE;
        <span class="keywd">else</span>
          writeln(<span class="stri">" ***** Unknown option "</span> &lt;&amp; arg_v[argumentIndex]);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        incr(argumentIndex);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">if</span> argumentIndex &lt;= length(arg_v) <span class="keywd">then</span>
        <span class="keywd">if</span> succ(argumentIndex) &lt;= length(arg_v) <span class="keywd">then</span>
          command_line := join(arg_v[succ(argumentIndex) ..], <span class="stri">" "</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        err := open(<span class="stri">"bas7.log"</span>, <span class="stri">"w"</span>);
        <span class="keywd">if</span> err = STD_NULL <span class="keywd">then</span>
          writeln(<span class="stri">" ***** Could not open log file."</span>);
        <span class="keywd">else</span>
          err := openLine(err);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> doLog <span class="keywd">then</span>
          log := err;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> loadProg(arg_v[argumentIndex]) <span class="keywd">then</span>
          writeln(log, <span class="stri">"load program finished"</span>);
          prepareLoops;
          <span class="comment"># listProg(log, 0, MAX_LINENUM);</span>
          scr := open(CONSOLE);
          cursor(scr, TRUE);
          win := openWindow(scr, 1, 1, TEXT_LINES, TEXT_COLUMNS);
          OUT := win;
          IN := openEcho(KEYBOARD, OUT);
          IN := openLine(IN);
          runProg;
          <span class="keywd">if</span> doPauseAtEnd <span class="keywd">then</span>
            writeln(<span class="stri">"=== Program finished ==="</span>);
            write(<span class="stri">"Press return to continue "</span>);
            readln(KEYBOARD);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          writeln(<span class="stri">" ***** File "</span> &lt;&amp; literal(arg_v[argumentIndex]) &lt;&amp;
              <span class="stri">" not found."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> interactive <span class="keywd">then</span>
        interactiveMode;
      <span class="keywd">else</span>
        writeln(<span class="stri">" ***** File name missing"</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      writeln(<span class="stri">"Bas7 Version 1.0 - Basic interpreter"</span>);
      writeln(<span class="stri">"Copyright (C) 1994, 2001, 2004 - 2010, 2013, 2016 - 2020 Thomas Mertes"</span>);
      writeln(<span class="stri">"This is free software; see the source for copying conditions.  There is NO"</span>);
      writeln(<span class="stri">"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."</span>);
      writeln(<span class="stri">"Bas7 is written in the Seed7 programming language"</span>);
      writeln(<span class="stri">"Homepage: http://seed7.sourceforge.net"</span>);
      writeln;
      writeln(<span class="stri">"usage: bas7 [options] basic_program"</span>);
      writeln;
      writeln(<span class="stri">"options: -p  Ask for a prompt at the end of the program"</span>);
      writeln(<span class="stri">"         -l  List program and write log of executed statements"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
