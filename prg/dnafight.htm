<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style2.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  dnafight.sd7  Bacterial dna fight programming game              *)</span>
<span class="comment">(*  Copyright (C) 1985, 1986, 2005  Thomas Mertes                   *)</span>
<span class="comment">(*  Copyright (C) 1985, 1986,       Markus Stumptner                *)</span>
<span class="comment">(*  Copyright (C) 1985, 1986, 1991  Johannes Gritsch                *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/seed7_05.htm">seed7_05.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/window.htm">window.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/keybd.htm">keybd.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/float.htm">float.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bigint.htm">bigint.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/draw.htm">draw.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/graph_file.htm">graph_file.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/field.htm">field.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/dna_base.htm">dna_base.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/time.htm">time.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/duration.htm">duration.s7i</a>"</span>;

  <span class="keywd">include</span> <span class="stri">"white.dna"</span>;
  <span class="keywd">include</span> <span class="stri">"violet.dna"</span>;
  <span class="keywd">include</span> <span class="stri">"indigo.dna"</span>;
  <span class="keywd">include</span> <span class="stri">"blue.dna"</span>;
  <span class="keywd">include</span> <span class="stri">"green.dna"</span>;
  <span class="keywd">include</span> <span class="stri">"orange.dna"</span>;
  <span class="keywd">include</span> <span class="stri">"red.dna"</span>;
  <span class="keywd">include</span> <span class="stri">"tan.dna"</span>;


<span class="keywd">const</span> <span class="type">string</span>:   Version     <span class="keywd">is</span>   <span class="stri">"5.3"</span>;

<span class="keywd">var</span> <span class="type">text</span>: scr <span class="keywd">is</span> STD_NULL;
<span class="keywd">var</span> <span class="type">text</span>: info <span class="keywd">is</span> STD_NULL;
<span class="keywd">var</span> <span class="type">text</span>: stat <span class="keywd">is</span> STD_NULL;
<span class="keywd">var</span> <span class="type">text</span>: fstat <span class="keywd">is</span> STD_NULL;

<span class="keywd">const</span> <span class="type">integer</span>: MAX_LINE       <span class="keywd">is</span> 21;
<span class="keywd">const</span> <span class="type">integer</span>: MAX_COLUMN     <span class="keywd">is</span> 21;
<span class="keywd">const</span> <span class="type">integer</span>: STRETCH_FACTOR <span class="keywd">is</span> 12;
<span class="keywd">const</span> <span class="type">integer</span>: PLATE_XPOS     <span class="keywd">is</span>  6;
<span class="keywd">const</span> <span class="type">integer</span>: PLATE_YPOS     <span class="keywd">is</span> 16;
<span class="keywd">const</span> <span class="type">integer</span>: PLATE_BORDER   <span class="keywd">is</span>  3;

<span class="keywd">const</span> <span class="type">integer</span>: HALF_FACTOR    <span class="keywd">is</span> STRETCH_FACTOR <span class="op">div</span> 2;
<span class="keywd">const</span> <span class="type">integer</span>: NORMAL_RADIUS  <span class="keywd">is</span> pred(HALF_FACTOR);
<span class="keywd">const</span> <span class="type">integer</span>: SMALL_RADIUS   <span class="keywd">is</span> pred(NORMAL_RADIUS);
<span class="keywd">const</span> <span class="type">integer</span>: X_SHIFT        <span class="keywd">is</span> PLATE_XPOS + PLATE_BORDER - STRETCH_FACTOR * 2;
<span class="keywd">const</span> <span class="type">integer</span>: Y_SHIFT        <span class="keywd">is</span> PLATE_YPOS + PLATE_BORDER - STRETCH_FACTOR * 2;
<span class="keywd">const</span> <span class="type">integer</span>: XMAX           <span class="keywd">is</span> MAX_COLUMN + 2;
<span class="keywd">const</span> <span class="type">integer</span>: YMAX           <span class="keywd">is</span> MAX_LINE + 2;

<span class="keywd">const</span> <span class="type">type</span>: xcoordinate <span class="keywd">is</span> subtype integer; <span class="comment">(* 1 .. XMAX *)</span>
<span class="keywd">const</span> <span class="type">type</span>: ycoordinate <span class="keywd">is</span> subtype integer; <span class="comment">(* 1 .. YMAX *)</span>

<span class="keywd">const</span> <span class="type">type</span>: hue <span class="keywd">is</span> subrange FIRSTCOL .. LASTCOL;

<span class="keywd">const</span> <span class="type">type</span>: bacterium <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">xcoordinate</span>: xpos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">ycoordinate</span>: ypos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">lifeSpan</span>:    hungry <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>:       mass <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: microbe <span class="keywd">is</span> varptr bacterium;

<span class="keywd">const</span> <span class="type">type</span>: position <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">bactColor</span>: content <span class="keywd">is</span> CLEAR;
    <span class="keywd">var</span> <span class="type">power</span>:     meal <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">microbe</span>:   possessor <span class="keywd">is</span> microbe.NIL;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">var</span> <span class="type">array</span> <span class="type">array</span> <span class="type">position</span>: area <span class="keywd">is</span> XMAX <span class="op">times</span> YMAX <span class="op">times</span> position.value;
<span class="keywd">var</span> <span class="type">array</span> <span class="type">microbe</span>: animates <span class="keywd">is</span> 0 <span class="op">times</span> microbe.NIL;
<span class="keywd">var</span> <span class="type">array</span> <span class="type">microbe</span>: children <span class="keywd">is</span> 0 <span class="op">times</span> microbe.NIL;
<span class="keywd">var</span> <span class="type">xcoordinate</span>: x <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">ycoordinate</span>: y <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">boolean</span>: done <span class="keywd">is</span> FALSE;

<span class="keywd">const</span> <span class="type">type</span>: killReason <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">enum</span>
    KNoReason, KEdge, KHunger, KWhite, KViolet, KIndigo, KBlue, KCyan,
    KGreen, KYellow, KAmber, KOrange, KRed, KScarlet, KTan, KLilac, KPink,
    KWrMove, KBigMouth, KSuicide, KFnotEmpty
  <span class="keywd">end</span> <span class="keywd">enum</span>;

<span class="keywd">const</span> <span class="type">string</span>: str (KEdge) <span class="keywd">is</span>      <span class="stri">"Edge"</span>;
<span class="keywd">const</span> <span class="type">string</span>: str (KHunger) <span class="keywd">is</span>    <span class="stri">"Hunger"</span>;
<span class="keywd">const</span> <span class="type">string</span>: str (KWrMove) <span class="keywd">is</span>    <span class="stri">"WrMove"</span>;
<span class="keywd">const</span> <span class="type">string</span>: str (KBigMouth) <span class="keywd">is</span>  <span class="stri">"Big M."</span>;
<span class="keywd">const</span> <span class="type">string</span>: str (KSuicide) <span class="keywd">is</span>   <span class="stri">"Suic"</span>;
<span class="keywd">const</span> <span class="type">string</span>: str (KFnotEmpty) <span class="keywd">is</span> <span class="stri">"F.n.e"</span>;
<span class="keywd">const</span> <span class="type">string</span>: str (KWhite) <span class="keywd">is</span>     str(WHITE);
<span class="keywd">const</span> <span class="type">string</span>: str (KViolet) <span class="keywd">is</span>    str(VIOLET);
<span class="keywd">const</span> <span class="type">string</span>: str (KIndigo) <span class="keywd">is</span>    str(INDIGO);
<span class="keywd">const</span> <span class="type">string</span>: str (KBlue) <span class="keywd">is</span>      str(BLUE);
<span class="keywd">const</span> <span class="type">string</span>: str (KCyan) <span class="keywd">is</span>      str(CYAN);
<span class="keywd">const</span> <span class="type">string</span>: str (KGreen) <span class="keywd">is</span>     str(GREEN);
<span class="keywd">const</span> <span class="type">string</span>: str (KYellow) <span class="keywd">is</span>    str(YELLOW);
<span class="keywd">const</span> <span class="type">string</span>: str (KAmber) <span class="keywd">is</span>     str(AMBER);
<span class="keywd">const</span> <span class="type">string</span>: str (KOrange) <span class="keywd">is</span>    str(ORANGE);
<span class="keywd">const</span> <span class="type">string</span>: str (KRed) <span class="keywd">is</span>       str(RED);
<span class="keywd">const</span> <span class="type">string</span>: str (KScarlet) <span class="keywd">is</span>   str(SCARLET);
<span class="keywd">const</span> <span class="type">string</span>: str (KTan) <span class="keywd">is</span>       str(TAN);
<span class="keywd">const</span> <span class="type">string</span>: str (KLilac) <span class="keywd">is</span>     str(LILIAC);
<span class="keywd">const</span> <span class="type">string</span>: str (KPink) <span class="keywd">is</span>      str(PINK);

<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">killReason</span>: aReason) <span class="keywd">is</span> DYNAMIC;

enable_output(killReason);

<span class="keywd">const</span> <span class="type">type</span>: statRecord <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: accno <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: accmass <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: deathtime <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: totalno <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: totalmass <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">var</span> <span class="type">array</span> <span class="type">[</span>bactColor] <span class="type">array</span> <span class="type">[</span>boolean] <span class="type">statRecord</span>: statValues <span class="keywd">is</span>
    bactColor <span class="op">times</span> boolean <span class="op">times</span> statRecord.value;

<span class="keywd">var</span> <span class="type">array</span> <span class="type">[</span>bactColor] <span class="type">array</span> <span class="type">[</span>killReason] <span class="type">integer</span>: killarray <span class="keywd">is</span>
    bactColor <span class="op">times</span> killReason <span class="op">times</span> 0;

<span class="keywd">const</span> <span class="type">array</span> <span class="type">[</span>bactColor] <span class="type">killReason</span>: REASON <span class="keywd">is</span> [bactColor] (
    KNoReason, KNoReason, KWhite, KViolet, KIndigo, KBlue, KCyan,
    KGreen, KYellow, KAmber, KOrange, KRed, KScarlet, KTan,
    KLilac, KPink
  );

<span class="keywd">const</span> <span class="type">integer</span>: STATTIME <span class="keywd">is</span> 1;     <span class="comment">(* Interval of Statistics *)</span>

<span class="keywd">var</span> <span class="type">integer</span>: genNr <span class="keywd">is</span> 0;

<span class="keywd">const</span> <span class="type">color</span>: statCol <span class="keywd">is</span> white;   <span class="comment">(* Color for statistics *)</span>

<span class="keywd">const</span> <span class="type">color</span>: display_color (EDGE) <span class="keywd">is</span>    white;
<span class="keywd">const</span> <span class="type">color</span>: display_color (CLEAR) <span class="keywd">is</span>   white;

<span class="keywd">const</span> <span class="type">color</span>: display_color (WHITE) <span class="keywd">is</span>   white;
<span class="keywd">const</span> <span class="type">color</span>: display_color (VIOLET) <span class="keywd">is</span>  dark_magenta;
<span class="keywd">const</span> <span class="type">color</span>: display_color (INDIGO) <span class="keywd">is</span>  white;
<span class="keywd">const</span> <span class="type">color</span>: display_color (BLUE) <span class="keywd">is</span>    light_blue;
<span class="keywd">const</span> <span class="type">color</span>: display_color (CYAN) <span class="keywd">is</span>    dark_cyan;
<span class="keywd">const</span> <span class="type">color</span>: display_color (GREEN) <span class="keywd">is</span>   light_green;
<span class="keywd">const</span> <span class="type">color</span>: display_color (YELLOW) <span class="keywd">is</span>  yellow;
<span class="keywd">const</span> <span class="type">color</span>: display_color (AMBER) <span class="keywd">is</span>   amber;
<span class="keywd">const</span> <span class="type">color</span>: display_color (ORANGE) <span class="keywd">is</span>  orange;
<span class="keywd">const</span> <span class="type">color</span>: display_color (RED) <span class="keywd">is</span>     light_red;
<span class="keywd">const</span> <span class="type">color</span>: display_color (SCARLET) <span class="keywd">is</span> dark_red;
<span class="keywd">const</span> <span class="type">color</span>: display_color (TAN) <span class="keywd">is</span>     brown;
<span class="keywd">const</span> <span class="type">color</span>: display_color (LILIAC) <span class="keywd">is</span>  light_magenta;
<span class="keywd">const</span> <span class="type">color</span>: display_color (PINK) <span class="keywd">is</span>    pink;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">color</span>: display_color (<span class="op">in</span> <span class="type">bactColor</span>: aColor) <span class="keywd">is</span> DYNAMIC;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">char</span>: upper_char (<span class="op">in</span> <span class="type">bactColor</span>: aColor) <span class="keywd">is</span>
  <span class="keywd">return</span> [] (
    <span class="stri">' '</span>, <span class="stri">' '</span>, <span class="stri">'W'</span>, <span class="stri">'V'</span>, <span class="stri">'I'</span>, <span class="stri">'B'</span>, <span class="stri">'C'</span>,
    <span class="stri">'G'</span>, <span class="stri">'Y'</span>, <span class="stri">'A'</span>, <span class="stri">'O'</span>, <span class="stri">'R'</span>, <span class="stri">'S'</span>, <span class="stri">'T'</span>,
    <span class="stri">'L'</span>, <span class="stri">'P'</span>
  )[succ(ord(aColor))];

<span class="keywd">const</span> <span class="type">func</span> <span class="type">char</span>: lower_char (<span class="op">in</span> <span class="type">bactColor</span>: aColor) <span class="keywd">is</span>
  <span class="keywd">return</span> [] (
    <span class="stri">' '</span>, <span class="stri">' '</span>, <span class="stri">'w'</span>, <span class="stri">'v'</span>, <span class="stri">'i'</span>, <span class="stri">'b'</span>, <span class="stri">'c'</span>,
    <span class="stri">'g'</span>, <span class="stri">'y'</span>, <span class="stri">'a'</span>, <span class="stri">'o'</span>, <span class="stri">'r'</span>, <span class="stri">'s'</span>, <span class="stri">'t'</span>,
    <span class="stri">'l'</span>, <span class="stri">'p'</span>
  )[succ(ord(aColor))];

<span class="keywd">const</span> <span class="type">color</span>: textColor       <span class="keywd">is</span> white;
<span class="keywd">const</span> <span class="type">color</span>: textBackground  <span class="keywd">is</span> dark_blue;
<span class="keywd">const</span> <span class="type">color</span>: plateBackground <span class="keywd">is</span> dark_blue;

<span class="keywd">var</span> <span class="type">array</span> <span class="type">file</span>: fieldWin <span class="keywd">is</span> 3 <span class="op">times</span> STD_NULL;


<span class="keywd">const</span> <span class="type">array</span> <span class="type">[</span>direction] <span class="type">integer</span>: diffx <span class="keywd">is</span> [direction] (
    0, -1,  1,  0,  0, -1, -1,  1,  1);
<span class="keywd">const</span> <span class="type">array</span> <span class="type">[</span>direction] <span class="type">integer</span>: diffy <span class="keywd">is</span> [direction] (
    0,  0,  0, -1,  1, -1,  1, -1,  1);


<span class="keywd">var</span> <span class="type">colorSet</span>: playerSet <span class="keywd">is</span> colorSet.EMPTY_SET;


<span class="keywd">const</span> <span class="type">proc</span>: resetStat (<span class="op">in</span> <span class="type">bactColor</span>: species) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span> <span class="comment">(* resetStat *)</span>
<span class="comment">(*! statValues[species][FALSE].accno:= 0;
    statValues[species][FALSE].accmass:= 0; *)</span>
    noop;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* resetStat *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: incrKillStat (<span class="op">in</span> <span class="type">bactColor</span>: content, <span class="op">in</span> <span class="type">killReason</span>: Killer) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span> <span class="comment">(* incrKillStat *)</span>
    incr(killarray[content][Killer]);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* incrKillStat *)</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: continue (GAME) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: doContinue <span class="keywd">is</span> FALSE;

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: c <span class="keywd">is</span> <span class="stri">' '</span>;

  <span class="keywd">begin</span> <span class="comment">(* continue (GAME) *)</span>
    setPos(stat, 34, 1);
    color(stat, statCol);
    write(stat, <span class="stri">" Once more (y/n) ?                 "</span>);
    setPos(stat, 34, 21);
    <span class="keywd">repeat</span>
      c := upper(getc(KEYBOARD));
    <span class="keywd">until</span> c = <span class="stri">'Y'</span> <span class="op">or</span> c = <span class="stri">'N'</span>;
    setPos(stat, 34, 1);
    doContinue := c = <span class="stri">'Y'</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* continue (GAME) *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: setclass (<span class="op">in</span> <span class="type">xcoordinate</span>: x, <span class="op">in</span> <span class="type">ycoordinate</span>: y,
    <span class="op">in</span> <span class="type">bactColor</span>: sclass, <span class="op">in</span> <span class="type">boolean</span>: small) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span> <span class="comment">(* setclass *)</span>
    <span class="keywd">if</span> sclass = CLEAR <span class="keywd">then</span>
      rect(X_SHIFT + STRETCH_FACTOR * x, Y_SHIFT + STRETCH_FACTOR * y,
          STRETCH_FACTOR, STRETCH_FACTOR, plateBackground);
      <span class="keywd">if</span> area[x][y].meal &lt;> 0 <span class="keywd">then</span>
        point(X_SHIFT + STRETCH_FACTOR * x + HALF_FACTOR,
            Y_SHIFT + STRETCH_FACTOR * y + HALF_FACTOR,
            white);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      <span class="keywd">if</span> small <span class="keywd">then</span>
        fcircle(X_SHIFT + STRETCH_FACTOR * x + HALF_FACTOR,
            Y_SHIFT + STRETCH_FACTOR * y + HALF_FACTOR,
            SMALL_RADIUS, display_color(sclass));
      <span class="keywd">else</span>
        fcircle(X_SHIFT + STRETCH_FACTOR * x + HALF_FACTOR,
            Y_SHIFT + STRETCH_FACTOR * y + HALF_FACTOR,
            NORMAL_RADIUS, display_color(sclass));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* setclass *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: writeParameters (<span class="op">in</span> <span class="type">integer</span>: initSize,
    <span class="op">in</span> <span class="type">integer</span>: foodReserve, <span class="op">in</span> <span class="type">integer</span>: shrinkage) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span> <span class="comment">(* writeParameters *)</span>
    setPos(info, 1, 1);
    writeln(info, <span class="stri">"Isize "</span>     &lt;&amp; initSize    <span class="op">lpad</span> 5);
    writeln(info, <span class="stri">"Foodr "</span>     &lt;&amp; foodReserve <span class="op">lpad</span> 5);
    writeln(info, <span class="stri">"Shrinkage "</span> &lt;&amp; shrinkage   <span class="op">lpad</span> 3 &lt;&amp; <span class="stri">"%"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* writeParameters *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: initScreen <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: x <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: y <span class="keywd">is</span> 0;

  <span class="keywd">begin</span> <span class="comment">(* initScreen *)</span>
    info := openWindow(scr, 2, 48, 34, 58);
    stat := info;
    fstat := info;
    rect(PLATE_XPOS, PLATE_YPOS,
        STRETCH_FACTOR * MAX_COLUMN + 2 * PLATE_BORDER + 1,
        STRETCH_FACTOR * MAX_LINE + 2 * PLATE_BORDER + 1, plateBackground);
    box(PLATE_XPOS, PLATE_YPOS,
        STRETCH_FACTOR * MAX_COLUMN + 2 * PLATE_BORDER + 1,
        STRETCH_FACTOR * MAX_LINE + 2 * PLATE_BORDER + 1, light_cyan);
    <span class="keywd">if</span> foodReserve > 0 <span class="keywd">then</span>
      <span class="keywd">for</span> x <span class="keywd">range</span> 2 <span class="keywd">to</span> pred(XMAX) <span class="keywd">do</span>
        <span class="keywd">for</span> y <span class="keywd">range</span> 2 <span class="keywd">to</span> pred(YMAX) <span class="keywd">do</span>
          point(X_SHIFT + STRETCH_FACTOR * x + HALF_FACTOR,
              Y_SHIFT + STRETCH_FACTOR * y + HALF_FACTOR, white);
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    color(scr, white, dark_blue);
    box(info);
    setPos(scr, 25, 2);
    color(scr, black, dark_cyan);
    write(scr, <span class="stri">" F1 "</span>);
    color(scr, white, black);
    write(scr, <span class="stri">" brings bacteria to life "</span>);

    setPos(scr, 27, 2);
    color(scr, white, textBackground);
    write(scr, <span class="stri">" W White   "</span>);
    color(scr, dark_magenta, textBackground);
    write(scr, <span class="stri">" V Violet  "</span>);
    color(scr, white, textBackground);
    write(scr, <span class="stri">" I Indigo  "</span>);
    color(scr, light_blue, textBackground);
    write(scr, <span class="stri">" B Blue   "</span>);
    setPos(scr, 28, 2);
    color(scr, dark_cyan, textBackground);
    write(scr, <span class="stri">" C Cyan    "</span>);
    color(scr, light_green, textBackground);
    write(scr, <span class="stri">" G Green   "</span>);
    color(scr, yellow, textBackground);
    write(scr, <span class="stri">" Y Yellow  "</span>);
    color(scr, amber, textBackground);
    write(scr, <span class="stri">" A Amber  "</span>);
    setPos(scr, 29, 2);
    color(scr, orange, textBackground);
    write(scr, <span class="stri">" O Orange  "</span>);
    color(scr, light_red, textBackground);
    write(scr, <span class="stri">" R Red     "</span>);
    color(scr, dark_red, textBackground);
    write(scr, <span class="stri">" S Scarlet "</span>);
    color(scr, brown, textBackground);
    write(scr, <span class="stri">" T Tan    "</span>);
    setPos(scr, 30, 2);
    color(scr, light_magenta, textBackground);
    write(scr, <span class="stri">" L Lilac   "</span>);
    color(scr, pink, textBackground);
    write(scr, <span class="stri">" P Pink    "</span>);
    write(scr, <span class="stri">"           "</span>);
    write(scr, <span class="stri">"          "</span>);

    setPos(scr, 1, 1);
    color(scr, textColor, textBackground)
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* initScreen *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: readLimits <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: currWin <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: intValue <span class="keywd">is</span> 3 <span class="op">times</span> 10;
    <span class="keywd">var</span> <span class="type">boolean</span>: leave <span class="keywd">is</span> FALSE;

  <span class="keywd">begin</span> <span class="comment">(* readLimits *)</span>
    intValue[1] := initSize;
    intValue[2] := foodReserve;
    intValue[3] := shrinkage;
    leave := FALSE;
    currWin:= 1;
    <span class="keywd">repeat</span>
      read(fieldWin[currWin], intValue[currWin]);
      <span class="keywd">case</span> fieldWin[currWin].bufferChar <span class="keywd">of</span>
        <span class="keywd">when</span> {KEY_TAB, KEY_DOWN}:
          writeParameters(intValue[1], intValue[2], intValue[3]);
          incr(currWin);
          <span class="keywd">if</span> currWin = 4 <span class="keywd">then</span>
            currWin := 1;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {KEY_BACKTAB, KEY_UP}:
          writeParameters(intValue[1], intValue[2], intValue[3]);
          decr(currWin);
          <span class="keywd">if</span> currWin = 0 <span class="keywd">then</span>
            currWin := 3;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {KEY_NL}:
          initSize    := intValue[1];
          foodReserve := intValue[2];
          shrinkage   := intValue[3];
          leave := TRUE;
        <span class="keywd">when</span> {KEY_ESC}:
          leave := TRUE;
      <span class="keywd">end</span> <span class="keywd">case</span>;
<span class="comment">(*
      write(intValue[1]); write(" "); write(intValue[2]); write(" "); write(intValue[3]); write("  ");
      write(initSize); write(" "); write(foodReserve); write(" "); writeln(shrinkage);
*)</span>
    <span class="keywd">until</span> leave;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* readLimits *)</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">bactColor</span>: charCol (<span class="op">in</span> <span class="type">char</span>: ch) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">bactColor</span>: col <span class="keywd">is</span> CLEAR;

  <span class="keywd">begin</span> <span class="comment">(* charCol *)</span>
    <span class="keywd">case</span> upper(ch) <span class="keywd">of</span>
      <span class="keywd">when</span> {<span class="stri">' '</span>}: col:= CLEAR;
      <span class="keywd">when</span> {<span class="stri">'.'</span>}: col:= CLEAR;
      <span class="keywd">when</span> {<span class="stri">'W'</span>}: col:= WHITE;
      <span class="keywd">when</span> {<span class="stri">'V'</span>}: col:= VIOLET;
      <span class="keywd">when</span> {<span class="stri">'I'</span>}: col:= INDIGO;
      <span class="keywd">when</span> {<span class="stri">'B'</span>}: col:= BLUE;
      <span class="keywd">when</span> {<span class="stri">'C'</span>}: col:= CYAN;
      <span class="keywd">when</span> {<span class="stri">'G'</span>}: col:= GREEN;
      <span class="keywd">when</span> {<span class="stri">'Y'</span>}: col:= YELLOW;
      <span class="keywd">when</span> {<span class="stri">'A'</span>}: col:= AMBER;
      <span class="keywd">when</span> {<span class="stri">'O'</span>}: col:= ORANGE;
      <span class="keywd">when</span> {<span class="stri">'R'</span>}: col:= RED;
      <span class="keywd">when</span> {<span class="stri">'S'</span>}: col:= SCARLET;
      <span class="keywd">when</span> {<span class="stri">'T'</span>}: col:= TAN;
      <span class="keywd">when</span> {<span class="stri">'L'</span>}: col:= LILIAC;
      <span class="keywd">when</span> {<span class="stri">'P'</span>}: col:= PINK
      <span class="keywd">otherwise</span>: col := EDGE;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* charCol *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: initDisplay <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span> <span class="comment">(* initDisplay *)</span>
    fieldWin[1] := openField(KEYBOARD, info, 1,  7, 5, <span class="stri">"   10"</span>);
    fieldWin[2] := openField(KEYBOARD, info, 2,  7, 5, <span class="stri">"   10"</span>);
    fieldWin[3] := openField(KEYBOARD, info, 3, 11, 3, <span class="stri">" 10"</span>);
<span class="comment">(*
    color(scr, textColor, textBackground);
    clear(scr);
*)</span>
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* initDisplay *)</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">direction</span>: ranDir (<span class="op">in</span> <span class="type">directSet</span>: dirset) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">direction</span>: dir <span class="keywd">is</span> HERE;

  <span class="keywd">begin</span> <span class="comment">(* ranDir *)</span>
    <span class="keywd">if</span> dirset &lt;> directSet.EMPTY_SET <span class="keywd">then</span>
      dir := rand(dirset);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* ranDir *)</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">power</span>: shrinkSize (<span class="op">in</span> <span class="type">power</span>: size) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">power</span>: shrinkSize <span class="keywd">is</span> 0;

  <span class="keywd">begin</span> <span class="comment">(* shrinkSize *)</span>
    <span class="keywd">if</span> size &lt;> 0 <span class="keywd">then</span>
      shrinkSize := succ((pred(size) * shrinkage) <span class="op">div</span> 100);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* shrinkSize *)</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">power</span>: nextSize (<span class="op">in</span> <span class="type">power</span>: ownSize, <span class="op">in</span> <span class="type">power</span>: foodMass,
    <span class="op">in</span> <span class="type">lifeSpan</span>: ownHunger) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">power</span>: size <span class="keywd">is</span> 0;

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">power</span>: shrinkext <span class="keywd">is</span> 0;

  <span class="keywd">begin</span> <span class="comment">(* nextSize *)</span>
    shrinkext := shrinkSize(ownSize);
    <span class="keywd">if</span> foodMass >= shrinkext <span class="op">or</span> ownHunger &lt;> 0 <span class="keywd">then</span>
      size := ownSize - shrinkext + foodMass;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* nextSize *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: initBacterium (<span class="keywd">inout</span> <span class="type">bacterium</span>: bact,
    <span class="op">in</span> <span class="type">xcoordinate</span>: cx, <span class="op">in</span> <span class="type">ycoordinate</span>: cy,
    <span class="op">in</span> <span class="type">lifeSpan</span>: ownHunger, <span class="op">in</span> <span class="type">power</span>: strength) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span> <span class="comment">(* initBacterium *)</span>
    bact.xpos := cx;
    bact.ypos := cy;
    bact.hungry := ownHunger;
    bact.mass := strength;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* initBacterium *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: create (<span class="op">in</span> <span class="type">xcoordinate</span>: cx, <span class="op">in</span> <span class="type">ycoordinate</span>: cy,
    <span class="keywd">inout</span> <span class="type">array</span> <span class="type">microbe</span>: animates, <span class="op">in</span> <span class="type">bactColor</span>: species,
    <span class="op">in</span> <span class="type">lifeSpan</span>: ownHunger, <span class="op">in</span> <span class="type">power</span>: strength) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">bacterium</span>: bact <span class="keywd">is</span> bacterium.value;

  <span class="keywd">begin</span> <span class="comment">(* create *)</span>
    area[cx][cy].content := species;
    initBacterium(bact, cx, cy, ownHunger, strength);
    area[cx][cy].possessor := varalloc(bact);
    children &amp;:= [] (area[cx][cy].possessor);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* create *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: setBact (<span class="op">in</span> <span class="type">xcoordinate</span>: x, <span class="op">in</span> <span class="type">ycoordinate</span>: y, <span class="op">in</span> <span class="type">bactColor</span>: species) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span> <span class="comment">(* setBact *)</span>
    create(x, y, animates, species, MAXLIFESPAN, initSize);
    incl(playerSet, species);
    resetStat(species);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* setBact *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: die (<span class="op">in</span> <span class="type">xcoordinate</span>: x, <span class="op">in</span> <span class="type">ycoordinate</span>: y, <span class="op">in</span> <span class="type">killReason</span>: killer) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span> <span class="comment">(* die *)</span>
    <span class="keywd">if</span> area[x][y].content &lt;> CLEAR <span class="keywd">then</span>
      area[x][y].meal +:= area[x][y].possessor->mass;
      area[x][y].possessor->mass := 0;
      area[x][y].possessor := microbe.NIL;
      incrKillStat(area[x][y].content, killer);
      area[x][y].content := CLEAR;
      setclass(x, y, CLEAR, FALSE);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* die *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: move (<span class="keywd">inout</span> <span class="type">xcoordinate</span>: old_x_pos, <span class="keywd">inout</span> <span class="type">ycoordinate</span>: old_y_pos,
    <span class="op">in</span> <span class="type">direction</span>: direct) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">xcoordinate</span>: new_x_pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">ycoordinate</span>: new_y_pos <span class="keywd">is</span> 0;

  <span class="keywd">begin</span> <span class="comment">(* move *)</span>
    new_x_pos := old_x_pos + diffx[direct];
    new_y_pos := old_y_pos + diffy[direct];
    <span class="keywd">if</span> area[new_x_pos][new_y_pos].content = CLEAR <span class="keywd">then</span>
      area[new_x_pos][new_y_pos].content :=
          area[old_x_pos][old_y_pos].content;
      area[new_x_pos][new_y_pos].possessor :=
          area[old_x_pos][old_y_pos].possessor;
      area[new_x_pos][new_y_pos].possessor->xpos := new_x_pos;
      area[new_x_pos][new_y_pos].possessor->ypos := new_y_pos;
      area[old_x_pos][old_y_pos].content := CLEAR;
      area[old_x_pos][old_y_pos].possessor := microbe.NIL;
      setclass(old_x_pos, old_y_pos, CLEAR, FALSE);
      setclass(new_x_pos, new_y_pos,
          area[new_x_pos][new_y_pos].content, FALSE);
      old_x_pos := new_x_pos;
      old_y_pos := new_y_pos;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* move *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: digest (<span class="op">in</span> <span class="type">xcoordinate</span>: x, <span class="op">in</span> <span class="type">ycoordinate</span>: y, <span class="op">in</span> <span class="type">power</span>: quantity) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">microbe</span>: bact_1 <span class="keywd">is</span> microbe.NIL;
    <span class="keywd">var</span> <span class="type">power</span>: shrinkext <span class="keywd">is</span> 0;

  <span class="keywd">begin</span> <span class="comment">(* digest *)</span>
    bact_1 := area[x][y].possessor;
    shrinkext := shrinkSize(bact_1->mass);
    <span class="keywd">if</span> quantity &lt; shrinkext <span class="keywd">then</span>
      <span class="keywd">if</span> bact_1->hungry = 0 <span class="op">or</span>
          bact_1->mass - shrinkext + quantity &lt;= 0 <span class="keywd">then</span>
        die(x, y, KHunger);
      <span class="keywd">else</span>
        bact_1->mass +:= quantity - shrinkext;
        area[x][y].meal -:= quantity;
        bact_1->hungry := min(pred(bact_1->mass), pred(bact_1->hungry));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      bact_1->mass +:= quantity - shrinkext;
      area[x][y].meal -:= quantity;
      bact_1->hungry := min(MAXLIFESPAN, pred(bact_1->mass));
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* digest *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: eatat (<span class="op">in</span> <span class="type">xcoordinate</span>: x, <span class="op">in</span> <span class="type">ycoordinate</span>: y, <span class="op">in</span> <span class="keywd">var</span> <span class="type">power</span>: quantity) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span> <span class="comment">(* eatat *)</span>
    quantity := min(quantity, area[x][y].meal);
    <span class="keywd">if</span> area[x][y].possessor->mass &lt; quantity <span class="keywd">then</span>
      die(x, y, KBigMouth)
    <span class="keywd">else</span>
      digest(x, y, quantity)
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* eatat *)</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">power</span>: strength (<span class="op">in</span> <span class="type">direction</span>: direct) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">power</span>: strength <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">microbe</span>: possessor <span class="keywd">is</span> microbe.NIL;

  <span class="keywd">begin</span> <span class="comment">(* strength *)</span>
    possessor := area[x + diffx[direct]][y + diffy[direct]].possessor;
    <span class="keywd">if</span> possessor &lt;> microbe.NIL <span class="keywd">then</span>
      strength := possessor->mass;
    <span class="keywd">else</span>
      strength := 0;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* strength *)</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">bactColor</span>: view (<span class="op">in</span> <span class="type">direction</span>: direct) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">bactColor</span>: content <span class="keywd">is</span> CLEAR;

  <span class="keywd">begin</span> <span class="comment">(* view *)</span>
    content := area[x + diffx[direct]][y + diffy[direct]].content;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* view *)</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">power</span>: food (<span class="op">in</span> <span class="type">direction</span>: direct) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">power</span>: meal <span class="keywd">is</span> 0;

  <span class="keywd">begin</span> <span class="comment">(* food *)</span>
    meal := area[x + diffx[direct]][y + diffy[direct]].meal;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* food *)</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">lifeSpan</span>: hunger <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">lifeSpan</span>: hungry <span class="keywd">is</span> 0;

  <span class="keywd">begin</span> <span class="comment">(* hunger *)</span>
    hungry := area[x][y].possessor->hungry;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* hunger *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: doWait <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">power</span>: quantity <span class="keywd">is</span> 0;

  <span class="keywd">begin</span> <span class="comment">(* doWait *)</span>
    <span class="keywd">if</span> <span class="op">not</span> done <span class="keywd">then</span>
      digest(x, y, quantity);
      done := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* doWait *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: eat (<span class="op">in</span> <span class="type">direction</span>: direct, <span class="op">in</span> <span class="type">power</span>: quantity) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span> <span class="comment">(* eat *)</span>
    <span class="keywd">if</span> <span class="op">not</span> done <span class="keywd">then</span>
<span class="comment">(*    write("eat("); write(direct); write(", "); write(quantity); writeln(");"); *)</span>
      <span class="keywd">if</span> area[x + diffx[direct]][y + diffy[direct]].content &lt;> CLEAR <span class="op">and</span>
          direct &lt;> HERE <span class="keywd">then</span>
        die(x, y, KFnotEmpty);
      <span class="keywd">elsif</span> direct <span class="op">in</span> {NW, NE, SW, SE} <span class="keywd">then</span>
        die(x, y, KWrMove);
      <span class="keywd">else</span>
        <span class="keywd">if</span> direct = HERE <span class="keywd">then</span>
          setclass(x, y, area[x][y].content, FALSE);
        <span class="keywd">else</span>
          move(x, y, direct);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        eatat(x, y, quantity);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      done := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* eat *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: kill (<span class="op">in</span> <span class="type">direction</span>: direct) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">xcoordinate</span>: new_x <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">ycoordinate</span>: new_y <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: quantity <span class="keywd">is</span> 0;

  <span class="keywd">begin</span> <span class="comment">(* kill *)</span>
    <span class="keywd">if</span> <span class="op">not</span> done <span class="keywd">then</span>
<span class="comment">(*    write("kill("); write(direct); write(", "); write(quantity); writeln(");"); *)</span>
      <span class="keywd">if</span> direct = HERE <span class="keywd">then</span>
        die(x, y, KSuicide);
      <span class="keywd">elsif</span> direct <span class="op">in</span> {NW, NE, SW, SE} <span class="keywd">then</span>
        die(x, y, KWrMove);
      <span class="keywd">elsif</span> strength(direct) > strength(HERE) <span class="keywd">then</span>
        die(x, y, KBigMouth);
      <span class="keywd">else</span>
        new_x := x + diffx[direct];
        new_y := y + diffy[direct];
        <span class="keywd">case</span> area[new_x][new_y].content <span class="keywd">of</span>
          <span class="keywd">when</span> {EDGE}:
            die(x, y, KEdge);
          <span class="keywd">when</span> {CLEAR}:
            move(x, y, direct);
          <span class="keywd">otherwise</span>:
            quantity := strength(direct);
            die(new_x, new_y, REASON[area[x][y].content]);
            move(x, y, direct);
            digest(x, y, quantity);
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      done := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* kill *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: split (<span class="op">in</span> <span class="type">direction</span>: direct, <span class="op">in</span> <span class="type">power</span>: quantity1, <span class="op">in</span> <span class="type">power</span>: quantity2) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">microbe</span>: bact_1 <span class="keywd">is</span> microbe.NIL;
    <span class="keywd">var</span> <span class="type">xcoordinate</span>: new_x <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">ycoordinate</span>: new_y <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">bactColor</span>: species <span class="keywd">is</span> CLEAR;
    <span class="keywd">var</span> <span class="type">lifeSpan</span>: hungry <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">power</span>: strength <span class="keywd">is</span> 0;

  <span class="keywd">begin</span> <span class="comment">(* split *)</span>
    <span class="keywd">if</span> <span class="op">not</span> done <span class="keywd">then</span>
<span class="comment">(*    write("split("); write(direct); write(", "); write(quantity1); write(", "); write(quantity2); writeln(");"); *)</span>
      bact_1 := area[x][y].possessor;
      new_x := x + diffx[direct];
      new_y := y + diffy[direct];
      <span class="keywd">if</span> area[new_x][new_y].content = EDGE <span class="keywd">then</span>
        die(x, y, KEdge);
      <span class="keywd">elsif</span> direct <span class="op">in</span> {HERE, NW, NE, SW, SE} <span class="keywd">then</span>
        die(x, y, KWrMove);
      <span class="keywd">elsif</span> area[new_x][new_y].content &lt;> CLEAR <span class="keywd">then</span>
        die(x, y, KFnotEmpty);
      <span class="keywd">elsif</span> bact_1->mass &lt;= 1 <span class="keywd">then</span>
        die(x, y, KHunger);
      <span class="keywd">else</span>
        species := view(HERE);
        setclass(x, y, species, TRUE);
        setclass(new_x, new_y, species, TRUE);
        hungry := min(bact_1->hungry, pred(bact_1->mass <span class="op">div</span> 2));
        strength := bact_1->mass <span class="op">div</span> 2;
        create(new_x, new_y, animates, species, hungry, strength);
        bact_1->hungry := min(bact_1->hungry, pred(bact_1->mass));
        bact_1->mass -:= strength;
        eatat(x, y, quantity1);
        eatat(new_x, new_y, quantity2);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      done := TRUE
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* split *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: setAllBacterials <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">xcoordinate</span>: x <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">ycoordinate</span>: y <span class="keywd">is</span> 0;

  <span class="keywd">begin</span> <span class="comment">(* setAllBacterials *)</span>
    children := 0 <span class="op">times</span> microbe.NIL;
    <span class="keywd">for</span> x <span class="keywd">range</span> 2 <span class="keywd">to</span> pred(XMAX) <span class="keywd">do</span>
      <span class="keywd">for</span> y <span class="keywd">range</span> 2 <span class="keywd">to</span> pred(YMAX) <span class="keywd">do</span>
        <span class="comment">(* write(STD_ERR, x lpad 2);
        write(STD_ERR, y lpad 3);
        write(STD_ERR, " ");
        writeln(STD_ERR, area[x][y].content); *)</span>
        area[x][y].meal := foodReserve;
        <span class="keywd">if</span> area[x][y].content &lt;> CLEAR <span class="keywd">then</span>
          setBact(x, y, area[x][y].content);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    animates := children;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* setAllBacterials *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: writeInfo (<span class="op">in</span> <span class="type">integer</span>: line, <span class="op">in</span> <span class="type">integer</span>: column) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">bactColor</span>: species <span class="keywd">is</span> CLEAR;

  <span class="keywd">begin</span> <span class="comment">(* writeInfo *)</span>
    color(info, white, dark_blue);
    clear(info);
    writeParameters(initSize, foodReserve, shrinkage);
    writeln(info, <span class="stri">"Position "</span> &lt;&amp; line <span class="op">lpad</span> 2 &lt;&amp; <span class="stri">" "</span> &lt;&amp; column <span class="op">lpad</span> 2);
    species := area[succ(column)][succ(line)].content;
    write(info, species);
    <span class="keywd">if</span> species &lt;> EDGE <span class="op">and</span> species &lt;> CLEAR <span class="keywd">then</span>
      write(info, <span class="stri">" of size "</span>);
      <span class="keywd">if</span> area[succ(column)][succ(line)].possessor &lt;> microbe.NIL <span class="keywd">then</span>
        write(info, area[succ(column)][succ(line)].possessor->mass);
      <span class="keywd">else</span>
        write(info, initSize);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(info);
    write(info, <span class="stri">"Meal "</span>);
    write(info, area[succ(column)][succ(line)].meal);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* writeInfo *)</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">char</span>: readCommand (<span class="op">in</span> <span class="type">integer</span>: line, <span class="op">in</span> <span class="type">integer</span>: column) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">char</span>: command <span class="keywd">is</span> <span class="stri">' '</span>;

  <span class="keywd">begin</span> <span class="comment">(* readCommand *)</span>
    writeInfo(line, column);
    box(X_SHIFT + STRETCH_FACTOR * succ(column), Y_SHIFT + STRETCH_FACTOR * succ(line),
        succ(STRETCH_FACTOR), succ(STRETCH_FACTOR), white);
    command := getc(KEYBOARD);
    box(X_SHIFT + STRETCH_FACTOR * succ(column), Y_SHIFT + STRETCH_FACTOR * succ(line),
        succ(STRETCH_FACTOR), succ(STRETCH_FACTOR), plateBackground);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* readCommand *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: InitAnimates <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: x <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: y <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">char</span>: command <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">bactColor</span>: species <span class="keywd">is</span> CLEAR;

  <span class="keywd">begin</span> <span class="comment">(* InitAnimates *)</span>
    playerSet:= colorSet.EMPTY_SET;
    animates:= 0 <span class="op">times</span> microbe.value;
    command := readCommand(line, column);
    <span class="keywd">while</span> upper(command) &lt;> <span class="stri">'Q'</span> <span class="op">and</span> command &lt;> KEY_CLOSE <span class="op">and</span> command &lt;> KEY_F1 <span class="keywd">do</span>
      <span class="keywd">case</span> command <span class="keywd">of</span>
        <span class="keywd">when</span> {<span class="stri">'2'</span>, KEY_DOWN}:
          <span class="keywd">if</span> line &lt; MAX_LINE <span class="keywd">then</span>
            incr(line);
          <span class="keywd">else</span>
            line := 1;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'8'</span>, KEY_UP}:
          <span class="keywd">if</span> line > 1 <span class="keywd">then</span>
            decr(line);
          <span class="keywd">else</span>
            line := MAX_LINE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'6'</span>, KEY_RIGHT}:
          <span class="keywd">if</span> column &lt; MAX_COLUMN <span class="keywd">then</span>
            incr(column);
          <span class="keywd">else</span>
            column := 1;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'4'</span>, KEY_LEFT}:
          <span class="keywd">if</span> column > 1 <span class="keywd">then</span>
            decr(column);
          <span class="keywd">else</span>
            column := MAX_COLUMN;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'7'</span>, KEY_HOME}:
          line := 1;
          column := 1;
        <span class="keywd">when</span> {<span class="stri">'1'</span>, KEY_END}:
          line := MAX_LINE;
          column := MAX_COLUMN;
        <span class="keywd">when</span> {KEY_TAB}:
          column := MAX_COLUMN;
        <span class="keywd">when</span> {KEY_NL}:
          <span class="keywd">if</span> line = MAX_LINE <span class="keywd">then</span>
            column := 1;
          <span class="keywd">else</span>
            incr(line);
            column := 1;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {KEY_MOUSE1}:
          x := clickedXPos(KEYBOARD);
          y := clickedYPos(KEYBOARD);
          <span class="keywd">if</span> x >= X_SHIFT + STRETCH_FACTOR * 2 + 1 <span class="op">and</span>
              x &lt;= X_SHIFT + STRETCH_FACTOR * XMAX <span class="op">and</span>
              y >= Y_SHIFT + STRETCH_FACTOR * 2 + 1 <span class="op">and</span>
              y &lt;= Y_SHIFT + STRETCH_FACTOR * YMAX <span class="keywd">then</span>
            line := pred(y - Y_SHIFT) <span class="op">div</span> STRETCH_FACTOR - 1;
            column := pred(x - X_SHIFT) <span class="op">div</span> STRETCH_FACTOR - 1;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {KEY_ESC}:
          readLimits;
        <span class="keywd">otherwise</span>:
          species := charCol(command);
          <span class="keywd">if</span> species &lt;> EDGE <span class="keywd">then</span>
            area[succ(column)][succ(line)].content := species;
            <span class="keywd">if</span> species = CLEAR <span class="keywd">then</span>
              rect(X_SHIFT + STRETCH_FACTOR * succ(column),
                  Y_SHIFT + STRETCH_FACTOR * succ(line),
                  STRETCH_FACTOR, STRETCH_FACTOR, plateBackground);
              <span class="keywd">if</span> command = <span class="stri">'.'</span> <span class="keywd">then</span>
                point(X_SHIFT + STRETCH_FACTOR * succ(column) + HALF_FACTOR,
                    Y_SHIFT + STRETCH_FACTOR * succ(line) + HALF_FACTOR, white);
                area[succ(column)][succ(line)].meal := foodReserve;
              <span class="keywd">else</span>
                area[succ(column)][succ(line)].meal := 0;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">else</span>
              fcircle(X_SHIFT + STRETCH_FACTOR * succ(column) + HALF_FACTOR,
                  Y_SHIFT + STRETCH_FACTOR * succ(line) + HALF_FACTOR,
                  4, display_color(species));
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">case</span>;
      command := readCommand(line, column);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> command = KEY_F1 <span class="keywd">then</span>
      setAllBacterials;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* InitAnimates *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: initArea <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">xcoordinate</span>: x <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">ycoordinate</span>: y <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">position</span>: edgePosition <span class="keywd">is</span> position.value;

  <span class="keywd">begin</span> <span class="comment">(* initArea *)</span>
    edgePosition.content := EDGE;
    edgePosition.meal := 0;
    edgePosition.possessor := microbe.NIL;
    <span class="keywd">for</span> x <span class="keywd">range</span> 1 <span class="keywd">to</span> XMAX <span class="keywd">do</span>
      area[x][1] := edgePosition;
      area[x][YMAX] := edgePosition;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> y <span class="keywd">range</span> 2 <span class="keywd">to</span> pred(YMAX) <span class="keywd">do</span>
      area[1][y] := edgePosition;
      area[XMAX][y] := edgePosition;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> x <span class="keywd">range</span> 2 <span class="keywd">to</span> pred(XMAX) <span class="keywd">do</span>
      <span class="keywd">for</span> y <span class="keywd">range</span> 2 <span class="keywd">to</span> pred(YMAX) <span class="keywd">do</span>
        area[x][y].content := CLEAR;
        area[x][y].meal := foodReserve;
        area[x][y].possessor := microbe.NIL;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    InitAnimates;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* initArea *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: statistics (<span class="op">in</span> <span class="type">integer</span>: genNr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: playanz <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: sumAccno <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: sumAccmass <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: sumFoodno <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: sumFoodmass <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">xcoordinate</span>: x <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">ycoordinate</span>: y <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">hue</span>: species <span class="keywd">is</span> CLEAR;
    <span class="keywd">var</span> <span class="type">boolean</span>: anychange <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">microbe</span>: p <span class="keywd">is</span> microbe.NIL;

  <span class="keywd">begin</span> <span class="comment">(* statistics *)</span>
    sumAccno := 0;
    sumAccmass := 0;
    anychange := FALSE;
    <span class="keywd">for</span> species <span class="keywd">range</span> FIRSTCOL <span class="keywd">to</span> LASTCOL <span class="keywd">do</span>
      statValues[species][TRUE].accno := 0;
      statValues[species][TRUE].accmass := 0;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    color(stat, statCol);
    setPos(stat, 1, 12);
    writeln(stat, genNr <span class="op">lpad</span> 1);
    <span class="keywd">for</span> p <span class="keywd">range</span> animates <span class="keywd">do</span>
      <span class="keywd">if</span> p->mass > 0 <span class="keywd">then</span>
        incr(statValues[area[p->xpos][p->ypos].content][TRUE].accno);
        statValues[area[p->xpos][p->ypos].content][TRUE].accmass +:= p->mass;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    playanz := 1;
    <span class="keywd">for</span> species <span class="keywd">range</span> FIRSTCOL <span class="keywd">to</span> LASTCOL <span class="keywd">do</span>
      <span class="keywd">if</span> species <span class="op">in</span> playerSet <span class="keywd">then</span>
        <span class="keywd">if</span> statValues[species][TRUE].deathtime = 0 <span class="keywd">then</span>
          <span class="keywd">if</span> statValues[species][TRUE].accno = 0 <span class="keywd">then</span>
            statValues[species][TRUE].deathtime := genNr;
            setPos(stat, 4 + playanz, 9);
            write(stat, <span class="stri">"("</span>);
            write(stat, statValues[species][TRUE].totalno <span class="op">lpad</span> 5);
            write(stat, <span class="stri">" "</span>);
            write(stat, statValues[species][TRUE].totalmass <span class="op">lpad</span> 9);
            write(stat, flt(statValues[species][TRUE].totalmass) /
                flt(succ(statValues[species][TRUE].totalno)) <span class="op">digits</span> 1 <span class="op">lpad</span> 8);
            write(stat, <span class="stri">") d"</span>);
            writeln(stat, genNr <span class="op">lpad</span> 5);
            anychange := TRUE;
          <span class="keywd">else</span>
            sumAccno +:= statValues[species][TRUE].accno;
            sumAccmass +:= statValues[species][TRUE].accmass;
            statValues[species][TRUE].totalno +:=
                statValues[species][TRUE].accno;
            statValues[species][TRUE].totalmass +:=
                statValues[species][TRUE].accmass;
            <span class="keywd">if</span> statValues[species][TRUE].accno &lt;>
                statValues[species][FALSE].accno <span class="op">or</span>
                statValues[species][TRUE].accmass &lt;>
                statValues[species][FALSE].accmass <span class="keywd">then</span>
              setPos(stat, 4 + playanz, 9);
              write(stat, statValues[species][TRUE].accno <span class="op">lpad</span> 6);
              write(stat, <span class="stri">" "</span>);
              write(stat, statValues[species][TRUE].accmass <span class="op">lpad</span> 9);
              writeln(stat, flt(statValues[species][TRUE].accmass) /
                  flt(statValues[species][TRUE].accno) <span class="op">digits</span> 1 <span class="op">lpad</span> 8);
              statValues[species][FALSE] := statValues[species][TRUE];
              anychange := TRUE;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        incr(playanz);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> anychange <span class="keywd">then</span>
      setPos(stat, 5 + playanz, 9);
      write(stat, sumAccno <span class="op">lpad</span> 6);
      write(stat, <span class="stri">" "</span>);
      write(stat, sumAccmass <span class="op">lpad</span> 9);
      <span class="keywd">if</span> sumAccno &lt;> 0 <span class="keywd">then</span>
        writeln(stat, flt(sumAccmass) / flt(sumAccno) <span class="op">digits</span> 1 <span class="op">lpad</span> 8);
      <span class="keywd">else</span>
        writeln(stat, <span class="stri">" "</span> <span class="op">lpad</span> 8);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    sumFoodno := 0;
    sumFoodmass := 0;
    <span class="keywd">for</span> x <span class="keywd">range</span> 2 <span class="keywd">to</span> pred(XMAX) <span class="keywd">do</span>
      <span class="keywd">for</span> y <span class="keywd">range</span> 2 <span class="keywd">to</span> pred(YMAX) <span class="keywd">do</span>
        <span class="keywd">if</span> area[x][y].meal &lt;> 0 <span class="keywd">then</span>
          incr(sumFoodno);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        sumFoodmass +:= area[x][y].meal;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    setPos(stat, 6 + playanz, 9);
    write(stat, sumFoodno <span class="op">lpad</span> 6);
    write(stat, <span class="stri">" "</span>);
    write(stat, sumFoodmass <span class="op">lpad</span> 9);
    <span class="keywd">if</span> sumFoodno &lt;> 0 <span class="keywd">then</span>
      writeln(stat, flt(sumFoodmass) / flt(sumFoodno) <span class="op">digits</span> 1 <span class="op">lpad</span> 8);
    <span class="keywd">else</span>
      writeln(stat, <span class="stri">" "</span> <span class="op">lpad</span> 8);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    setPos(stat, 8 + playanz, 9);
    write(stat, sumAccno + sumFoodno <span class="op">lpad</span> 6);
    write(stat, <span class="stri">" "</span>);
    write(stat, sumAccmass + sumFoodmass <span class="op">lpad</span> 9);
    <span class="keywd">if</span> sumAccno + sumFoodno &lt;> 0 <span class="keywd">then</span>
      writeln(stat, flt(sumAccmass + sumFoodmass) / flt(sumAccno + sumFoodno) <span class="op">digits</span> 1 <span class="op">lpad</span> 8);
    <span class="keywd">else</span>
      writeln(stat, <span class="stri">" "</span> <span class="op">lpad</span> 8);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* statistics *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: finalStatistics <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: i <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: cardPlayerSet <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">hue</span>: col1 <span class="keywd">is</span> CLEAR;
    <span class="keywd">var</span> <span class="type">hue</span>: col2 <span class="keywd">is</span> CLEAR;
    <span class="keywd">var</span> <span class="type">bactColor</span>: col3 <span class="keywd">is</span> CLEAR;
    <span class="keywd">var</span> <span class="type">killReason</span>: reason <span class="keywd">is</span> KHunger;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">[</span>hue] <span class="type">hue</span>: colField <span class="keywd">is</span> hue <span class="op">times</span> hue.value;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">[</span>hue] <span class="type">bigInteger</span>: valueField <span class="keywd">is</span> hue <span class="op">times</span> 0_;

  <span class="keywd">begin</span> <span class="comment">(* finalStatistics *)</span>
    cardPlayerSet:= 0;
    color(stat, statCol);
    <span class="keywd">for</span> col1 <span class="keywd">range</span> FIRSTCOL <span class="keywd">to</span> LASTCOL <span class="keywd">do</span>
      <span class="keywd">if</span> col1 <span class="op">in</span> playerSet <span class="keywd">then</span>
        incr(cardPlayerSet);
        valueField[col1] := bigInteger(abs(statValues[col1][TRUE].totalno) + 1) *
            bigInteger(abs(statValues[col1][TRUE].totalmass) + 1) *
            bigInteger(abs(statValues[col1][TRUE].deathtime) + 1);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      colField[col1] := col1;
    <span class="keywd">end</span> <span class="keywd">for</span>;

    <span class="keywd">if</span> cardPlayerSet &lt;> 0 <span class="keywd">then</span>
      <span class="keywd">for</span> col1 <span class="keywd">range</span> FIRSTCOL <span class="keywd">to</span> pred(LASTCOL) <span class="keywd">do</span>
        <span class="keywd">for</span> col2 <span class="keywd">range</span> succ(col1) <span class="keywd">to</span> LASTCOL <span class="keywd">do</span>
          <span class="keywd">if</span> valueField[colField[col1]] &lt; valueField[colField[col2]] <span class="keywd">then</span>
            col3 := colField[col2];
            colField[col2] := colField[col1];
            colField[col1] := col3;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;

      <span class="keywd">for</span> col1 <span class="keywd">range</span> FIRSTCOL <span class="keywd">to</span> LASTCOL <span class="keywd">do</span>
        <span class="keywd">if</span> colField[col1] <span class="op">in</span> playerSet <span class="keywd">then</span>
          i:= 0;
          <span class="keywd">for</span> col3 <span class="keywd">range</span> FIRSTCOL <span class="keywd">to</span> colField[col1] <span class="keywd">do</span>
            <span class="keywd">if</span> col3 <span class="op">in</span> playerSet <span class="keywd">then</span>
              incr(i);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">for</span>;
          setPos(stat, 4 + i, 42);
          writeln(stat, ord(col1) - ord(FIRSTCOL) + 1 <span class="op">lpad</span> 1);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;

      setPos(fstat, cardPlayerSet + 11, 1);
      write(fstat, <span class="stri">"Victims:"</span>);
      <span class="keywd">for</span> col1 <span class="keywd">range</span> FIRSTCOL <span class="keywd">to</span> LASTCOL <span class="keywd">do</span>
        <span class="keywd">if</span> col1 <span class="op">in</span> playerSet <span class="keywd">then</span>
          write(fstat, col1 <span class="op">lpad</span> 7);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      writeln(fstat);
      <span class="keywd">for</span> reason <span class="keywd">range</span> KEdge <span class="keywd">to</span> KFnotEmpty <span class="keywd">do</span>
        <span class="keywd">if</span> reason &lt;= KHunger <span class="op">or</span> reason >= KWrMove <span class="op">or</span>
            hue <span class="op">conv</span> (ord(reason) - ord(KWhite) + ord(WHITE)) <span class="op">in</span> playerSet <span class="keywd">then</span>
          write(fstat, reason <span class="op">rpad</span> 8);
          <span class="keywd">for</span> col1 <span class="keywd">range</span> FIRSTCOL <span class="keywd">to</span> LASTCOL <span class="keywd">do</span>
            <span class="keywd">if</span> col1 <span class="op">in</span> playerSet | {CLEAR} <span class="keywd">then</span>
              write(fstat, killarray[col1][reason] <span class="op">lpad</span> 7);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">for</span>;
          writeln(fstat);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* finalStatistics *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: initStatistics <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">bactColor</span>: col1 <span class="keywd">is</span> CLEAR;
    <span class="keywd">var</span> <span class="type">killReason</span>: reason <span class="keywd">is</span> KHunger;
    <span class="keywd">var</span> <span class="type">integer</span>: playanz <span class="keywd">is</span> 0;

  <span class="keywd">begin</span> <span class="comment">(* initStatistics *)</span>
    playanz:= 0;
    clear(stat);
    color(stat, statCol);
    setPos(stat, 1, 1);
    writeln(stat, <span class="stri">"Generation"</span>);
    setPos(stat, 3, 1);
    writeln(stat, <span class="stri">"bact    number      mass  av.size"</span>);
    <span class="keywd">for</span> col1 <span class="keywd">range</span> ALL_COLORS <span class="keywd">do</span>
      <span class="keywd">if</span> col1 <span class="op">in</span> playerSet <span class="keywd">then</span>
        setPos(stat, 5 + playanz, 1);
        writeln(stat, col1);
        incr(playanz);
        statValues[col1][TRUE].deathtime:= 0;
        statValues[col1][TRUE].totalno:= 0;
        statValues[col1][TRUE].totalmass:= 0;
        <span class="keywd">for</span> reason <span class="keywd">range</span> KEdge <span class="keywd">to</span> KFnotEmpty <span class="keywd">do</span>
          killarray[col1][reason] := 0;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    setPos(stat, 6 + playanz, 1);
    writeln(stat, <span class="stri">"Sum"</span>);
    setPos(stat, 7 + playanz, 1);
    writeln(stat, <span class="stri">"Food"</span>);
    setPos(stat, 9 + playanz, 1);
    writeln(stat, <span class="stri">"Total"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* initStatistics *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: execute (<span class="keywd">ref</span> <span class="type">microbe</span>: individuum) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">bactColor</span>: species <span class="keywd">is</span> CLEAR;

  <span class="keywd">begin</span>
    x := individuum->xpos;
    y := individuum->ypos;
    done:= FALSE;
    species := area[x][y].content;
    <span class="keywd">case</span> species <span class="keywd">of</span>
      <span class="keywd">when</span> {WHITE}:   dna(WHITE);
      <span class="keywd">when</span> {VIOLET}:  dna(VIOLET);
      <span class="keywd">when</span> {INDIGO}:  dna(INDIGO);
      <span class="keywd">when</span> {BLUE}:    dna(BLUE);
      <span class="keywd">when</span> {GREEN}:   dna(GREEN);
      <span class="keywd">when</span> {ORANGE}:  dna(ORANGE);
      <span class="keywd">when</span> {RED}:     dna(RED);
      <span class="keywd">when</span> {TAN}:     dna(TAN);
<span class="comment">(*
      when {CYAN}:    dna(CYAN);
      when {YELLOW}:  dna(YELLOW);
      when {AMBER}:   dna(AMBER);
      when {SCARLET}: dna(SCARLET);
      when {LILIAC}:  dna(LILIAC);
      when {PINK}:    dna(PINK);
*)</span>
    <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">if</span> <span class="op">not</span> done <span class="keywd">then</span>
      doWait;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* execute *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: generation <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">microbe</span>: individuum <span class="keywd">is</span> microbe.NIL;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 1;

  <span class="keywd">begin</span> <span class="comment">(* generation *)</span>
    children := 0 <span class="op">times</span> microbe.NIL;
    index := 1;
    <span class="keywd">while</span> index &lt;= length(animates) <span class="keywd">do</span>
      <span class="keywd">if</span> animates[index]->mass = 0 <span class="keywd">then</span>
        ignore(remove(animates, index));
      <span class="keywd">else</span>
        execute(animates[index]);
        incr(index);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    animates := children &amp; animates;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* generation *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: command <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">time</span>: turnTime <span class="keywd">is</span> time.value;

  <span class="keywd">begin</span> <span class="comment">(* main *)</span>
    screen(640, 480);
    clear(curr_win, white);
    color(black, white);
    KEYBOARD := GRAPH_KEYBOARD;
    scr := open(curr_win);
    color(scr, black, white);
    setPos(scr, 4, 47);
    writeln(scr, <span class="stri">"D N A F I G H T"</span>);
    setPos(scr, 6, 31);
    writeln(scr, <span class="stri">"Copyright (C) 1985, 1986, 2005  Thomas Mertes"</span>);
    setPos(scr, 7, 31);
    writeln(scr, <span class="stri">"Copyright (C) 1985, 1986,       Markus Stumptner"</span>);
    setPos(scr, 8, 31);
    writeln(scr, <span class="stri">"Copyright (C) 1985, 1986, 1991  Johannes Gritsch"</span>);
    setPos(scr, 10, 35);
    writeln(scr, <span class="stri">"This program is free software under the"</span>);
    setPos(scr, 11, 35);
    writeln(scr, <span class="stri">"terms of the GNU General Public License"</span>);
    setPos(scr, 13, 28);
    writeln(scr, <span class="stri">"Dnafight is written in the Seed7 programming language"</span>);
    setPos(scr, 14, 35);
    writeln(scr, <span class="stri">"Homepage:  http://seed7.sourceforge.net"</span>);
    setPos(scr, 17, 1);
    writeln(scr, <span class="stri">"   Dnafight is a programming game in which bacteria fight \
        \against each other."</span>);
    writeln(scr);
    writeln(scr, <span class="stri">"   In Dnafight there are different types of bacteria named \
        \with colors. Each bacterium is controlled by"</span>);
    writeln(scr, <span class="stri">"   a DNA program written in Seed7. The plate on which the bacteria \
        \live is a rectangular grid of cells."</span>);
    writeln(scr, <span class="stri">"   A cell can be empty or contain one bacterium. A cell can also \
        \contain some food. In every turn a"</span>);
    writeln(scr, <span class="stri">"   bacterium can inspect its own cell and the eight neighbour cells. \
        \Then the bacterium can decide"</span>);
    writeln(scr, <span class="stri">"   between eating, killing or splitting in one of the four cardinal \
        \directions."</span>);
    writeln(scr);
    writeln(scr, <span class="stri">"     - Eating food includes moving and is also allowed when the \
        \bacterium stays in place."</span>);
    writeln(scr, <span class="stri">"     - Killing another bacterium is allowed when the other \
        \bacterium is of the same size or smaller."</span>);
    writeln(scr, <span class="stri">"     - Splitting a bacterium produces two half-sized bacteria. \
        \The first stays in place while the"</span>);
    writeln(scr, <span class="stri">"       second moves to another place. Both new bacteria can eat food."</span>);
    writeln(scr);
    writeln(scr, <span class="stri">"   There are two ways to play this game:"</span>);
    writeln(scr);
    writeln(scr, <span class="stri">"     1. Place some bacteria on the plate and let them fight \
        \against each other."</span>);
    writeln(scr, <span class="stri">"     2. Write a DNA program for a new bacterium and measure your \
        \programming skills."</span>);
    setPos(scr, 36, 41);
    writeln(scr, <span class="stri">"Press any key to start game"</span>);
    command := upper(getc(KEYBOARD));
    <span class="keywd">if</span> command &lt;> <span class="stri">'Q'</span> <span class="op">and</span> command &lt;> KEY_CLOSE <span class="keywd">then</span>
      clear(curr_win, white);
      setPos(scr, 1, 1);
      write(scr, <span class="stri">"DNAFIGHT V"</span>);
      writeln(scr, Version);
      <span class="keywd">repeat</span>
        initScreen;
        initDisplay;
        initArea;
        initStatistics;
        genNr := 0;

        turnTime := time(NOW);
        <span class="keywd">while</span> length(animates) &lt;> 0 <span class="op">and</span> getc(KEYBOARD, NO_WAIT) = KEY_NONE <span class="keywd">do</span>
          generation;
          turnTime +:= 50000 . MICRO_SECONDS;
          flushGraphic;
          await(turnTime);
          incr(genNr);
          <span class="keywd">if</span> genNr <span class="op">mod</span> STATTIME = 0 <span class="keywd">then</span>
            statistics(genNr);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">while</span>;

        finalStatistics;
      <span class="keywd">until</span> <span class="op">not</span> continue(GAME);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* main *)</span>
</pre>
</body>
</html>
