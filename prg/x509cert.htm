<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  x509cert.s7i  Support for X.509 public key certificates.        *)</span>
<span class="comment">(*  Copyright (C) 2013 - 2016, 2018, 2019  Thomas Mertes            *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/asn1.htm">asn1.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/pkcs1.htm">pkcs1.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/elliptic.htm">elliptic.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/msgdigest.htm">msgdigest.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/time.htm">time.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/duration.htm">duration.s7i</a>"</span>;


<span class="keywd">const</span> <span class="type">type</span>: algorithmIdentifierType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">string</span>: algorithm <span class="keywd">is</span> <span class="stri">""</span>;     <span class="comment"># OBJECT IDENTIFIER</span>
    <span class="keywd">var</span> <span class="type">string</span>: parameters <span class="keywd">is</span> <span class="stri">""</span>;    <span class="comment"># ANY DEFINED BY algorithm OPTIONAL</span>
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: nameType <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">string</span><span class="type">]</span> <span class="type">string</span>;

<span class="keywd">const</span> <span class="type">type</span>: validityType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">time</span>: notBefore <span class="keywd">is</span> time.value;
    <span class="keywd">var</span> <span class="type">time</span>: notAfter <span class="keywd">is</span> time.value;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: subjectPublicKeyInfoType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">algorithmIdentifierType</span>: algorithm <span class="keywd">is</span> algorithmIdentifierType.value;
    <span class="keywd">var</span> <span class="type">string</span>: subjectPublicKey <span class="keywd">is</span> <span class="stri">""</span>;  <span class="comment"># BIT STRING</span>
    <span class="keywd">var</span> rsaKey: publicRsaKey <span class="keywd">is</span> rsaKey.value;
    <span class="keywd">var</span> ellipticCurve: eCurve <span class="keywd">is</span> ellipticCurve.value;
    <span class="keywd">var</span> ecPoint: publicEccKey <span class="keywd">is</span> ecPoint.value;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: tbsCertificateType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: version <span class="keywd">is</span> 0;  <span class="comment"># v1</span>
    <span class="keywd">var</span> <span class="type">string</span>: serialNumber <span class="keywd">is</span> <span class="stri">""</span>;  <span class="comment"># INTEGER (up to 20 octets in length)</span>
    <span class="keywd">var</span> <span class="type">algorithmIdentifierType</span>: signature <span class="keywd">is</span> algorithmIdentifierType.value;
    <span class="keywd">var</span> <span class="type">nameType</span>: issuer <span class="keywd">is</span> nameType.value;
    <span class="keywd">var</span> <span class="type">validityType</span>: validity <span class="keywd">is</span> validityType.value;
    <span class="keywd">var</span> <span class="type">nameType</span>: subject <span class="keywd">is</span> nameType.value;
    <span class="keywd">var</span> <span class="type">subjectPublicKeyInfoType</span>: subjectPublicKeyInfo <span class="keywd">is</span> subjectPublicKeyInfoType.value;
    <span class="keywd">var</span> <span class="type">integer</span>: digestStartPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: digestEndPos <span class="keywd">is</span> 0;
<span class="comment">(*
        issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
                             -- If present, version shall be v2 or v3
        subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
                             -- If present, version shall be v2 or v3
        extensions      [3]  EXPLICIT Extensions OPTIONAL
                             -- If present, version shall be v3
*)</span>
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: x509cert <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">tbsCertificateType</span>:      tbsCertificate     <span class="keywd">is</span> tbsCertificateType.value;
    <span class="keywd">var</span> <span class="type">algorithmIdentifierType</span>: signatureAlgorithm <span class="keywd">is</span> algorithmIdentifierType.value;
    <span class="keywd">var</span> <span class="type">string</span>:                  signatureValue     <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>:                  messageDigest      <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: certSubjectIndexHashType <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">string</span><span class="type">]</span> <span class="type">integer</span>;

<span class="keywd">const</span> <span class="type">type</span>: certAndKey <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: certList <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
    <span class="keywd">var</span> rsaKey: privateRsaKey <span class="keywd">is</span> rsaKey.value;
    <span class="keywd">var</span> <span class="type">bigInteger</span>: privateEccKey <span class="keywd">is</span> 0_;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: rsaSignatureType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">algorithmIdentifierType</span>: algorithmIdentifier <span class="keywd">is</span> algorithmIdentifierType.value;
    <span class="keywd">var</span> <span class="type">string</span>: signature <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">string</span>: ALIASED_ENTRY_NAME_OID        <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 4, 1));   <span class="comment"># "U\4;\1;"</span>
<span class="keywd">const</span> <span class="type">string</span>: KNOWLEDGE_INFORMATION_OID     <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 4, 2));   <span class="comment"># "U\4;\2;"</span>
<span class="keywd">const</span> <span class="type">string</span>: COMMON_NAME_OID               <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 4, 3));   <span class="comment"># "U\4;\3;"</span>
<span class="keywd">const</span> <span class="type">string</span>: SURNAME_OID                   <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 4, 4));   <span class="comment"># "U\4;\4;"</span>
<span class="keywd">const</span> <span class="type">string</span>: SERIAL_NUMBER_OID             <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 4, 5));   <span class="comment"># "U\4;\5;"</span>
<span class="keywd">const</span> <span class="type">string</span>: COUNTRY_NAME_OID              <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 4, 6));   <span class="comment"># "U\4;\6;"</span>
<span class="keywd">const</span> <span class="type">string</span>: LOCALITY_NAME_OID             <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 4, 7));   <span class="comment"># "U\4;\a"</span>
<span class="keywd">const</span> <span class="type">string</span>: STATE_OR_OR_PROVINCE_NAME_OID <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 4, 8));   <span class="comment"># "U\4;\b"</span>
<span class="keywd">const</span> <span class="type">string</span>: STREET_ADDRESS_OID            <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 4, 9));   <span class="comment"># "U\4;\t"</span>
<span class="keywd">const</span> <span class="type">string</span>: ORGANIZATION_NAME_OID         <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 4, 10));  <span class="comment"># "U\4;\n"</span>
<span class="keywd">const</span> <span class="type">string</span>: ORGANIZATION_UNIT_NAME_OID    <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 4, 11));  <span class="comment"># "U\4;\v"</span>
<span class="keywd">const</span> <span class="type">string</span>: TITLE_OID                     <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 4, 12));  <span class="comment"># "U\4;\f"</span>

<span class="keywd">const</span> <span class="type">string</span>: SUBJECT_KEY_IDENTIFIER_OID    <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 29, 14));  <span class="comment"># "U\29;\14;"</span>
<span class="keywd">const</span> <span class="type">string</span>: KEY_USAGE_OID                 <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 29, 15));  <span class="comment"># "U\29;\15;"</span>
<span class="keywd">const</span> <span class="type">string</span>: SUBJECT_ALT_NAME              <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 29, 17));  <span class="comment"># "U\29;\17;"</span>
<span class="keywd">const</span> <span class="type">string</span>: BASIC_CONSTRAINTS_OID         <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 29, 19));  <span class="comment"># "U\29;\19;"</span>
<span class="keywd">const</span> <span class="type">string</span>: CRLD_DISTRIBUTION_POINTS_OID  <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 29, 31));  <span class="comment"># "U\29;\31;"</span>
<span class="keywd">const</span> <span class="type">string</span>: CERTIFICATE_POLICIES_OID      <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 29, 32));  <span class="comment"># "U\29; "</span>
<span class="keywd">const</span> <span class="type">string</span>: AUTHORITY_KEY_IDENTIFIER_OID  <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 29, 35));  <span class="comment"># "U\29;#"</span>
<span class="keywd">const</span> <span class="type">string</span>: EXT_KEY_USAGE_OID             <span class="keywd">is</span> encodeObjectIdentifier([] (2, 5, 29, 37));  <span class="comment"># "U\29;%"</span>

<span class="keywd">const</span> <span class="type">string</span>: CERT_TYPE_OID                 <span class="keywd">is</span> encodeObjectIdentifier([] (2, 16, 840, 1, 113730, 1, 1));  <span class="comment"># "`\134;H\1;\134;�B\1;\1;"</span>

<span class="comment"># iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 1</span>
<span class="keywd">const</span> <span class="type">string</span>: PKCS_1 <span class="keywd">is</span>  encodeObjectIdentifier([] (1, 2, 840, 113549, 1, 1));  <span class="comment"># "*\134;H\134;\247;\r\1;\1;"</span>
<span class="keywd">const</span> <span class="type">string</span>: RSA_ENCRYPTION_OID         <span class="keywd">is</span> PKCS_1 &amp; <span class="stri">"\1;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: MD2_WITH_RSA_ENCRYPTION    <span class="keywd">is</span> PKCS_1 &amp; <span class="stri">"\2;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: MD5_WITH_RSA_ENCRYPTION    <span class="keywd">is</span> PKCS_1 &amp; <span class="stri">"\4;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: SHA1_WITH_RSA_ENCRYPTION   <span class="keywd">is</span> PKCS_1 &amp; <span class="stri">"\5;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: RSAES_OAEP_OID             <span class="keywd">is</span> PKCS_1 &amp; <span class="stri">"\7;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: MGF1_OID                   <span class="keywd">is</span> PKCS_1 &amp; <span class="stri">"\8;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: P_SPECIFIED_OID            <span class="keywd">is</span> PKCS_1 &amp; <span class="stri">"\9;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: RSASSA_PSS_OID             <span class="keywd">is</span> PKCS_1 &amp; <span class="stri">"\10;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: SHA256_WITH_RSA_ENCRYPTION <span class="keywd">is</span> PKCS_1 &amp; <span class="stri">"\11;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: SHA384_WITH_RSA_ENCRYPTION <span class="keywd">is</span> PKCS_1 &amp; <span class="stri">"\12;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: SHA512_WITH_RSA_ENCRYPTION <span class="keywd">is</span> PKCS_1 &amp; <span class="stri">"\13;"</span>;

<span class="keywd">const</span> <span class="type">string</span>: PKCS_7 <span class="keywd">is</span>  encodeObjectIdentifier([] (1, 2, 840, 113549, 1, 7));  <span class="comment"># "*\134;H\134;\247;\r\1;\a"</span>
<span class="keywd">const</span> <span class="type">string</span>: PKCS_7_DATA                      <span class="keywd">is</span> PKCS_7 &amp; <span class="stri">"\1;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: PKCS_7_SIGNED_DATA               <span class="keywd">is</span> PKCS_7 &amp; <span class="stri">"\2;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: PKCS_7_ENVELOPED_DATA            <span class="keywd">is</span> PKCS_7 &amp; <span class="stri">"\3;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: PKCS_7_SIGNED_AND_ENVELOPED_DATA <span class="keywd">is</span> PKCS_7 &amp; <span class="stri">"\4;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: PKCS_7_DIGESTED_DATA             <span class="keywd">is</span> PKCS_7 &amp; <span class="stri">"\5;"</span>;
<span class="keywd">const</span> <span class="type">string</span>: PKCS_7_ENCRYPTED_DATA            <span class="keywd">is</span> PKCS_7 &amp; <span class="stri">"\6;"</span>;

<span class="keywd">const</span> <span class="type">string</span>: ECDSA_WITH_SHA224 <span class="keywd">is</span> encodeObjectIdentifier([] (1, 2, 840, 10045, 4, 3, 1));
<span class="keywd">const</span> <span class="type">string</span>: ECDSA_WITH_SHA256 <span class="keywd">is</span> encodeObjectIdentifier([] (1, 2, 840, 10045, 4, 3, 2));
<span class="keywd">const</span> <span class="type">string</span>: ECDSA_WITH_SHA384 <span class="keywd">is</span> encodeObjectIdentifier([] (1, 2, 840, 10045, 4, 3, 3));
<span class="keywd">const</span> <span class="type">string</span>: ECDSA_WITH_SHA512 <span class="keywd">is</span> encodeObjectIdentifier([] (1, 2, 840, 10045, 4, 3, 4));

<span class="keywd">const</span> <span class="type">string</span>: EC_PUBLIC_KEY <span class="keywd">is</span> encodeObjectIdentifier([] (1, 2, 840, 10045, 2, 1));     <span class="comment"># "*\134;H\206;=\2;\1;"</span>

<span class="keywd">const</span> <span class="type">string</span>: SECP192K1_OID <span class="keywd">is</span> encodeObjectIdentifier([] (1, 3, 132, 0, 31));
<span class="keywd">const</span> <span class="type">string</span>: SECP192R1_OID <span class="keywd">is</span> encodeObjectIdentifier([] (1, 2, 840, 10045, 3, 1, 1));
<span class="keywd">const</span> <span class="type">string</span>: SECP224K1_OID <span class="keywd">is</span> encodeObjectIdentifier([] (1, 3, 132, 0, 32));
<span class="keywd">const</span> <span class="type">string</span>: SECP224R1_OID <span class="keywd">is</span> encodeObjectIdentifier([] (1, 3, 132, 0, 33));
<span class="keywd">const</span> <span class="type">string</span>: SECP256K1_OID <span class="keywd">is</span> encodeObjectIdentifier([] (1, 3, 132, 0, 10));
<span class="keywd">const</span> <span class="type">string</span>: SECP256R1_OID <span class="keywd">is</span> encodeObjectIdentifier([] (1, 2, 840, 10045, 3, 1, 7));
<span class="keywd">const</span> <span class="type">string</span>: SECP384R1_OID <span class="keywd">is</span> encodeObjectIdentifier([] (1, 3, 132, 0, 34));
<span class="keywd">const</span> <span class="type">string</span>: SECP521R1_OID <span class="keywd">is</span> encodeObjectIdentifier([] (1, 3, 132, 0, 35));

<span class="keywd">const</span> <span class="type">string</span>: MD5_OID    <span class="keywd">is</span> encodeObjectIdentifier([] (1, 2, 840, 113549, 2, 5));
<span class="keywd">const</span> <span class="type">string</span>: SHA1_OID   <span class="keywd">is</span> encodeObjectIdentifier([] (1, 3, 14, 3, 2, 26));
<span class="keywd">const</span> <span class="type">string</span>: SHA256_OID <span class="keywd">is</span> encodeObjectIdentifier([] (2, 16, 840, 1, 101, 3, 4, 2, 1));
<span class="keywd">const</span> <span class="type">string</span>: SHA384_OID <span class="keywd">is</span> encodeObjectIdentifier([] (2, 16, 840, 1, 101, 3, 4, 2, 2));
<span class="keywd">const</span> <span class="type">string</span>: SHA512_OID <span class="keywd">is</span> encodeObjectIdentifier([] (2, 16, 840, 1, 101, 3, 4, 2, 3));


<span class="keywd">const</span> <span class="type">func</span> <span class="type">algorithmIdentifierType</span>: getAlgorithmIdentifier (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">integer</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">algorithmIdentifierType</span>: algId <span class="keywd">is</span> algorithmIdentifierType.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> asn1DataElement: dataElem <span class="keywd">is</span> asn1DataElement.value;
    <span class="keywd">var</span> <span class="type">integer</span>: beyond <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    dataElem := getAsn1DataElement(stri, pos);
    <span class="comment"># writeln("in getAlgorithmIdentifier " &lt;&amp; classTagName[ord(dataElem.tagCategory)]);</span>
    <span class="keywd">if</span> dataElem.tagCategory = tagSequence <span class="keywd">then</span>
      beyond := pos + dataElem.length;
      dataElem := getAsn1DataElement(stri, pos);
      <span class="comment"># writeln("in getAlgorithmIdentifier " &lt;&amp; classTagName[ord(dataElem.tagCategory)]);</span>
      <span class="keywd">if</span> dataElem.tagCategory = tagObjectIdentifier <span class="keywd">then</span>
        algId.algorithm := getData(stri, pos, dataElem);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> pos &lt; beyond <span class="keywd">then</span>
        dataElem := getAsn1DataElement(stri, pos);
        <span class="comment"># writeln("in getAlgorithmIdentifier " &lt;&amp; classTagName[ord(dataElem.tagCategory)]);</span>
        <span class="keywd">if</span> dataElem.tagCategory = tagNull <span class="keywd">then</span>
          algId.parameters := <span class="stri">""</span>;
        <span class="keywd">elsif</span> dataElem.tagCategory = tagObjectIdentifier <span class="keywd">then</span>
          algId.parameters := getData(stri, pos, dataElem);
          <span class="comment"># writeln("algId.parameters: " &lt;&amp; literal(algId.parameters));</span>
        <span class="keywd">else</span>
          writeln(<span class="stri">"*** Unexpected data element ***"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: genAlgorithmIdentifier (<span class="op">in</span> <span class="type">algorithmIdentifierType</span>: algId) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := genAsn1Element(tagObjectIdentifier, algId.algorithm);
    <span class="keywd">if</span> algId.parameters = <span class="stri">""</span> <span class="keywd">then</span>
      stri &amp;:= genAsn1Element(tagNull, <span class="stri">""</span>);
    <span class="keywd">else</span>
      stri &amp;:= genAsn1Element(tagObjectIdentifier, algId.parameters);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    stri := genAsn1Sequence(stri);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> rsaKey: getRsaKey (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> rsaKey: anRsaKey <span class="keywd">is</span> rsaKey.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> asn1DataElement: dataElem <span class="keywd">is</span> asn1DataElement.value;
    <span class="keywd">var</span> <span class="type">bigInteger</span>: modulus <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <span class="type">bigInteger</span>: exponent <span class="keywd">is</span> 0_;
  <span class="keywd">begin</span>
    dataElem := getAsn1DataElement(stri, pos);
    <span class="keywd">if</span> dataElem.tagCategory = tagSequence <span class="keywd">then</span>
      dataElem := getAsn1DataElement(stri, pos);
      <span class="keywd">if</span> dataElem.tagCategory = tagInteger <span class="keywd">then</span>
        modulus := bytes2BigInt(getData(stri, pos, dataElem), UNSIGNED, BE);
        dataElem := getAsn1DataElement(stri, pos);
        <span class="keywd">if</span> dataElem.tagCategory = tagInteger <span class="keywd">then</span>
          exponent := bytes2BigInt(getData(stri, pos, dataElem), UNSIGNED, BE);
          anRsaKey := rsaKey(modulus, exponent);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: genX509RsaKey (<span class="op">in</span> rsaKey: anRsaKey) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := genAsn1Integer(bytes(anRsaKey.modulus, SIGNED, BE));
    stri &amp;:= genAsn1Integer(bytes(anRsaKey.exponent, SIGNED, BE));
    stri := genAsn1Sequence(stri);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">rsaSignatureType</span>: getRsaSignature (<span class="op">in</span> <span class="type">string</span>: signatureStri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">rsaSignatureType</span>: signature <span class="keywd">is</span> rsaSignatureType.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> asn1DataElement: dataElem <span class="keywd">is</span> asn1DataElement.value;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    dataElem := getAsn1DataElement(signatureStri, pos);
    <span class="keywd">if</span> dataElem.tagCategory = tagSequence <span class="keywd">then</span>
      signature.algorithmIdentifier := getAlgorithmIdentifier(signatureStri, pos);
      dataElem := getAsn1DataElement(signatureStri, pos);
      <span class="keywd">if</span> dataElem.tagCategory = tagOctetString <span class="keywd">then</span>
        signature.signature := getData(signatureStri, pos, dataElem);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> pos &lt;> succ(length(signatureStri)) <span class="keywd">then</span>
      <span class="comment"># Tailing garbage bytes</span>
      <span class="comment"># writeln("Tailing garbage bytes");</span>
      signature.algorithmIdentifier.algorithm := <span class="stri">""</span>;
      signature.algorithmIdentifier.parameters := <span class="stri">""</span>;
      signature.signature := <span class="stri">""</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> ecdsaSignatureType: getEcdsaSignature (<span class="op">in</span> <span class="type">string</span>: signatureStri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> ecdsaSignatureType: signature <span class="keywd">is</span> ecdsaSignatureType.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> asn1DataElement: dataElem <span class="keywd">is</span> asn1DataElement.value;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    dataElem := getAsn1DataElement(signatureStri, pos);
    <span class="keywd">if</span> dataElem.tagCategory = tagSequence <span class="keywd">then</span>
      dataElem := getAsn1DataElement(signatureStri, pos);
      <span class="keywd">if</span> dataElem.tagCategory = tagInteger <span class="keywd">then</span>
        signature.r := bytes2BigInt(getData(signatureStri, pos, dataElem), UNSIGNED, BE);
        dataElem := getAsn1DataElement(signatureStri, pos);
        <span class="keywd">if</span> dataElem.tagCategory = tagInteger <span class="keywd">then</span>
          signature.s := bytes2BigInt(getData(signatureStri, pos, dataElem), UNSIGNED, BE);
        <span class="keywd">else</span>
          signature.r := 0_;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> pos &lt;> succ(length(signatureStri)) <span class="keywd">then</span>
      <span class="comment"># Tailing garbage bytes</span>
      <span class="comment"># writeln("Tailing garbage bytes");</span>
      signature.r := 0_;
      signature.s := 0_;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> ellipticCurve: getEllipticCurveFromOid (<span class="op">in</span> <span class="type">string</span>: oid) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> ellipticCurve: curve <span class="keywd">is</span> ellipticCurve.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> oid = SECP192K1_OID <span class="keywd">then</span>
      curve := secp192k1;
    <span class="keywd">elsif</span> oid = SECP192R1_OID <span class="keywd">then</span>
      curve := secp192r1;
    <span class="keywd">elsif</span> oid = SECP224K1_OID <span class="keywd">then</span>
      curve := secp224k1;
    <span class="keywd">elsif</span> oid = SECP224R1_OID <span class="keywd">then</span>
      curve := secp224r1;
    <span class="keywd">elsif</span> oid = SECP256K1_OID <span class="keywd">then</span>
      curve := secp256k1;
    <span class="keywd">elsif</span> oid = SECP256R1_OID <span class="keywd">then</span>
      curve := secp256r1;
    <span class="keywd">elsif</span> oid = SECP384R1_OID <span class="keywd">then</span>
      curve := secp384r1;
    <span class="keywd">elsif</span> oid = SECP521R1_OID <span class="keywd">then</span>
      curve := secp521r1;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getEllipticCurveOid (<span class="op">in</span> ellipticCurve: curve) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: oid <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> curve.name = <span class="stri">"secp192k1"</span> <span class="keywd">then</span>
      oid := SECP192K1_OID;
    <span class="keywd">elsif</span> curve.name = <span class="stri">"secp192r1"</span> <span class="keywd">then</span>
      oid := SECP192R1_OID;
    <span class="keywd">elsif</span> curve.name = <span class="stri">"secp224k1"</span> <span class="keywd">then</span>
      oid := SECP224K1_OID;
    <span class="keywd">elsif</span> curve.name = <span class="stri">"secp224r1"</span> <span class="keywd">then</span>
      oid := SECP224R1_OID;
    <span class="keywd">elsif</span> curve.name = <span class="stri">"secp256k1"</span> <span class="keywd">then</span>
      oid := SECP256K1_OID;
    <span class="keywd">elsif</span> curve.name = <span class="stri">"secp256r1"</span> <span class="keywd">then</span>
      oid := SECP256R1_OID;
    <span class="keywd">elsif</span> curve.name = <span class="stri">"secp384r1"</span> <span class="keywd">then</span>
      oid := SECP384R1_OID;
    <span class="keywd">elsif</span> curve.name = <span class="stri">"secp512r1"</span> <span class="keywd">then</span>
      oid := SECP521R1_OID;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">subjectPublicKeyInfoType</span>: getPublicKeyInfo (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">integer</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">subjectPublicKeyInfoType</span>: keyInfo <span class="keywd">is</span> subjectPublicKeyInfoType.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> asn1DataElement: dataElem <span class="keywd">is</span> asn1DataElement.value;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("in getPublicKeyInfo " &lt;&amp; pos);</span>
    dataElem := getAsn1DataElement(stri, pos);
    <span class="comment"># writeln("tag: " &lt;&amp; classTagName[ord(dataElem.tagCategory)]);</span>
    <span class="keywd">if</span> dataElem.tagCategory = tagSequence <span class="keywd">then</span>
      keyInfo.algorithm := getAlgorithmIdentifier(stri, pos);
      dataElem := getAsn1DataElement(stri, pos);
      <span class="comment"># writeln("tag: " &lt;&amp; classTagName[ord(dataElem.tagCategory)]);</span>
      <span class="keywd">if</span> dataElem.tagCategory = tagBitString <span class="keywd">then</span>
        <span class="comment"># The initial octet of a bit-string encodes</span>
        <span class="comment"># the number of unused bits in the final octet.</span>
        keyInfo.subjectPublicKey := getData(stri, pos, dataElem);
        <span class="keywd">if</span> keyInfo.subjectPublicKey[1] &lt;> <span class="stri">'\0;'</span> <span class="keywd">then</span>
          writeln(<span class="stri">"Initial octet of bit-string: "</span> &lt;&amp; ord(keyInfo.subjectPublicKey[1]));
        <span class="keywd">end</span> <span class="keywd">if</span>;
        keyInfo.subjectPublicKey := keyInfo.subjectPublicKey[2 ..];
        <span class="comment"># keyInfo.subjectPublicKey := getData(stri, pos, dataElem)[2 ..];</span>
        <span class="comment"># writeln("subjectPublicKey: " &lt;&amp; literal(keyInfo.subjectPublicKey));</span>
        <span class="comment"># writeln("length(subjectPublicKey): " &lt;&amp; length(keyInfo.subjectPublicKey));</span>
        <span class="comment"># writeln("algorithm: " &lt;&amp; literal(keyInfo.algorithm.algorithm));</span>
        <span class="comment"># writeln("algorithm parameters: " &lt;&amp; literal(keyInfo.algorithm.parameters));</span>
        <span class="keywd">if</span> keyInfo.algorithm.algorithm = RSA_ENCRYPTION_OID <span class="keywd">then</span>
          <span class="comment"># writeln("RSA_ENCRYPTION_OID");</span>
          keyInfo.publicRsaKey := getRsaKey(keyInfo.subjectPublicKey);
        <span class="keywd">elsif</span> keyInfo.algorithm.algorithm = EC_PUBLIC_KEY <span class="keywd">then</span>
          <span class="comment"># writeln("EC_PUBLIC_KEY");</span>
          keyInfo.eCurve := getEllipticCurveFromOid(keyInfo.algorithm.parameters);
          <span class="keywd">if</span> keyInfo.eCurve.bits &lt;> 0 <span class="keywd">then</span>
            keyInfo.publicEccKey := ecPointDecode(keyInfo.eCurve, keyInfo.subjectPublicKey);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          writeln(<span class="stri">"*** Unknown algorithm ***"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: genX509PublicKeyInfo (<span class="op">in</span> <span class="type">subjectPublicKeyInfoType</span>: keyInfo) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: subjectPublicKey <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := genAlgorithmIdentifier(keyInfo.algorithm);
    <span class="keywd">if</span> keyInfo.subjectPublicKey &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      subjectPublicKey := keyInfo.subjectPublicKey;
    <span class="keywd">else</span>
      subjectPublicKey := genX509RsaKey(keyInfo.publicRsaKey);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="comment"># The initial octet of a bit-string encodes</span>
    <span class="comment"># the number of unused bits in the final octet.</span>
    stri &amp;:= genAsn1Element(tagBitString, <span class="stri">"\0;"</span> &amp; subjectPublicKey);
    stri := genAsn1Sequence(stri);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">nameType</span>: getName (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">integer</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">nameType</span>: name <span class="keywd">is</span> nameType.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> asn1DataElement: dataElem <span class="keywd">is</span> asn1DataElement.value;
    <span class="keywd">var</span> <span class="type">integer</span>: posAfterwards <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: attrKey <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: attrValue <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("in getName");</span>
    dataElem := getAsn1DataElement(stri, pos);
    <span class="comment"># writeln("tag: " &lt;&amp; classTagName[ord(dataElem.tagCategory)]);</span>
    <span class="keywd">if</span> dataElem.tagCategory = tagSequence <span class="keywd">then</span>
      posAfterwards := pos + dataElem.length;
      <span class="keywd">while</span> pos &lt; posAfterwards <span class="keywd">do</span>
        dataElem := getAsn1DataElement(stri, pos);
        <span class="keywd">if</span> dataElem.tagCategory = tagSet <span class="keywd">then</span>
          dataElem := getAsn1DataElement(stri, pos);
          <span class="keywd">if</span> dataElem.tagCategory = tagSequence <span class="keywd">then</span>
            dataElem := getAsn1DataElement(stri, pos);
            <span class="keywd">if</span> dataElem.tagCategory = tagObjectIdentifier <span class="keywd">then</span>
              attrKey := getData(stri, pos, dataElem);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            dataElem := getAsn1DataElement(stri, pos);
            attrValue := getData(stri, pos, dataElem);
            name @:= [attrKey] attrValue;
            <span class="comment"># writeln("getName: " &lt;&amp; objectIdentifier(attrKey) &lt;&amp; ": " &lt;&amp; literal(attrValue));</span>
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: genX509Name (<span class="op">in</span> <span class="type">nameType</span>: name) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: attrKey <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: attrValue <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: setElement <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> attrValue <span class="keywd">key</span> attrKey <span class="keywd">range</span> name <span class="keywd">do</span>
      setElement := genAsn1Element(tagObjectIdentifier, attrKey);
      setElement &amp;:= genAsn1Element(tagPrintableString, attrValue);
      setElement := genAsn1Sequence(setElement);
      stri &amp;:= genAsn1Set(setElement);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    stri := genAsn1Sequence(stri);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: getTime_yymmddhhmmssZ (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: aTime <span class="keywd">is</span> time.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: yearInCentury <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: referenceYear <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: referenceCentury <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: possibleYear1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: possibleYear2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: possibleYear3 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: diffToYear1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: diffToYear2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: diffToYear3 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: year <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    yearInCentury := integer(stri[.. 2]);
    referenceYear := time(NOW).year;
    referenceCentury := referenceYear <span class="op">mdiv</span> 100;
    possibleYear1 := pred(referenceCentury) * 100 + yearInCentury;
    possibleYear2 :=      referenceCentury  * 100 + yearInCentury;
    possibleYear3 := succ(referenceCentury) * 100 + yearInCentury;
    diffToYear1 := abs(referenceYear - possibleYear1);
    diffToYear2 := abs(referenceYear - possibleYear2);
    diffToYear3 := abs(referenceYear - possibleYear3);
    <span class="comment"># writeln("possibleYear1: " &lt;&amp; possibleYear1 &lt;&amp; " diff: " &lt;&amp; diffToYear1);</span>
    <span class="comment"># writeln("possibleYear2: " &lt;&amp; possibleYear2 &lt;&amp; " diff: " &lt;&amp; diffToYear2);</span>
    <span class="comment"># writeln("possibleYear3: " &lt;&amp; possibleYear3 &lt;&amp; " diff: " &lt;&amp; diffToYear3);</span>
    <span class="keywd">if</span>  diffToYear1 &lt; diffToYear2 <span class="op">and</span> diffToYear1 &lt; diffToYear3 <span class="keywd">then</span>
      year := possibleYear1;
    <span class="keywd">elsif</span> diffToYear3 &lt; diffToYear1 <span class="op">and</span> diffToYear3 &lt; diffToYear2 <span class="keywd">then</span>
      year := possibleYear3;
    <span class="keywd">else</span>
      year := possibleYear2;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    aTime := time(year,
                  integer(stri[ 3 len 2]),  <span class="comment"># month</span>
                  integer(stri[ 5 len 2]),  <span class="comment"># day</span>
                  integer(stri[ 7 len 2]),  <span class="comment"># hour</span>
                  integer(stri[ 9 len 2]),  <span class="comment"># minute</span>
                  integer(stri[11 len 2])); <span class="comment"># second</span>
    <span class="comment"># writeln("getTime_yymmddhhmmssZ(" &lt;&amp; literal(stri) &lt;&amp; ") --> " &lt;&amp; aTime);</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: getTime_yyyymmddhhmmssfffZ (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: aTime <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    aTime := time(integer(stri[.. 4]),      <span class="comment"># year</span>
                  integer(stri[ 3 len 2]),  <span class="comment"># month</span>
                  integer(stri[ 5 len 2]),  <span class="comment"># day</span>
                  integer(stri[ 7 len 2]),  <span class="comment"># hour</span>
                  integer(stri[ 9 len 2]),  <span class="comment"># minute</span>
                  integer(stri[11 len 2])); <span class="comment"># second</span>
    <span class="comment"># writeln("getTime_yyyymmddhhmmssfffZ(" &lt;&amp; literal(stri) &lt;&amp; ") --> " &lt;&amp; aTime);</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">validityType</span>: validityType (<span class="op">in</span> <span class="type">time</span>: notBefore, <span class="op">in</span> <span class="type">time</span>: notAfter) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">validityType</span>: validity <span class="keywd">is</span> validityType.value;
  <span class="keywd">begin</span>
    validity.notBefore := notBefore;
    validity.notAfter := notAfter;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">validityType</span>: getValidity (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">integer</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">validityType</span>: validity <span class="keywd">is</span> validityType.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> asn1DataElement: dataElem <span class="keywd">is</span> asn1DataElement.value;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("in getValidity");</span>
    dataElem := getAsn1DataElement(stri, pos);
    <span class="comment"># writeln("tag: " &lt;&amp; classTagName[ord(dataElem.tagCategory)]);</span>
    <span class="keywd">if</span> dataElem.tagCategory = tagSequence <span class="keywd">then</span>
      dataElem := getAsn1DataElement(stri, pos);
      <span class="comment"># writeln("tag: " &lt;&amp; classTagName[ord(dataElem.tagCategory)]);</span>
      <span class="keywd">if</span> dataElem.tagCategory = tagUTCTime <span class="keywd">then</span>
        validity.notBefore := getTime_yymmddhhmmssZ(getData(stri, pos, dataElem));
      <span class="keywd">elsif</span> dataElem.tagCategory = tagGeneralizedTime <span class="keywd">then</span>
        validity.notBefore := getTime_yyyymmddhhmmssfffZ(getData(stri, pos, dataElem));
      <span class="keywd">end</span> <span class="keywd">if</span>;
      dataElem := getAsn1DataElement(stri, pos);
      <span class="comment"># writeln("tag: " &lt;&amp; classTagName[ord(dataElem.tagCategory)]);</span>
      <span class="keywd">if</span> dataElem.tagCategory = tagUTCTime <span class="keywd">then</span>
        validity.notAfter := getTime_yymmddhhmmssZ(getData(stri, pos, dataElem));
      <span class="keywd">elsif</span> dataElem.tagCategory = tagGeneralizedTime <span class="keywd">then</span>
        validity.notAfter := getTime_yyyymmddhhmmssfffZ(getData(stri, pos, dataElem));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: genX509Validity (<span class="op">in</span> <span class="type">validityType</span>: validity) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := genAsn1Element(tagUTCTime, str_yy_mm_dd(validity.notBefore, <span class="stri">""</span>) &amp;
                                       str_hh_mm_ss(validity.notBefore, <span class="stri">""</span>) &amp; <span class="stri">"Z"</span>);
    stri &amp;:= genAsn1Element(tagUTCTime, str_yy_mm_dd(validity.notAfter, <span class="stri">""</span>) &amp;
                                        str_hh_mm_ss(validity.notAfter, <span class="stri">""</span>) &amp; <span class="stri">"Z"</span>);
    stri := genAsn1Sequence(stri);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">tbsCertificateType</span>: getTbsCertificate (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">integer</span>: pos, <span class="op">in</span> <span class="type">integer</span>: beyond) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">tbsCertificateType</span>: tbsCertificate <span class="keywd">is</span> tbsCertificateType.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> asn1DataElement: dataElem <span class="keywd">is</span> asn1DataElement.value;
  <span class="keywd">begin</span>
    dataElem := getAsn1DataElement(stri, pos);
    <span class="keywd">if</span> dataElem.tagClass = contextSpecificTagClass <span class="op">and</span> dataElem.constructed <span class="keywd">then</span>
      dataElem := getAsn1DataElement(stri, pos);
      <span class="keywd">if</span> dataElem.tagCategory = tagInteger <span class="keywd">then</span>
        tbsCertificate.version := bytes2Int(getData(stri, pos, dataElem), UNSIGNED, BE);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      dataElem := getAsn1DataElement(stri, pos);
      <span class="keywd">if</span> dataElem.tagCategory = tagInteger <span class="keywd">then</span>
        tbsCertificate.serialNumber := getData(stri, pos, dataElem);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> dataElem.tagCategory = tagInteger <span class="keywd">then</span>
      <span class="comment"># Some certificates don't have an explicit tag and a version number.</span>
      tbsCertificate.serialNumber := getData(stri, pos, dataElem);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    tbsCertificate.signature := getAlgorithmIdentifier(stri, pos);
    tbsCertificate.issuer := getName(stri, pos);
    tbsCertificate.validity := getValidity(stri, pos);
    tbsCertificate.subject := getName(stri, pos);
    tbsCertificate.subjectPublicKeyInfo := getPublicKeyInfo(stri, pos);
    <span class="keywd">if</span> pos &lt; beyond <span class="keywd">then</span>
      dataElem := getAsn1DataElement(stri, pos);
      <span class="keywd">if</span> dataElem.constructed <span class="op">and</span> ord(dataElem.tagCategory) = 3 <span class="keywd">then</span>
        <span class="comment"># EXPLICIT TAG 3</span>
        skipData(pos, dataElem);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    tbsCertificate.digestEndPos := pred(beyond);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">tbsCertificateType</span>: getPkcs7SignedDataCert (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">integer</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">tbsCertificateType</span>: tbsCertificate <span class="keywd">is</span> tbsCertificateType.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> asn1DataElement: dataElem <span class="keywd">is</span> asn1DataElement.value;
    <span class="keywd">var</span> <span class="type">integer</span>: version <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: digestAlgorithmIdentifiers <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: contentType <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: content <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: digestStartPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("SIGNED_DATA pos: " &lt;&amp; pos &lt;&amp; ", length(stri): " &lt;&amp; length(stri));</span>
    dataElem := getAsn1DataElement(stri, pos);
    <span class="keywd">if</span> dataElem.tagClass = contextSpecificTagClass <span class="op">and</span> dataElem.constructed <span class="keywd">then</span>
      <span class="comment"># writeln("EXPLICIT TAG: " &lt;&amp; ord(dataElem.tagCategory) &lt;&amp; ", length: " &lt;&amp; dataElem.length);</span>
      dataElem := getAsn1DataElement(stri, pos);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> dataElem.tagCategory = tagSequence <span class="keywd">then</span>
      dataElem := getAsn1DataElement(stri, pos);
      <span class="keywd">if</span> dataElem.tagCategory = tagInteger <span class="keywd">then</span>
        version := bytes2Int(getData(stri, pos, dataElem), UNSIGNED, BE);
        <span class="comment"># writeln("version: " &lt;&amp; version);</span>
      <span class="keywd">end</span> <span class="keywd">if</span>;
      dataElem := getAsn1DataElement(stri, pos);
      <span class="keywd">if</span> dataElem.tagCategory = tagSet <span class="keywd">then</span>
        digestAlgorithmIdentifiers := getData(stri, pos, dataElem);
        <span class="comment"># writeln(literal(digestAlgorithmIdentifiers));</span>
      <span class="keywd">end</span> <span class="keywd">if</span>;
      dataElem := getAsn1DataElement(stri, pos);
      <span class="keywd">if</span> dataElem.tagCategory = tagSequence <span class="keywd">then</span>
        dataElem := getAsn1DataElement(stri, pos);
        <span class="keywd">if</span> dataElem.tagCategory = tagObjectIdentifier <span class="keywd">then</span>
          contentType := getData(stri, pos, dataElem);  <span class="comment"># E.g.: PKCS_7_DATA</span>
          <span class="comment"># writeln("contentType: " &lt;&amp; literal(contentType));</span>
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      dataElem := getAsn1DataElement(stri, pos);
      <span class="keywd">if</span> dataElem.tagClass = contextSpecificTagClass <span class="op">and</span> dataElem.constructed <span class="keywd">then</span>
        <span class="comment"># writeln("EXPLICIT TAG: " &lt;&amp; ord(dataElem.tagCategory) &lt;&amp; ", length: " &lt;&amp; dataElem.length);</span>
        dataElem := getAsn1DataElement(stri, pos);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> dataElem.tagCategory = tagOctetString <span class="keywd">then</span>
        content := getData(stri, pos, dataElem);
        <span class="comment"># writeln(literal(content));</span>
        dataElem := getAsn1DataElement(stri, pos);
        <span class="keywd">if</span> dataElem.tagClass = contextSpecificTagClass <span class="op">and</span> dataElem.constructed <span class="keywd">then</span>
          <span class="comment"># writeln("EXPLICIT TAG: " &lt;&amp; ord(dataElem.tagCategory) &lt;&amp; ", length: " &lt;&amp; dataElem.length);</span>
          dataElem := getAsn1DataElement(stri, pos);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        digestStartPos := pos;
        dataElem := getAsn1DataElement(stri, pos);
      <span class="keywd">elsif</span> dataElem.tagCategory = tagSequence <span class="keywd">then</span>
        digestStartPos := pos;
        dataElem := getAsn1DataElement(stri, pos);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> dataElem.tagCategory = tagSequence <span class="keywd">then</span>
        tbsCertificate := getTbsCertificate(stri, pos, pos + dataElem.length);
        tbsCertificate.digestStartPos := digestStartPos;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">tbsCertificateType</span>: getTbsCertificate (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">integer</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">tbsCertificateType</span>: tbsCertificate <span class="keywd">is</span> tbsCertificateType.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> asn1DataElement: dataElem <span class="keywd">is</span> asn1DataElement.value;
    <span class="keywd">var</span> <span class="type">integer</span>: digestStartPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    digestStartPos := pos;
    dataElem := getAsn1DataElement(stri, pos);
    <span class="keywd">if</span> dataElem.tagCategory = tagObjectIdentifier <span class="keywd">then</span>
      <span class="keywd">if</span> getData(stri, pos, dataElem) = PKCS_7_SIGNED_DATA <span class="keywd">then</span>
        tbsCertificate := getPkcs7SignedDataCert(stri, pos);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> dataElem.tagCategory = tagSequence <span class="keywd">then</span>
      tbsCertificate := getTbsCertificate(stri, pos, pos + dataElem.length);
      tbsCertificate.digestStartPos := digestStartPos;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: genX509TbsCertificate (<span class="op">in</span> <span class="type">tbsCertificateType</span>: tbsCertificate) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: version <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    version := genAsn1Integer(str(chr(tbsCertificate.version)));
    stri := genAsn1Tag(0, version);
    stri &amp;:= genAsn1Integer(tbsCertificate.serialNumber);
    stri &amp;:= genAlgorithmIdentifier(tbsCertificate.signature);
    stri &amp;:= genX509Name(tbsCertificate.issuer);
    stri &amp;:= genX509Validity(tbsCertificate.validity);
    stri &amp;:= genX509Name(tbsCertificate.subject);
    stri &amp;:= genX509PublicKeyInfo(tbsCertificate.subjectPublicKeyInfo);
    stri := genAsn1Sequence(stri);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getDigestOidFromAlgorithm (<span class="op">in</span> digestAlgorithm: digestAlg) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: digestOid <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> digestAlg <span class="keywd">of</span>
      <span class="keywd">when</span> {MD5}:    digestOid := MD5_OID;
      <span class="keywd">when</span> {SHA1}:   digestOid := SHA1_OID;
      <span class="keywd">when</span> {SHA256}: digestOid := SHA256_OID;
      <span class="keywd">when</span> {SHA384}: digestOid := SHA384_OID;
      <span class="keywd">when</span> {SHA512}: digestOid := SHA512_OID;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> digestAlgorithm: getDigestAlgorithm (<span class="op">in</span> <span class="type">string</span>: algorithm) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> digestAlgorithm: digestAlg <span class="keywd">is</span> NO_DIGEST;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> algorithm = MD5_OID <span class="keywd">then</span>
      digestAlg := MD5;
    <span class="keywd">elsif</span> algorithm = SHA1_OID <span class="keywd">then</span>
      digestAlg := SHA1;
    <span class="keywd">elsif</span> algorithm = SHA256_OID <span class="keywd">then</span>
      digestAlg := SHA256;
    <span class="keywd">elsif</span> algorithm = SHA384_OID <span class="keywd">then</span>
      digestAlg := SHA384;
    <span class="keywd">elsif</span> algorithm = SHA512_OID <span class="keywd">then</span>
      digestAlg := SHA512;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> digestAlgorithm: getDigestFromSignatureAlgorithm (<span class="op">in</span> <span class="type">string</span>: algorithm) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> digestAlgorithm: digestAlg <span class="keywd">is</span> NO_DIGEST;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> algorithm = MD5_WITH_RSA_ENCRYPTION <span class="keywd">then</span>
      digestAlg := MD5;
    <span class="keywd">elsif</span> algorithm = SHA1_WITH_RSA_ENCRYPTION <span class="keywd">then</span>
      digestAlg := SHA1;
    <span class="keywd">elsif</span> algorithm = SHA256_WITH_RSA_ENCRYPTION <span class="op">or</span>
          algorithm = ECDSA_WITH_SHA256 <span class="keywd">then</span>
      digestAlg := SHA256;
    <span class="keywd">elsif</span> algorithm = SHA384_WITH_RSA_ENCRYPTION <span class="op">or</span>
          algorithm = ECDSA_WITH_SHA384 <span class="keywd">then</span>
      digestAlg := SHA384;
    <span class="keywd">elsif</span> algorithm = SHA512_WITH_RSA_ENCRYPTION <span class="op">or</span>
          algorithm = ECDSA_WITH_SHA512 <span class="keywd">then</span>
      digestAlg := SHA512;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showSignatureAlgorithm (<span class="op">in</span> <span class="type">string</span>: algorithm) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> algorithm = MD5_WITH_RSA_ENCRYPTION <span class="keywd">then</span>
      writeln(<span class="stri">"MD5 with RSA Encryption"</span>);
    <span class="keywd">elsif</span> algorithm = SHA1_WITH_RSA_ENCRYPTION <span class="keywd">then</span>
      writeln(<span class="stri">"SHA-1 with RSA Encryption"</span>);
    <span class="keywd">elsif</span> algorithm = SHA256_WITH_RSA_ENCRYPTION <span class="keywd">then</span>
      writeln(<span class="stri">"SHA-256 with RSA Encryption"</span>);
    <span class="keywd">elsif</span> algorithm = SHA384_WITH_RSA_ENCRYPTION <span class="keywd">then</span>
      writeln(<span class="stri">"SHA-384 with RSA Encryption"</span>);
    <span class="keywd">elsif</span> algorithm = SHA512_WITH_RSA_ENCRYPTION <span class="keywd">then</span>
      writeln(<span class="stri">"SHA-512 with RSA Encryption"</span>);
    <span class="keywd">elsif</span> algorithm = ECDSA_WITH_SHA256 <span class="keywd">then</span>
      writeln(<span class="stri">"ECDSA with SHA-256"</span>);
    <span class="keywd">elsif</span> algorithm = ECDSA_WITH_SHA384 <span class="keywd">then</span>
      writeln(<span class="stri">"ECDSA with SHA-384"</span>);
    <span class="keywd">elsif</span> algorithm = ECDSA_WITH_SHA512 <span class="keywd">then</span>
      writeln(<span class="stri">"ECDSA with SHA-512"</span>);
    <span class="keywd">else</span>
      writeln(<span class="stri">"Unknown: "</span> &lt;&amp; literal(algorithm));
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Read a X.509 public key certificate from ''stri''.
 *  @return the X.509 public key certificate.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">x509cert</span>: getX509Cert (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">x509cert</span>: cert <span class="keywd">is</span> x509cert.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> asn1DataElement: dataElem <span class="keywd">is</span> asn1DataElement.value;
    <span class="keywd">var</span> digestAlgorithm: digestAlg <span class="keywd">is</span> NO_DIGEST;
  <span class="keywd">begin</span>
    dataElem := getAsn1DataElement(stri, pos);
    <span class="comment"># writeln("getX509Cert: tagCategory=" &lt;&amp; classTagName[ord(dataElem.tagCategory)]);</span>
    <span class="keywd">if</span> dataElem.tagCategory = tagSequence <span class="keywd">then</span>
      cert.tbsCertificate := getTbsCertificate(stri, pos);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    cert.signatureAlgorithm := getAlgorithmIdentifier(stri, pos);
    dataElem := getAsn1DataElement(stri, pos);
    <span class="keywd">if</span> dataElem.tagCategory = tagBitString <span class="keywd">then</span>
      <span class="comment"># The initial octet of a bit-string encodes</span>
      <span class="comment"># the number of unused bits in the final octet.</span>
      cert.signatureValue := getData(stri, pos, dataElem)[2 ..];
      <span class="comment"># showSignatureAlgorithm(cert.signatureAlgorithm.algorithm);</span>
      digestAlg := getDigestFromSignatureAlgorithm(cert.signatureAlgorithm.algorithm);
      <span class="keywd">if</span> digestAlg &lt;> NO_DIGEST <span class="keywd">then</span>
        cert.messageDigest := msgDigest(digestAlg,
            stri[cert.tbsCertificate.digestStartPos .. cert.tbsCertificate.digestEndPos]);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="comment"># writeln("end getX509Cert");</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: genX509Cert (<span class="keywd">inout</span> <span class="type">x509cert</span>: cert, <span class="op">in</span> rsaKey: encryptionKey) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> digestAlgorithm: digestAlg <span class="keywd">is</span> NO_DIGEST;
    <span class="keywd">var</span> <span class="type">string</span>: signature <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">algorithmIdentifierType</span>: signatureAlgorithmIdentifier <span class="keywd">is</span> algorithmIdentifierType.value;
  <span class="keywd">begin</span>
    stri := genX509TbsCertificate(cert.tbsCertificate);
    digestAlg := getDigestFromSignatureAlgorithm(cert.signatureAlgorithm.algorithm);
    <span class="keywd">if</span> digestAlg &lt;> NO_DIGEST <span class="keywd">then</span>
      cert.messageDigest := msgDigest(digestAlg, stri);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    signature := genAlgorithmIdentifier(cert.signatureAlgorithm);
    signature &amp;:= genAsn1Element(tagOctetString, cert.messageDigest);
    signature := genAsn1Sequence(signature);
    cert.signatureValue := rsassaPkcs1V15Encrypt(encryptionKey, signature);
    stri &amp;:= genAlgorithmIdentifier(cert.signatureAlgorithm);
    stri &amp;:= genAsn1Element(tagBitString, <span class="stri">"\0;"</span> &amp; cert.signatureValue);
    stri := genAsn1Sequence(stri);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Validate the signature of a X.509 certificate ''cert'' with ''publicKey''.
 *  @return TRUE if the certificate can be validated,
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: validateSignature (<span class="op">in</span> <span class="type">x509cert</span>: cert, <span class="op">in</span> <span class="type">subjectPublicKeyInfoType</span>: publicKey) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> digestAlgorithm: digestAlg <span class="keywd">is</span> NO_DIGEST;
    <span class="keywd">var</span> <span class="type">string</span>: decrypted <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">rsaSignatureType</span>: rsaSignature <span class="keywd">is</span> rsaSignatureType.value;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("in validateSignature: algorithm=" &lt;&amp; literal(cert.signatureAlgorithm.algorithm));</span>
    digestAlg := getDigestFromSignatureAlgorithm(cert.signatureAlgorithm.algorithm);
    <span class="keywd">if</span> digestAlg &lt;> NO_DIGEST <span class="keywd">then</span>
      <span class="keywd">block</span>
        <span class="comment"># writeln("length(messageDigest): " &lt;&amp; length(cert.messageDigest));</span>
        <span class="comment"># writeln("messageDigest: " &lt;&amp; literal(cert.messageDigest));</span>
        <span class="comment"># writeln("algorith: " &lt;&amp; literal(publicKey.algorithm.algorithm));</span>
        <span class="keywd">if</span> publicKey.algorithm.algorithm = RSA_ENCRYPTION_OID <span class="keywd">then</span>
          <span class="comment"># writeln("RSA_ENCRYPTION_OID:");</span>
          decrypted := rsassaPkcs1V15Decrypt(publicKey.publicRsaKey, cert.signatureValue);
          <span class="comment"># writeln("length(decrypted):     " &lt;&amp; length(decrypted));</span>
          <span class="comment"># writeln("decrypted:     " &lt;&amp; literal(decrypted));</span>
          <span class="comment"># printAsn1(decrypted);</span>
          rsaSignature := getRsaSignature(decrypted);
          okay := digestAlg = getDigestAlgorithm(rsaSignature.algorithmIdentifier.algorithm) <span class="op">and</span>
                  cert.messageDigest = rsaSignature.signature;
        <span class="keywd">elsif</span> publicKey.algorithm.algorithm = EC_PUBLIC_KEY <span class="keywd">then</span>
          <span class="comment"># writeln("EC_PUBLIC_KEY:");</span>
          <span class="comment"># writeln("signatureValue: " &lt;&amp; literal(cert.signatureValue));</span>
          <span class="comment"># writeln("length(signatureValue): " &lt;&amp; length(cert.signatureValue));</span>
          <span class="comment"># printAsn1(cert.signatureValue);</span>
          okay := verify(publicKey.eCurve, bytes2BigInt(cert.messageDigest, UNSIGNED, BE),
                         getEcdsaSignature(cert.signatureValue), publicKey.publicEccKey);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      exception
        <span class="keywd">otherwise</span>: okay := FALSE;
      <span class="keywd">end</span> <span class="keywd">block</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Create a X509 certificate that can be used for self signing.
 *  @param publicRsaKey Public RSA key to be entered to the certificate.
 *  @param serialNumber Serial number of certificate.
 *  @param commonName Common name of issuer and subject.
 *  @param country Country of issuer and subject (e.g. "AT" for Austria).
 *  @param locality Locality of issuer and subject (e.g. "Vienna").
 *  @param organization Organization of issuer and subject.
 *  @param organizationUnit Organization unit of issuer and subject.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">x509cert</span>: createX509Cert (<span class="op">in</span> rsaKey: publicRsaKey,
    <span class="op">in</span> <span class="type">bigInteger</span>: serialNumber, <span class="op">in</span> <span class="type">string</span>: commonName, <span class="op">in</span> <span class="type">string</span>: country,
    <span class="op">in</span> <span class="type">string</span>: locality, <span class="op">in</span> <span class="type">string</span>: organization,
    <span class="op">in</span> <span class="type">string</span>: organizationUnit, <span class="op">in</span> <span class="type">validityType</span>: validity) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">x509cert</span>: cert <span class="keywd">is</span> x509cert.value;
  <span class="keywd">begin</span>
    cert.tbsCertificate.version := 0;  <span class="comment"># v1</span>
    cert.tbsCertificate.serialNumber := bytes(serialNumber, UNSIGNED, BE);
    cert.tbsCertificate.signature.algorithm := SHA1_WITH_RSA_ENCRYPTION;
    cert.tbsCertificate.issuer @:= [COMMON_NAME_OID] commonName;
    cert.tbsCertificate.issuer @:= [COUNTRY_NAME_OID] country;
    cert.tbsCertificate.issuer @:= [LOCALITY_NAME_OID] locality;
    cert.tbsCertificate.issuer @:= [ORGANIZATION_NAME_OID] organization;
    cert.tbsCertificate.issuer @:= [ORGANIZATION_UNIT_NAME_OID] organizationUnit;
    cert.tbsCertificate.validity := validity;
    cert.tbsCertificate.subject @:= [COMMON_NAME_OID] commonName;
    cert.tbsCertificate.subject @:= [COUNTRY_NAME_OID] country;
    cert.tbsCertificate.subject @:= [LOCALITY_NAME_OID] locality;
    cert.tbsCertificate.subject @:= [ORGANIZATION_NAME_OID] organization;
    cert.tbsCertificate.subject @:= [ORGANIZATION_UNIT_NAME_OID] organizationUnit;
    cert.tbsCertificate.subjectPublicKeyInfo.algorithm.algorithm := RSA_ENCRYPTION_OID;
    cert.tbsCertificate.subjectPublicKeyInfo.publicRsaKey := publicRsaKey;
    cert.signatureAlgorithm.algorithm := SHA1_WITH_RSA_ENCRYPTION;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Create a X509 certificate that can be used for self signing.
 *  @param curve Elliptic curve used for the cryptographie.
 *  @param publicEccKey Public ECC key to be entered to the certificate.
 *  @param serialNumber Serial number of certificate.
 *  @param commonName Common name of issuer and subject.
 *  @param country Country of issuer and subject (e.g. "AT" for Austria).
 *  @param locality Locality of issuer and subject (e.g. "Vienna").
 *  @param organization Organization of issuer and subject.
 *  @param organizationUnit Organization unit of issuer and subject.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">x509cert</span>: createX509Cert (<span class="op">in</span> ellipticCurve: curve, <span class="op">in</span> ecPoint: publicEccKey,
    <span class="op">in</span> <span class="type">bigInteger</span>: serialNumber, <span class="op">in</span> <span class="type">string</span>: commonName, <span class="op">in</span> <span class="type">string</span>: country,
    <span class="op">in</span> <span class="type">string</span>: locality, <span class="op">in</span> <span class="type">string</span>: organization,
    <span class="op">in</span> <span class="type">string</span>: organizationUnit, <span class="op">in</span> <span class="type">validityType</span>: validity) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">x509cert</span>: cert <span class="keywd">is</span> x509cert.value;
  <span class="keywd">begin</span>
    cert.tbsCertificate.version := 0;  <span class="comment"># v1</span>
    cert.tbsCertificate.serialNumber := bytes(serialNumber, UNSIGNED, BE);
    cert.tbsCertificate.signature.algorithm := SHA1_WITH_RSA_ENCRYPTION;
    cert.tbsCertificate.issuer @:= [COMMON_NAME_OID] commonName;
    cert.tbsCertificate.issuer @:= [COUNTRY_NAME_OID] country;
    cert.tbsCertificate.issuer @:= [LOCALITY_NAME_OID] locality;
    cert.tbsCertificate.issuer @:= [ORGANIZATION_NAME_OID] organization;
    cert.tbsCertificate.issuer @:= [ORGANIZATION_UNIT_NAME_OID] organizationUnit;
    cert.tbsCertificate.validity := validity;
    cert.tbsCertificate.subject @:= [COMMON_NAME_OID] commonName;
    cert.tbsCertificate.subject @:= [COUNTRY_NAME_OID] country;
    cert.tbsCertificate.subject @:= [LOCALITY_NAME_OID] locality;
    cert.tbsCertificate.subject @:= [ORGANIZATION_NAME_OID] organization;
    cert.tbsCertificate.subject @:= [ORGANIZATION_UNIT_NAME_OID] organizationUnit;
    cert.tbsCertificate.subjectPublicKeyInfo.algorithm.algorithm := EC_PUBLIC_KEY;
    cert.tbsCertificate.subjectPublicKeyInfo.algorithm.parameters := getEllipticCurveOid(curve);
    cert.tbsCertificate.subjectPublicKeyInfo.eCurve := curve;
    cert.tbsCertificate.subjectPublicKeyInfo.publicEccKey := publicEccKey;
    cert.signatureAlgorithm.algorithm := SHA1_WITH_RSA_ENCRYPTION;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">certAndKey</span>: certAndKey (<span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: certList, <span class="op">in</span> rsaKey: privateRsaKey) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">certAndKey</span>: certificate <span class="keywd">is</span> certAndKey.value;
  <span class="keywd">begin</span>
    certificate.certList := certList;
    certificate.privateRsaKey := privateRsaKey;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">certAndKey</span>: certAndKey (<span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: certList, <span class="op">in</span> <span class="type">bigInteger</span>: privateEccKey) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">certAndKey</span>: certificate <span class="keywd">is</span> certAndKey.value;
  <span class="keywd">begin</span>
    certificate.certList := certList;
    certificate.privateEccKey := privateEccKey;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Create a self signed X509 certificate from a RSA key pair.
 *  @param keyPair Public and private RSA keys.
 *  @param serialNumber Serial number of certificate.
 *  @param commonName Common name of issuer and subject.
 *  @param country Country of issuer and subject (e.g. "AT" for Austria).
 *  @param locality Locality of issuer and subject (e.g. "Vienna").
 *  @param organization Organization of issuer and subject.
 *  @param organizationUnit Organization unit of issuer and subject.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">certAndKey</span>: selfSignedX509Cert (<span class="op">in</span> rsaKeyPair: keyPair,
    <span class="op">in</span> <span class="type">bigInteger</span>: serialNumber, <span class="op">in</span> <span class="type">string</span>: commonName, <span class="op">in</span> <span class="type">string</span>: country,
    <span class="op">in</span> <span class="type">string</span>: locality, <span class="op">in</span> <span class="type">string</span>: organization,
    <span class="op">in</span> <span class="type">string</span>: organizationUnit, <span class="op">in</span> <span class="type">validityType</span>: validity) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">certAndKey</span>: certificate <span class="keywd">is</span> certAndKey.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">x509cert</span>: cert <span class="keywd">is</span> x509cert.value;
  <span class="keywd">begin</span>
    cert := createX509Cert(keyPair.publicKey, serialNumber, commonName,
                           country, locality, organization, organizationUnit,
                           validity);
    certificate.certList := [] (genX509Cert(cert, keyPair.privateKey));
    certificate.privateRsaKey := keyPair.privateKey;
    <span class="comment"># printAsn1(certificate.certList[1]);</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Create a self signed X509 certificate.
 *  @param commonName Common name of issuer and subject.
 *  @param country Country of issuer and subject (e.g. "AT" for Austria).
 *  @param locality Locality of issuer and subject (e.g. "Vienna").
 *  @param organization Organization of issuer and subject.
 *  @param organizationUnit Organization unit of issuer and subject.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">certAndKey</span>: selfSignedX509Cert (<span class="op">in</span> <span class="type">string</span>: commonName,
    <span class="op">in</span> <span class="type">string</span>: country, <span class="op">in</span> <span class="type">string</span>: locality, <span class="op">in</span> <span class="type">string</span>: organization,
    <span class="op">in</span> <span class="type">string</span>: organizationUnit) <span class="keywd">is</span>
  <span class="keywd">return</span> selfSignedX509Cert(genRsaKeyPair(2048, 16#10001_),
                            rand(0_, 2_ ** (20 * 8) - 1_), commonName,
                            country, locality, organization, organizationUnit,
                            validityType(time(NOW) - 1 . YEARS,
                                         time(NOW) + 1 . YEARS));


<span class="comment">(**
 *  Self signed X509 certificate.
 *)</span>
<span class="keywd">const</span> <span class="type">certAndKey</span>: stdCertificate <span class="keywd">is</span> selfSignedX509Cert(
    stdRsaKeyPair, 4_, <span class="stri">"localhost"</span>,
    <span class="stri">"AT"</span>, <span class="stri">"Vienna"</span>, <span class="stri">"Black Hole"</span>, <span class="stri">"Super Massive"</span>,
    validityType(date(2021, 1, 1), date(2025, 1, 1)));
</pre>
</body>
</html>
