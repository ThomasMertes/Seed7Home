<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../../style1.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  expr_utl.s7i  Functions for the internal C expressions.         *)</span>
<span class="comment">(*  Copyright (C) 1990 - 1994, 2004 - 2015  Thomas Mertes           *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 compiler.                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">var</span> <span class="type">boolean_obj_hash</span>: function_pointer_declared <span class="keywd">is</span> boolean_obj_hash.EMPTY_HASH;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: mapSpecialIdentifier (<span class="op">in</span> <span class="type">string</span>: rawName) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: mappedIdentifier <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> ch <span class="keywd">range</span> rawName <span class="keywd">do</span>
      <span class="keywd">case</span> ch <span class="keywd">of</span>
        <span class="keywd">when</span> {<span class="stri">'!'</span>}:  mappedIdentifier &amp;:= <span class="stri">"excl"</span>;
        <span class="keywd">when</span> {<span class="stri">'$'</span>}:  mappedIdentifier &amp;:= <span class="stri">"dollar"</span>;
        <span class="keywd">when</span> {<span class="stri">'%'</span>}:  mappedIdentifier &amp;:= <span class="stri">"percnt"</span>;
        <span class="keywd">when</span> {<span class="stri">'&amp;'</span>}:  mappedIdentifier &amp;:= <span class="stri">"amp"</span>;
        <span class="keywd">when</span> {<span class="stri">'*'</span>}:  mappedIdentifier &amp;:= <span class="stri">"ast"</span>;
        <span class="keywd">when</span> {<span class="stri">'+'</span>}:  mappedIdentifier &amp;:= <span class="stri">"plus"</span>;
        <span class="keywd">when</span> {<span class="stri">','</span>}:  mappedIdentifier &amp;:= <span class="stri">"comma"</span>;
        <span class="keywd">when</span> {<span class="stri">'-'</span>}:  mappedIdentifier &amp;:= <span class="stri">"minus"</span>;
        <span class="keywd">when</span> {<span class="stri">'.'</span>}:  mappedIdentifier &amp;:= <span class="stri">"period"</span>;
        <span class="keywd">when</span> {<span class="stri">'/'</span>}:  mappedIdentifier &amp;:= <span class="stri">"sol"</span>;
        <span class="keywd">when</span> {<span class="stri">':'</span>}:  mappedIdentifier &amp;:= <span class="stri">"colon"</span>;
        <span class="keywd">when</span> {<span class="stri">';'</span>}:  mappedIdentifier &amp;:= <span class="stri">"semi"</span>;
        <span class="keywd">when</span> {<span class="stri">'&lt;'</span>}:  mappedIdentifier &amp;:= <span class="stri">"lt"</span>;
        <span class="keywd">when</span> {<span class="stri">'='</span>}:  mappedIdentifier &amp;:= <span class="stri">"equals"</span>;
        <span class="keywd">when</span> {<span class="stri">'>'</span>}:  mappedIdentifier &amp;:= <span class="stri">"gt"</span>;
        <span class="keywd">when</span> {<span class="stri">'?'</span>}:  mappedIdentifier &amp;:= <span class="stri">"quest"</span>;
        <span class="keywd">when</span> {<span class="stri">'@'</span>}:  mappedIdentifier &amp;:= <span class="stri">"commat"</span>;
        <span class="keywd">when</span> {<span class="stri">'['</span>}:  mappedIdentifier &amp;:= <span class="stri">"lbrack"</span>;
        <span class="keywd">when</span> {<span class="stri">'\\'</span>}: mappedIdentifier &amp;:= <span class="stri">"bsol"</span>;
        <span class="keywd">when</span> {<span class="stri">']'</span>}:  mappedIdentifier &amp;:= <span class="stri">"rbrack"</span>;
        <span class="keywd">when</span> {<span class="stri">'^'</span>}:  mappedIdentifier &amp;:= <span class="stri">"circ"</span>;
        <span class="keywd">when</span> {<span class="stri">'`'</span>}:  mappedIdentifier &amp;:= <span class="stri">"grave"</span>;
        <span class="keywd">when</span> {<span class="stri">'{'</span>}:  mappedIdentifier &amp;:= <span class="stri">"lbrace"</span>;
        <span class="keywd">when</span> {<span class="stri">'|'</span>}:  mappedIdentifier &amp;:= <span class="stri">"verbar"</span>;
        <span class="keywd">when</span> {<span class="stri">'}'</span>}:  mappedIdentifier &amp;:= <span class="stri">"rbrace"</span>;
        <span class="keywd">when</span> {<span class="stri">'~'</span>}:  mappedIdentifier &amp;:= <span class="stri">"tilde"</span>;
      <span class="keywd">end</span> <span class="keywd">case</span>;
      mappedIdentifier &amp;:= <span class="stri">"_"</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: mangleParameters (<span class="op">in</span> <span class="type">ref_list</span>: formalParams) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: mangledParams <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: formalParam <span class="keywd">is</span> reference.value;
    <span class="keywd">var</span> <span class="type">category</span>: paramCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">string</span>: rawName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> formalParam <span class="keywd">range</span> formalParams <span class="keywd">do</span>
      paramCategory := category(formalParam);
      <span class="keywd">if</span> paramCategory = SYMBOLOBJECT <span class="keywd">then</span>
        rawName := str(formalParam);
        name := getName(rawName);
        <span class="keywd">if</span> name &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          mangledParams &amp;:= <span class="stri">"_sym_"</span>;
          mangledParams &amp;:= name;
        <span class="keywd">else</span>
          mangledParams &amp;:= <span class="stri">"_spsym_"</span>;
          mangledParams &amp;:= mapSpecialIdentifier(rawName);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> paramCategory = TYPEOBJECT <span class="keywd">then</span>
        mangledParams &amp;:= <span class="stri">"_attr_"</span>;
        mangledParams &amp;:= mangleTypeName(getValue(formalParam, type));
      <span class="keywd">elsif</span> paramCategory = REFPARAMOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> isVar(formalParam) <span class="keywd">then</span>
          mangledParams &amp;:= <span class="stri">"_inout_"</span>;
        <span class="keywd">else</span>
          mangledParams &amp;:= <span class="stri">"_ref_"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        mangledParams &amp;:= mangleTypeName(getType(formalParam));
      <span class="keywd">elsif</span> paramCategory = VALUEPARAMOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> isVar(formalParam) <span class="keywd">then</span>
          mangledParams &amp;:= <span class="stri">"_in_var_"</span>;
        <span class="keywd">else</span>
          mangledParams &amp;:= <span class="stri">"_val_"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        mangledParams &amp;:= mangleTypeName(getType(formalParam));
      <span class="keywd">else</span>
        mangledParams &amp;:= <span class="stri">"?????"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: create_name (<span class="op">in</span> <span class="type">reference</span>: current_object, <span class="op">in</span> <span class="type">integer</span>: object_number,
    <span class="keywd">inout</span> <span class="type">string</span>: expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: rawName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">ref_list</span>: paramList <span class="keywd">is</span> ref_list.EMPTY;
  <span class="keywd">begin</span>
    rawName := str(current_object);
    name := getName(rawName);
    paramList := formalParams(current_object);
    <span class="keywd">if</span> <span class="op">not</span> do_name_mangling <span class="op">or</span>
        (category(current_object) <span class="op">not</span> <span class="op">in</span> {BLOCKOBJECT, ACTOBJECT}) <span class="keywd">then</span>  <span class="comment"># and paramList = ref_list.EMPTY) then</span>
      expr &amp;:= str(object_number);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> name &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      expr &amp;:= <span class="stri">"_"</span>;
      expr &amp;:= name;
    <span class="keywd">elsif</span> do_name_mangling <span class="keywd">then</span>
      expr &amp;:= mapSpecialIdentifier(rawName);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> do_name_mangling <span class="op">and</span>
        (category(current_object) <span class="op">in</span> {BLOCKOBJECT, ACTOBJECT}) <span class="keywd">then</span>  <span class="comment"># or paramList &lt;> ref_list.EMPTY) then</span>
      expr &amp;:= mangleParameters(formalParams(current_object));
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> rawName &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      expr &amp;:= <span class="stri">"/*"</span>;
      expr &amp;:= toUtf8(rawName);
      expr &amp;:= <span class="stri">"*/"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: create_name (<span class="op">in</span> <span class="type">reference</span>: current_object, <span class="keywd">inout</span> <span class="type">string</span>: expr) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    create_name(current_object, objNumber(current_object), expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: create_name2 (<span class="op">in</span> <span class="type">reference</span>: current_object, <span class="keywd">inout</span> <span class="type">string</span>: expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: rawName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    rawName := str(current_object);
    name := getName(rawName);
    expr &amp;:= str(objNumber(current_object));
    <span class="keywd">if</span> name &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      expr &amp;:= <span class="stri">"_"</span>;
      expr &amp;:= name;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> rawName &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      expr &amp;:= <span class="stri">"/ "</span>;
      expr &amp;:= toUtf8(rawName);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_expr (<span class="op">in</span> <span class="type">reference</span>: current_expression, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">forward</span>;
<span class="keywd">const</span> <span class="type">proc</span>: process_call_by_name_expr (<span class="op">in</span> <span class="keywd">var</span> <span class="type">reference</span>: current_expression, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">proc</span>: prepare_typed_result (<span class="op">in</span> <span class="type">type</span>: aType, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    incr(c_expr.temp_num);
    c_expr.result_name := <span class="stri">"tmp_"</span>;
    c_expr.result_name &amp;:= str(c_expr.temp_num);
    c_expr.result_decl := type_name(aType);
    c_expr.result_decl &amp;:= <span class="stri">" tmp_"</span>;
    c_expr.result_decl &amp;:= str(c_expr.temp_num);
    c_expr.result_decl &amp;:= <span class="stri">" = ("</span>;
    c_expr.result_decl &amp;:= type_name(aType);
    c_expr.result_decl &amp;:= <span class="stri">")(NULL);\n"</span>;
    process_destr_declaration(aType, global_c_expr);
    process_destr_call(aType, c_expr.result_name, c_expr.result_free);
    c_expr.result_to_null := c_expr.result_name;
    c_expr.result_to_null &amp;:= <span class="stri">" = ("</span>;
    c_expr.result_to_null &amp;:= type_name(aType);
    c_expr.result_to_null &amp;:= <span class="stri">")(NULL);\n"</span>;
    c_expr.result_intro := <span class="stri">"(tmp_"</span>;
    c_expr.result_intro &amp;:= str(c_expr.temp_num);
    c_expr.result_intro &amp;:= <span class="stri">"=("</span>;
    c_expr.result_intro &amp;:= type_name(aType);
    c_expr.result_intro &amp;:= <span class="stri">")("</span>;
    c_expr.result_finish := <span class="stri">"))"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: prepare_bigint_result (<span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    incr(c_expr.temp_num);
    c_expr.result_name := <span class="stri">"tmp_"</span>;
    c_expr.result_name &amp;:= str(c_expr.temp_num);
    c_expr.result_decl := <span class="stri">"bigIntType tmp_"</span>;
    c_expr.result_decl &amp;:= str(c_expr.temp_num);
    c_expr.result_decl &amp;:= <span class="stri">" = NULL;\n"</span>;
    c_expr.result_free := <span class="stri">"bigDestr(tmp_"</span>;
    c_expr.result_free &amp;:= str(c_expr.temp_num);
    c_expr.result_free &amp;:= <span class="stri">");\n"</span>;
    c_expr.result_to_null := c_expr.result_name;
    c_expr.result_to_null &amp;:= <span class="stri">" = NULL;\n"</span>;
    c_expr.result_intro := <span class="stri">"(tmp_"</span>;
    c_expr.result_intro &amp;:= str(c_expr.temp_num);
    c_expr.result_intro &amp;:= <span class="stri">"="</span>;
    c_expr.result_finish := <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: prepare_list_result (<span class="op">in</span> <span class="type">type</span>: list_type, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    incr(c_expr.temp_num);
    c_expr.result_name := <span class="stri">"tmp_"</span>;
    c_expr.result_name &amp;:= str(c_expr.temp_num);
    c_expr.result_decl := type_name(list_type);
    c_expr.result_decl &amp;:= <span class="stri">" tmp_"</span>;
    c_expr.result_decl &amp;:= str(c_expr.temp_num);
    c_expr.result_decl &amp;:= <span class="stri">" = ("</span>;
    c_expr.result_decl &amp;:= type_name(list_type);
    c_expr.result_decl &amp;:= <span class="stri">")(NULL);\n"</span>;
    c_expr.result_free := <span class="stri">"rflDestr(tmp_"</span>;
    c_expr.result_free &amp;:= str(c_expr.temp_num);
    c_expr.result_free &amp;:= <span class="stri">");\n"</span>;
    c_expr.result_to_null := c_expr.result_name;
    c_expr.result_to_null &amp;:= <span class="stri">" = ("</span>;
    c_expr.result_to_null &amp;:= type_name(list_type);
    c_expr.result_to_null &amp;:= <span class="stri">")(NULL);\n"</span>;
    c_expr.result_intro := <span class="stri">"(tmp_"</span>;
    c_expr.result_intro &amp;:= str(c_expr.temp_num);
    c_expr.result_intro &amp;:= <span class="stri">"=("</span>;
    c_expr.result_intro &amp;:= type_name(list_type);
    c_expr.result_intro &amp;:= <span class="stri">")("</span>;
    c_expr.result_finish := <span class="stri">"))"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: prepare_set_result (<span class="op">in</span> <span class="type">type</span>: set_type, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    incr(c_expr.temp_num);
    c_expr.result_name := <span class="stri">"tmp_"</span>;
    c_expr.result_name &amp;:= str(c_expr.temp_num);
    c_expr.result_decl := type_name(set_type);
    c_expr.result_decl &amp;:= <span class="stri">" tmp_"</span>;
    c_expr.result_decl &amp;:= str(c_expr.temp_num);
    c_expr.result_decl &amp;:= <span class="stri">" = ("</span>;
    c_expr.result_decl &amp;:= type_name(set_type);
    c_expr.result_decl &amp;:= <span class="stri">")(NULL);\n"</span>;
    c_expr.result_free := <span class="stri">"setDestr(tmp_"</span>;
    c_expr.result_free &amp;:= str(c_expr.temp_num);
    c_expr.result_free &amp;:= <span class="stri">");\n"</span>;
    c_expr.result_to_null := c_expr.result_name;
    c_expr.result_to_null &amp;:= <span class="stri">" = ("</span>;
    c_expr.result_to_null &amp;:= type_name(set_type);
    c_expr.result_to_null &amp;:= <span class="stri">")(NULL);\n"</span>;
    c_expr.result_intro := <span class="stri">"(tmp_"</span>;
    c_expr.result_intro &amp;:= str(c_expr.temp_num);
    c_expr.result_intro &amp;:= <span class="stri">"=("</span>;
    c_expr.result_intro &amp;:= type_name(set_type);
    c_expr.result_intro &amp;:= <span class="stri">")("</span>;
    c_expr.result_finish := <span class="stri">"))"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: prepare_stri_result (<span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    incr(c_expr.temp_num);
    c_expr.result_name := <span class="stri">"tmp_"</span>;
    c_expr.result_name &amp;:= str(c_expr.temp_num);
    c_expr.result_decl := <span class="stri">"striType tmp_"</span>;
    c_expr.result_decl &amp;:= str(c_expr.temp_num);
    c_expr.result_decl &amp;:= <span class="stri">" = NULL;\n"</span>;
    c_expr.result_free := <span class="stri">"strDestr(tmp_"</span>;
    c_expr.result_free &amp;:= str(c_expr.temp_num);
    c_expr.result_free &amp;:= <span class="stri">");\n"</span>;
    c_expr.result_to_null := c_expr.result_name;
    c_expr.result_to_null &amp;:= <span class="stri">" = NULL;\n"</span>;
    c_expr.result_intro := <span class="stri">"(tmp_"</span>;
    c_expr.result_intro &amp;:= str(c_expr.temp_num);
    c_expr.result_intro &amp;:= <span class="stri">"="</span>;
    c_expr.result_finish := <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: prepare_bstri_result (<span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    incr(c_expr.temp_num);
    c_expr.result_name := <span class="stri">"tmp_"</span>;
    c_expr.result_name &amp;:= str(c_expr.temp_num);
    c_expr.result_decl := <span class="stri">"bstriType tmp_"</span>;
    c_expr.result_decl &amp;:= str(c_expr.temp_num);
    c_expr.result_decl &amp;:= <span class="stri">" = NULL;\n"</span>;
    c_expr.result_free := <span class="stri">"bstDestr(tmp_"</span>;
    c_expr.result_free &amp;:= str(c_expr.temp_num);
    c_expr.result_free &amp;:= <span class="stri">");\n"</span>;
    c_expr.result_to_null := c_expr.result_name;
    c_expr.result_to_null &amp;:= <span class="stri">" = NULL;\n"</span>;
    c_expr.result_intro := <span class="stri">"(tmp_"</span>;
    c_expr.result_intro &amp;:= str(c_expr.temp_num);
    c_expr.result_intro &amp;:= <span class="stri">"="</span>;
    c_expr.result_finish := <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: prepare_file_result (<span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    incr(c_expr.temp_num);
    c_expr.result_name := <span class="stri">"tmp_"</span>;
    c_expr.result_name &amp;:= str(c_expr.temp_num);
    c_expr.result_decl := <span class="stri">"fileType tmp_"</span>;
    c_expr.result_decl &amp;:= str(c_expr.temp_num);
    c_expr.result_decl &amp;:= <span class="stri">" = NULL;\n"</span>;
    c_expr.result_free := <span class="stri">"filDestr(tmp_"</span>;
    c_expr.result_free &amp;:= str(c_expr.temp_num);
    c_expr.result_free &amp;:= <span class="stri">");\n"</span>;
    c_expr.result_to_null := c_expr.result_name;
    c_expr.result_to_null &amp;:= <span class="stri">" = NULL;\n"</span>;
    c_expr.result_intro := <span class="stri">"(tmp_"</span>;
    c_expr.result_intro &amp;:= str(c_expr.temp_num);
    c_expr.result_intro &amp;:= <span class="stri">"="</span>;
    c_expr.result_finish := <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: prepare_prog_result (<span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    incr(c_expr.temp_num);
    c_expr.result_name := <span class="stri">"tmp_"</span>;
    c_expr.result_name &amp;:= str(c_expr.temp_num);
    c_expr.result_decl := <span class="stri">"progType tmp_"</span>;
    c_expr.result_decl &amp;:= str(c_expr.temp_num);
    c_expr.result_decl &amp;:= <span class="stri">" = NULL;\n"</span>;
    c_expr.result_free := <span class="stri">"prgDestr(tmp_"</span>;
    c_expr.result_free &amp;:= str(c_expr.temp_num);
    c_expr.result_free &amp;:= <span class="stri">");\n"</span>;
    c_expr.result_to_null := c_expr.result_name;
    c_expr.result_to_null &amp;:= <span class="stri">" = NULL;\n"</span>;
    c_expr.result_intro := <span class="stri">"(tmp_"</span>;
    c_expr.result_intro &amp;:= str(c_expr.temp_num);
    c_expr.result_intro &amp;:= <span class="stri">"="</span>;
    c_expr.result_finish := <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: prepare_win_result (<span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    incr(c_expr.temp_num);
    c_expr.result_name := <span class="stri">"tmp_"</span>;
    c_expr.result_name &amp;:= str(c_expr.temp_num);
    c_expr.result_decl := <span class="stri">"winType tmp_"</span>;
    c_expr.result_decl &amp;:= str(c_expr.temp_num);
    c_expr.result_decl &amp;:= <span class="stri">" = NULL;\n"</span>;
    c_expr.result_free := <span class="stri">"drwDestr(tmp_"</span>;
    c_expr.result_free &amp;:= str(c_expr.temp_num);
    c_expr.result_free &amp;:= <span class="stri">");\n"</span>;
    c_expr.result_to_null := c_expr.result_name;
    c_expr.result_to_null &amp;:= <span class="stri">" = NULL;\n"</span>;
    c_expr.result_intro := <span class="stri">"(tmp_"</span>;
    c_expr.result_intro &amp;:= str(c_expr.temp_num);
    c_expr.result_intro &amp;:= <span class="stri">"="</span>;
    c_expr.result_finish := <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: prepare_process_result (<span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    incr(c_expr.temp_num);
    c_expr.result_name := <span class="stri">"tmp_"</span>;
    c_expr.result_name &amp;:= str(c_expr.temp_num);
    c_expr.result_decl := <span class="stri">"processType tmp_"</span>;
    c_expr.result_decl &amp;:= str(c_expr.temp_num);
    c_expr.result_decl &amp;:= <span class="stri">" = NULL;\n"</span>;
    c_expr.result_free := <span class="stri">"pcsDestr(tmp_"</span>;
    c_expr.result_free &amp;:= str(c_expr.temp_num);
    c_expr.result_free &amp;:= <span class="stri">");\n"</span>;
    c_expr.result_to_null := c_expr.result_name;
    c_expr.result_to_null &amp;:= <span class="stri">" = NULL;\n"</span>;
    c_expr.result_intro := <span class="stri">"(tmp_"</span>;
    c_expr.result_intro &amp;:= str(c_expr.temp_num);
    c_expr.result_intro &amp;:= <span class="stri">"="</span>;
    c_expr.result_finish := <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: prepareAnyParamTemporarys (<span class="op">in</span> <span class="type">reference</span>: aParam,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_param, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_param.temp_num := c_expr.temp_num;
    process_expr(aParam, c_param);
    c_expr.temp_num := c_param.temp_num;
    c_expr.temp_decls &amp;:= c_param.temp_decls;
    c_expr.temp_assigns &amp;:= c_param.temp_assigns;
    c_expr.temp_frees &amp;:= c_param.temp_frees;
    c_expr.temp_to_null &amp;:= c_param.temp_to_null;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: prepareCallByNameParamTemporarys (<span class="op">in</span> <span class="type">reference</span>: aParam,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_param, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_param.temp_num := c_expr.temp_num;
    process_call_by_name_expr(aParam, c_param);
    c_expr.temp_num := c_param.temp_num;
    c_expr.temp_decls &amp;:= c_param.temp_decls;
    c_expr.temp_assigns &amp;:= c_param.temp_assigns;
    c_expr.temp_frees &amp;:= c_param.temp_frees;
    c_expr.temp_to_null &amp;:= c_param.temp_to_null;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getAnyParamToExpr (<span class="op">in</span> <span class="type">expr_type</span>: c_param, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> c_param.expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= c_param.expr;
    <span class="keywd">else</span>
      c_expr.temp_decls &amp;:= c_param.result_decl;
      c_expr.temp_frees &amp;:= c_param.result_free;
      c_expr.temp_to_null &amp;:= c_param.result_to_null;
      c_expr.expr &amp;:= c_param.result_intro;
      c_expr.expr &amp;:= c_param.result_expr;
      c_expr.expr &amp;:= c_param.result_finish;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getAnyParamToExpr (<span class="op">in</span> <span class="type">reference</span>: aParam, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    prepareAnyParamTemporarys(aParam, c_param, c_expr);
    getAnyParamToExpr(c_param, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getAnyParamToResultExpr (<span class="op">in</span> <span class="type">expr_type</span>: c_param, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> c_param.expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.result_expr &amp;:= c_param.expr;
    <span class="keywd">else</span>
      c_expr.temp_decls &amp;:= c_param.result_decl;
      c_expr.temp_frees &amp;:= c_param.result_free;
      c_expr.temp_to_null &amp;:= c_param.result_to_null;
      c_expr.result_expr &amp;:= c_param.result_intro;
      c_expr.result_expr &amp;:= c_param.result_expr;
      c_expr.result_expr &amp;:= c_param.result_finish;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getAnyParamToResultExpr (<span class="op">in</span> <span class="type">reference</span>: aParam, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    prepareAnyParamTemporarys(aParam, c_param, c_expr);
    getAnyParamToResultExpr(c_param, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getStdParamToResultExpr (<span class="op">in</span> <span class="type">reference</span>: aParam, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    prepareAnyParamTemporarys(aParam, c_param, c_expr);
    c_expr.result_expr &amp;:= c_param.expr;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getGenericValue (<span class="op">in</span> <span class="type">reference</span>: current_expression,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: result_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">string</span>: temp_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    result_type := getExprResultType(current_expression);
    <span class="keywd">if</span> result_type <span class="op">in</span> typeCategory <span class="op">and</span> typeCategory[result_type] = FLOATOBJECT <span class="op">or</span>
        <span class="op">not</span> ccConf.LITTLE_ENDIAN_INTTYPE <span class="keywd">then</span>
      incr(c_expr.temp_num);
      temp_name := <span class="stri">"tmp_"</span> &amp; str(c_expr.temp_num);
      c_expr.temp_decls &amp;:= <span class="stri">"const_rtlValueUnion "</span>;
      c_expr.temp_decls &amp;:= temp_name;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      c_expr.expr &amp;:= temp_name;
      c_expr.expr &amp;:= <span class="stri">"."</span>;
      c_expr.expr &amp;:= raw_type_value(result_type);
      c_expr.expr &amp;:= <span class="stri">"="</span>;
      process_expr(current_expression, c_expr);
      c_expr.expr &amp;:= <span class="stri">","</span>;
      c_expr.expr &amp;:= temp_name;
      c_expr.expr &amp;:= <span class="stri">".genericValue)"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"(genericType)("</span>;
      process_expr(current_expression, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getGenericValue (<span class="op">in</span> <span class="type">type</span>: variableType, <span class="op">in</span> <span class="type">string</span>: variableName,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: temp_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> variableType <span class="op">in</span> typeCategory <span class="op">and</span> typeCategory[variableType] = FLOATOBJECT <span class="op">or</span>
        <span class="op">not</span> ccConf.LITTLE_ENDIAN_INTTYPE <span class="keywd">then</span>
      incr(c_expr.temp_num);
      temp_name := <span class="stri">"tmp_"</span> &amp; str(c_expr.temp_num);
      c_expr.temp_decls &amp;:= <span class="stri">"const_rtlValueUnion "</span>;
      c_expr.temp_decls &amp;:= temp_name;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      c_expr.expr &amp;:= temp_name;
      c_expr.expr &amp;:= <span class="stri">"."</span>;
      c_expr.expr &amp;:= raw_type_value(variableType);
      c_expr.expr &amp;:= <span class="stri">"="</span>;
      c_expr.expr &amp;:= variableName;
      c_expr.expr &amp;:= <span class="stri">","</span>;
      c_expr.expr &amp;:= temp_name;
      c_expr.expr &amp;:= <span class="stri">".genericValue)"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"(genericType)("</span>;
      c_expr.expr &amp;:= variableName;
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getGenericValueOfVariableObject (<span class="op">in</span> <span class="type">reference</span>: variableObject,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: result_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">string</span>: temp_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    result_type := getType(variableObject);
    <span class="keywd">if</span> result_type <span class="op">in</span> typeCategory <span class="op">and</span> typeCategory[result_type] = FLOATOBJECT <span class="op">or</span>
        <span class="op">not</span> ccConf.LITTLE_ENDIAN_INTTYPE <span class="keywd">then</span>
      incr(c_expr.temp_num);
      temp_name := <span class="stri">"tmp_"</span> &amp; str(c_expr.temp_num);
      c_expr.temp_decls &amp;:= <span class="stri">"const_rtlValueUnion "</span>;
      c_expr.temp_decls &amp;:= temp_name;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      c_expr.expr &amp;:= temp_name;
      c_expr.expr &amp;:= <span class="stri">"."</span>;
      c_expr.expr &amp;:= raw_type_value(result_type);
      c_expr.expr &amp;:= <span class="stri">"=o_"</span>;
      create_name(variableObject, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">","</span>;
      c_expr.expr &amp;:= temp_name;
      c_expr.expr &amp;:= <span class="stri">".genericValue)"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"(genericType)(o_"</span>;
      create_name(variableObject, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getCreatedValueAsGeneric (<span class="op">in</span> <span class="type">type</span>: param_type, <span class="op">in</span> <span class="type">expr_type</span>: c_param,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: temp_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> param_type <span class="op">in</span> typeCategory <span class="op">and</span> typeCategory[param_type] = FLOATOBJECT <span class="op">or</span>
        <span class="op">not</span> ccConf.LITTLE_ENDIAN_INTTYPE <span class="keywd">then</span>
      incr(c_expr.temp_num);
      temp_name := <span class="stri">"tmp_"</span> &amp; str(c_expr.temp_num);
      c_expr.temp_decls &amp;:= <span class="stri">"rtlValueUnion "</span>;
      c_expr.temp_decls &amp;:= temp_name;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      c_expr.expr &amp;:= temp_name;
      c_expr.expr &amp;:= <span class="stri">"."</span>;
      c_expr.expr &amp;:= raw_type_value(param_type);
      c_expr.expr &amp;:= <span class="stri">"="</span>;
      <span class="keywd">if</span> c_param.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        c_expr.expr &amp;:= c_param.result_expr;
      <span class="keywd">else</span>
        process_create_declaration(param_type, global_c_expr);
        process_create_call(param_type, c_param.expr, c_expr.expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">","</span>;
      c_expr.expr &amp;:= temp_name;
      c_expr.expr &amp;:= <span class="stri">".genericValue)"</span>;
    <span class="keywd">elsif</span> c_param.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= c_param.result_expr;
    <span class="keywd">else</span>
      process_create_declaration(param_type, global_c_expr);
      process_create_call(param_type, c_param.expr, c_expr.expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getCreatedValueAsGeneric (<span class="op">in</span> <span class="type">reference</span>: aParam, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">type</span>: param_type <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    param_type := getExprResultType(aParam);
    prepareAnyParamTemporarys(aParam, c_param, c_expr);
    getCreatedValueAsGeneric(param_type, c_param, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getGenericValueToResultExpr (<span class="op">in</span> <span class="type">reference</span>: current_expression,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: result_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">string</span>: temp_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    result_type := getExprResultType(current_expression);
    <span class="keywd">if</span> result_type <span class="op">in</span> typeCategory <span class="op">and</span> typeCategory[result_type] = FLOATOBJECT <span class="op">or</span>
        <span class="op">not</span> ccConf.LITTLE_ENDIAN_INTTYPE <span class="keywd">then</span>
      incr(c_expr.temp_num);
      temp_name := <span class="stri">"tmp_"</span> &amp; str(c_expr.temp_num);
      c_expr.temp_decls &amp;:= <span class="stri">"const_rtlValueUnion "</span>;
      c_expr.temp_decls &amp;:= temp_name;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      c_expr.result_expr &amp;:= <span class="stri">"("</span>;
      c_expr.result_expr &amp;:= temp_name;
      c_expr.result_expr &amp;:= <span class="stri">"."</span>;
      c_expr.result_expr &amp;:= raw_type_value(result_type);
      c_expr.result_expr &amp;:= <span class="stri">"="</span>;
      getAnyParamToResultExpr(current_expression, c_expr);
      c_expr.result_expr &amp;:= <span class="stri">","</span>;
      c_expr.result_expr &amp;:= temp_name;
      c_expr.result_expr &amp;:= <span class="stri">".genericValue)"</span>;
    <span class="keywd">else</span>
      c_expr.result_expr &amp;:= <span class="stri">"(genericType)("</span>;
      getAnyParamToResultExpr(current_expression, c_expr);
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getGenericTemporaryToResultExpr (<span class="op">in</span> <span class="type">type</span>: param_type, <span class="op">in</span> <span class="type">expr_type</span>: c_param,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: temp_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> param_type <span class="op">in</span> typeCategory <span class="op">and</span> typeCategory[param_type] = FLOATOBJECT <span class="op">or</span>
        <span class="op">not</span> ccConf.LITTLE_ENDIAN_INTTYPE <span class="keywd">then</span>
      incr(c_expr.temp_num);
      temp_name := <span class="stri">"tmp_"</span> &amp; str(c_expr.temp_num);
      c_expr.temp_decls &amp;:= <span class="stri">"rtlValueUnion "</span>;
      c_expr.temp_decls &amp;:= temp_name;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      c_expr.result_expr &amp;:= <span class="stri">"("</span>;
      c_expr.result_expr &amp;:= temp_name;
      c_expr.result_expr &amp;:= <span class="stri">"."</span>;
      c_expr.result_expr &amp;:= raw_type_value(param_type);
      c_expr.result_expr &amp;:= <span class="stri">"="</span>;
      <span class="keywd">if</span> c_param.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        c_expr.result_expr &amp;:= c_param.result_expr;
      <span class="keywd">else</span>
        process_create_declaration(param_type, global_c_expr);
        process_create_call(param_type, c_param.expr, c_expr.result_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.result_expr &amp;:= <span class="stri">","</span>;
      c_expr.result_expr &amp;:= temp_name;
      c_expr.result_expr &amp;:= <span class="stri">".genericValue)"</span>;
    <span class="keywd">elsif</span> c_param.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.result_expr &amp;:= c_param.result_expr;
    <span class="keywd">else</span>
      process_create_declaration(param_type, global_c_expr);
      process_create_call(param_type, c_param.expr, c_expr.result_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getGenericTemporaryToResultExpr (<span class="op">in</span> <span class="type">reference</span>: aParam, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">type</span>: param_type <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    param_type := getExprResultType(aParam);
    prepareAnyParamTemporarys(aParam, c_param, c_expr);
    getGenericTemporaryToResultExpr(param_type, c_param, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getTemporaryToExpr (<span class="op">in</span> <span class="type">type</span>: param_type, <span class="op">in</span> <span class="type">expr_type</span>: c_param,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: temp_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> c_param.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= c_param.result_expr;
    <span class="keywd">else</span>
      process_create_declaration(param_type, global_c_expr);
      process_create_call(param_type, c_param.expr, c_expr.expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getTemporaryToExpr (<span class="op">in</span> <span class="type">reference</span>: aParam, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">type</span>: param_type <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    param_type := getExprResultType(aParam);
    prepareAnyParamTemporarys(aParam, c_param, c_expr);
    getTemporaryToExpr(param_type, c_param, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getTemporaryToResultExpr (<span class="op">in</span> <span class="type">type</span>: param_type, <span class="op">in</span> <span class="type">expr_type</span>: c_param,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: temp_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> param_type <span class="op">in</span> typeCategory <span class="op">and</span> typeCategory[param_type] = FLOATOBJECT <span class="keywd">then</span>
      incr(c_expr.temp_num);
      temp_name := <span class="stri">"tmp_"</span> &amp; str(c_expr.temp_num);
      c_expr.temp_decls &amp;:= <span class="stri">"rtlValueUnion "</span>;
      c_expr.temp_decls &amp;:= temp_name;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      c_expr.result_expr &amp;:= <span class="stri">"("</span>;
      c_expr.result_expr &amp;:= temp_name;
      c_expr.result_expr &amp;:= <span class="stri">".floatValue="</span>;
      c_expr.result_expr &amp;:= c_param.expr;
      c_expr.result_expr &amp;:= <span class="stri">","</span>;
      c_expr.result_expr &amp;:= temp_name;
      c_expr.result_expr &amp;:= <span class="stri">".genericValue)"</span>;
    <span class="keywd">elsif</span> c_param.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.result_expr &amp;:= c_param.result_expr;
    <span class="keywd">else</span>
      process_create_declaration(param_type, global_c_expr);
      process_create_call(param_type, c_param.expr, c_expr.result_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getTemporaryToResultExpr (<span class="op">in</span> <span class="type">reference</span>: aParam, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">type</span>: param_type <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    param_type := getExprResultType(aParam);
    prepareAnyParamTemporarys(aParam, c_param, c_expr);
    getTemporaryToResultExpr(param_type, c_param, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: doLocalDeclsOfStatement (<span class="op">in</span> <span class="type">expr_type</span>: statement, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> statement.temp_decls &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      setDiagnosticLine(c_expr);
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      appendWithDiagnostic(statement.temp_decls, c_expr);
      appendWithDiagnostic(statement.temp_assigns, c_expr);
      appendWithDiagnostic(statement.expr, c_expr);
      appendWithDiagnostic(statement.temp_frees, c_expr);
      appendWithDiagnostic(statement.result_free, c_expr);
      setDiagnosticLine(c_expr);
      c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">else</span>
      appendWithDiagnostic(statement.temp_assigns, c_expr);
      appendWithDiagnostic(statement.expr, c_expr);
      appendWithDiagnostic(statement.temp_frees, c_expr);
      appendWithDiagnostic(statement.result_free, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: defineTempVariable (<span class="op">in</span> <span class="type">string</span>: typeName, <span class="op">in</span> <span class="type">string</span>: namePrefix,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: variableName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    incr(c_expr.temp_num);
    variableName := namePrefix &amp; str(c_expr.temp_num);
    c_expr.temp_decls &amp;:= typeName;
    c_expr.temp_decls &amp;:= <span class="stri">" "</span>;
    c_expr.temp_decls &amp;:= variableName;
    c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: defineTempVariable (<span class="op">in</span> <span class="type">string</span>: typeName, <span class="op">in</span> <span class="type">string</span>: namePrefix,
    <span class="op">in</span> <span class="type">string</span>: initValue, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: variableName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    incr(c_expr.temp_num);
    variableName := namePrefix &amp; str(c_expr.temp_num);
    c_expr.temp_decls &amp;:= typeName;
    c_expr.temp_decls &amp;:= <span class="stri">" "</span>;
    c_expr.temp_decls &amp;:= variableName;
    c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
    c_expr.expr &amp;:= variableName;
    c_expr.expr &amp;:= <span class="stri">"="</span>;
    c_expr.expr &amp;:= initValue;
    c_expr.expr &amp;:= <span class="stri">","</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isNormalVariable (<span class="op">in</span> <span class="type">reference</span>: a_param) <span class="keywd">is</span>
  <span class="keywd">return</span> category(a_param) <span class="op">in</span> {TYPEOBJECT, INTOBJECT, BIGINTOBJECT,
      CHAROBJECT, STRIOBJECT, BSTRIOBJECT, ARRAYOBJECT, HASHOBJECT,
      STRUCTOBJECT, INTERFACEOBJECT, SETOBJECT, FILEOBJECT,
      SOCKETOBJECT, POLLOBJECT, LISTOBJECT, FLOATOBJECT, WINOBJECT,
      PROCESSOBJECT, REFOBJECT, REFLISTOBJECT, ACTOBJECT, VALUEPARAMOBJECT,
      REFPARAMOBJECT, RESULTOBJECT, LOCALVOBJECT, PROGOBJECT};


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: normalVariable (<span class="op">in</span> <span class="type">reference</span>: aParam, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: varName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    prepareAnyParamTemporarys(aParam, c_param, c_expr);
    varName := <span class="stri">"("</span> &amp; c_param.expr &amp; <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getTempVariable (<span class="op">in</span> <span class="type">string</span>: typeName, <span class="op">in</span> <span class="type">string</span>: namePrefix,
    <span class="op">in</span> <span class="type">string</span>: initValue, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: variableName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    incr(c_expr.temp_num);
    variableName := namePrefix &amp; str(c_expr.temp_num);
    c_expr.temp_decls &amp;:= typeName;
    c_expr.temp_decls &amp;:= <span class="stri">" "</span>;
    c_expr.temp_decls &amp;:= variableName;
    c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
    <span class="keywd">if</span> initValue &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= variableName;
      c_expr.expr &amp;:= <span class="stri">"="</span>;
      c_expr.expr &amp;:= initValue;
      c_expr.expr &amp;:= <span class="stri">","</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getTempVariable (<span class="op">in</span> <span class="type">string</span>: typeName, <span class="op">in</span> <span class="type">string</span>: namePrefix,
    <span class="op">in</span> <span class="type">reference</span>: param1, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: variableName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    incr(c_expr.temp_num);
    variableName := namePrefix &amp; str(c_expr.temp_num);
    c_expr.temp_decls &amp;:= typeName;
    c_expr.temp_decls &amp;:= <span class="stri">" "</span>;
    c_expr.temp_decls &amp;:= variableName;
    c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
    c_expr.expr &amp;:= variableName;
    c_expr.expr &amp;:= <span class="stri">"="</span>;
    getAnyParamToExpr(param1, c_expr);
    c_expr.expr &amp;:= <span class="stri">","</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getParameterAsVariable (<span class="op">in</span> <span class="type">string</span>: typeName, <span class="op">in</span> <span class="type">string</span>: namePrefix,
    <span class="op">in</span> <span class="type">reference</span>: param1, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: variableName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isNormalVariable(param1) <span class="keywd">then</span>
      variableName := normalVariable(param1, c_expr);
    <span class="keywd">else</span>
      variableName := getTempVariable(typeName, namePrefix, param1, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: getParameterAsVariable (<span class="op">in</span> <span class="type">reference</span>: param1,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">reference</span>: variableObject <span class="keywd">is</span> NIL;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: resultType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isNormalVariable(param1) <span class="keywd">then</span>
      variableObject := param1;
    <span class="keywd">else</span>
      resultType := getType(param1);
      <span class="keywd">if</span> isFunc(resultType) <span class="op">or</span> isVarfunc(resultType) <span class="keywd">then</span>
        resultType := resultType(resultType);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      variableObject := allocVar(resultType, typeCategory[resultType]);
      incr(c_expr.temp_num);
      c_expr.temp_decls &amp;:= type_name(getType(variableObject));
      c_expr.temp_decls &amp;:= <span class="stri">" o_"</span>;
      create_name(variableObject, c_expr.temp_decls);
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      c_expr.expr &amp;:= <span class="stri">" o_"</span>;
      create_name(variableObject, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">"="</span>;
      getAnyParamToExpr(param1, c_expr);
      c_expr.expr &amp;:= <span class="stri">";\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getReference (<span class="op">in</span> <span class="type">string</span>: typeName, <span class="op">in</span> <span class="type">string</span>: namePrefix,
    <span class="op">in</span> <span class="type">reference</span>: param1, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: variableName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    incr(c_expr.temp_num);
    variableName := namePrefix &amp; str(c_expr.temp_num);
    c_expr.temp_decls &amp;:= typeName;
    c_expr.temp_decls &amp;:= <span class="stri">" *"</span>;
    c_expr.temp_decls &amp;:= variableName;
    c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
    c_expr.expr &amp;:= variableName;
    c_expr.expr &amp;:= <span class="stri">"=&amp;("</span>;
    getAnyParamToExpr(param1, c_expr);
    c_expr.expr &amp;:= <span class="stri">");\n"</span>;
    variableName := <span class="stri">"(*"</span> &amp; variableName &amp; <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getParameterAsReference (<span class="op">in</span> <span class="type">string</span>: typeName, <span class="op">in</span> <span class="type">string</span>: namePrefix,
    <span class="op">in</span> <span class="type">reference</span>: param1, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: variableName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isNormalVariable(param1) <span class="keywd">then</span>
      variableName := normalVariable(param1, c_expr);
    <span class="keywd">else</span>
      variableName := getReference(typeName, namePrefix, param1, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: defineTempConstant (<span class="op">in</span> <span class="type">string</span>: typeName, <span class="op">in</span> <span class="type">string</span>: namePrefix,
    <span class="op">in</span> <span class="type">reference</span>: param1, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: variableName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: param_expr <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    incr(c_expr.temp_num);
    variableName := namePrefix &amp; str(c_expr.temp_num);
    param_expr.temp_num := c_expr.temp_num;
    process_expr(param1, param_expr);
    c_expr.temp_num := param_expr.temp_num;
    c_expr.temp_decls &amp;:= typeName;
    c_expr.temp_decls &amp;:= <span class="stri">" "</span>;
    c_expr.temp_decls &amp;:= variableName;
    <span class="keywd">if</span> param_expr.temp_frees &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      c_expr.temp_assigns &amp;:= <span class="stri">"{\n"</span>;
      c_expr.temp_assigns &amp;:= param_expr.temp_decls;
      c_expr.temp_assigns &amp;:= param_expr.temp_assigns;
      c_expr.temp_assigns &amp;:= variableName;
      c_expr.temp_assigns &amp;:= <span class="stri">"="</span>;
      c_expr.temp_assigns &amp;:= param_expr.expr;
      c_expr.temp_assigns &amp;:= <span class="stri">";\n"</span>;
      c_expr.temp_assigns &amp;:= param_expr.temp_frees;
      c_expr.temp_assigns &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">elsif</span> param_expr.temp_decls &lt;> <span class="stri">""</span> <span class="op">or</span> param_expr.temp_assigns &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      c_expr.temp_decls &amp;:= param_expr.temp_decls;
      c_expr.temp_assigns &amp;:= param_expr.temp_assigns;
      c_expr.temp_assigns &amp;:= variableName;
      c_expr.temp_assigns &amp;:= <span class="stri">"="</span>;
      c_expr.temp_assigns &amp;:= param_expr.expr;
      c_expr.temp_assigns &amp;:= <span class="stri">";\n"</span>;
    <span class="keywd">else</span>
      c_expr.temp_decls &amp;:= <span class="stri">"="</span>;
      c_expr.temp_decls &amp;:= param_expr.expr;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: defineForStartVariable (<span class="op">in</span> <span class="type">string</span>: typeName, <span class="op">in</span> <span class="type">string</span>: namePrefix,
    <span class="op">in</span> <span class="type">reference</span>: param1, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: variableName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: param_expr <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    param_expr.temp_num := c_expr.temp_num;
    process_expr(param1, param_expr);
    c_expr.temp_num := param_expr.temp_num;
    <span class="keywd">if</span> param_expr.temp_frees &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      incr(c_expr.temp_num);
      variableName := <span class="stri">"start_"</span> &amp; str(c_expr.temp_num);
      c_expr.temp_decls &amp;:= <span class="stri">"intType "</span>;
      c_expr.temp_decls &amp;:= variableName;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      c_expr.temp_assigns &amp;:= <span class="stri">"{\n"</span>;
      c_expr.temp_assigns &amp;:= param_expr.temp_decls;
      c_expr.temp_assigns &amp;:= param_expr.temp_assigns;
      c_expr.temp_assigns &amp;:= variableName;
      c_expr.temp_assigns &amp;:= <span class="stri">"="</span>;
      c_expr.temp_assigns &amp;:= param_expr.expr;
      c_expr.temp_assigns &amp;:= <span class="stri">";\n"</span>;
      c_expr.temp_assigns &amp;:= param_expr.temp_frees;
      c_expr.temp_assigns &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">else</span>
      <span class="keywd">if</span> param_expr.temp_decls &lt;> <span class="stri">""</span> <span class="op">or</span> param_expr.temp_assigns &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        c_expr.temp_decls &amp;:= param_expr.temp_decls;
        c_expr.temp_assigns &amp;:= param_expr.temp_assigns;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      variableName := param_expr.expr;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: has_temp_values (<span class="op">in</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span>
  <span class="keywd">return</span> c_expr.temp_num >= 2 <span class="op">or</span>
      (c_expr.temp_num = 1 <span class="op">and</span> c_expr.result_expr = <span class="stri">""</span>);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: beginCastGeneric (<span class="op">in</span> <span class="type">type</span>: dest_type, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: temp_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"("</span>;
    <span class="keywd">if</span> dest_type <span class="op">in</span> typeCategory <span class="op">and</span> typeCategory[dest_type] = FLOATOBJECT <span class="op">or</span>
        <span class="op">not</span> ccConf.LITTLE_ENDIAN_INTTYPE <span class="keywd">then</span>
      incr(c_expr.temp_num);
      temp_name := <span class="stri">"tmp_"</span> &amp; str(c_expr.temp_num);
      c_expr.temp_decls &amp;:= <span class="stri">"rtlValueUnion "</span>;
      c_expr.temp_decls &amp;:= temp_name;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      c_expr.expr &amp;:= temp_name;
      c_expr.expr &amp;:= <span class="stri">".genericValue="</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= type_name(dest_type);
      c_expr.expr &amp;:= <span class="stri">")("</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: endCastGeneric (<span class="op">in</span> <span class="type">type</span>: dest_type, <span class="op">in</span> <span class="type">string</span>: temp_name, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> dest_type <span class="op">in</span> typeCategory <span class="op">and</span> typeCategory[dest_type] = FLOATOBJECT <span class="op">or</span>
        <span class="op">not</span> ccConf.LITTLE_ENDIAN_INTTYPE <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">","</span>;
      c_expr.expr &amp;:= temp_name;
      c_expr.expr &amp;:= <span class="stri">"."</span>;
      c_expr.expr &amp;:= raw_type_value(dest_type);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: beginCastGenericToResultExpr (<span class="op">in</span> <span class="type">type</span>: dest_type, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: temp_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    c_expr.result_expr &amp;:= <span class="stri">"("</span>;
    <span class="keywd">if</span> dest_type <span class="op">in</span> typeCategory <span class="op">and</span> typeCategory[dest_type] = FLOATOBJECT <span class="op">or</span>
        <span class="op">not</span> ccConf.LITTLE_ENDIAN_INTTYPE <span class="keywd">then</span>
      incr(c_expr.temp_num);
      temp_name := <span class="stri">"tmp_"</span> &amp; str(c_expr.temp_num);
      c_expr.temp_decls &amp;:= <span class="stri">"rtlValueUnion "</span>;
      c_expr.temp_decls &amp;:= temp_name;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      c_expr.result_expr &amp;:= temp_name;
      c_expr.result_expr &amp;:= <span class="stri">".genericValue="</span>;
    <span class="keywd">else</span>
      c_expr.result_expr &amp;:= type_name(dest_type);
      c_expr.result_expr &amp;:= <span class="stri">")("</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: endCastGenericToResultExpr (<span class="op">in</span> <span class="type">type</span>: dest_type, <span class="op">in</span> <span class="type">string</span>: temp_name, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> dest_type <span class="op">in</span> typeCategory <span class="op">and</span> typeCategory[dest_type] = FLOATOBJECT <span class="op">or</span>
        <span class="op">not</span> ccConf.LITTLE_ENDIAN_INTTYPE <span class="keywd">then</span>
      c_expr.result_expr &amp;:= <span class="stri">","</span>;
      c_expr.result_expr &amp;:= temp_name;
      c_expr.result_expr &amp;:= <span class="stri">"."</span>;
      c_expr.result_expr &amp;:= raw_type_value(dest_type);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: useFunctype (<span class="op">in</span> <span class="type">reference</span>: current_object) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: curr_expr <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">category</span>: exprCategory <span class="keywd">is</span> category.value;
  <span class="keywd">begin</span>
    curr_expr := getValue(current_object, reference);
    <span class="keywd">if</span> curr_expr &lt;> NIL <span class="keywd">then</span>
      exprCategory := category(curr_expr);
      okay := exprCategory = ACTOBJECT <span class="op">or</span>
              exprCategory = BLOCKOBJECT;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: declare_func_pointer_if_necessary (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: func_pointer <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> category(current_object) = CALLOBJECT <span class="keywd">then</span>
      params := getValue(current_object, ref_list);
      <span class="keywd">if</span> length(params) >= 1 <span class="keywd">then</span>
        func_pointer := params[1];
        <span class="keywd">if</span> category(func_pointer) = REFOBJECT <span class="keywd">then</span>
          <span class="keywd">if</span> func_pointer <span class="op">not</span> <span class="op">in</span> function_pointer_declared <span class="keywd">then</span>
            <span class="keywd">if</span> useFunctype(func_pointer) <span class="keywd">then</span>
              c_expr.expr &amp;:= <span class="stri">"extern intfunctype o_"</span>;
            <span class="keywd">else</span>
              c_expr.expr &amp;:= <span class="stri">"extern objRefType o_"</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            create_name(func_pointer, c_expr.expr);
            c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
            function_pointer_declared @:= [func_pointer] TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isActionExpression (<span class="op">in</span> <span class="type">reference</span>: current_expression, <span class="op">in</span> <span class="type">string</span>: actionName) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: isActionExpression <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> category(current_expression) = CALLOBJECT <span class="keywd">then</span>
      params := getValue(current_expression, ref_list);
      <span class="keywd">if</span> category(params[1]) = ACTOBJECT <span class="op">and</span> str(getValue(params[1], ACTION)) = actionName <span class="keywd">then</span>
        isActionExpression := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: getActionParameter (<span class="op">in</span> <span class="type">reference</span>: current_expression, <span class="op">in</span> <span class="type">integer</span>: number) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">reference</span>: actionParameter <span class="keywd">is</span> NIL;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> category(current_expression) = CALLOBJECT <span class="keywd">then</span>
      params := getValue(current_expression, ref_list);
      actionParameter := params[succ(number)];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: doRshift (<span class="op">in</span> <span class="type">string</span>: number_name, <span class="op">in</span> <span class="type">string</span>: rshift_name,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="comment">(* Formula used: a&lt;0?~(~a>>b):a>>b *)</span>
    c_expr.expr &amp;:= number_name;
    c_expr.expr &amp;:= <span class="stri">"&lt;0?~(~"</span>;
    c_expr.expr &amp;:= number_name;
    c_expr.expr &amp;:= <span class="stri">" >> "</span>;
    c_expr.expr &amp;:= rshift_name;
    c_expr.expr &amp;:= <span class="stri">"):"</span>;
    c_expr.expr &amp;:= number_name;
    c_expr.expr &amp;:= <span class="stri">" >> "</span>;
    c_expr.expr &amp;:= rshift_name;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
