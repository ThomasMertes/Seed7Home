<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../../style1.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  str_act.s7i   Generate code for actions of the type string.     *)</span>
<span class="comment">(*  Copyright (C) 1990 - 1994, 2004 - 2017  Thomas Mertes           *)</span>
<span class="comment">(*                2019 - 2022  Thomas Mertes                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 compiler.                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">const</span> <span class="type">ACTION</span>: STR_APPEND        <span class="keywd">is</span> action <span class="stri">"STR_APPEND"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_CAT           <span class="keywd">is</span> action <span class="stri">"STR_CAT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_CHIPOS        <span class="keywd">is</span> action <span class="stri">"STR_CHIPOS"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_CHPOS         <span class="keywd">is</span> action <span class="stri">"STR_CHPOS"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_CHSPLIT       <span class="keywd">is</span> action <span class="stri">"STR_CHSPLIT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_CLIT          <span class="keywd">is</span> action <span class="stri">"STR_CLIT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_CMP           <span class="keywd">is</span> action <span class="stri">"STR_CMP"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_CPY           <span class="keywd">is</span> action <span class="stri">"STR_CPY"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_ELEMCPY       <span class="keywd">is</span> action <span class="stri">"STR_ELEMCPY"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_EQ            <span class="keywd">is</span> action <span class="stri">"STR_EQ"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_FOR           <span class="keywd">is</span> action <span class="stri">"STR_FOR"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_FOR_KEY       <span class="keywd">is</span> action <span class="stri">"STR_FOR_KEY"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_FOR_VAR_KEY   <span class="keywd">is</span> action <span class="stri">"STR_FOR_VAR_KEY"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_GE            <span class="keywd">is</span> action <span class="stri">"STR_GE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_GT            <span class="keywd">is</span> action <span class="stri">"STR_GT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_HASHCODE      <span class="keywd">is</span> action <span class="stri">"STR_HASHCODE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_HEAD          <span class="keywd">is</span> action <span class="stri">"STR_HEAD"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_IDX           <span class="keywd">is</span> action <span class="stri">"STR_IDX"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_IPOS          <span class="keywd">is</span> action <span class="stri">"STR_IPOS"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_LE            <span class="keywd">is</span> action <span class="stri">"STR_LE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_LIT           <span class="keywd">is</span> action <span class="stri">"STR_LIT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_LNG           <span class="keywd">is</span> action <span class="stri">"STR_LNG"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_LOW           <span class="keywd">is</span> action <span class="stri">"STR_LOW"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_LPAD          <span class="keywd">is</span> action <span class="stri">"STR_LPAD"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_LPAD0         <span class="keywd">is</span> action <span class="stri">"STR_LPAD0"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_LT            <span class="keywd">is</span> action <span class="stri">"STR_LT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_LTRIM         <span class="keywd">is</span> action <span class="stri">"STR_LTRIM"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_MULT          <span class="keywd">is</span> action <span class="stri">"STR_MULT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_NE            <span class="keywd">is</span> action <span class="stri">"STR_NE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_POS           <span class="keywd">is</span> action <span class="stri">"STR_POS"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_POSCPY        <span class="keywd">is</span> action <span class="stri">"STR_POSCPY"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_PUSH          <span class="keywd">is</span> action <span class="stri">"STR_PUSH"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_RANGE         <span class="keywd">is</span> action <span class="stri">"STR_RANGE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_RCHIPOS       <span class="keywd">is</span> action <span class="stri">"STR_RCHIPOS"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_RCHPOS        <span class="keywd">is</span> action <span class="stri">"STR_RCHPOS"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_REPL          <span class="keywd">is</span> action <span class="stri">"STR_REPL"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_RIPOS         <span class="keywd">is</span> action <span class="stri">"STR_RIPOS"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_RPAD          <span class="keywd">is</span> action <span class="stri">"STR_RPAD"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_RPOS          <span class="keywd">is</span> action <span class="stri">"STR_RPOS"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_RTRIM         <span class="keywd">is</span> action <span class="stri">"STR_RTRIM"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_SPLIT         <span class="keywd">is</span> action <span class="stri">"STR_SPLIT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_STR           <span class="keywd">is</span> action <span class="stri">"STR_STR"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_SUBSTR        <span class="keywd">is</span> action <span class="stri">"STR_SUBSTR"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_SUBSTR_FIXLEN <span class="keywd">is</span> action <span class="stri">"STR_SUBSTR_FIXLEN"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_TAIL          <span class="keywd">is</span> action <span class="stri">"STR_TAIL"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_TOUTF8        <span class="keywd">is</span> action <span class="stri">"STR_TOUTF8"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_TRIM          <span class="keywd">is</span> action <span class="stri">"STR_TRIM"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_UP            <span class="keywd">is</span> action <span class="stri">"STR_UP"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_UTF8TOSTRI    <span class="keywd">is</span> action <span class="stri">"STR_UTF8TOSTRI"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: STR_VALUE         <span class="keywd">is</span> action <span class="stri">"STR_VALUE"</span>;


<span class="keywd">const</span> <span class="type">proc</span>: str_prototypes (<span class="keywd">inout</span> <span class="type">file</span>: c_prog) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    declareExtern(c_prog, <span class="stri">"void        strAppend (striType *const, const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        strAppendN (striType *const, const const_striType[], memSizeType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        strAppendTemp (striType *const, const striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strChChRepl (const const_striType, const charType, const charType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     strChIPos (const const_striType, const charType, const intType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strChMult (const charType, const intType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     strChPos (const const_striType, const charType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strChRepl (const const_striType, const charType, const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"arrayType   strChSplit (const const_striType, const charType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     strCmpGeneric (const genericType, const genericType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     strCompare (const const_striType, const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strConcat (const const_striType, const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strConcatChar (const const_striType, const charType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strConcatCharTemp (striType, const charType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strConcatN (const const_striType[], memSizeType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strConcatTemp (striType, const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strCLit (const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        strCopy (striType *const, const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        strCpyGeneric (genericType *const, const genericType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strCreate (const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"genericType strCreateGeneric (const genericType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        strDestr (const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        strDestrGeneric (const genericType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strEmpty(void);"</span>);
    declareExtern(c_prog, <span class="stri">"boolType    strGe (const const_striType, const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"boolType    strGt (const const_striType, const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     strHashCode (const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strHead (const_striType, intType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        strHeadSlice (const const_striType, const intType, striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strHeadTemp (const striType, const intType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     strIPos (const const_striType, const const_striType, const intType);"</span>);
    declareExtern(c_prog, <span class="stri">"boolType    strLe (const const_striType, const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strLit (const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strLow (const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strLowTemp (const striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strLpad (const const_striType, const intType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strLpadTemp (const striType, const intType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strLpad0 (const const_striType, const intType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strLpad0Temp (const striType, const intType);"</span>);
    declareExtern(c_prog, <span class="stri">"boolType    strLt (const const_striType, const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strLtrim (const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strMult (const const_striType, const intType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     strPos (const const_striType, const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        strPush (striType *const, const charType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strRange (const_striType, intType, intType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        strRangeSlice (const const_striType, intType, intType, striType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     strRChIPos (const const_striType, const charType, const intType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     strRChPos (const const_striType, const charType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strRepl (const const_striType, const const_striType, const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     strRIPos (const const_striType, const const_striType, const intType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strRpad (const const_striType, const intType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     strRPos (const const_striType, const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strRtrim (const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"arrayType   strSplit (const const_striType, const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strSubstr (const_striType, intType, intType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        strSubstrSlice (const const_striType, intType, intType, striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strSubstrFixLen (const const_striType, intType, intType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        strSubstrFixLenSlice (const const_striType, intType, intType, striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strTail (const_striType, intType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        strTailSlice (const const_striType, intType, striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strTailTemp (const striType, intType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strToUtf8 (const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strTrim (const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strUp (const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strUpTemp (const striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strUtf8ToStri (const const_striType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strValue (const const_objRefType);"</span>);
    declareExtern(c_prog, <span class="stri">"const_striType strValueRef (const const_objRefType);"</span>);
    declareExtern(c_prog, <span class="stri">"striType    strZero (const intType);"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">reference</span>: getConcatNParamList (<span class="op">in</span> <span class="type">ref_list</span>: params) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">reference</span>: concatNParamList <span class="keywd">is</span> 0 <span class="op">times</span> NIL;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: leftParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">reference</span>: rightParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">boolean</span>: concatFound <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">ref_list</span>: subExprParams <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">ref_list</span>: rightParamList <span class="keywd">is</span> ref_list.EMPTY;
  <span class="keywd">begin</span>
    leftParam := params[1];
    rightParam := params[3];
    <span class="keywd">if</span> isActionExpression(rightParam, <span class="stri">"STR_CAT"</span>) <span class="keywd">then</span>
      rightParamList := getValue(rightParam, ref_list)[2 ..];
      concatNParamList := getConcatNParamList(rightParamList);
    <span class="keywd">else</span>
      concatNParamList := [] (rightParam);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">repeat</span>
      concatFound := FALSE;
      <span class="keywd">if</span> category(leftParam) = CALLOBJECT <span class="keywd">then</span>
        subExprParams := getValue(leftParam, ref_list);
        <span class="keywd">if</span> category(subExprParams[1]) = ACTOBJECT <span class="keywd">then</span>
          <span class="keywd">if</span> str(getValue(subExprParams[1], ACTION)) = <span class="stri">"STR_CAT"</span> <span class="keywd">then</span>
            leftParam := subExprParams[2];
            rightParam := subExprParams[4];
            <span class="keywd">if</span> isActionExpression(rightParam, <span class="stri">"STR_CAT"</span>) <span class="keywd">then</span>
              rightParamList := getValue(rightParam, ref_list)[2 ..];
              concatNParamList := getConcatNParamList(rightParamList) &amp; concatNParamList;
            <span class="keywd">else</span>
              concatNParamList := [] (rightParam) &amp; concatNParamList;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            concatFound := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> <span class="op">not</span> concatFound;
    concatNParamList := [] (leftParam) &amp; concatNParamList;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">reference</span>: getAppendExtensions (<span class="op">in</span> <span class="type">reference</span>: extension) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">reference</span>: appendNParamList <span class="keywd">is</span> 0 <span class="op">times</span> NIL;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> category(extension) = CALLOBJECT <span class="keywd">then</span>
      params := getValue(extension, ref_list);
      <span class="keywd">if</span> category(params[1]) = ACTOBJECT <span class="op">and</span>
          str(getValue(params[1], ACTION)) = <span class="stri">"STR_CAT"</span> <span class="keywd">then</span>
        appendNParamList := getConcatNParamList(params[2 ..]);
      <span class="keywd">else</span>
        appendNParamList := [] (extension);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      appendNParamList := [] (extension);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: concatConstants (<span class="keywd">inout</span> <span class="type">array</span> <span class="type">reference</span>: concatNParamList) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: paramValue <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> index &lt;= length(concatNParamList) <span class="keywd">do</span>
      <span class="keywd">if</span> getConstant(concatNParamList[index], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
        paramValue := getValue(evaluatedParam, string);
        <span class="keywd">if</span> paramValue = <span class="stri">""</span> <span class="keywd">then</span>
          <span class="comment"># Empty strings are removed.</span>
          incr(countOptimizations);
          ignore(remove(concatNParamList, index));
        <span class="keywd">elsif</span> succ(index) &lt;= length(concatNParamList) <span class="op">and</span>
            getConstant(concatNParamList[succ(index)], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
          <span class="comment"># Two consecutive constant strings are concatenated at compile time.</span>
          incr(countOptimizations);
          concatNParamList[index] := alloc(FALSE, getType(concatNParamList[index]),
              paramValue &amp; getValue(evaluatedParam, string));
          ignore(remove(concatNParamList, succ(index)));
        <span class="keywd">else</span>
          incr(index);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        incr(index);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_inline_str_push (<span class="op">in</span> <span class="type">reference</span>: param1, <span class="op">in</span> <span class="type">char</span>: ch,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">string</span>: stri_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isNormalVariable(param1) <span class="keywd">then</span>
      stri_name := normalVariable(param1, statement);
    <span class="keywd">else</span>
      incr(statement.temp_num);
      stri_name := <span class="stri">"tmp_"</span> &amp; str(statement.temp_num);
      statement.temp_decls &amp;:= <span class="stri">"striType *"</span>;
      statement.temp_decls &amp;:= stri_name;
      statement.temp_decls &amp;:= <span class="stri">";\n"</span>;
      statement.expr &amp;:= stri_name;
      statement.expr &amp;:= <span class="stri">"=&amp;("</span>;
      process_expr(param1, statement);
      statement.expr &amp;:= <span class="stri">");\n"</span>;
      stri_name := <span class="stri">"*"</span> &amp; stri_name;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    statement.expr &amp;:= <span class="stri">"if (("</span>;
    statement.expr &amp;:= stri_name;
    statement.expr &amp;:= <span class="stri">")->size == ("</span>;
    statement.expr &amp;:= stri_name;
    statement.expr &amp;:= <span class="stri">")->capacity) {\n"</span>;
    statement.expr &amp;:= <span class="stri">"strPush(&amp;("</span>;
    statement.expr &amp;:= stri_name;
    statement.expr &amp;:= <span class="stri">"), "</span>;
    statement.expr &amp;:= charLiteral(ch);
    statement.expr &amp;:= <span class="stri">");\n"</span>;
    statement.expr &amp;:= <span class="stri">"} else {\n"</span>;
    statement.expr &amp;:= <span class="stri">"("</span>;
    statement.expr &amp;:= stri_name;
    statement.expr &amp;:= <span class="stri">")->mem[("</span>;
    statement.expr &amp;:= stri_name;
    statement.expr &amp;:= <span class="stri">")->size]="</span>;
    statement.expr &amp;:= charLiteral(ch);
    statement.expr &amp;:= <span class="stri">";\n"</span>;
    statement.expr &amp;:= <span class="stri">"("</span>;
    statement.expr &amp;:= stri_name;
    statement.expr &amp;:= <span class="stri">")->size++;\n"</span>;
    statement.expr &amp;:= <span class="stri">"}\n"</span>;
    doLocalDeclsOfStatement(statement, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_push (<span class="op">in</span> <span class="type">reference</span>: param1, <span class="op">in</span> <span class="type">char</span>: ch,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> inlineFunctions <span class="op">and</span> ccConf.WITH_STRI_CAPACITY <span class="keywd">then</span>
      incr(countInlinedFunctions);
      process_const_inline_str_push(param1, ch, c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strPush(&amp;("</span>;
      process_expr(param1, c_expr);
      c_expr.expr &amp;:= <span class="stri">"), "</span>;
      c_expr.expr &amp;:= charLiteral(ch);
      c_expr.expr &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_append (<span class="op">in</span> <span class="type">reference</span>: param1, <span class="op">in</span> <span class="type">string</span>: stri,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    setDiagnosticLine(c_expr);
    <span class="keywd">if</span> stri = <span class="stri">""</span> <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"/* Append empty string */\n"</span>;
    <span class="keywd">elsif</span> length(stri) = 1 <span class="keywd">then</span>
      incr(countOptimizations);
      process_const_str_push(param1, stri[1], c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strAppend(&amp;("</span>;
      process_expr(param1, c_expr);
      c_expr.expr &amp;:= <span class="stri">"), "</span>;
      c_expr.expr &amp;:= stringLiteral(stri);
      c_expr.expr &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Produces code for the string append operator.
 *  If two or more strings are appended the function
 *  strAppendN is used. This avoids copying and allocation operations.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: optimize_str_append (<span class="op">in</span> <span class="type">reference</span>: dest, <span class="op">in</span> <span class="type">reference</span>: extension,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">reference</span>: appendExtensions <span class="keywd">is</span> 0 <span class="op">times</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: concatNParamName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_extension <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    appendExtensions := getAppendExtensions(extension);
    concatConstants(appendExtensions);
    <span class="keywd">if</span> length(appendExtensions) >= 2 <span class="keywd">then</span>
      incr(countOptimizations);
      incr(statement.temp_num);
      concatNParamName := <span class="stri">"tmp_"</span> &amp; str(statement.temp_num);
      statement.temp_decls &amp;:= <span class="stri">"const_striType "</span>;
      statement.temp_decls &amp;:= concatNParamName;
      statement.temp_decls &amp;:= <span class="stri">"["</span>;
      statement.temp_decls &amp;:= str(length(appendExtensions));
      statement.temp_decls &amp;:= <span class="stri">"];\n"</span>;
      <span class="keywd">for</span> <span class="keywd">key</span> index <span class="keywd">range</span> appendExtensions <span class="keywd">do</span>
        statement.expr &amp;:= concatNParamName;
        statement.expr &amp;:= <span class="stri">"["</span>;
        statement.expr &amp;:= str(pred(index));
        statement.expr &amp;:= <span class="stri">"] = "</span>;
        getAnyParamToExpr(appendExtensions[index], statement);
        statement.expr &amp;:= <span class="stri">";\n"</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      statement.expr &amp;:= <span class="stri">"strAppendN(&amp;("</span>;
      process_expr(dest, statement);
      statement.expr &amp;:= <span class="stri">"), "</span>;
      statement.expr &amp;:= concatNParamName;
      statement.expr &amp;:= <span class="stri">", "</span>;
      statement.expr &amp;:= str(length(appendExtensions));
      statement.expr &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">elsif</span> length(appendExtensions) = 1 <span class="keywd">then</span>
      <span class="keywd">if</span> getConstant(appendExtensions[1], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
        process_const_str_append(dest, getValue(evaluatedParam, string), c_expr);
      <span class="keywd">else</span>
        <span class="keywd">if</span> isActionExpression(appendExtensions[1], <span class="stri">"CHR_STR"</span>) <span class="keywd">then</span>
          incr(countOptimizations);
          statement.expr &amp;:= <span class="stri">"strPush(&amp;("</span>;
          process_expr(dest, statement);
          statement.expr &amp;:= <span class="stri">"), "</span>;
          process_expr(getActionParameter(appendExtensions[1], 1), statement);
        <span class="keywd">else</span>
          prepareAnyParamTemporarys(appendExtensions[1], c_extension, statement);
          <span class="keywd">if</span> c_extension.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            statement.expr := <span class="stri">"strAppendTemp(&amp;("</span>;
            process_expr(dest, statement);
            statement.expr &amp;:= <span class="stri">"), "</span>;
            statement.expr &amp;:= c_extension.result_expr;
          <span class="keywd">else</span>
            statement.expr := <span class="stri">"strAppend(&amp;("</span>;
            process_expr(dest, statement);
            statement.expr &amp;:= <span class="stri">"), "</span>;
            statement.expr &amp;:= c_extension.expr;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        statement.expr &amp;:= <span class="stri">");\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      incr(countOptimizations);
      statement.expr &amp;:= <span class="stri">"/* Append empty string */\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    doLocalDeclsOfStatement(statement, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_str_append (<span class="op">in</span> <span class="type">reference</span>: param1, <span class="op">in</span> <span class="type">reference</span>: param3,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param1 <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param3 <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> evaluate_const_expr >= 1 <span class="keywd">then</span>
      optimize_str_append(param1, param3, c_expr);
    <span class="keywd">elsif</span> getConstant(param3, STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_append(param1, getValue(evaluatedParam, string), c_expr);
    <span class="keywd">else</span>
      process_expr(param1, c_param1);
      c_param3.temp_num := c_param1.temp_num;
      <span class="keywd">if</span> isActionExpression(param3, <span class="stri">"CHR_STR"</span>) <span class="keywd">then</span>
        incr(countOptimizations);
        process_expr(getActionParameter(param3, 1), c_param3);
      <span class="keywd">else</span>
        process_expr(param3, c_param3);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> has_temp_values(c_param3) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
        appendWithDiagnostic(c_param1.temp_decls, c_expr);
        appendWithDiagnostic(c_param3.temp_decls, c_expr);
        appendWithDiagnostic(c_param1.temp_assigns, c_expr);
        appendWithDiagnostic(c_param3.temp_assigns, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      setDiagnosticLine(c_expr);
      <span class="keywd">if</span> isActionExpression(param3, <span class="stri">"CHR_STR"</span>) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"strPush(&amp;("</span>;
        c_expr.expr &amp;:= c_param1.expr;
        c_expr.expr &amp;:= <span class="stri">"), "</span>;
        c_expr.expr &amp;:= c_param3.expr;
      <span class="keywd">elsif</span> c_param3.expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"strAppend(&amp;("</span>;
        c_expr.expr &amp;:= c_param1.expr;
        c_expr.expr &amp;:= <span class="stri">"), "</span>;
        c_expr.expr &amp;:= c_param3.expr;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"strAppendTemp(&amp;("</span>;
        c_expr.expr &amp;:= c_param1.expr;
        c_expr.expr &amp;:= <span class="stri">"), "</span>;
        c_expr.expr &amp;:= c_param3.result_expr;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">");\n"</span>;
      <span class="keywd">if</span> has_temp_values(c_param3) <span class="keywd">then</span>
        appendWithDiagnostic(c_param1.temp_frees, c_expr);
        appendWithDiagnostic(c_param3.temp_frees, c_expr);
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_APPEND, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    process_str_append(params[1], params[3], c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Produces code for the string concatenation.
 *  If three or more strings are concatenated the function
 *  strConcatN is used. This saves copying and allocation operations.
 *  If the first parameter is a temporary value the concatenation
 *  is done with strConcatTemp. The strConcatTemp function returns
 *  the first parameter as result of the concatenation. That way the
 *  temporary of the first parameter must not be freed.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: optimize_str_cat (<span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">reference</span>: concatNParamList <span class="keywd">is</span> 0 <span class="op">times</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: concatNParamName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param1 <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    concatNParamList := getConcatNParamList(params);
    concatConstants(concatNParamList);
    <span class="keywd">if</span> length(concatNParamList) >= 3 <span class="keywd">then</span>
      incr(countOptimizations);
      prepare_stri_result(c_expr);
      incr(c_expr.temp_num);
      concatNParamName := <span class="stri">"tmp_"</span> &amp; str(c_expr.temp_num);
      c_expr.temp_decls &amp;:= <span class="stri">"const_striType "</span>;
      c_expr.temp_decls &amp;:= concatNParamName;
      c_expr.temp_decls &amp;:= <span class="stri">"["</span>;
      c_expr.temp_decls &amp;:= str(length(concatNParamList));
      c_expr.temp_decls &amp;:= <span class="stri">"];\n"</span>;
      c_expr.result_expr := <span class="stri">"("</span>;
      <span class="keywd">for</span> <span class="keywd">key</span> index <span class="keywd">range</span> concatNParamList <span class="keywd">do</span>
        <span class="keywd">if</span> getConstant(concatNParamList[index], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
          c_expr.temp_assigns &amp;:= concatNParamName;
          c_expr.temp_assigns &amp;:= <span class="stri">"["</span>;
          c_expr.temp_assigns &amp;:= str(pred(index));
          c_expr.temp_assigns &amp;:= <span class="stri">"] = "</span>;
          c_expr.temp_assigns &amp;:= stringLiteral(getValue(evaluatedParam, string));
          c_expr.temp_assigns &amp;:= <span class="stri">";\n"</span>;
        <span class="keywd">else</span>
          c_expr.result_expr &amp;:= concatNParamName;
          c_expr.result_expr &amp;:= <span class="stri">"["</span>;
          c_expr.result_expr &amp;:= str(pred(index));
          c_expr.result_expr &amp;:= <span class="stri">"] = "</span>;
          getAnyParamToResultExpr(concatNParamList[index], c_expr);
          c_expr.result_expr &amp;:= <span class="stri">", "</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      c_expr.result_expr &amp;:= <span class="stri">"strConcatN("</span>;
      c_expr.result_expr &amp;:= concatNParamName;
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      c_expr.result_expr &amp;:= str(length(concatNParamList));
      c_expr.result_expr &amp;:= <span class="stri">"))"</span>;
    <span class="keywd">elsif</span> length(concatNParamList) = 2 <span class="keywd">then</span>
      prepare_stri_result(c_expr);
      prepareAnyParamTemporarys(concatNParamList[1], c_param1, c_expr);
      <span class="keywd">if</span> isActionExpression(concatNParamList[2], <span class="stri">"CHR_STR"</span>) <span class="keywd">then</span>
        incr(countOptimizations);
        <span class="keywd">if</span> c_param1.expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          c_expr.result_expr := <span class="stri">"strConcatChar("</span>;
          c_expr.result_expr &amp;:= c_param1.expr;
        <span class="keywd">else</span>
          c_expr.result_expr := <span class="stri">"strConcatCharTemp("</span>;
          c_expr.result_expr &amp;:= c_param1.result_expr;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.result_expr &amp;:= <span class="stri">", "</span>;
        getAnyParamToResultExpr(getActionParameter(concatNParamList[2], 1), c_expr);
      <span class="keywd">else</span>
        <span class="keywd">if</span> c_param1.expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          c_expr.result_expr := <span class="stri">"strConcat("</span>;
          c_expr.result_expr &amp;:= c_param1.expr;
        <span class="keywd">else</span>
          c_expr.result_expr := <span class="stri">"strConcatTemp("</span>;
          c_expr.result_expr &amp;:= c_param1.result_expr;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.result_expr &amp;:= <span class="stri">", "</span>;
        getAnyParamToResultExpr(concatNParamList[2], c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">elsif</span> length(concatNParamList) = 1 <span class="keywd">then</span>
      incr(countOptimizations);
      process_expr(concatNParamList[1], c_expr);
    <span class="keywd">else</span>
      incr(countOptimizations);
      <span class="keywd">if</span> c_expr.demand >= ASSIGN_RESULT <span class="keywd">then</span>
        c_expr.result_expr := <span class="stri">"strEmpty()"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= stringLiteral(<span class="stri">""</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_CAT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param1 <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> evaluate_const_expr >= 1 <span class="keywd">then</span>
      optimize_str_cat(params, c_expr);
    <span class="keywd">else</span>
      prepare_stri_result(c_expr);
      prepareAnyParamTemporarys(params[1], c_param1, c_expr);
      <span class="keywd">if</span> c_param1.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        c_expr.result_expr := <span class="stri">"strConcatTemp("</span>;
        c_expr.result_expr &amp;:= c_param1.result_expr;
      <span class="keywd">else</span>
        c_expr.result_expr := <span class="stri">"strConcat("</span>;
        c_expr.result_expr &amp;:= c_param1.expr;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToResultExpr(params[3], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_CHIPOS, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"strChIPos("</span>;
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    process_expr(params[2], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    process_expr(params[3], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_chpos (<span class="op">in</span> <span class="type">string</span>: mainStri, <span class="op">in</span> <span class="type">reference</span>: searched,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(searched, CHAROBJECT, evaluatedParam) <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"/* pos("</span>;
      c_expr.expr &amp;:= replace(literal(mainStri), <span class="stri">"*/"</span>, <span class="stri">"*\\/"</span>);
      c_expr.expr &amp;:= <span class="stri">","</span>;
      c_expr.expr &amp;:= literal(getValue(evaluatedParam, char));
      c_expr.expr &amp;:= <span class="stri">") */ "</span>;
      c_expr.expr &amp;:= integerLiteral(pos(mainStri, getValue(evaluatedParam, char)));
    <span class="keywd">elsif</span> length(mainStri) = 0 <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"/* pos(\"\", *) */ "</span>;
      c_expr.expr &amp;:= integerLiteral(0);
    <span class="keywd">elsif</span> length(mainStri) = 1 <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"/* pos("</span>;
      c_expr.expr &amp;:= literal(mainStri);
      c_expr.expr &amp;:= <span class="stri">", *) */ "</span>;
      c_expr.expr &amp;:= charLiteral(mainStri[1]);
      c_expr.expr &amp;:= <span class="stri">"==("</span>;
      getAnyParamToExpr(searched, c_expr);
      c_expr.expr &amp;:= <span class="stri">")?"</span>;
      c_expr.expr &amp;:= integerLiteral(1);
      c_expr.expr &amp;:= <span class="stri">":"</span>;
      c_expr.expr &amp;:= integerLiteral(0);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strChPos("</span>;
      c_expr.expr &amp;:= stringLiteral(mainStri);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToExpr(searched, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_CHPOS, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_chpos(getValue(evaluatedParam, string), params[2], c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strChPos("</span>;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(params[2], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_CHSPLIT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_typed_result(array_type[getExprResultType(params[1])], c_expr);
    c_expr.result_expr := <span class="stri">"strChSplit("</span>;
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">", "</span>;
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_CLIT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_stri_result(c_expr);
    c_expr.result_expr := <span class="stri">"strCLit("</span>;
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_CMP, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"strCompare("</span>;
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_CPY, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param1 <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param3 <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isActionExpression(params[3], <span class="stri">"STR_CAT"</span>) <span class="op">and</span>
        getActionParameter(params[3], 1) = params[1] <span class="keywd">then</span>
      process_str_append(params[1], getActionParameter(params[3], 3), c_expr);
    <span class="keywd">else</span>
      statement.temp_num := c_expr.temp_num;
      prepareAnyParamTemporarys(params[1], c_param1, statement);
      <span class="keywd">if</span> isActionExpression(params[3], <span class="stri">"STR_HEAD"</span>) <span class="op">and</span>
          getActionParameter(params[3], 1) = params[1] <span class="keywd">then</span>
        statement.expr &amp;:= c_param1.expr;
        statement.expr &amp;:= <span class="stri">"=strHeadTemp("</span>;
        statement.expr &amp;:= c_param1.expr;
        statement.expr &amp;:= <span class="stri">", "</span>;
        process_expr(getActionParameter(params[3], 4), statement);
        statement.expr &amp;:= <span class="stri">");\n"</span>;
      <span class="keywd">elsif</span> isActionExpression(params[3], <span class="stri">"STR_TAIL"</span>) <span class="op">and</span>
          getActionParameter(params[3], 1) = params[1] <span class="keywd">then</span>
        statement.expr &amp;:= c_param1.expr;
        statement.expr &amp;:= <span class="stri">"=strTailTemp("</span>;
        statement.expr &amp;:= c_param1.expr;
        statement.expr &amp;:= <span class="stri">", "</span>;
        process_expr(getActionParameter(params[3], 3), statement);
        statement.expr &amp;:= <span class="stri">");\n"</span>;
      <span class="keywd">elsif</span> isActionExpression(params[3], <span class="stri">"STR_LOW"</span>) <span class="op">and</span>
          getActionParameter(params[3], 1) = params[1] <span class="keywd">then</span>
        statement.expr &amp;:= c_param1.expr;
        statement.expr &amp;:= <span class="stri">"=strLowTemp("</span>;
        statement.expr &amp;:= c_param1.expr;
        statement.expr &amp;:= <span class="stri">");\n"</span>;
      <span class="keywd">elsif</span> isActionExpression(params[3], <span class="stri">"STR_UP"</span>) <span class="op">and</span>
          getActionParameter(params[3], 1) = params[1] <span class="keywd">then</span>
        statement.expr &amp;:= c_param1.expr;
        statement.expr &amp;:= <span class="stri">"=strUpTemp("</span>;
        statement.expr &amp;:= c_param1.expr;
        statement.expr &amp;:= <span class="stri">");\n"</span>;
      <span class="keywd">else</span>
        c_param3.demand := ASSIGN_RESULT;
        prepareAnyParamTemporarys(params[3], c_param3, statement);
        <span class="keywd">if</span> c_param3.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          <span class="keywd">if</span> isNormalVariable(params[1]) <span class="keywd">then</span>
            statement.temp_decls &amp;:= <span class="stri">"striType old_stri="</span>;
            statement.temp_decls &amp;:= c_param1.expr;
            statement.temp_decls &amp;:= <span class="stri">";\n"</span>;
            statement.expr &amp;:= c_param1.expr;
            statement.expr &amp;:= <span class="stri">"="</span>;
          <span class="keywd">else</span>
            statement.temp_decls &amp;:= <span class="stri">"striType old_stri;\n"</span>;
            statement.temp_decls &amp;:= <span class="stri">"striType *stri_ptr=&amp;("</span>;
            statement.temp_decls &amp;:= c_param1.expr;
            statement.temp_decls &amp;:= <span class="stri">");\n"</span>;
            statement.expr &amp;:= <span class="stri">"old_stri=*stri_ptr;\n"</span>;
            statement.expr &amp;:= <span class="stri">"*stri_ptr="</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          statement.expr &amp;:= c_param3.result_expr;
          statement.expr &amp;:= <span class="stri">";\n"</span>;
          statement.expr &amp;:= <span class="stri">"strDestr(old_stri);\n"</span>;
        <span class="keywd">else</span>
          statement.expr &amp;:= <span class="stri">"strCopy(&amp;("</span>;
          statement.expr &amp;:= c_param1.expr;
          statement.expr &amp;:= <span class="stri">"), "</span>;
          statement.expr &amp;:= c_param3.expr;
          statement.expr &amp;:= <span class="stri">");\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      doLocalDeclsOfStatement(statement, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_elemcpy (<span class="op">in</span> <span class="type">reference</span>: destStri,
    <span class="op">in</span> <span class="type">integer</span>: position, <span class="op">in</span> <span class="type">char</span>: aChar, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_destStri <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    incr(countOptimizations);
    <span class="keywd">if</span> position &lt; 1 <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"/* 'string @:= [n] char' with n &lt; 1 */\n"</span>;
      warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
      c_expr.expr &amp;:= raiseError(<span class="stri">"INDEX_ERROR"</span>);
    <span class="keywd">else</span>
      process_expr(destStri, c_destStri);
      <span class="keywd">if</span> c_destStri.temp_num &lt;> 0 <span class="op">or</span> string_index_check <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> c_destStri.temp_num &lt;> 0 <span class="keywd">then</span>
        appendWithDiagnostic(c_destStri.temp_decls, c_expr);
        appendWithDiagnostic(c_destStri.temp_assigns, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
        incr(countIndexChecks);
        c_expr.expr &amp;:= <span class="stri">"striType destStri="</span>;
        c_expr.expr &amp;:= c_destStri.expr;
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"if (idxChk(destStri->size&lt;="</span>;
        c_expr.expr &amp;:= integerLiteral(pred(position));
        c_expr.expr &amp;:= <span class="stri">")) {\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"  "</span>;
        c_expr.expr &amp;:= raiseError(<span class="stri">"INDEX_ERROR"</span>);
        c_expr.expr &amp;:= <span class="stri">"} else {\n"</span>;
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"  destStri->mem["</span>;
        c_expr.expr &amp;:= integerLiteral(pred(position));
        c_expr.expr &amp;:= <span class="stri">"] = (strElemType)("</span>;
        c_expr.expr &amp;:= c_literal(aChar);
        c_expr.expr &amp;:= <span class="stri">");\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
      <span class="keywd">else</span>
        incr(countSuppressedIndexChecks);
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        c_expr.expr &amp;:= c_destStri.expr;
        c_expr.expr &amp;:= <span class="stri">")->mem["</span>;
        c_expr.expr &amp;:= integerLiteral(pred(position));
        c_expr.expr &amp;:= <span class="stri">"] = (strElemType)("</span>;
        c_expr.expr &amp;:= c_literal(aChar);
        c_expr.expr &amp;:= <span class="stri">");\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> c_destStri.temp_num &lt;> 0 <span class="keywd">then</span>
        appendWithDiagnostic(c_destStri.temp_frees, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> c_destStri.temp_num &lt;> 0 <span class="op">or</span> string_index_check <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_elemcpy (<span class="op">in</span> <span class="type">reference</span>: destStri,
    <span class="op">in</span> <span class="type">integer</span>: position, <span class="op">in</span> <span class="type">reference</span>: aChar, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_destStri <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_aChar <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    incr(countOptimizations);
    <span class="keywd">if</span> position &lt; 1 <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"/* 'string @:= [n] char' with n &lt; 1 */\n"</span>;
      warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
      c_expr.expr &amp;:= raiseError(<span class="stri">"INDEX_ERROR"</span>);
    <span class="keywd">else</span>
      process_expr(destStri, c_destStri);
      c_aChar.temp_num := c_destStri.temp_num;
      process_expr(aChar, c_aChar);
      <span class="keywd">if</span> c_aChar.temp_num &lt;> 0 <span class="op">or</span> string_index_check <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> c_aChar.temp_num &lt;> 0 <span class="keywd">then</span>
        appendWithDiagnostic(c_destStri.temp_decls, c_expr);
        appendWithDiagnostic(c_aChar.temp_decls, c_expr);
        appendWithDiagnostic(c_destStri.temp_assigns, c_expr);
        appendWithDiagnostic(c_aChar.temp_assigns, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
        incr(countIndexChecks);
        c_expr.expr &amp;:= <span class="stri">"striType destStri="</span>;
        c_expr.expr &amp;:= c_destStri.expr;
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"if (idxChk(destStri->size&lt;="</span>;
        c_expr.expr &amp;:= integerLiteral(pred(position));
        c_expr.expr &amp;:= <span class="stri">")) {\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"  "</span>;
        c_expr.expr &amp;:= raiseError(<span class="stri">"INDEX_ERROR"</span>);
        c_expr.expr &amp;:= <span class="stri">"} else {\n"</span>;
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"  destStri->mem["</span>;
        c_expr.expr &amp;:= integerLiteral(pred(position));
        c_expr.expr &amp;:= <span class="stri">"] = (strElemType)("</span>;
        c_expr.expr &amp;:= c_aChar.expr;
        c_expr.expr &amp;:= <span class="stri">");\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
      <span class="keywd">else</span>
        incr(countSuppressedIndexChecks);
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        c_expr.expr &amp;:= c_destStri.expr;
        c_expr.expr &amp;:= <span class="stri">")->mem["</span>;
        c_expr.expr &amp;:= integerLiteral(pred(position));
        c_expr.expr &amp;:= <span class="stri">"] = (strElemType)("</span>;
        c_expr.expr &amp;:= c_aChar.expr;
        c_expr.expr &amp;:= <span class="stri">");\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> c_aChar.temp_num &lt;> 0 <span class="keywd">then</span>
        appendWithDiagnostic(c_destStri.temp_frees, c_expr);
        appendWithDiagnostic(c_aChar.temp_frees, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> c_aChar.temp_num &lt;> 0 <span class="op">or</span> string_index_check <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_elemcpy (<span class="op">in</span> <span class="type">reference</span>: destStri,
    <span class="op">in</span> <span class="type">reference</span>: position, <span class="op">in</span> <span class="type">char</span>: aChar, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_destStri <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_position <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(position, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_elemcpy(destStri, getValue(evaluatedParam, integer), aChar, c_expr);
    <span class="keywd">else</span>
      incr(countOptimizations);
      process_expr(destStri, c_destStri);
      c_position.temp_num := c_destStri.temp_num;
      process_expr(position, c_position);
      <span class="keywd">if</span> c_position.temp_num &lt;> 0 <span class="op">or</span> string_index_check <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> c_position.temp_num &lt;> 0 <span class="keywd">then</span>
        appendWithDiagnostic(c_destStri.temp_decls, c_expr);
        appendWithDiagnostic(c_position.temp_decls, c_expr);
        appendWithDiagnostic(c_destStri.temp_assigns, c_expr);
        appendWithDiagnostic(c_position.temp_assigns, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
        incr(countIndexChecks);
        c_expr.expr &amp;:= <span class="stri">"striType destStri="</span>;
        c_expr.expr &amp;:= c_destStri.expr;
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        <span class="keywd">if</span> ccConf.TWOS_COMPLEMENT_INTTYPE <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"uintType position=(uintType)("</span>;
          c_expr.expr &amp;:= c_position.expr;
          c_expr.expr &amp;:= <span class="stri">")-1;\n"</span>;
          c_expr.expr &amp;:= <span class="stri">"if (idxChk("</span>;
          c_expr.expr &amp;:= <span class="stri">"position>=destStri->size)) {\n"</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"intType position="</span>;
          c_expr.expr &amp;:= c_position.expr;
          c_expr.expr &amp;:= <span class="stri">";\n"</span>;
          c_expr.expr &amp;:= <span class="stri">"if (idxChk("</span>;
          c_expr.expr &amp;:= <span class="stri">"position&lt;=0 || "</span>;
          c_expr.expr &amp;:= <span class="stri">"position>destStri->size)) {\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"  "</span>;
        c_expr.expr &amp;:= raiseError(<span class="stri">"INDEX_ERROR"</span>);
        c_expr.expr &amp;:= <span class="stri">"} else {\n"</span>;
        setDiagnosticLine(c_expr);
        <span class="keywd">if</span> ccConf.TWOS_COMPLEMENT_INTTYPE <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"  destStri->mem[position] = (strElemType)("</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"  destStri->mem[position-1] = (strElemType)("</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= c_literal(aChar);
        c_expr.expr &amp;:= <span class="stri">");\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
      <span class="keywd">else</span>
        incr(countSuppressedIndexChecks);
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        c_expr.expr &amp;:= c_destStri.expr;
        c_expr.expr &amp;:= <span class="stri">")->mem[("</span>;
        c_expr.expr &amp;:= c_position.expr;
        c_expr.expr &amp;:= <span class="stri">")-1] = (strElemType)("</span>;
        c_expr.expr &amp;:= c_literal(aChar);
        c_expr.expr &amp;:= <span class="stri">");\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> c_position.temp_num &lt;> 0 <span class="keywd">then</span>
        appendWithDiagnostic(c_destStri.temp_frees, c_expr);
        appendWithDiagnostic(c_position.temp_frees, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> c_position.temp_num &lt;> 0 <span class="op">or</span> string_index_check <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_ELEMCPY, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_destStri <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_position <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_aChar <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[6], CHAROBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_elemcpy(params[1], params[4], getValue(evaluatedParam, char), c_expr);
    <span class="keywd">elsif</span> getConstant(params[4], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_elemcpy(params[1], getValue(evaluatedParam, integer), params[6], c_expr);
    <span class="keywd">else</span>
      process_expr(params[1], c_destStri);
      c_position.temp_num := c_destStri.temp_num;
      process_expr(params[4], c_position);
      c_aChar.temp_num := c_position.temp_num;
      process_expr(params[6], c_aChar);
      <span class="keywd">if</span> c_aChar.temp_num &lt;> 0 <span class="op">or</span> string_index_check <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> c_aChar.temp_num &lt;> 0 <span class="keywd">then</span>
        appendWithDiagnostic(c_destStri.temp_decls, c_expr);
        appendWithDiagnostic(c_position.temp_decls, c_expr);
        appendWithDiagnostic(c_aChar.temp_decls, c_expr);
        appendWithDiagnostic(c_destStri.temp_assigns, c_expr);
        appendWithDiagnostic(c_position.temp_assigns, c_expr);
        appendWithDiagnostic(c_aChar.temp_assigns, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
        incr(countIndexChecks);
        c_expr.expr &amp;:= <span class="stri">"striType destStri="</span>;
        c_expr.expr &amp;:= c_destStri.expr;
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        <span class="keywd">if</span> ccConf.TWOS_COMPLEMENT_INTTYPE <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"uintType position=(uintType)("</span>;
          c_expr.expr &amp;:= c_position.expr;
          c_expr.expr &amp;:= <span class="stri">")-1;\n"</span>;
          c_expr.expr &amp;:= <span class="stri">"if (idxChk("</span>;
          c_expr.expr &amp;:= <span class="stri">"position>=destStri->size)) {\n"</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"intType position="</span>;
          c_expr.expr &amp;:= c_position.expr;
          c_expr.expr &amp;:= <span class="stri">";\n"</span>;
          c_expr.expr &amp;:= <span class="stri">"if (idxChk("</span>;
          c_expr.expr &amp;:= <span class="stri">"position&lt;=0 || "</span>;
          c_expr.expr &amp;:= <span class="stri">"position>destStri->size)) {\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"  "</span>;
        c_expr.expr &amp;:= raiseError(<span class="stri">"INDEX_ERROR"</span>);
        c_expr.expr &amp;:= <span class="stri">"} else {\n"</span>;
        setDiagnosticLine(c_expr);
        <span class="keywd">if</span> ccConf.TWOS_COMPLEMENT_INTTYPE <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"  destStri->mem[position] = (strElemType)("</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"  destStri->mem[position-1] = (strElemType)("</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= c_aChar.expr;
        c_expr.expr &amp;:= <span class="stri">");\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
      <span class="keywd">else</span>
        incr(countSuppressedIndexChecks);
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        c_expr.expr &amp;:= c_destStri.expr;
        c_expr.expr &amp;:= <span class="stri">")->mem[("</span>;
        c_expr.expr &amp;:= c_position.expr;
        c_expr.expr &amp;:= <span class="stri">")-1] = (strElemType)("</span>;
        c_expr.expr &amp;:= c_aChar.expr;
        c_expr.expr &amp;:= <span class="stri">");\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> c_aChar.temp_num &lt;> 0 <span class="keywd">then</span>
        appendWithDiagnostic(c_destStri.temp_frees, c_expr);
        appendWithDiagnostic(c_position.temp_frees, c_expr);
        appendWithDiagnostic(c_aChar.temp_frees, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> c_aChar.temp_num &lt;> 0 <span class="op">or</span> string_index_check <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_eq (<span class="op">in</span> <span class="type">reference</span>: param1, <span class="op">in</span> <span class="type">string</span>: stri_b,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: stri_a_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    incr(countOptimizations);
    <span class="keywd">if</span> getConstant(param1, STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"/* "</span>;
      c_expr.expr &amp;:= replace(literal(getValue(evaluatedParam, string)), <span class="stri">"*/"</span>, <span class="stri">"*\\/"</span>);
      c_expr.expr &amp;:= <span class="stri">" == "</span>;
      c_expr.expr &amp;:= replace(literal(stri_b), <span class="stri">"*/"</span>, <span class="stri">"*\\/"</span>);
      c_expr.expr &amp;:= <span class="stri">" */ "</span>;
      <span class="keywd">if</span> getValue(evaluatedParam, string) = stri_b <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"1"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"0"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> stri_b = <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"(("</span>;
      getAnyParamToExpr(param1, c_expr);
      c_expr.expr &amp;:= <span class="stri">")->size==0 /* \"\" */)"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      stri_a_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"tmp_"</span>, param1, c_expr);
      <span class="keywd">if</span> length(stri_b) = 1 <span class="keywd">then</span>
        <span class="comment">(* Formula used: (a->size==1&amp;&amp;a->mem[0]==b->mem[0]) *)</span>
        c_expr.expr &amp;:= stri_a_name;
        c_expr.expr &amp;:= <span class="stri">"->size==1&amp;&amp;"</span>;
        c_expr.expr &amp;:= stri_a_name;
        c_expr.expr &amp;:= <span class="stri">"->mem[0]==(strElemType)("</span>;
        c_expr.expr &amp;:= c_literal(stri_b[1]);
        c_expr.expr &amp;:= <span class="stri">") /* "</span>;
        c_expr.expr &amp;:= literal(stri_b);
        c_expr.expr &amp;:= <span class="stri">" */)"</span>;
      <span class="keywd">else</span>
        <span class="comment">(* Formula used: (a->size==b->size&amp;&amp;memcmp(a->mem,b->mem,
                         b->size*sizeof(strElemType))==0) *)</span>
        c_expr.expr &amp;:= stri_a_name;
        c_expr.expr &amp;:= <span class="stri">"->size=="</span>;
        c_expr.expr &amp;:= str(length(stri_b));
        c_expr.expr &amp;:= <span class="stri">"&amp;&amp;memcmp("</span>;
        c_expr.expr &amp;:= stri_a_name;
        c_expr.expr &amp;:= <span class="stri">"->mem,("</span>;
        c_expr.expr &amp;:= stringLiteral(stri_b);
        c_expr.expr &amp;:= <span class="stri">")->mem,"</span>;
        c_expr.expr &amp;:= str(length(stri_b));
        c_expr.expr &amp;:= <span class="stri">"*sizeof(strElemType))==0)"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_EQ, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: stri_a_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri_b_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[3], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_eq(params[1], getValue(evaluatedParam, string), c_expr);
    <span class="keywd">elsif</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_eq(params[3], getValue(evaluatedParam, string), c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      stri_a_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"tmp_a_"</span>, params[1], c_expr);
      stri_b_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"tmp_b_"</span>, params[3], c_expr);
      <span class="comment">(* Formula used: (a->size==b->size&amp;&amp;memcmp(a->mem,b->mem,
                       a->size*sizeof(strElemType))==0) *)</span>
      c_expr.expr &amp;:= stri_a_name;
      c_expr.expr &amp;:= <span class="stri">"->size=="</span>;
      c_expr.expr &amp;:= stri_b_name;
      c_expr.expr &amp;:= <span class="stri">"->size&amp;&amp;memcmp("</span>;
      c_expr.expr &amp;:= stri_a_name;
      c_expr.expr &amp;:= <span class="stri">"->mem,"</span>;
      c_expr.expr &amp;:= stri_b_name;
      c_expr.expr &amp;:= <span class="stri">"->mem,"</span>;
      c_expr.expr &amp;:= stri_a_name;
      c_expr.expr &amp;:= <span class="stri">"->size*sizeof(strElemType))==0)"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_FOR, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: size_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: index_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    size_name := defineTempVariable(<span class="stri">"memSizeType"</span>, <span class="stri">"size_"</span>, statement);
    index_name := defineTempVariable(<span class="stri">"memSizeType"</span>, <span class="stri">"index_"</span>, statement);
    statement.expr &amp;:= <span class="stri">"for ("</span>;
    stri_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"stri_"</span>, params[4], statement);
    statement.expr &amp;:= size_name;
    statement.expr &amp;:= <span class="stri">"="</span>;
    statement.expr &amp;:= stri_name;
    statement.expr &amp;:= <span class="stri">"->size,"</span>;
    statement.expr &amp;:= index_name;
    statement.expr &amp;:= <span class="stri">"=0; "</span>;
    statement.expr &amp;:= index_name;
    statement.expr &amp;:= <span class="stri">"&lt;"</span>;
    statement.expr &amp;:= size_name;
    statement.expr &amp;:= <span class="stri">"; ("</span>;
    statement.expr &amp;:= index_name;
    statement.expr &amp;:= <span class="stri">")++) {\n"</span>;
    process_expr(params[2], statement);
    statement.expr &amp;:= <span class="stri">"="</span>;
    statement.expr &amp;:= stri_name;
    statement.expr &amp;:= <span class="stri">"->mem["</span>;
    statement.expr &amp;:= index_name;
    statement.expr &amp;:= <span class="stri">"];\n"</span>;
    process_call_by_name_expr(params[6], statement);
    statement.expr &amp;:= <span class="stri">"}\n"</span>;
    doLocalDeclsOfStatement(statement, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_FOR_KEY, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: size_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: index_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    size_name := defineTempVariable(<span class="stri">"memSizeType"</span>, <span class="stri">"size_"</span>, statement);
    index_name := defineTempVariable(<span class="stri">"memSizeType"</span>, <span class="stri">"index_"</span>, statement);
    statement.expr &amp;:= <span class="stri">"for ("</span>;
    stri_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"stri_"</span>, params[5], statement);
    statement.expr &amp;:= size_name;
    statement.expr &amp;:= <span class="stri">"="</span>;
    statement.expr &amp;:= stri_name;
    statement.expr &amp;:= <span class="stri">"->size,"</span>;
    statement.expr &amp;:= index_name;
    statement.expr &amp;:= <span class="stri">"=0; "</span>;
    statement.expr &amp;:= index_name;
    statement.expr &amp;:= <span class="stri">"&lt;"</span>;
    statement.expr &amp;:= size_name;
    statement.expr &amp;:= <span class="stri">"; ("</span>;
    statement.expr &amp;:= index_name;
    statement.expr &amp;:= <span class="stri">")++) {\n"</span>;
    process_expr(params[3], statement);
    statement.expr &amp;:= <span class="stri">"= (intType)("</span>;
    statement.expr &amp;:= index_name;
    statement.expr &amp;:= <span class="stri">" + 1);\n"</span>;
    process_call_by_name_expr(params[7], statement);
    statement.expr &amp;:= <span class="stri">"}\n"</span>;
    doLocalDeclsOfStatement(statement, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_FOR_VAR_KEY, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: size_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: index_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    size_name := defineTempVariable(<span class="stri">"memSizeType"</span>, <span class="stri">"size_"</span>, statement);
    index_name := defineTempVariable(<span class="stri">"memSizeType"</span>, <span class="stri">"index_"</span>, statement);
    statement.expr &amp;:= <span class="stri">"for ("</span>;
    stri_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"stri_"</span>, params[6], statement);
    statement.expr &amp;:= size_name;
    statement.expr &amp;:= <span class="stri">"="</span>;
    statement.expr &amp;:= stri_name;
    statement.expr &amp;:= <span class="stri">"->size,"</span>;
    statement.expr &amp;:= index_name;
    statement.expr &amp;:= <span class="stri">"=0; "</span>;
    statement.expr &amp;:= index_name;
    statement.expr &amp;:= <span class="stri">"&lt;"</span>;
    statement.expr &amp;:= size_name;
    statement.expr &amp;:= <span class="stri">"; ("</span>;
    statement.expr &amp;:= index_name;
    statement.expr &amp;:= <span class="stri">")++) {\n"</span>;
    process_expr(params[2], statement);
    statement.expr &amp;:= <span class="stri">"="</span>;
    statement.expr &amp;:= stri_name;
    statement.expr &amp;:= <span class="stri">"->mem["</span>;
    statement.expr &amp;:= index_name;
    statement.expr &amp;:= <span class="stri">"];\n"</span>;
    process_expr(params[4], statement);
    statement.expr &amp;:= <span class="stri">"= (intType)("</span>;
    statement.expr &amp;:= index_name;
    statement.expr &amp;:= <span class="stri">" + 1);\n"</span>;
    process_call_by_name_expr(params[8], statement);
    statement.expr &amp;:= <span class="stri">"}\n"</span>;
    doLocalDeclsOfStatement(statement, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_le (<span class="op">in</span> <span class="type">string</span>: stri1, <span class="op">in</span> <span class="type">reference</span>: stri2,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_ge (<span class="op">in</span> <span class="type">string</span>: stri1, <span class="op">in</span> <span class="type">reference</span>: stri2,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri2_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> stri1 = <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      getAnyParamToExpr(stri2, c_expr);
      c_expr.expr &amp;:= <span class="stri">")->size==0"</span>;
    <span class="keywd">elsif</span> length(stri1) = 1 <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      stri2_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"stri2_"</span>, stri2, c_expr);
      c_expr.expr &amp;:= stri2_name;
      c_expr.expr &amp;:= <span class="stri">"->size==0||"</span>;
      c_expr.expr &amp;:= stri2_name;
      c_expr.expr &amp;:= <span class="stri">"->size==1&amp;&amp;"</span>;
      c_expr.expr &amp;:= stri2_name;
      c_expr.expr &amp;:= <span class="stri">"->mem[0]&lt;=(strElemType)("</span>;
      c_expr.expr &amp;:= c_literal(stri1[1]);
      c_expr.expr &amp;:= <span class="stri">") /* "</span>;
      c_expr.expr &amp;:= literal(stri1);
      c_expr.expr &amp;:= <span class="stri">" */||"</span>;
      c_expr.expr &amp;:= stri2_name;
      c_expr.expr &amp;:= <span class="stri">"->mem[0]&lt;(strElemType)("</span>;
      c_expr.expr &amp;:= c_literal(stri1[1]);
      c_expr.expr &amp;:= <span class="stri">") /* "</span>;
      c_expr.expr &amp;:= literal(stri1);
      c_expr.expr &amp;:= <span class="stri">" */)"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strGe("</span>;
      c_expr.expr &amp;:= stringLiteral(stri1);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToExpr(stri2, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_GE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_ge(getValue(evaluatedParam, string), params[3], c_expr);
    <span class="keywd">elsif</span> getConstant(params[3], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_le(getValue(evaluatedParam, string), params[1], c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strGe("</span>;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToExpr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_lt (<span class="op">in</span> <span class="type">string</span>: stri1, <span class="op">in</span> <span class="type">reference</span>: stri2,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_gt (<span class="op">in</span> <span class="type">string</span>: stri1, <span class="op">in</span> <span class="type">reference</span>: stri2,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri2_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> stri1 = <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"0"</span>;
    <span class="keywd">elsif</span> length(stri1) = 1 <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      stri2_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"stri2_"</span>, stri2, c_expr);
      c_expr.expr &amp;:= stri2_name;
      c_expr.expr &amp;:= <span class="stri">"->size==0||"</span>;
      c_expr.expr &amp;:= stri2_name;
      c_expr.expr &amp;:= <span class="stri">"->mem[0]&lt;(strElemType)("</span>;
      c_expr.expr &amp;:= c_literal(stri1[1]);
      c_expr.expr &amp;:= <span class="stri">") /* "</span>;
      c_expr.expr &amp;:= literal(stri1);
      c_expr.expr &amp;:= <span class="stri">" */)"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strGt("</span>;
      c_expr.expr &amp;:= stringLiteral(stri1);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToExpr(stri2, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_GT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_gt(getValue(evaluatedParam, string), params[3], c_expr);
    <span class="keywd">elsif</span> getConstant(params[3], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_lt(getValue(evaluatedParam, string), params[1], c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strGt("</span>;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToExpr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_HASHCODE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: stri_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= integerLiteral(hashCode(getValue(evaluatedParam, string)));
    <span class="keywd">elsif</span> inlineFunctions <span class="keywd">then</span>
      incr(countInlinedFunctions);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      stri_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"tmp_"</span>, params[1], c_expr);
      c_expr.expr &amp;:= stri_name;
      c_expr.expr &amp;:= <span class="stri">"->size==0 ? 0 : ("</span>;
      c_expr.expr &amp;:= stri_name;
      c_expr.expr &amp;:= <span class="stri">"->mem[0]&lt;&lt;5 ^ "</span>;
      c_expr.expr &amp;:= stri_name;
      c_expr.expr &amp;:= <span class="stri">"->mem["</span>;
      c_expr.expr &amp;:= stri_name;
      c_expr.expr &amp;:= <span class="stri">"->size>>1]&lt;&lt;3 ^ "</span>;
      c_expr.expr &amp;:= stri_name;
      c_expr.expr &amp;:= <span class="stri">"->mem["</span>;
      c_expr.expr &amp;:= stri_name;
      c_expr.expr &amp;:= <span class="stri">"->size-1]&lt;&lt;1 ^ "</span>;
      c_expr.expr &amp;:= stri_name;
      c_expr.expr &amp;:= <span class="stri">"->size))"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strHashCode("</span>;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_head (<span class="op">in</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="type">reference</span>: length,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">integer</span>: length_value <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: length_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">intRange</span>: length_range <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">string</span>: slice_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(length, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      incr(countOptimizations);
      length_value := getValue(evaluatedParam, integer);
      <span class="keywd">if</span> length_value &lt; 0 <span class="keywd">then</span>
        warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
        c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= stringLiteral(stri[.. length_value]);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> stri = <span class="stri">""</span> <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"/* \"\"[ .. n] */ ("</span>;
      <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
        length_range := getIntRange(length);
        <span class="keywd">if</span> length_range.minValue &lt; 0 <span class="keywd">then</span>
          incr(countIndexChecks);
          c_expr.expr &amp;:= <span class="stri">"idxChk("</span>;
          process_expr(length, c_expr);
          c_expr.expr &amp;:= <span class="stri">"&lt;0)?"</span>;
          c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
          c_expr.expr &amp;:= <span class="stri">":"</span>;
        <span class="keywd">else</span>
          countIndexOptimizations(c_expr);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        incr(countSuppressedIndexChecks);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= stringLiteral(<span class="stri">""</span>);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">elsif</span> length(stri) = 1 <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      length_name := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"length_"</span>, length, c_expr);
      <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
        length_range := getIntRange(length);
        <span class="keywd">if</span> length_range.minValue &lt; 0 <span class="keywd">then</span>
          incr(countIndexChecks);
          c_expr.expr &amp;:= <span class="stri">"idxChk("</span>;
          c_expr.expr &amp;:= length_name;
          c_expr.expr &amp;:= <span class="stri">"&lt;0)?"</span>;
          c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
          c_expr.expr &amp;:= <span class="stri">":"</span>;
        <span class="keywd">else</span>
          countIndexOptimizations(c_expr);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        incr(countSuppressedIndexChecks);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= length_name;
      c_expr.expr &amp;:= <span class="stri">">=1?"</span>;
      c_expr.expr &amp;:= stringLiteral(stri);
      c_expr.expr &amp;:= <span class="stri">":"</span>;
      c_expr.expr &amp;:= stringLiteral(<span class="stri">""</span>);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">elsif</span> ccConf.ALLOW_STRITYPE_SLICES <span class="op">and</span> c_expr.demand &lt; REQUIRE_RESULT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      incr(c_expr.temp_num);
      slice_name := <span class="stri">"slice_"</span> &amp; str(c_expr.temp_num);
      c_expr.temp_decls &amp;:= <span class="stri">"struct striStruct "</span>;
      c_expr.temp_decls &amp;:= slice_name;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      <span class="keywd">if</span> inlineFunctions <span class="keywd">then</span>
        incr(countInlinedFunctions);
        length_name := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"length_"</span>, length, c_expr);
        <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
          length_range := getIntRange(length);
          <span class="keywd">if</span> length_range.minValue &lt; 0 <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"idxChk("</span>;
            c_expr.expr &amp;:= length_name;
            c_expr.expr &amp;:= <span class="stri">"&lt;0)?"</span>;
            c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
            c_expr.expr &amp;:= <span class="stri">":"</span>;
          <span class="keywd">else</span>
            countIndexOptimizations(c_expr);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          incr(countSuppressedIndexChecks);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        c_expr.expr &amp;:= slice_name;
        c_expr.expr &amp;:= <span class="stri">".mem = ("</span>;
        c_expr.expr &amp;:= stringLiteral(stri);
        c_expr.expr &amp;:= <span class="stri">")->mem, "</span>;
        c_expr.expr &amp;:= memSizeLiteral(length(stri));
        c_expr.expr &amp;:= <span class="stri">"&lt;=(uintType)"</span>;
        c_expr.expr &amp;:= length_name;
        c_expr.expr &amp;:= <span class="stri">" ? "</span>;
        c_expr.expr &amp;:= slice_name;
        c_expr.expr &amp;:= <span class="stri">".size = "</span>;
        c_expr.expr &amp;:= memSizeLiteral(length(stri));
        c_expr.expr &amp;:= <span class="stri">" : ("</span>;
        c_expr.expr &amp;:= slice_name;
        c_expr.expr &amp;:= <span class="stri">".size = (memSizeType)"</span>;
        c_expr.expr &amp;:= length_name;
        c_expr.expr &amp;:= <span class="stri">"), &amp;"</span>;
        c_expr.expr &amp;:= slice_name;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"strHeadSlice("</span>;
        c_expr.expr &amp;:= stringLiteral(stri);
        c_expr.expr &amp;:= <span class="stri">", "</span>;
        process_expr(length, c_expr);
        c_expr.expr &amp;:= <span class="stri">", &amp;"</span>;
        c_expr.expr &amp;:= slice_name;
        c_expr.expr &amp;:= <span class="stri">"), &amp;"</span>;
        c_expr.expr &amp;:= slice_name;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      prepare_stri_result(c_expr);
      c_expr.result_expr := <span class="stri">"strHead("</span>;
      c_expr.result_expr &amp;:= stringLiteral(stri);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getStdParamToResultExpr(length, c_expr);
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_head1 (<span class="op">in</span> <span class="type">reference</span>: param1,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: temp_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri1_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param1 <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> c_expr.demand &lt; REQUIRE_RESULT <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      temp_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"tmp_"</span>, param1, c_expr);
      incr(c_expr.temp_num);
      stri1_name := <span class="stri">"stri1_"</span> &amp; str(c_expr.temp_num);
      c_expr.temp_decls &amp;:= <span class="stri">"struct striStruct "</span>;
      c_expr.temp_decls &amp;:= stri1_name;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      c_expr.expr &amp;:= temp_name;
      c_expr.expr &amp;:= <span class="stri">"->size>=1?chrStrMacro("</span>;
      c_expr.expr &amp;:= temp_name;
      c_expr.expr &amp;:= <span class="stri">"->mem[0],"</span>;
      c_expr.expr &amp;:= stri1_name;
      c_expr.expr &amp;:= <span class="stri">"):"</span>;
      c_expr.expr &amp;:= stringLiteral(<span class="stri">""</span>);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      prepareAnyParamTemporarys(param1, c_param1, c_expr);
      prepare_stri_result(c_expr);
      <span class="keywd">if</span> c_param1.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        c_expr.result_expr := <span class="stri">"strHeadTemp("</span>;
        c_expr.result_expr &amp;:= c_param1.result_expr;
      <span class="keywd">else</span>
        c_expr.result_expr := <span class="stri">"strHead("</span>;
        c_expr.result_expr &amp;:= c_param1.expr;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.result_expr &amp;:= <span class="stri">", 1)"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_inline_str_head (<span class="op">in</span> <span class="type">reference</span>: stri, <span class="op">in</span> <span class="type">reference</span>: length,
    <span class="op">in</span> <span class="type">string</span>: slice_name, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: stri_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri_value <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri_size <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: length_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: length_value <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: length_is_variable <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">intRange</span>: length_range <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">boolean</span>: raisesIndexError <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    stri_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"stri_"</span>, stri, c_expr);
    stri_size := stri_name &amp; <span class="stri">"->size"</span>;
    <span class="keywd">if</span> getConstant(length, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      length_is_variable := FALSE;
      length_value := getValue(evaluatedParam, integer);
      <span class="keywd">if</span> length_value &lt; 0 <span class="keywd">then</span>
        warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
        c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
        raisesIndexError := TRUE;
      <span class="keywd">else</span>
        length_name := integerLiteral(length_value);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      length_name := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"length_"</span>, length, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="op">not</span> raisesIndexError <span class="keywd">then</span>
      <span class="keywd">if</span> length_is_variable <span class="keywd">then</span>
        <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
          length_range := getIntRange(length);
          <span class="keywd">if</span> length_range.minValue &lt; 0 <span class="keywd">then</span>
            incr(countIndexChecks);
            c_expr.expr &amp;:= <span class="stri">"idxChk("</span>;
            c_expr.expr &amp;:= length_name;
            c_expr.expr &amp;:= <span class="stri">"&lt;0"</span>;
            c_expr.expr &amp;:= <span class="stri">")?"</span>;
            c_expr.expr &amp;:= intRaiseError(<span class="stri">"INDEX_ERROR"</span>);
            c_expr.expr &amp;:= <span class="stri">":0, "</span>;
          <span class="keywd">else</span>
            countIndexOptimizations(c_expr);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          incr(countSuppressedIndexChecks);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> ccConf.WITH_STRI_CAPACITY <span class="op">and</span> FALSE <span class="keywd">then</span>
        c_expr.expr &amp;:= slice_name;
        c_expr.expr &amp;:= <span class="stri">".capacity=0, "</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> <span class="op">not</span> length_is_variable <span class="op">and</span> length_value = 0 <span class="keywd">then</span>
        c_expr.expr &amp;:= slice_name;
        c_expr.expr &amp;:= <span class="stri">".mem = NULL, "</span>;
        c_expr.expr &amp;:= slice_name;
        c_expr.expr &amp;:= <span class="stri">".size = 0"</span>;
      <span class="keywd">else</span>
        <span class="comment">(* Formula used: slice.mem = stri->mem,
                         stri->size &lt;= (uintType)length ?
                         slice.size = stri->size :
                         (slice.size = (memSizeType)length) *)</span>
        c_expr.expr &amp;:= slice_name;
        c_expr.expr &amp;:= <span class="stri">".mem = "</span>;
        c_expr.expr &amp;:= stri_name;
        c_expr.expr &amp;:= <span class="stri">"->mem,"</span>;
        c_expr.expr &amp;:= stri_size;
        c_expr.expr &amp;:= <span class="stri">" &lt;= (uintType)"</span>;
        c_expr.expr &amp;:= length_name;
        c_expr.expr &amp;:= <span class="stri">" ? "</span>;
        c_expr.expr &amp;:= slice_name;
        c_expr.expr &amp;:= <span class="stri">".size = "</span>;
        c_expr.expr &amp;:= stri_size;
        c_expr.expr &amp;:= <span class="stri">" : ("</span>;
        c_expr.expr &amp;:= slice_name;
        c_expr.expr &amp;:= <span class="stri">".size = (memSizeType)"</span>;
        c_expr.expr &amp;:= length_name;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_str_head (<span class="op">in</span> <span class="type">reference</span>: stri, <span class="op">in</span> <span class="type">reference</span>: length,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_stri <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">string</span>: slice_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(stri, STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_head(getValue(evaluatedParam, string), length, c_expr);
    <span class="keywd">elsif</span> getConstant(length, INTOBJECT, evaluatedParam) <span class="op">and</span>
        getValue(evaluatedParam, integer) = 1 <span class="keywd">then</span>
      process_const_str_head1(stri, c_expr);
    <span class="keywd">else</span>
      prepareAnyParamTemporarys(stri, c_stri, c_expr);
      <span class="keywd">if</span> c_stri.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        prepare_stri_result(c_expr);
        c_expr.result_expr := <span class="stri">"strHeadTemp("</span>;
        c_expr.result_expr &amp;:= c_stri.result_expr;
        c_expr.result_expr &amp;:= <span class="stri">", "</span>;
        getStdParamToResultExpr(length, c_expr);
        c_expr.result_expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">elsif</span> ccConf.ALLOW_STRITYPE_SLICES <span class="op">and</span> c_expr.demand &lt; REQUIRE_RESULT <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        incr(c_expr.temp_num);
        slice_name := <span class="stri">"slice_"</span> &amp; str(c_expr.temp_num);
        c_expr.temp_decls &amp;:= <span class="stri">"struct striStruct "</span>;
        c_expr.temp_decls &amp;:= slice_name;
        c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
        <span class="keywd">if</span> inlineFunctions <span class="keywd">then</span>
          incr(countInlinedFunctions);
          process_inline_str_head(stri, length, slice_name, c_expr);
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"strHeadSlice("</span>;
          c_expr.expr &amp;:= c_stri.expr;
          c_expr.expr &amp;:= <span class="stri">", "</span>;
          process_expr(length, c_expr);
          c_expr.expr &amp;:= <span class="stri">", &amp;"</span>;
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">", &amp;"</span>;
        c_expr.expr &amp;:= slice_name;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">else</span>
        prepare_stri_result(c_expr);
        c_expr.result_expr := <span class="stri">"strHead("</span>;
        c_expr.result_expr &amp;:= c_stri.expr;
        c_expr.result_expr &amp;:= <span class="stri">", "</span>;
        getStdParamToResultExpr(length, c_expr);
        c_expr.result_expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_HEAD, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    process_str_head(params[1], params[4], c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_idx (<span class="op">in</span> <span class="type">string</span>: stri,
    <span class="op">in</span> <span class="type">reference</span>: index, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">intRange</span>: index_range <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">integer</span>: index_value <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: index_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    incr(countOptimizations);
    <span class="keywd">if</span> getConstant(index, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      index_value := getValue(evaluatedParam, integer);
      <span class="keywd">if</span> index_value &lt; 1 <span class="op">or</span> index_value > length(stri) <span class="keywd">then</span>
        warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
        c_expr.expr &amp;:= intRaiseError(<span class="stri">"INDEX_ERROR"</span>);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= charLiteral(stri[index_value]);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      c_expr.expr &amp;:= stringLiteral(stri);
      c_expr.expr &amp;:= <span class="stri">")->mem["</span>;
      <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
        index_range := getIntRange(index);
        <span class="keywd">if</span> index_range.minValue &lt; 1 <span class="op">or</span>
            index_range.maxValue > length(stri) <span class="keywd">then</span>
          incr(countIndexChecks);
          incr(c_expr.temp_num);
          index_name := <span class="stri">"idx_"</span> &amp; str(c_expr.temp_num);
          <span class="keywd">if</span> ccConf.TWOS_COMPLEMENT_INTTYPE <span class="keywd">then</span>
            c_expr.temp_decls &amp;:= <span class="stri">"uintType "</span>;
          <span class="keywd">else</span>
            c_expr.temp_decls &amp;:= <span class="stri">"intType "</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.temp_decls &amp;:= index_name;
          c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
          c_expr.expr &amp;:= <span class="stri">"("</span>;
          c_expr.expr &amp;:= index_name;
          c_expr.expr &amp;:= <span class="stri">"="</span>;
          <span class="keywd">if</span> ccConf.TWOS_COMPLEMENT_INTTYPE <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"(uintType)("</span>;
            process_expr(index, c_expr);
            c_expr.expr &amp;:= <span class="stri">")-1, idxChk("</span>;
            c_expr.expr &amp;:= index_name;
            c_expr.expr &amp;:= <span class="stri">">="</span>;
          <span class="keywd">else</span>
            process_expr(index, c_expr);
            c_expr.expr &amp;:= <span class="stri">", idxChk("</span>;
            c_expr.expr &amp;:= index_name;
            c_expr.expr &amp;:= <span class="stri">"&lt;=0 || "</span>;
            c_expr.expr &amp;:= index_name;
            c_expr.expr &amp;:= <span class="stri">">"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= str(length(stri));
          c_expr.expr &amp;:= <span class="stri">") ? "</span>;
          c_expr.expr &amp;:= intRaiseError(<span class="stri">"INDEX_ERROR"</span>);
          c_expr.expr &amp;:= <span class="stri">" : "</span>;
          c_expr.expr &amp;:= index_name;
          <span class="keywd">if</span> ccConf.TWOS_COMPLEMENT_INTTYPE <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">")"</span>;
          <span class="keywd">else</span>
            c_expr.expr &amp;:= <span class="stri">"-1)"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          countIndexOptimizations(c_expr);
          c_expr.expr &amp;:= <span class="stri">"("</span>;
          process_expr(index, c_expr);
          c_expr.expr &amp;:= <span class="stri">")-1"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        incr(countSuppressedIndexChecks);
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        process_expr(index, c_expr);
        c_expr.expr &amp;:= <span class="stri">")-1"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">"]"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_idx (<span class="op">in</span> <span class="type">reference</span>: stri,
    <span class="op">in</span> <span class="type">integer</span>: index, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    incr(countOptimizations);
    <span class="keywd">if</span> index &lt; 1 <span class="keywd">then</span>
      warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
      c_expr.expr &amp;:= intRaiseError(<span class="stri">"INDEX_ERROR"</span>);
    <span class="keywd">elsif</span> string_index_check <span class="keywd">then</span>
      incr(countIndexChecks);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      stri_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"tmp_"</span>, stri, c_expr);
      c_expr.expr &amp;:= stri_name;
      c_expr.expr &amp;:= <span class="stri">"->mem[(idxChk("</span>;
      c_expr.expr &amp;:= stri_name;
      c_expr.expr &amp;:= <span class="stri">"->size&lt;"</span>;
      c_expr.expr &amp;:= integerLiteral(index);
      c_expr.expr &amp;:= <span class="stri">") ? "</span>;
      c_expr.expr &amp;:= intRaiseError(<span class="stri">"INDEX_ERROR"</span>);
      c_expr.expr &amp;:= <span class="stri">" : "</span>;
      c_expr.expr &amp;:= integerLiteral(pred(index));
      c_expr.expr &amp;:= <span class="stri">")])"</span>;
    <span class="keywd">else</span>
      incr(countSuppressedIndexChecks);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      getAnyParamToExpr(stri, c_expr);
      c_expr.expr &amp;:= <span class="stri">")->mem["</span>;
      c_expr.expr &amp;:= integerLiteral(pred(index));
      c_expr.expr &amp;:= <span class="stri">"]"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_IDX, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: stri_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: index_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_idx(getValue(evaluatedParam, string), params[3], c_expr);
    <span class="keywd">elsif</span> getConstant(params[3], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_idx(params[1], getValue(evaluatedParam, integer), c_expr);
    <span class="keywd">elsif</span> string_index_check <span class="keywd">then</span>
      incr(countIndexChecks);
      incr(c_expr.temp_num);
      index_name := <span class="stri">"idx_"</span> &amp; str(c_expr.temp_num);
      <span class="keywd">if</span> ccConf.TWOS_COMPLEMENT_INTTYPE <span class="keywd">then</span>
        c_expr.temp_decls &amp;:= <span class="stri">"uintType "</span>;
      <span class="keywd">else</span>
        c_expr.temp_decls &amp;:= <span class="stri">"intType "</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.temp_decls &amp;:= index_name;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      stri_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"tmp_"</span>, params[1], c_expr);
      c_expr.expr &amp;:= stri_name;
      c_expr.expr &amp;:= <span class="stri">"->mem[("</span>;
      c_expr.expr &amp;:= index_name;
      c_expr.expr &amp;:= <span class="stri">"="</span>;
      <span class="keywd">if</span> ccConf.TWOS_COMPLEMENT_INTTYPE <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"(uintType)("</span>;
        process_expr(params[3], c_expr);
        c_expr.expr &amp;:= <span class="stri">")-1, idxChk("</span>;
        c_expr.expr &amp;:= index_name;
        c_expr.expr &amp;:= <span class="stri">">="</span>;
      <span class="keywd">else</span>
        process_expr(params[3], c_expr);
        c_expr.expr &amp;:= <span class="stri">", idxChk("</span>;
        c_expr.expr &amp;:= index_name;
        c_expr.expr &amp;:= <span class="stri">"&lt;=0 || "</span>;
        c_expr.expr &amp;:= index_name;
        c_expr.expr &amp;:= <span class="stri">">"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= stri_name;
      c_expr.expr &amp;:= <span class="stri">"->size) ? "</span>;
      c_expr.expr &amp;:= intRaiseError(<span class="stri">"INDEX_ERROR"</span>);
      c_expr.expr &amp;:= <span class="stri">" : "</span>;
      c_expr.expr &amp;:= index_name;
      <span class="keywd">if</span> ccConf.TWOS_COMPLEMENT_INTTYPE <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">")])"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"-1)])"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      incr(countSuppressedIndexChecks);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">")->mem[("</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")-1]"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_IPOS, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[2], STRIOBJECT, evaluatedParam) <span class="op">and</span>
        length(getValue(evaluatedParam, string)) = 1 <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"strChIPos("</span>;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      c_expr.expr &amp;:= charLiteral(getValue(evaluatedParam, string)[1]);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strIPos("</span>;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToExpr(params[2], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_le (<span class="op">in</span> <span class="type">string</span>: stri1, <span class="op">in</span> <span class="type">reference</span>: stri2,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri2_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> stri1 = <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"1"</span>;
    <span class="keywd">elsif</span> length(stri1) = 1 <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      stri2_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"stri2_"</span>, stri2, c_expr);
      c_expr.expr &amp;:= stri2_name;
      c_expr.expr &amp;:= <span class="stri">"->size>=1&amp;&amp;"</span>;
      c_expr.expr &amp;:= stri2_name;
      c_expr.expr &amp;:= <span class="stri">"->mem[0]>=(strElemType)("</span>;
      c_expr.expr &amp;:= c_literal(stri1[1]);
      c_expr.expr &amp;:= <span class="stri">") /* "</span>;
      c_expr.expr &amp;:= literal(stri1);
      c_expr.expr &amp;:= <span class="stri">" */)"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strLe("</span>;
      c_expr.expr &amp;:= stringLiteral(stri1);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToExpr(stri2, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_LE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_le(getValue(evaluatedParam, string), params[3], c_expr);
    <span class="keywd">elsif</span> getConstant(params[3], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_ge(getValue(evaluatedParam, string), params[1], c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strLe("</span>;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToExpr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_LIT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_stri_result(c_expr);
    c_expr.result_expr := <span class="stri">"strLit("</span>;
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: sumLengthOfConstants (<span class="keywd">inout</span> <span class="type">array</span> <span class="type">reference</span>: concatNParamList) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: lengthOfConstants <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: paramValue <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> index &lt;= length(concatNParamList) <span class="keywd">do</span>
      <span class="keywd">if</span> getConstant(concatNParamList[index], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
        lengthOfConstants +:= length(getValue(evaluatedParam, string));
        ignore(remove(concatNParamList, index));
      <span class="keywd">else</span>
        incr(index);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: optimize_str_lng (<span class="op">in</span> <span class="type">reference</span>: lengthParam,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">proc</span>: optimize_str_lng (STR_CAT, <span class="op">in</span> <span class="type">ref_list</span>: params,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">reference</span>: concatNParamList <span class="keywd">is</span> 0 <span class="op">times</span> NIL;
    <span class="keywd">var</span> <span class="type">integer</span>: lengthOfConstants <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reference</span>: striObj <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    concatNParamList := getConcatNParamList(params);
    lengthOfConstants := sumLengthOfConstants(concatNParamList);
    <span class="keywd">for</span> striObj <span class="keywd">range</span> concatNParamList <span class="keywd">do</span>
      optimize_str_lng(striObj, c_expr);
      c_expr.expr &amp;:= <span class="stri">" + "</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    c_expr.expr &amp;:= integerLiteral(lengthOfConstants);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: optimize_str_lng (<span class="op">in</span> <span class="type">reference</span>: lengthParam,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(lengthParam, STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      incr(countOptimizations);
      stri := getValue(evaluatedParam, string);
      c_expr.expr &amp;:= integerLiteral(length(stri));
      c_expr.expr &amp;:= <span class="stri">" /* length("</span>;
      c_expr.expr &amp;:= replace(literal(stri), <span class="stri">"*/"</span>, <span class="stri">"*\\/"</span>);
      c_expr.expr &amp;:= <span class="stri">") */"</span>;
    <span class="keywd">elsif</span> isActionExpression(lengthParam, <span class="stri">"STR_CAT"</span>) <span class="keywd">then</span>
      params := getValue(lengthParam, ref_list)[2 ..];
      optimize_str_lng(STR_CAT, params, c_expr);
    <span class="keywd">elsif</span> isActionExpression(lengthParam, <span class="stri">"STR_SUBSTR_FIXLEN"</span>) <span class="keywd">then</span>
      incr(countOptimizations);
      <span class="keywd">if</span> getConstant(getActionParameter(lengthParam, 5), INTOBJECT, evaluatedParam) <span class="keywd">then</span>
        c_expr.expr &amp;:= integerLiteral(getValue(evaluatedParam, integer));
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        process_expr(getActionParameter(lengthParam, 5), c_expr);
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">" /* length of fixlLen substring */"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"(intType)(("</span>;
      getAnyParamToExpr(lengthParam, c_expr);
      c_expr.expr &amp;:= <span class="stri">")->size)"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_LNG, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> evaluate_const_expr >= 1 <span class="keywd">then</span>
      optimize_str_lng(params[1], c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"(intType)(("</span>;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">")->size)"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Produces code to return a string converted to lower case.
 *  If the parameter is a temporary value the conversion is done
 *  with strLowTemp. The strLowTemp function returns the parameter as
 *  result of the conversion. That way the temporary of the parameter
 *  must not be freed.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: process (STR_LOW, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param1 <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    prepare_stri_result(c_expr);
    prepareAnyParamTemporarys(params[1], c_param1, c_expr);
    <span class="keywd">if</span> c_param1.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.result_expr := <span class="stri">"strLowTemp("</span>;
      c_expr.result_expr &amp;:= c_param1.result_expr;
    <span class="keywd">else</span>
      c_expr.result_expr := <span class="stri">"strLow("</span>;
      c_expr.result_expr &amp;:= c_param1.expr;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Produces code for the lpad operator.
 *  If the first parameter is a temporary value the operation
 *  is done with strLpadTemp. The strLpadTemp function returns
 *  the first parameter as result of the operation. That way the
 *  temporary of the first parameter must not be freed.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: process (STR_LPAD, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param1 <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    prepare_stri_result(c_expr);
    prepareAnyParamTemporarys(params[1], c_param1, c_expr);
    <span class="keywd">if</span> c_param1.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.result_expr := <span class="stri">"strLpadTemp("</span>;
      c_expr.result_expr &amp;:= c_param1.result_expr;
    <span class="keywd">else</span>
      c_expr.result_expr := <span class="stri">"strLpad("</span>;
      c_expr.result_expr &amp;:= c_param1.expr;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.result_expr &amp;:= <span class="stri">", "</span>;
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Produces code for the lpad0 operator.
 *  If the first parameter is a temporary value the operation
 *  is done with strLpad0Temp. The strLpad0Temp function returns
 *  the first parameter as result of the operation. That way the
 *  temporary of the first parameter must not be freed.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: process (STR_LPAD0, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param1 <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    prepare_stri_result(c_expr);
    prepareAnyParamTemporarys(params[1], c_param1, c_expr);
    <span class="keywd">if</span> c_param1.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.result_expr := <span class="stri">"strLpad0Temp("</span>;
      c_expr.result_expr &amp;:= c_param1.result_expr;
    <span class="keywd">else</span>
      c_expr.result_expr := <span class="stri">"strLpad0("</span>;
      c_expr.result_expr &amp;:= c_param1.expr;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.result_expr &amp;:= <span class="stri">", "</span>;
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_lt (<span class="op">in</span> <span class="type">string</span>: stri1, <span class="op">in</span> <span class="type">reference</span>: stri2,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri2_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> stri1 = <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      getAnyParamToExpr(stri2, c_expr);
      c_expr.expr &amp;:= <span class="stri">")->size!=0"</span>;
    <span class="keywd">elsif</span> length(stri1) = 1 <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      stri2_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"stri2_"</span>, stri2, c_expr);
      c_expr.expr &amp;:= stri2_name;
      c_expr.expr &amp;:= <span class="stri">"->size>1&amp;&amp;"</span>;
      c_expr.expr &amp;:= stri2_name;
      c_expr.expr &amp;:= <span class="stri">"->mem[0]>=(strElemType)("</span>;
      c_expr.expr &amp;:= c_literal(stri1[1]);
      c_expr.expr &amp;:= <span class="stri">") /* "</span>;
      c_expr.expr &amp;:= literal(stri1);
      c_expr.expr &amp;:= <span class="stri">" */)||"</span>;
      c_expr.expr &amp;:= stri2_name;
      c_expr.expr &amp;:= <span class="stri">"->size==1&amp;&amp;"</span>;
      c_expr.expr &amp;:= stri2_name;
      c_expr.expr &amp;:= <span class="stri">"->mem[0]>(strElemType)("</span>;
      c_expr.expr &amp;:= c_literal(stri1[1]);
      c_expr.expr &amp;:= <span class="stri">") /* "</span>;
      c_expr.expr &amp;:= literal(stri1);
      c_expr.expr &amp;:= <span class="stri">" */"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strLt("</span>;
      c_expr.expr &amp;:= stringLiteral(stri1);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToExpr(stri2, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_LT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_lt(getValue(evaluatedParam, string), params[3], c_expr);
    <span class="keywd">elsif</span> getConstant(params[3], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_gt(getValue(evaluatedParam, string), params[1], c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strLt("</span>;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToExpr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_LTRIM, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_stri_result(c_expr);
    c_expr.result_expr := <span class="stri">"strLtrim("</span>;
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_mult (<span class="op">in</span> <span class="type">string</span>: stri, <span class="op">in</span> <span class="type">reference</span>: factor,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> stri = <span class="stri">""</span> <span class="keywd">then</span>
      incr(countOptimizations);
      <span class="keywd">if</span> function_range_check <span class="keywd">then</span>
        incr(countRangeChecks);
        c_expr.expr &amp;:= <span class="stri">"(rngChk(("</span>;
        process_expr(factor, c_expr);
        c_expr.expr &amp;:= <span class="stri">")&lt;0)?"</span>;
        c_expr.expr &amp;:= strRaiseError(<span class="stri">"RANGE_ERROR"</span>);
        c_expr.expr &amp;:= <span class="stri">":"</span>;
        c_expr.expr &amp;:= stringLiteral(<span class="stri">""</span>);
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">else</span>
        incr(countNoRangeChecks);
        c_expr.expr &amp;:= stringLiteral(<span class="stri">""</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      prepare_stri_result(c_expr);
      <span class="keywd">if</span> length(stri) = 1 <span class="keywd">then</span>
        incr(countOptimizations);
        ch := stri[1];
        <span class="keywd">if</span> ch = <span class="stri">'\0;'</span> <span class="keywd">then</span>
          c_expr.result_expr := <span class="stri">"strZero("</span>;
        <span class="keywd">else</span>
          c_expr.result_expr := <span class="stri">"strChMult("</span>;
          c_expr.result_expr &amp;:= charLiteral(ch);
          c_expr.result_expr &amp;:= <span class="stri">", "</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        c_expr.result_expr := <span class="stri">"strMult("</span>;
        c_expr.result_expr &amp;:= stringLiteral(stri);
        c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      getStdParamToResultExpr(factor, c_expr);
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_mult (<span class="op">in</span> <span class="type">reference</span>: stri, <span class="op">in</span> <span class="type">integer</span>: factor,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_stri <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> factor &lt; 0 <span class="keywd">then</span>
      incr(countOptimizations);
      warning(DOES_RAISE, <span class="stri">"RANGE_ERROR"</span>, c_expr);
      c_expr.expr &amp;:= strRaiseError(<span class="stri">"RANGE_ERROR"</span>);
    <span class="keywd">elsif</span> factor = 0 <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= stringLiteral(<span class="stri">""</span>);
    <span class="keywd">elsif</span> factor = 1 <span class="keywd">then</span>
      incr(countOptimizations);
      process_expr(stri, c_expr);
    <span class="keywd">else</span>
      prepare_stri_result(c_expr);
      c_expr.result_expr := <span class="stri">"strMult("</span>;
      getAnyParamToResultExpr(stri, c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      c_expr.result_expr &amp;:= integerLiteral(factor);
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_MULT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_mult(getValue(evaluatedParam, string), params[3], c_expr);
    <span class="keywd">elsif</span> getConstant(params[3], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_mult(params[1], getValue(evaluatedParam, integer), c_expr);
    <span class="keywd">elsif</span> isActionExpression(params[1], <span class="stri">"CHR_STR"</span>) <span class="keywd">then</span>
      incr(countOptimizations);
      prepare_stri_result(c_expr);
      c_expr.result_expr := <span class="stri">"strChMult("</span>;
      getAnyParamToResultExpr(getActionParameter(params[1], 1), c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getStdParamToResultExpr(params[3], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      prepare_stri_result(c_expr);
      c_expr.result_expr := <span class="stri">"strMult("</span>;
      getAnyParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getStdParamToResultExpr(params[3], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_ne (<span class="op">in</span> <span class="type">reference</span>: param1, <span class="op">in</span> <span class="type">string</span>: stri_b,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: stri_a_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    incr(countOptimizations);
    <span class="keywd">if</span> getConstant(param1, STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"/* "</span>;
      c_expr.expr &amp;:= replace(literal(getValue(evaluatedParam, string)), <span class="stri">"*/"</span>, <span class="stri">"*\\/"</span>);
      c_expr.expr &amp;:= <span class="stri">" != "</span>;
      c_expr.expr &amp;:= replace(literal(stri_b), <span class="stri">"*/"</span>, <span class="stri">"*\\/"</span>);
      c_expr.expr &amp;:= <span class="stri">" */ "</span>;
      <span class="keywd">if</span> getValue(evaluatedParam, string) &lt;> stri_b <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"1"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"0"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> stri_b = <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"(("</span>;
      getAnyParamToExpr(param1, c_expr);
      c_expr.expr &amp;:= <span class="stri">")->size!=0 /* \"\" */)"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      stri_a_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"tmp_"</span>, param1, c_expr);
      <span class="keywd">if</span> length(stri_b) = 1 <span class="keywd">then</span>
        <span class="comment">(* Formula used: (a->size!=1||a->mem[0]!=b->mem[0]) *)</span>
        c_expr.expr &amp;:= stri_a_name;
        c_expr.expr &amp;:= <span class="stri">"->size!=1||"</span>;
        c_expr.expr &amp;:= stri_a_name;
        c_expr.expr &amp;:= <span class="stri">"->mem[0]!=(strElemType)("</span>;
        c_expr.expr &amp;:= c_literal(stri_b[1]);
        c_expr.expr &amp;:= <span class="stri">") /* "</span>;
        c_expr.expr &amp;:= literal(stri_b);
        c_expr.expr &amp;:= <span class="stri">" */)"</span>;
      <span class="keywd">else</span>
        <span class="comment">(* Formula used: (a->size!=b->size||memcmp(a->mem,b->mem,
                         b->size*sizeof(strElemType))!=0) *)</span>
        c_expr.expr &amp;:= stri_a_name;
        c_expr.expr &amp;:= <span class="stri">"->size!="</span>;
        c_expr.expr &amp;:= str(length(stri_b));
        c_expr.expr &amp;:= <span class="stri">"||memcmp("</span>;
        c_expr.expr &amp;:= stri_a_name;
        c_expr.expr &amp;:= <span class="stri">"->mem,("</span>;
        c_expr.expr &amp;:= stringLiteral(stri_b);
        c_expr.expr &amp;:= <span class="stri">")->mem,"</span>;
        c_expr.expr &amp;:= str(length(stri_b));
        c_expr.expr &amp;:= <span class="stri">"*sizeof(strElemType))!=0)"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_NE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: stri_a_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri_b_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[3], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_ne(params[1], getValue(evaluatedParam, string), c_expr);
    <span class="keywd">elsif</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_ne(params[3], getValue(evaluatedParam, string), c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      stri_a_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"tmp_a_"</span>, params[1], c_expr);
      stri_b_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"tmp_b_"</span>, params[3], c_expr);
      <span class="comment">(* Formula used: (a->size!=b->size||memcmp(a->mem,b->mem,
                       a->size*sizeof(strElemType))!=0) *)</span>
      c_expr.expr &amp;:= stri_a_name;
      c_expr.expr &amp;:= <span class="stri">"->size!="</span>;
      c_expr.expr &amp;:= stri_b_name;
      c_expr.expr &amp;:= <span class="stri">"->size||memcmp("</span>;
      c_expr.expr &amp;:= stri_a_name;
      c_expr.expr &amp;:= <span class="stri">"->mem,"</span>;
      c_expr.expr &amp;:= stri_b_name;
      c_expr.expr &amp;:= <span class="stri">"->mem,"</span>;
      c_expr.expr &amp;:= stri_a_name;
      c_expr.expr &amp;:= <span class="stri">"->size*sizeof(strElemType))!=0)"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_pos (<span class="op">in</span> <span class="type">reference</span>: mainStri, <span class="op">in</span> <span class="type">string</span>: searched,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(mainStri, STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"/* pos("</span>;
      c_expr.expr &amp;:= replace(literal(getValue(evaluatedParam, string)), <span class="stri">"*/"</span>, <span class="stri">"*\\/"</span>);
      c_expr.expr &amp;:= <span class="stri">","</span>;
      c_expr.expr &amp;:= replace(literal(searched), <span class="stri">"*/"</span>, <span class="stri">"*\\/"</span>);
      c_expr.expr &amp;:= <span class="stri">") */ "</span>;
      c_expr.expr &amp;:= integerLiteral(pos(getValue(evaluatedParam, string), searched));
    <span class="keywd">elsif</span> length(searched) = 0 <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"/* pos(*, \"\") */ "</span>;
      c_expr.expr &amp;:= integerLiteral(0);
    <span class="keywd">elsif</span> length(searched) = 1 <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"strChPos("</span>;
      getAnyParamToExpr(mainStri, c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      c_expr.expr &amp;:= charLiteral(searched[1]);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strPos("</span>;
      getAnyParamToExpr(mainStri, c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      c_expr.expr &amp;:= stringLiteral(searched);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_POS, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[2], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_pos(params[1], getValue(evaluatedParam, string), c_expr);
    <span class="keywd">elsif</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="op">and</span>
        length(getValue(evaluatedParam, string)) = 0 <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"/* pos(\"\", *) */ "</span>;
      c_expr.expr &amp;:= integerLiteral(0);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strPos("</span>;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToExpr(params[2], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_poscpy (<span class="op">in</span> <span class="type">reference</span>: destStri,
    <span class="op">in</span> <span class="type">integer</span>: position, <span class="op">in</span> <span class="type">string</span>: aStri, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_destStri <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    incr(countOptimizations);
    <span class="keywd">if</span> position &lt; 1 <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"/* 'string @:= [n] string' with n &lt; 1 */\n"</span>;
      warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
      c_expr.expr &amp;:= raiseError(<span class="stri">"INDEX_ERROR"</span>);
    <span class="keywd">else</span>
      incr(countOptimizations);
      process_expr(destStri, c_destStri);
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      <span class="keywd">if</span> c_destStri.temp_num &lt;> 0 <span class="keywd">then</span>
        appendWithDiagnostic(c_destStri.temp_decls, c_expr);
        appendWithDiagnostic(c_destStri.temp_assigns, c_expr);
       <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
        incr(countIndexChecks);
        c_expr.expr &amp;:= <span class="stri">"striType destStri="</span>;
        c_expr.expr &amp;:= c_destStri.expr;
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"if (idxChk("</span>;
        c_expr.expr &amp;:= <span class="stri">"destStri->size&lt;"</span>;
        c_expr.expr &amp;:= integerLiteral(length(aStri));
        c_expr.expr &amp;:= <span class="stri">" || (uintType)"</span>;
        c_expr.expr &amp;:= integerLiteral(pred(position));
        c_expr.expr &amp;:= <span class="stri">">destStri->size-"</span>;
        c_expr.expr &amp;:= integerLiteral(length(aStri));
        c_expr.expr &amp;:= <span class="stri">")) {\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"  "</span>;
        c_expr.expr &amp;:= raiseError(<span class="stri">"INDEX_ERROR"</span>);
        c_expr.expr &amp;:= <span class="stri">"} else {\n"</span>;
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"  memcpy(&amp;destStri->mem["</span>;
        c_expr.expr &amp;:= integerLiteral(pred(position));
        c_expr.expr &amp;:= <span class="stri">"], ("</span>;
        c_expr.expr &amp;:= stringLiteral(aStri);
        c_expr.expr &amp;:= <span class="stri">")->mem, "</span>;
        c_expr.expr &amp;:= integerLiteral(length(aStri));
        c_expr.expr &amp;:= <span class="stri">"*sizeof(strElemType));\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
      <span class="keywd">else</span>
        incr(countSuppressedIndexChecks);
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"memcpy(&amp;("</span>;
        c_expr.expr &amp;:= c_destStri.expr;
        c_expr.expr &amp;:= <span class="stri">")->mem["</span>;
        c_expr.expr &amp;:= integerLiteral(pred(position));
        c_expr.expr &amp;:= <span class="stri">"], ("</span>;
        c_expr.expr &amp;:= stringLiteral(aStri);
        c_expr.expr &amp;:= <span class="stri">")->mem, "</span>;
        c_expr.expr &amp;:= integerLiteral(length(aStri));
        c_expr.expr &amp;:= <span class="stri">"*sizeof(strElemType));\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> c_destStri.temp_num &lt;> 0 <span class="keywd">then</span>
        appendWithDiagnostic(c_destStri.temp_frees, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_poscpy (<span class="op">in</span> <span class="type">reference</span>: destStri,
    <span class="op">in</span> <span class="type">integer</span>: position, <span class="op">in</span> <span class="type">reference</span>: aStri, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_destStri <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_aStri <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    incr(countOptimizations);
    <span class="keywd">if</span> position &lt; 1 <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"/* 'string @:= [n] string' with n &lt; 1 */\n"</span>;
      warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
      c_expr.expr &amp;:= raiseError(<span class="stri">"INDEX_ERROR"</span>);
    <span class="keywd">else</span>
      process_expr(destStri, c_destStri);
      c_aStri.temp_num := c_destStri.temp_num;
      getAnyParamToExpr(aStri, c_aStri);
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      <span class="keywd">if</span> c_aStri.temp_num &lt;> 0 <span class="keywd">then</span>
        appendWithDiagnostic(c_destStri.temp_decls, c_expr);
        appendWithDiagnostic(c_aStri.temp_decls, c_expr);
        appendWithDiagnostic(c_destStri.temp_assigns, c_expr);
        appendWithDiagnostic(c_aStri.temp_assigns, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
        incr(countIndexChecks);
        c_expr.expr &amp;:= <span class="stri">"striType destStri="</span>;
        c_expr.expr &amp;:= c_destStri.expr;
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"const_striType aStri="</span>;
        c_expr.expr &amp;:= c_aStri.expr;
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"if (idxChk(destStri->size&lt;aStri->size || (uintType)"</span>;
        c_expr.expr &amp;:= integerLiteral(pred(position));
        c_expr.expr &amp;:= <span class="stri">">destStri->size-aStri->size)) {\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"  "</span>;
        c_expr.expr &amp;:= raiseError(<span class="stri">"INDEX_ERROR"</span>);
        c_expr.expr &amp;:= <span class="stri">"} else {\n"</span>;
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"  memmove(&amp;destStri->mem["</span>;
        c_expr.expr &amp;:= integerLiteral(pred(position));
        c_expr.expr &amp;:= <span class="stri">"], aStri->mem, aStri->size*sizeof(strElemType));\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
      <span class="keywd">else</span>
        incr(countSuppressedIndexChecks);
        c_expr.expr &amp;:= <span class="stri">"const_striType aStri="</span>;
        c_expr.expr &amp;:= c_aStri.expr;
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"memmove(&amp;("</span>;
        c_expr.expr &amp;:= c_destStri.expr;
        c_expr.expr &amp;:= <span class="stri">")->mem["</span>;
        c_expr.expr &amp;:= integerLiteral(pred(position));
        c_expr.expr &amp;:= <span class="stri">"], aStri->mem, aStri->size*sizeof(strElemType));\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> c_aStri.temp_num &lt;> 0 <span class="keywd">then</span>
        appendWithDiagnostic(c_destStri.temp_frees, c_expr);
        appendWithDiagnostic(c_aStri.temp_frees, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_poscpy (<span class="op">in</span> <span class="type">reference</span>: destStri,
    <span class="op">in</span> <span class="type">reference</span>: position, <span class="op">in</span> <span class="type">string</span>: aStri, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_destStri <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_position <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(position, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_poscpy(destStri, getValue(evaluatedParam, integer), aStri, c_expr);
    <span class="keywd">else</span>
      incr(countOptimizations);
      process_expr(destStri, c_destStri);
      c_position.temp_num := c_destStri.temp_num;
      process_expr(position, c_position);
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      <span class="keywd">if</span> c_position.temp_num &lt;> 0 <span class="keywd">then</span>
        appendWithDiagnostic(c_destStri.temp_decls, c_expr);
        appendWithDiagnostic(c_position.temp_decls, c_expr);
        appendWithDiagnostic(c_destStri.temp_assigns, c_expr);
        appendWithDiagnostic(c_position.temp_assigns, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
        incr(countIndexChecks);
        c_expr.expr &amp;:= <span class="stri">"striType destStri="</span>;
        c_expr.expr &amp;:= c_destStri.expr;
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"intType position="</span>;
        c_expr.expr &amp;:= c_position.expr;
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"if (idxChk("</span>;
        c_expr.expr &amp;:= <span class="stri">"position&lt;=0 || "</span>;
        c_expr.expr &amp;:= <span class="stri">"destStri->size&lt;"</span>;
        c_expr.expr &amp;:= integerLiteral(length(aStri));
        c_expr.expr &amp;:= <span class="stri">" || (uintType)(position-1)>destStri->size-"</span>;
        c_expr.expr &amp;:= integerLiteral(length(aStri));
        c_expr.expr &amp;:= <span class="stri">")) {\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"  "</span>;
        c_expr.expr &amp;:= raiseError(<span class="stri">"INDEX_ERROR"</span>);
        c_expr.expr &amp;:= <span class="stri">"} else {\n"</span>;
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"  memcpy(&amp;destStri->mem[position-1], ("</span>;
        c_expr.expr &amp;:= stringLiteral(aStri);
        c_expr.expr &amp;:= <span class="stri">")->mem, "</span>;
        c_expr.expr &amp;:= integerLiteral(length(aStri));
        c_expr.expr &amp;:= <span class="stri">"*sizeof(strElemType));\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
      <span class="keywd">else</span>
        incr(countSuppressedIndexChecks);
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"memcpy(&amp;("</span>;
        c_expr.expr &amp;:= c_destStri.expr;
        c_expr.expr &amp;:= <span class="stri">")->mem[("</span>;
        c_expr.expr &amp;:= c_position.expr;
        c_expr.expr &amp;:= <span class="stri">")-1], ("</span>;
        c_expr.expr &amp;:= stringLiteral(aStri);
        c_expr.expr &amp;:= <span class="stri">")->mem, "</span>;
        c_expr.expr &amp;:= integerLiteral(length(aStri));
        c_expr.expr &amp;:= <span class="stri">"*sizeof(strElemType));\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> c_position.temp_num &lt;> 0 <span class="keywd">then</span>
        appendWithDiagnostic(c_destStri.temp_frees, c_expr);
        appendWithDiagnostic(c_position.temp_frees, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_POSCPY, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: destStri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_destStri <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_position <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_aStri <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[6], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      destStri := getValue(evaluatedParam, string);
      <span class="keywd">if</span> length(destStri) = 1 <span class="keywd">then</span>
        process_const_str_elemcpy(params[1], params[4], destStri[1], c_expr);
      <span class="keywd">else</span>
        process_const_str_poscpy(params[1], params[4], destStri, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> getConstant(params[4], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_poscpy(params[1], getValue(evaluatedParam, integer), params[6], c_expr);
    <span class="keywd">else</span>
      process_expr(params[1], c_destStri);
      c_position.temp_num := c_destStri.temp_num;
      process_expr(params[4], c_position);
      c_aStri.temp_num := c_position.temp_num;
      getAnyParamToExpr(params[6], c_aStri);
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      <span class="keywd">if</span> c_aStri.temp_num &lt;> 0 <span class="keywd">then</span>
        appendWithDiagnostic(c_destStri.temp_decls, c_expr);
        appendWithDiagnostic(c_position.temp_decls, c_expr);
        appendWithDiagnostic(c_aStri.temp_decls, c_expr);
        appendWithDiagnostic(c_destStri.temp_assigns, c_expr);
        appendWithDiagnostic(c_position.temp_assigns, c_expr);
        appendWithDiagnostic(c_aStri.temp_assigns, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
        incr(countIndexChecks);
        c_expr.expr &amp;:= <span class="stri">"striType destStri="</span>;
        c_expr.expr &amp;:= c_destStri.expr;
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"const_striType aStri="</span>;
        c_expr.expr &amp;:= c_aStri.expr;
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"intType position="</span>;
        c_expr.expr &amp;:= c_position.expr;
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"if (idxChk("</span>;
        c_expr.expr &amp;:= <span class="stri">"position&lt;=0 || "</span>;
        c_expr.expr &amp;:= <span class="stri">"destStri->size&lt;aStri->size || (uintType)(position-1)>destStri->size-aStri->size)) {\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"  "</span>;
        c_expr.expr &amp;:= raiseError(<span class="stri">"INDEX_ERROR"</span>);
        c_expr.expr &amp;:= <span class="stri">"} else {\n"</span>;
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"  memmove(&amp;destStri->mem[position-1], aStri->mem, aStri->size*sizeof(strElemType));\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
      <span class="keywd">else</span>
        incr(countSuppressedIndexChecks);
        c_expr.expr &amp;:= <span class="stri">"const_striType aStri="</span>;
        c_expr.expr &amp;:= c_aStri.expr;
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"memmove(&amp;("</span>;
        c_expr.expr &amp;:= c_destStri.expr;
        c_expr.expr &amp;:= <span class="stri">")->mem[("</span>;
        c_expr.expr &amp;:= c_position.expr;
        c_expr.expr &amp;:= <span class="stri">")-1], aStri->mem, aStri->size*sizeof(strElemType));\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> c_aStri.temp_num &lt;> 0 <span class="keywd">then</span>
        appendWithDiagnostic(c_destStri.temp_frees, c_expr);
        appendWithDiagnostic(c_position.temp_frees, c_expr);
        appendWithDiagnostic(c_aStri.temp_frees, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_inline_str_push (<span class="op">in</span> <span class="type">ref_list</span>: params,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">string</span>: stri_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: char_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isNormalVariable(params[1]) <span class="keywd">then</span>
      stri_name := normalVariable(params[1], statement);
    <span class="keywd">else</span>
      incr(statement.temp_num);
      stri_name := <span class="stri">"tmp_"</span> &amp; str(statement.temp_num);
      statement.temp_decls &amp;:= <span class="stri">"striType *"</span>;
      statement.temp_decls &amp;:= stri_name;
      statement.temp_decls &amp;:= <span class="stri">";\n"</span>;
      statement.expr &amp;:= stri_name;
      statement.expr &amp;:= <span class="stri">"=&amp;("</span>;
      process_expr(params[1], statement);
      statement.expr &amp;:= <span class="stri">");\n"</span>;
      stri_name := <span class="stri">"*"</span> &amp; stri_name;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> isNormalVariable(params[3]) <span class="keywd">then</span>
      char_name := normalVariable(params[3], statement);
    <span class="keywd">else</span>
      incr(statement.temp_num);
      char_name := <span class="stri">"tmp_"</span> &amp; str(statement.temp_num);
      statement.temp_decls &amp;:= <span class="stri">"charType "</span>;
      statement.temp_decls &amp;:= char_name;
      statement.temp_decls &amp;:= <span class="stri">";\n"</span>;
      statement.expr &amp;:= char_name;
      statement.expr &amp;:= <span class="stri">"="</span>;
      process_expr(params[3], statement);
      statement.expr &amp;:= <span class="stri">";\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    statement.expr &amp;:= <span class="stri">"if (("</span>;
    statement.expr &amp;:= stri_name;
    statement.expr &amp;:= <span class="stri">")->size == ("</span>;
    statement.expr &amp;:= stri_name;
    statement.expr &amp;:= <span class="stri">")->capacity) {\n"</span>;
    statement.expr &amp;:= <span class="stri">"strPush(&amp;("</span>;
    statement.expr &amp;:= stri_name;
    statement.expr &amp;:= <span class="stri">"), "</span>;
    statement.expr &amp;:= char_name;
    statement.expr &amp;:= <span class="stri">");\n"</span>;
    statement.expr &amp;:= <span class="stri">"} else {\n"</span>;
    statement.expr &amp;:= <span class="stri">"("</span>;
    statement.expr &amp;:= stri_name;
    statement.expr &amp;:= <span class="stri">")->mem[("</span>;
    statement.expr &amp;:= stri_name;
    statement.expr &amp;:= <span class="stri">")->size]="</span>;
    statement.expr &amp;:= char_name;
    statement.expr &amp;:= <span class="stri">";\n"</span>;
    statement.expr &amp;:= <span class="stri">"("</span>;
    statement.expr &amp;:= stri_name;
    statement.expr &amp;:= <span class="stri">")->size++;\n"</span>;
    statement.expr &amp;:= <span class="stri">"}\n"</span>;
    doLocalDeclsOfStatement(statement, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_PUSH, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[3], CHAROBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_push(params[1], getValue(evaluatedParam, char), c_expr);
    <span class="keywd">elsif</span> inlineFunctions <span class="op">and</span> ccConf.WITH_STRI_CAPACITY <span class="keywd">then</span>
      incr(countInlinedFunctions);
      process_inline_str_push(params, c_expr);
    <span class="keywd">else</span>
      statement.expr := <span class="stri">"strPush(&amp;("</span>;
      process_expr(params[1], statement);
      statement.expr &amp;:= <span class="stri">"), "</span>;
      process_expr(params[3], statement);
      statement.expr &amp;:= <span class="stri">");\n"</span>;
      doLocalDeclsOfStatement(statement, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_inline_str_range (<span class="op">in</span> <span class="type">reference</span>: stri,
    <span class="op">in</span> <span class="type">reference</span>: start, <span class="op">in</span> <span class="type">reference</span>: stop, <span class="op">in</span> <span class="type">string</span>: slice_name,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: stri_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri_value <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: stri_is_variable <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">string</span>: stri_size <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: start_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: start_value <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: start_is_variable <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">intRange</span>: start_range <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">string</span>: stop_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: stop_value <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: stop_is_variable <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">intRange</span>: stop_range <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">boolean</span>: raisesIndexError <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(stri, STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      stri_is_variable := FALSE;
      stri_value := getValue(evaluatedParam, string);
      stri_name := <span class="stri">"("</span> &amp; stringLiteral(stri_value) &amp; <span class="stri">")"</span>;
      stri_size := memSizeLiteral(length(stri_value));
    <span class="keywd">else</span>
      stri_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"stri_"</span>, stri, c_expr);
      stri_size := stri_name &amp; <span class="stri">"->size"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    start_range := getIntRange(start);
    stop_range := getIntRange(stop);
    <span class="keywd">if</span> getConstant(start, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      start_is_variable := FALSE;
      start_value := getValue(evaluatedParam, integer);
      <span class="keywd">if</span> start_value &lt; 1 <span class="keywd">then</span>
        warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
        c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
        raisesIndexError := TRUE;
      <span class="keywd">else</span>
        start_name := integerLiteral(start_value);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      start_name := getTempVariable(<span class="stri">"intType"</span>, <span class="stri">"start_"</span>, start, c_expr);
      <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
        <span class="keywd">if</span> start_range.minValue &lt; 1 <span class="keywd">then</span>
          incr(countIndexChecks);
          c_expr.expr &amp;:= <span class="stri">"idxChk("</span>;
          c_expr.expr &amp;:= start_name;
          c_expr.expr &amp;:= <span class="stri">"&lt;1)?"</span>;
          c_expr.expr &amp;:= intRaiseError(<span class="stri">"INDEX_ERROR"</span>);
          c_expr.expr &amp;:= <span class="stri">":0, "</span>;
        <span class="keywd">else</span>
          countIndexOptimizations(c_expr);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        incr(countSuppressedIndexChecks);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="op">not</span> raisesIndexError <span class="keywd">then</span>
      <span class="keywd">if</span> getConstant(stop, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
        stop_is_variable := FALSE;
        stop_value := getValue(evaluatedParam, integer);
        <span class="keywd">if</span> stop_value &lt; 0 <span class="op">or</span>
            <span class="op">not</span> start_is_variable <span class="op">and</span> stop_value &lt; pred(start_value) <span class="keywd">then</span>
          warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
          c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
          raisesIndexError := TRUE;
        <span class="keywd">else</span>
          stop_name := integerLiteral(stop_value);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        stop_name := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"stop_"</span>, stop, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> <span class="op">not</span> raisesIndexError <span class="keywd">then</span>
        <span class="keywd">if</span> <span class="op">not</span> stri_is_variable <span class="op">and</span> <span class="op">not</span> start_is_variable <span class="op">and</span>
            length(stri_value) &lt; start_value <span class="keywd">then</span>
          <span class="keywd">if</span> stop_is_variable <span class="keywd">then</span>
            <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
              <span class="keywd">if</span> stop_range.minValue &lt; start_range.maxValue <span class="keywd">then</span>
                incr(countIndexChecks);
                c_expr.expr &amp;:= <span class="stri">"idxChk("</span>;
                c_expr.expr &amp;:= stop_name;
                c_expr.expr &amp;:= <span class="stri">"&lt;"</span>;
                <span class="keywd">if</span> start_is_variable <span class="keywd">then</span>
                  c_expr.expr &amp;:= start_name;
                  c_expr.expr &amp;:= <span class="stri">"-1"</span>;
                <span class="keywd">else</span>
                  c_expr.expr &amp;:= integerLiteral(pred(start_value));
                <span class="keywd">end</span> <span class="keywd">if</span>;
                c_expr.expr &amp;:= <span class="stri">")?"</span>;
                c_expr.expr &amp;:= intRaiseError(<span class="stri">"INDEX_ERROR"</span>);
                c_expr.expr &amp;:= <span class="stri">" : "</span>;
              <span class="keywd">else</span>
                countIndexOptimizations(c_expr);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">else</span>
              incr(countSuppressedIndexChecks);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">"("</span>;
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".mem = NULL,"</span>;
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".size = 0)"</span>;
        <span class="keywd">else</span>
          <span class="comment">(* Formula used: stop>=start &amp;&amp; (uintType)start &lt;= stri->size ?
                           (slice.mem = &amp;stri->mem[start-1],
                           (uintType)stop > stri->size ?
                           slice.size = stri->size-(memSizeType)start+1 :
                           (slice.size = (memSizeType)stop-(memSizeType)start+1))
                           : idxChk(stop&lt;start-1)?INDEX_ERROR
                           : (slice.mem = NULL,slice.size = 0) *)</span>
          <span class="keywd">if</span> ccConf.WITH_STRI_CAPACITY <span class="op">and</span> FALSE <span class="keywd">then</span>
            c_expr.expr &amp;:= slice_name;
            c_expr.expr &amp;:= <span class="stri">".capacity=0, "</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= stop_name;
          c_expr.expr &amp;:= <span class="stri">">="</span>;
          c_expr.expr &amp;:= start_name;
          <span class="keywd">if</span> start_is_variable <span class="op">or</span> stri_is_variable <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">" &amp;&amp; (uintType)"</span>;
            c_expr.expr &amp;:= start_name;
            c_expr.expr &amp;:= <span class="stri">"&lt;="</span>;
            c_expr.expr &amp;:= stri_size;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">" ? ("</span>;
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".mem = &amp;"</span>;
          c_expr.expr &amp;:= stri_name;
          c_expr.expr &amp;:= <span class="stri">"->mem["</span>;
          <span class="keywd">if</span> start_is_variable <span class="keywd">then</span>
            c_expr.expr &amp;:= start_name;
            c_expr.expr &amp;:= <span class="stri">"-1"</span>
          <span class="keywd">else</span>
            c_expr.expr &amp;:= integerLiteral(pred(start_value));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">"], (uintType)"</span>;
          c_expr.expr &amp;:= stop_name;
          c_expr.expr &amp;:= <span class="stri">" > "</span>;
          c_expr.expr &amp;:= stri_size;
          c_expr.expr &amp;:= <span class="stri">" ? "</span>;
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".size = "</span>;
          c_expr.expr &amp;:= stri_size;
          c_expr.expr &amp;:= <span class="stri">"-(memSizeType)"</span>;
          <span class="keywd">if</span> start_is_variable <span class="keywd">then</span>
            c_expr.expr &amp;:= start_name;
            c_expr.expr &amp;:= <span class="stri">"+1"</span>;
          <span class="keywd">else</span>
            c_expr.expr &amp;:= integerLiteral(pred(start_value));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">" : ("</span>;
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".size = (memSizeType)"</span>;
          c_expr.expr &amp;:= stop_name;
          c_expr.expr &amp;:= <span class="stri">"-(memSizeType)"</span>;
          <span class="keywd">if</span> start_is_variable <span class="keywd">then</span>
            c_expr.expr &amp;:= start_name;
            c_expr.expr &amp;:= <span class="stri">"+1"</span>;
          <span class="keywd">else</span>
            c_expr.expr &amp;:= integerLiteral(pred(start_value));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">"))"</span>;
          <span class="keywd">if</span> start_is_variable <span class="op">or</span> stop_is_variable <span class="keywd">then</span>
            <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
              <span class="keywd">if</span> stop_range.minValue &lt; start_range.maxValue <span class="keywd">then</span>
                incr(countIndexChecks);
                c_expr.expr &amp;:= <span class="stri">" : idxChk("</span>;
                c_expr.expr &amp;:= stop_name;
                c_expr.expr &amp;:= <span class="stri">"&lt;"</span>;
                <span class="keywd">if</span> start_is_variable <span class="keywd">then</span>
                  c_expr.expr &amp;:= start_name;
                  c_expr.expr &amp;:= <span class="stri">"-1"</span>;
                <span class="keywd">else</span>
                  c_expr.expr &amp;:= integerLiteral(pred(start_value));
                <span class="keywd">end</span> <span class="keywd">if</span>;
                c_expr.expr &amp;:= <span class="stri">")?"</span>;
                c_expr.expr &amp;:= intRaiseError(<span class="stri">"INDEX_ERROR"</span>);
              <span class="keywd">else</span>
                countIndexOptimizations(c_expr);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">else</span>
              incr(countSuppressedIndexChecks);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">" : ("</span>;
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".mem = NULL,"</span>;
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".size = 0)"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_str_range_of_empty_string (<span class="op">in</span> <span class="type">ref_list</span>: params,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: start_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stop_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: start_value <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: start_is_variable <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">integer</span>: stop_value <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: stop_is_variable <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">boolean</span>: raisesIndexError <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    incr(countOptimizations);
    c_expr.expr &amp;:= <span class="stri">"/* \"\"[m .. n] */ ("</span>;
    <span class="keywd">if</span> getConstant(params[3], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      start_is_variable := FALSE;
      start_value := getValue(evaluatedParam, integer);
      <span class="keywd">if</span> start_value &lt; 1 <span class="keywd">then</span>
        warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
        c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
        raisesIndexError := TRUE;
      <span class="keywd">else</span>
        start_name := integerLiteral(start_value);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      start_name := getTempVariable(<span class="stri">"intType"</span>, <span class="stri">"start_"</span>, params[3], c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="op">not</span> raisesIndexError <span class="keywd">then</span>
      <span class="keywd">if</span> getConstant(params[5], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
        stop_is_variable := FALSE;
        stop_value := getValue(evaluatedParam, integer);
        <span class="keywd">if</span> stop_value &lt; 0 <span class="op">or</span>
            <span class="op">not</span> start_is_variable <span class="op">and</span> stop_value &lt; pred(start_value) <span class="keywd">then</span>
          warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
          c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
          raisesIndexError := TRUE;
        <span class="keywd">else</span>
          stop_name := integerLiteral(stop_value);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        stop_name := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"stop_"</span>, params[5], c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> <span class="op">not</span> raisesIndexError <span class="keywd">then</span>
        <span class="keywd">if</span> start_is_variable <span class="op">or</span> stop_is_variable <span class="keywd">then</span>
          <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
            incr(countIndexChecks);
            c_expr.expr &amp;:= <span class="stri">"idxChk("</span>;
            <span class="keywd">if</span> start_is_variable <span class="keywd">then</span>
              c_expr.expr &amp;:= start_name;
              c_expr.expr &amp;:= <span class="stri">"&lt;1||"</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            c_expr.expr &amp;:= stop_name;
            c_expr.expr &amp;:= <span class="stri">"&lt;"</span>;
            c_expr.expr &amp;:= start_name;
            c_expr.expr &amp;:= <span class="stri">"-1)?"</span>;
            c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
            c_expr.expr &amp;:= <span class="stri">":"</span>;
          <span class="keywd">else</span>
            incr(countSuppressedIndexChecks);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= stringLiteral(<span class="stri">""</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_RANGE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: start_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: slice_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="op">and</span>
        getValue(evaluatedParam, string) = <span class="stri">""</span> <span class="keywd">then</span>
      process_str_range_of_empty_string(params, c_expr);
    <span class="keywd">elsif</span> getConstant(params[3], INTOBJECT, evaluatedParam) <span class="op">and</span>
        getValue(evaluatedParam, integer) = 1 <span class="keywd">then</span>
      incr(countOptimizations);
      process_str_head(params[1], params[5], c_expr);
    <span class="keywd">elsif</span> ccConf.ALLOW_STRITYPE_SLICES <span class="op">and</span> c_expr.demand &lt; REQUIRE_RESULT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      incr(c_expr.temp_num);
      slice_name := <span class="stri">"slice_"</span> &amp; str(c_expr.temp_num);
      c_expr.temp_decls &amp;:= <span class="stri">"struct striStruct "</span>;
      c_expr.temp_decls &amp;:= slice_name;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      <span class="keywd">if</span> inlineFunctions <span class="keywd">then</span>
        incr(countInlinedFunctions);
        process_inline_str_range(params[1], params[3], params[5],
                                 slice_name, c_expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"strRangeSlice("</span>;
        getAnyParamToExpr(params[1], c_expr);
        c_expr.expr &amp;:= <span class="stri">", "</span>;
        process_expr(params[3], c_expr);
        c_expr.expr &amp;:= <span class="stri">", "</span>;
        process_expr(params[5], c_expr);
        c_expr.expr &amp;:= <span class="stri">", &amp;"</span>;
        c_expr.expr &amp;:= slice_name;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">", &amp;"</span>;
      c_expr.expr &amp;:= slice_name;
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      prepare_stri_result(c_expr);
      c_expr.result_expr := <span class="stri">"strRange("</span>;
      getAnyParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getStdParamToResultExpr(params[3], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getStdParamToResultExpr(params[5], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_RCHIPOS, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"strRChIPos("</span>;
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    process_expr(params[2], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    process_expr(params[3], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_rchpos (<span class="op">in</span> <span class="type">string</span>: mainStri, <span class="op">in</span> <span class="type">reference</span>: param2,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(param2, CHAROBJECT, evaluatedParam) <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"/* rpos("</span>;
      c_expr.expr &amp;:= replace(literal(mainStri), <span class="stri">"*/"</span>, <span class="stri">"*\\/"</span>);
      c_expr.expr &amp;:= <span class="stri">","</span>;
      c_expr.expr &amp;:= literal(getValue(evaluatedParam, char));
      c_expr.expr &amp;:= <span class="stri">") */ "</span>;
      c_expr.expr &amp;:= integerLiteral(rpos(mainStri, getValue(evaluatedParam, char)));
    <span class="keywd">elsif</span> length(mainStri) = 0 <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"/* rpos(\"\", *) */ "</span>;
      c_expr.expr &amp;:= integerLiteral(0);
    <span class="keywd">elsif</span> length(mainStri) = 1 <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"/* rpos("</span>;
      c_expr.expr &amp;:= literal(mainStri);
      c_expr.expr &amp;:= <span class="stri">", *) */ "</span>;
      c_expr.expr &amp;:= charLiteral(mainStri[1]);
      c_expr.expr &amp;:= <span class="stri">"==("</span>;
      getAnyParamToExpr(param2, c_expr);
      c_expr.expr &amp;:= <span class="stri">")?"</span>;
      c_expr.expr &amp;:= integerLiteral(1);
      c_expr.expr &amp;:= <span class="stri">":"</span>;
      c_expr.expr &amp;:= integerLiteral(0);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strRChPos("</span>;
      c_expr.expr &amp;:= stringLiteral(mainStri);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToExpr(param2, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_RCHPOS, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_rchpos(getValue(evaluatedParam, string), params[2], c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strRChPos("</span>;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(params[2], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_repl (<span class="op">in</span> <span class="type">reference</span>: param1,
    <span class="op">in</span> <span class="type">string</span>: searched, <span class="op">in</span> <span class="type">reference</span>: param3, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param1 <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: replacement <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> searched = <span class="stri">""</span> <span class="keywd">then</span>
      incr(countOptimizations);
      prepareAnyParamTemporarys(param1, c_param1, c_expr);
      <span class="keywd">if</span> c_param1.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        prepare_stri_result(c_expr);
        c_expr.result_expr := <span class="stri">"/* strRepl(*, \"\", *) */ "</span>;
        c_expr.result_expr &amp;:= c_param1.result_expr;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"/* strRepl(*, \"\", *) */ "</span>;
        c_expr.expr &amp;:= c_param1.expr;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> getConstant(param3, STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      replacement := getValue(evaluatedParam, string);
      <span class="keywd">if</span> searched = replacement <span class="keywd">then</span>
        prepareAnyParamTemporarys(param1, c_param1, c_expr);
        <span class="keywd">if</span> c_param1.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          prepare_stri_result(c_expr);
          c_expr.result_expr := <span class="stri">"/* strRepl(*, "</span>;
          c_expr.result_expr &amp;:= replace(literal(searched), <span class="stri">"*/"</span>, <span class="stri">"*\\/"</span>);
          c_expr.result_expr &amp;:= <span class="stri">", "</span>;
          c_expr.result_expr &amp;:= replace(literal(replacement), <span class="stri">"*/"</span>, <span class="stri">"*\\/"</span>);
          c_expr.result_expr &amp;:= <span class="stri">") */ "</span>;
          c_expr.result_expr &amp;:= c_param1.result_expr;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"/* strRepl(*, "</span>;
          c_expr.expr &amp;:= replace(literal(searched), <span class="stri">"*/"</span>, <span class="stri">"*\\/"</span>);
          c_expr.expr &amp;:= <span class="stri">", "</span>;
          c_expr.expr &amp;:= replace(literal(replacement), <span class="stri">"*/"</span>, <span class="stri">"*\\/"</span>);
          c_expr.expr &amp;:= <span class="stri">") */ "</span>;
          c_expr.expr &amp;:= c_param1.expr;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> length(searched) = 1 <span class="keywd">then</span>
        <span class="keywd">if</span> length(replacement) = 1 <span class="keywd">then</span>
          prepare_stri_result(c_expr);
          c_expr.result_expr := <span class="stri">"strChChRepl("</span>;
          getAnyParamToResultExpr(param1, c_expr);
          c_expr.result_expr &amp;:= <span class="stri">", "</span>;
          c_expr.result_expr &amp;:= charLiteral(searched[1]);
          c_expr.result_expr &amp;:= <span class="stri">", "</span>;
          c_expr.result_expr &amp;:= charLiteral(replacement[1]);
          c_expr.result_expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">else</span>
          prepare_stri_result(c_expr);
          c_expr.result_expr := <span class="stri">"strChRepl("</span>;
          getAnyParamToResultExpr(param1, c_expr);
          c_expr.result_expr &amp;:= <span class="stri">", "</span>;
          c_expr.result_expr &amp;:= charLiteral(searched[1]);
          c_expr.result_expr &amp;:= <span class="stri">", "</span>;
          c_expr.result_expr &amp;:= stringLiteral(replacement);
          c_expr.result_expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        prepare_stri_result(c_expr);
        c_expr.result_expr := <span class="stri">"strRepl("</span>;
        getAnyParamToResultExpr(param1, c_expr);
        c_expr.result_expr &amp;:= <span class="stri">", "</span>;
        c_expr.result_expr &amp;:= stringLiteral(searched);
        c_expr.result_expr &amp;:= <span class="stri">", "</span>;
        c_expr.result_expr &amp;:= stringLiteral(replacement);
        c_expr.result_expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> length(searched) = 1 <span class="keywd">then</span>
      incr(countOptimizations);
      <span class="keywd">if</span> isActionExpression(param3, <span class="stri">"CHR_STR"</span>) <span class="keywd">then</span>
        prepare_stri_result(c_expr);
        c_expr.result_expr := <span class="stri">"strChChRepl("</span>;
        getAnyParamToResultExpr(param1, c_expr);
        c_expr.result_expr &amp;:= <span class="stri">", "</span>;
        c_expr.result_expr &amp;:= charLiteral(searched[1]);
        c_expr.result_expr &amp;:= <span class="stri">", "</span>;
        getAnyParamToResultExpr(getActionParameter(param3, 1), c_expr);
        c_expr.result_expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">else</span>
        prepare_stri_result(c_expr);
        c_expr.result_expr := <span class="stri">"strChRepl("</span>;
        getAnyParamToResultExpr(param1, c_expr);
        c_expr.result_expr &amp;:= <span class="stri">", "</span>;
        c_expr.result_expr &amp;:= charLiteral(searched[1]);
        c_expr.result_expr &amp;:= <span class="stri">", "</span>;
        getAnyParamToResultExpr(param3, c_expr);
        c_expr.result_expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      prepare_stri_result(c_expr);
      c_expr.result_expr := <span class="stri">"strRepl("</span>;
      getAnyParamToResultExpr(param1, c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      c_expr.result_expr &amp;:= stringLiteral(searched);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToResultExpr(param3, c_expr);
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_REPL, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: replacement <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[2], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_repl(params[1], getValue(evaluatedParam, string), params[3], c_expr);
    <span class="keywd">elsif</span> isActionExpression(params[2], <span class="stri">"CHR_STR"</span>) <span class="keywd">then</span>
      incr(countOptimizations);
      prepare_stri_result(c_expr);
      <span class="keywd">if</span> getConstant(params[3], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
        replacement := getValue(evaluatedParam, string);
        <span class="keywd">if</span> length(replacement) = 1 <span class="keywd">then</span>
          c_expr.result_expr := <span class="stri">"strChChRepl("</span>;
          getAnyParamToResultExpr(params[1], c_expr);
          c_expr.result_expr &amp;:= <span class="stri">", "</span>;
          getAnyParamToResultExpr(getActionParameter(params[2], 1), c_expr);
          c_expr.result_expr &amp;:= <span class="stri">", "</span>;
          c_expr.result_expr &amp;:= charLiteral(replacement[1]);
          c_expr.result_expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">else</span>
          c_expr.result_expr := <span class="stri">"strChRepl("</span>;
          getAnyParamToResultExpr(params[1], c_expr);
          c_expr.result_expr &amp;:= <span class="stri">", "</span>;
          getAnyParamToResultExpr(getActionParameter(params[2], 1), c_expr);
          c_expr.result_expr &amp;:= <span class="stri">", "</span>;
          c_expr.result_expr &amp;:= stringLiteral(replacement);
          c_expr.result_expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> isActionExpression(params[3], <span class="stri">"CHR_STR"</span>) <span class="keywd">then</span>
        c_expr.result_expr := <span class="stri">"strChChRepl("</span>;
        getAnyParamToResultExpr(params[1], c_expr);
        c_expr.result_expr &amp;:= <span class="stri">", "</span>;
        getAnyParamToResultExpr(getActionParameter(params[2], 1), c_expr);
        c_expr.result_expr &amp;:= <span class="stri">", "</span>;
        getAnyParamToResultExpr(getActionParameter(params[3], 1), c_expr);
        c_expr.result_expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">else</span>
        c_expr.result_expr := <span class="stri">"strChRepl("</span>;
        getAnyParamToResultExpr(params[1], c_expr);
        c_expr.result_expr &amp;:= <span class="stri">", "</span>;
        getAnyParamToResultExpr(getActionParameter(params[2], 1), c_expr);
        c_expr.result_expr &amp;:= <span class="stri">", "</span>;
        getAnyParamToResultExpr(params[3], c_expr);
        c_expr.result_expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      prepare_stri_result(c_expr);
      c_expr.result_expr := <span class="stri">"strRepl("</span>;
      getAnyParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToResultExpr(params[2], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToResultExpr(params[3], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_RIPOS, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[2], STRIOBJECT, evaluatedParam) <span class="op">and</span>
        length(getValue(evaluatedParam, string)) = 1 <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"strRChIPos("</span>;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      c_expr.expr &amp;:= charLiteral(getValue(evaluatedParam, string)[1]);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strRIPos("</span>;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToExpr(params[2], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_RPAD, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_stri_result(c_expr);
    c_expr.result_expr := <span class="stri">"strRpad("</span>;
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">", "</span>;
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_str_rpos (<span class="op">in</span> <span class="type">reference</span>: mainStri, <span class="op">in</span> <span class="type">string</span>: searched,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(mainStri, STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"/* rpos("</span>;
      c_expr.expr &amp;:= replace(literal(getValue(evaluatedParam, string)), <span class="stri">"*/"</span>, <span class="stri">"*\\/"</span>);
      c_expr.expr &amp;:= <span class="stri">","</span>;
      c_expr.expr &amp;:= replace(literal(searched), <span class="stri">"*/"</span>, <span class="stri">"*\\/"</span>);
      c_expr.expr &amp;:= <span class="stri">") */ "</span>;
      c_expr.expr &amp;:= integerLiteral(rpos(getValue(evaluatedParam, string), searched));
    <span class="keywd">elsif</span> length(searched) = 0 <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"/* rpos(*, \"\") */ "</span>;
      c_expr.expr &amp;:= integerLiteral(0);
    <span class="keywd">elsif</span> length(searched) = 1 <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"strRChPos("</span>;
      getAnyParamToExpr(mainStri, c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      c_expr.expr &amp;:= charLiteral(searched[1]);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strRPos("</span>;
      getAnyParamToExpr(mainStri, c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      c_expr.expr &amp;:= stringLiteral(searched);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_RPOS, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[2], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_str_rpos(params[1], getValue(evaluatedParam, string), c_expr);
    <span class="keywd">elsif</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="op">and</span>
        length(getValue(evaluatedParam, string)) = 0 <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"/* rpos(\"\", *) */ "</span>;
      c_expr.expr &amp;:= integerLiteral(0);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"strRPos("</span>;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToExpr(params[2], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_RTRIM, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_stri_result(c_expr);
    c_expr.result_expr := <span class="stri">"strRtrim("</span>;
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_SPLIT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    prepare_typed_result(array_type[getExprResultType(params[1])], c_expr);
    <span class="keywd">if</span> getConstant(params[2], STRIOBJECT, evaluatedParam) <span class="op">and</span>
        length(getValue(evaluatedParam, string)) = 1 <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.result_expr := <span class="stri">"strChSplit("</span>;
      getAnyParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      c_expr.result_expr &amp;:= charLiteral(getValue(evaluatedParam, string)[1]);
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.result_expr := <span class="stri">"strSplit("</span>;
      getAnyParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToResultExpr(params[2], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_STR, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    process_expr(params[1], c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_str_substr0 (<span class="op">in</span> <span class="type">reference</span>: stri, <span class="op">in</span> <span class="type">reference</span>: start,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: start_range <span class="keywd">is</span> intRange.value;
  <span class="keywd">begin</span>
    incr(countOptimizations);
    start_range := getIntRange(start);
    <span class="keywd">if</span> start_range.maxValue &lt; 1 <span class="keywd">then</span>
      warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
      c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"/* string[m len 0] */ ("</span>;
      <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
        <span class="keywd">if</span> start_range.minValue &lt; 1 <span class="keywd">then</span>
          incr(countIndexChecks);
          c_expr.expr &amp;:= <span class="stri">"idxChk(("</span>;
          process_expr(start, c_expr);
          c_expr.expr &amp;:= <span class="stri">")&lt;1)?"</span>;
          c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
          c_expr.expr &amp;:= <span class="stri">":"</span>;
        <span class="keywd">else</span>
          countIndexOptimizations(c_expr);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        incr(countSuppressedIndexChecks);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= stringLiteral(<span class="stri">""</span>);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_str_substr1 (<span class="op">in</span> <span class="type">reference</span>: stri, <span class="op">in</span> <span class="type">reference</span>: start,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: stri_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri_value <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri_size <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: start_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">intRange</span>: start_range <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">string</span>: striStruct_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> c_expr.demand &lt; REQUIRE_RESULT <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      <span class="keywd">if</span> getConstant(stri, STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
        stri_value := getValue(evaluatedParam, string);
        stri_name := <span class="stri">"("</span> &amp; stringLiteral(stri_value) &amp; <span class="stri">")"</span>;
        stri_size := memSizeLiteral(length(stri_value));
      <span class="keywd">else</span>
        stri_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"stri_"</span>, stri, c_expr);
        stri_size := stri_name &amp; <span class="stri">"->size"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      incr(c_expr.temp_num);
      start_name := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"start_"</span>, start, c_expr);
      incr(c_expr.temp_num);
      striStruct_name := <span class="stri">"stri_"</span> &amp; str(c_expr.temp_num);
      c_expr.temp_decls &amp;:= <span class="stri">"struct striStruct "</span>;
      c_expr.temp_decls &amp;:= striStruct_name;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
        start_range := getIntRange(start);
        <span class="keywd">if</span> start_range.minValue &lt; 1 <span class="keywd">then</span>
          incr(countIndexChecks);
          c_expr.expr &amp;:= <span class="stri">"idxChk("</span>;
          c_expr.expr &amp;:= start_name;
          c_expr.expr &amp;:= <span class="stri">"&lt;1)?"</span>;
          c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
          c_expr.expr &amp;:= <span class="stri">":"</span>;
        <span class="keywd">else</span>
          countIndexOptimizations(c_expr);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        incr(countSuppressedIndexChecks);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      c_expr.expr &amp;:= start_name;
      c_expr.expr &amp;:= <span class="stri">">"</span>;
      c_expr.expr &amp;:= stri_size;
      c_expr.expr &amp;:= <span class="stri">" ? "</span>;
      c_expr.expr &amp;:= stringLiteral(<span class="stri">""</span>);
      c_expr.expr &amp;:= <span class="stri">" : chrStrMacro("</span>;
      c_expr.expr &amp;:= stri_name;
      c_expr.expr &amp;:= <span class="stri">"->mem["</span>;
      c_expr.expr &amp;:= start_name;
      c_expr.expr &amp;:= <span class="stri">"-1],"</span>;
      c_expr.expr &amp;:= striStruct_name;
      c_expr.expr &amp;:= <span class="stri">")))"</span>;
    <span class="keywd">else</span>
      prepare_stri_result(c_expr);
      c_expr.result_expr := <span class="stri">"strSubstr("</span>;
      getAnyParamToResultExpr(stri, c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getStdParamToResultExpr(start, c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", 1)"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_inline_str_substr (<span class="op">in</span> <span class="type">reference</span>: stri,
    <span class="op">in</span> <span class="type">reference</span>: start, <span class="op">in</span> <span class="type">reference</span>: length, <span class="op">in</span> <span class="type">string</span>: slice_name,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: stri_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri_value <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: stri_is_variable <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">string</span>: stri_size <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: start_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: start_value <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: start_is_variable <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">intRange</span>: start_range <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">string</span>: length_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: length_value <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: length_is_variable <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">intRange</span>: length_range <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">boolean</span>: raisesIndexError <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(stri, STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      stri_is_variable := FALSE;
      stri_value := getValue(evaluatedParam, string);
      stri_name := <span class="stri">"("</span> &amp; stringLiteral(stri_value) &amp; <span class="stri">")"</span>;
      stri_size := memSizeLiteral(length(stri_value));
    <span class="keywd">else</span>
      stri_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"stri_"</span>, stri, c_expr);
      stri_size := stri_name &amp; <span class="stri">"->size"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> getConstant(start, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      start_is_variable := FALSE;
      start_value := getValue(evaluatedParam, integer);
      <span class="keywd">if</span> start_value &lt; 1 <span class="keywd">then</span>
        warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
        c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
        raisesIndexError := TRUE;
      <span class="keywd">else</span>
        start_name := integerLiteral(start_value);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      start_name := getTempVariable(<span class="stri">"intType"</span>, <span class="stri">"start_"</span>, start, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="op">not</span> raisesIndexError <span class="keywd">then</span>
      <span class="keywd">if</span> getConstant(length, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
        length_is_variable := FALSE;
        length_value := getValue(evaluatedParam, integer);
        <span class="keywd">if</span> length_value &lt; 0 <span class="keywd">then</span>
          warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
          c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
          raisesIndexError := TRUE;
        <span class="keywd">else</span>
          length_name := integerLiteral(length_value);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        length_name := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"length_"</span>, length, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> <span class="op">not</span> raisesIndexError <span class="keywd">then</span>
        <span class="keywd">if</span> start_is_variable <span class="op">or</span> length_is_variable <span class="keywd">then</span>
          <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
            start_range := getIntRange(start);
            length_range := getIntRange(length);
            <span class="keywd">if</span> start_range.minValue &lt; 1 <span class="op">or</span> length_range.minValue &lt; 0 <span class="keywd">then</span>
              incr(countIndexChecks);
              c_expr.expr &amp;:= <span class="stri">"idxChk("</span>;
              <span class="keywd">if</span> start_is_variable <span class="op">and</span> start_range.minValue &lt; 1 <span class="keywd">then</span>
                c_expr.expr &amp;:= start_name;
                c_expr.expr &amp;:= <span class="stri">"&lt;1"</span>;
              <span class="keywd">else</span>
                countIndexOptimizations(c_expr);
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> start_is_variable <span class="op">and</span> length_is_variable <span class="op">and</span>
                  start_range.minValue &lt; 1 <span class="op">and</span> length_range.minValue &lt; 0 <span class="keywd">then</span>
                c_expr.expr &amp;:= <span class="stri">"||"</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> length_is_variable <span class="op">and</span> length_range.minValue &lt; 0 <span class="keywd">then</span>
                c_expr.expr &amp;:= length_name;
                c_expr.expr &amp;:= <span class="stri">"&lt;0"</span>;
              <span class="keywd">else</span>
                countIndexOptimizations(c_expr);
              <span class="keywd">end</span> <span class="keywd">if</span>;
              c_expr.expr &amp;:= <span class="stri">")?"</span>;
              c_expr.expr &amp;:= intRaiseError(<span class="stri">"INDEX_ERROR"</span>);
              c_expr.expr &amp;:= <span class="stri">":0, "</span>;
            <span class="keywd">else</span>
              countIndexOptimizations(c_expr);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            incr(countSuppressedIndexChecks);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> ccConf.WITH_STRI_CAPACITY <span class="op">and</span> FALSE <span class="keywd">then</span>
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".capacity=0, "</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> (<span class="op">not</span> length_is_variable <span class="op">and</span> length_value = 0) <span class="op">or</span>
            (<span class="op">not</span> stri_is_variable <span class="op">and</span> <span class="op">not</span> start_is_variable <span class="op">and</span>
             length(stri_value) &lt; start_value) <span class="keywd">then</span>
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".mem = NULL, "</span>;
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".size = 0"</span>;
        <span class="keywd">elsif</span> <span class="op">not</span> start_is_variable <span class="op">and</span> <span class="op">not</span> length_is_variable <span class="op">and</span>
            start_value &lt;= integer.last - length_value <span class="keywd">then</span>
          <span class="comment">(* Formula used: slice.mem = &amp;stri->mem[start-1],
                           start+length-1 &lt;= stri->size ?
                           slice.size = (memSizeType)length :
                           ((uintType)start &lt;= stri->size ?
                           slice.size = stri->size-(memSizeType)start+1 :
                           (slice.size = 0)) *)</span>
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".mem = &amp;"</span>;
          c_expr.expr &amp;:= stri_name;
          c_expr.expr &amp;:= <span class="stri">"->mem["</span>;
          c_expr.expr &amp;:= integerLiteral(pred(start_value));
          c_expr.expr &amp;:= <span class="stri">"], "</span>;
          c_expr.expr &amp;:= integerLiteral(start_value + length_value - 1);
          c_expr.expr &amp;:= <span class="stri">"&lt;="</span>;
          c_expr.expr &amp;:= stri_size;
          c_expr.expr &amp;:= <span class="stri">" ? "</span>;
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".size = (memSizeType)"</span>;
          c_expr.expr &amp;:= length_name;
          c_expr.expr &amp;:= <span class="stri">" : ("</span>;
          c_expr.expr &amp;:= <span class="stri">"(uintType)"</span>;
          c_expr.expr &amp;:= start_name;
          c_expr.expr &amp;:= <span class="stri">"&lt;="</span>;
          c_expr.expr &amp;:= stri_size;
          c_expr.expr &amp;:= <span class="stri">" ? "</span>;
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".size = "</span>;
          c_expr.expr &amp;:= stri_size;
          c_expr.expr &amp;:= <span class="stri">"-(memSizeType)"</span>;
          c_expr.expr &amp;:= integerLiteral(pred(start_value));
          c_expr.expr &amp;:= <span class="stri">" : ("</span>;
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".size = 0))"</span>;
        <span class="keywd">else</span>
          <span class="comment">(* Formula used: length!=0 &amp;&amp;
                           (uintType)start&lt;=stri->size ?
                           (slice.mem = &amp;stri->mem[start-1],
                           (uintType)length > stri->size-(memSizeType)start+1 ?
                           slice.size = stri->size-(memSizeType)start+1 :
                           (slice.size = (memSizeType)length)) :
                           (slice.mem = NULL, slice.size = 0) *)</span>
          <span class="keywd">if</span> length_is_variable <span class="keywd">then</span>
            c_expr.expr &amp;:= length_name;
            c_expr.expr &amp;:= <span class="stri">"!=0 &amp;&amp; "</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">"(uintType)"</span>;
          c_expr.expr &amp;:= start_name;
          c_expr.expr &amp;:= <span class="stri">"&lt;="</span>;
          c_expr.expr &amp;:= stri_size;
          c_expr.expr &amp;:= <span class="stri">" ? ("</span>;
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".mem = &amp;"</span>;
          c_expr.expr &amp;:= stri_name;
          c_expr.expr &amp;:= <span class="stri">"->mem["</span>;
          <span class="keywd">if</span> start_is_variable <span class="keywd">then</span>
            c_expr.expr &amp;:= start_name;
            c_expr.expr &amp;:= <span class="stri">"-1"</span>;
          <span class="keywd">else</span>
            c_expr.expr &amp;:= integerLiteral(pred(start_value));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">"], (uintType)"</span>;
          c_expr.expr &amp;:= length_name;
          c_expr.expr &amp;:= <span class="stri">">"</span>;
          c_expr.expr &amp;:= stri_size;
          c_expr.expr &amp;:= <span class="stri">"-(memSizeType)"</span>;
          <span class="keywd">if</span> start_is_variable <span class="keywd">then</span>
            c_expr.expr &amp;:= start_name;
            c_expr.expr &amp;:= <span class="stri">"+1"</span>;
          <span class="keywd">else</span>
            c_expr.expr &amp;:= integerLiteral(pred(start_value));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">" ? "</span>;
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".size = "</span>;
          c_expr.expr &amp;:= stri_size;
          c_expr.expr &amp;:= <span class="stri">"-(memSizeType)"</span>;
          <span class="keywd">if</span> start_is_variable <span class="keywd">then</span>
            c_expr.expr &amp;:= start_name;
            c_expr.expr &amp;:= <span class="stri">"+1"</span>;
          <span class="keywd">else</span>
            c_expr.expr &amp;:= integerLiteral(pred(start_value));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">" : ("</span>;
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".size = (memSizeType)"</span>;
          c_expr.expr &amp;:= length_name;
          c_expr.expr &amp;:= <span class="stri">")) : ("</span>;
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".mem = NULL, "</span>;
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".size = 0)"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_SUBSTR, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: slice_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="op">and</span>
        getValue(evaluatedParam, string) = <span class="stri">""</span> <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"/* \"\"[m len n] */ ("</span>;
      <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
        incr(countIndexChecks);
        c_expr.expr &amp;:= <span class="stri">"idxChk(("</span>;
        process_expr(params[3], c_expr);
        c_expr.expr &amp;:= <span class="stri">")&lt;1||("</span>;
        process_expr(params[5], c_expr);
        c_expr.expr &amp;:= <span class="stri">")&lt;0)?"</span>;
        c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
        c_expr.expr &amp;:= <span class="stri">":"</span>;
      <span class="keywd">else</span>
        incr(countSuppressedIndexChecks);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= stringLiteral(<span class="stri">""</span>);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">elsif</span> getConstant(params[3], INTOBJECT, evaluatedParam) <span class="op">and</span>
        getValue(evaluatedParam, integer) = 1 <span class="keywd">then</span>
      incr(countOptimizations);
      process_str_head(params[1], params[5], c_expr);
    <span class="keywd">elsif</span> getConstant(params[5], INTOBJECT, evaluatedParam) <span class="op">and</span>
        getValue(evaluatedParam, integer) &lt;= 1 <span class="keywd">then</span>
      length := getValue(evaluatedParam, integer);
      <span class="keywd">if</span> length = 0 <span class="keywd">then</span>
        process_str_substr0(params[1], params[3], c_expr);
      <span class="keywd">elsif</span> length = 1 <span class="keywd">then</span>
        process_str_substr1(params[1], params[3], c_expr);
      <span class="keywd">else</span>
        incr(countOptimizations);
        warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
        c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> ccConf.ALLOW_STRITYPE_SLICES <span class="op">and</span> c_expr.demand &lt; REQUIRE_RESULT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      incr(c_expr.temp_num);
      slice_name := <span class="stri">"slice_"</span> &amp; str(c_expr.temp_num);
      c_expr.temp_decls &amp;:= <span class="stri">"struct striStruct "</span>;
      c_expr.temp_decls &amp;:= slice_name;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      <span class="keywd">if</span> inlineFunctions <span class="keywd">then</span>
        incr(countInlinedFunctions);
        process_inline_str_substr(params[1], params[3], params[5],
                                  slice_name, c_expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"strSubstrSlice("</span>;
        getAnyParamToExpr(params[1], c_expr);
        c_expr.expr &amp;:= <span class="stri">", "</span>;
        process_expr(params[3], c_expr);
        c_expr.expr &amp;:= <span class="stri">", "</span>;
        process_expr(params[5], c_expr);
        c_expr.expr &amp;:= <span class="stri">", &amp;"</span>;
        c_expr.expr &amp;:= slice_name;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">", &amp;"</span>;
      c_expr.expr &amp;:= slice_name;
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      prepare_stri_result(c_expr);
      c_expr.result_expr := <span class="stri">"strSubstr("</span>;
      getAnyParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getStdParamToResultExpr(params[3], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getStdParamToResultExpr(params[5], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_str_substr_fixlen0 (<span class="op">in</span> <span class="type">reference</span>: stri,
    <span class="op">in</span> <span class="type">reference</span>: start, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">boolean</span>: stri_is_variable <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">integer</span>: stri_length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">intRange</span>: start_range <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">string</span>: start_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: raisesIndexError <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    incr(countOptimizations);
    start_range := getIntRange(start);
    <span class="keywd">if</span> start_range.maxValue &lt; 1 <span class="keywd">then</span>
      warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
      c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
      raisesIndexError := TRUE;
    <span class="keywd">elsif</span> getConstant(stri, STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      stri_is_variable := FALSE;
      stri_length := length(getValue(evaluatedParam, string));
      <span class="keywd">if</span> start_range.minValue > stri_length <span class="keywd">then</span>
        warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
        c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
        raisesIndexError := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="op">not</span> raisesIndexError <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"/* string[m fixLen 0] */ ("</span>;
      <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
        <span class="keywd">if</span> stri_is_variable <span class="op">or</span> start_range.minValue &lt; 1 <span class="op">or</span>
                               start_range.maxValue > stri_length <span class="keywd">then</span>
          incr(countIndexChecks);
          <span class="keywd">if</span> start_range.minValue >= 1 <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"idxChk("</span>;
            c_expr.expr &amp;:= <span class="stri">"("</span>;
            process_expr(start, c_expr);
            c_expr.expr &amp;:= <span class="stri">")>"</span>;
          <span class="keywd">else</span>
            start_name := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"start_"</span>, start, c_expr);
            c_expr.expr &amp;:= <span class="stri">"idxChk("</span>;
            c_expr.expr &amp;:= start_name;
            c_expr.expr &amp;:= <span class="stri">"&lt;1||"</span>;
            c_expr.expr &amp;:= start_name;
            c_expr.expr &amp;:= <span class="stri">">"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> stri_is_variable <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"("</span>;
            getAnyParamToExpr(stri, c_expr);
            c_expr.expr &amp;:= <span class="stri">")->size"</span>;
          <span class="keywd">else</span>
            c_expr.expr &amp;:= memSizeLiteral(stri_length);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">")?"</span>;
          c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
          c_expr.expr &amp;:= <span class="stri">":"</span>;
        <span class="keywd">else</span>
          countIndexOptimizations(c_expr);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        incr(countSuppressedIndexChecks);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= stringLiteral(<span class="stri">""</span>);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_str_substr_fixlen1 (<span class="op">in</span> <span class="type">reference</span>: stri,
    <span class="op">in</span> <span class="type">reference</span>: start, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">boolean</span>: stri_is_variable <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">string</span>: stri_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri_value <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: stri_length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: stri_size <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: start_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: start_value <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">intRange</span>: start_range <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">boolean</span>: raisesIndexError <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">string</span>: logicalOr <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: striStruct_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> c_expr.demand &lt; REQUIRE_RESULT <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      <span class="keywd">if</span> getConstant(stri, STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
        stri_is_variable := FALSE;
        stri_value := getValue(evaluatedParam, string);
        stri_name := <span class="stri">"("</span> &amp; stringLiteral(stri_value) &amp; <span class="stri">")"</span>;
        stri_length := length(stri_value);
        stri_size := memSizeLiteral(stri_length);
      <span class="keywd">else</span>
        stri_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"stri_"</span>, stri, c_expr);
        stri_size := stri_name &amp; <span class="stri">"->size"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> getConstant(start, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
        start_value := getValue(evaluatedParam, integer);
        <span class="keywd">if</span> start_value &lt; 1 <span class="keywd">then</span>
          warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
          c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
          raisesIndexError := TRUE;
        <span class="keywd">elsif</span> <span class="op">not</span> stri_is_variable <span class="op">and</span> start_value > stri_length <span class="keywd">then</span>
          warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
          c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
          raisesIndexError := TRUE;
        <span class="keywd">else</span>
          start_name := integerLiteral(start_value);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        start_name := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"start_"</span>, start, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> <span class="op">not</span> raisesIndexError <span class="keywd">then</span>
        incr(c_expr.temp_num);
        striStruct_name := <span class="stri">"stri_"</span> &amp; str(c_expr.temp_num);
        c_expr.temp_decls &amp;:= <span class="stri">"struct striStruct "</span>;
        c_expr.temp_decls &amp;:= striStruct_name;
        c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
        <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
          start_range := getIntRange(start);
          <span class="keywd">if</span> stri_is_variable <span class="op">or</span> start_range.minValue &lt; 1 <span class="op">or</span>
                                 start_range.maxValue > stri_length <span class="keywd">then</span>
            incr(countIndexChecks);
            c_expr.expr &amp;:= <span class="stri">"idxChk("</span>;
            <span class="keywd">if</span> start_range.minValue &lt; 1 <span class="keywd">then</span>
              c_expr.expr &amp;:= start_name;
              c_expr.expr &amp;:= <span class="stri">"&lt;1"</span>;
              logicalOr := <span class="stri">"||"</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> stri_is_variable <span class="op">or</span> start_range.maxValue > stri_length <span class="keywd">then</span>
              c_expr.expr &amp;:= logicalOr;
              c_expr.expr &amp;:= start_name;
              c_expr.expr &amp;:= <span class="stri">">"</span>;
              c_expr.expr &amp;:= stri_size;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            c_expr.expr &amp;:= <span class="stri">")?"</span>;
            c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
            c_expr.expr &amp;:= <span class="stri">":"</span>;
          <span class="keywd">else</span>
            countIndexOptimizations(c_expr);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          incr(countSuppressedIndexChecks);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"chrStrMacro("</span>;
        c_expr.expr &amp;:= stri_name;
        c_expr.expr &amp;:= <span class="stri">"->mem["</span>;
        c_expr.expr &amp;:= start_name;
        c_expr.expr &amp;:= <span class="stri">"-1],"</span>;
        c_expr.expr &amp;:= striStruct_name;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      prepare_stri_result(c_expr);
      c_expr.result_expr := <span class="stri">"strSubstrFixLen("</span>;
      getAnyParamToResultExpr(stri, c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getStdParamToResultExpr(start, c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", 1)"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_inline_str_substr_fixlen (<span class="op">in</span> <span class="type">reference</span>: stri,
    <span class="op">in</span> <span class="type">reference</span>: start, <span class="op">in</span> <span class="type">reference</span>: length, <span class="op">in</span> <span class="type">string</span>: slice_name,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">boolean</span>: stri_is_variable <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">string</span>: stri_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri_value <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: stri_length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: stri_size <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: start_is_variable <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">string</span>: start_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: start_value <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">intRange</span>: start_range <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">string</span>: length_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: length_value <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: length_is_variable <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">intRange</span>: length_range <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">boolean</span>: raisesIndexError <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">string</span>: logicalOr <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(stri, STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      stri_is_variable := FALSE;
      stri_value := getValue(evaluatedParam, string);
      stri_name := <span class="stri">"("</span> &amp; stringLiteral(stri_value) &amp; <span class="stri">")"</span>;
      stri_length := length(stri_value);
      stri_size := memSizeLiteral(stri_length);
      <span class="comment"># An empty string ("") raises INDEX_ERROR in the calling function.</span>
    <span class="keywd">else</span>
      stri_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"stri_"</span>, stri, c_expr);
      stri_size := stri_name &amp; <span class="stri">"->size"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> getConstant(start, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      start_is_variable := FALSE;
      start_value := getValue(evaluatedParam, integer);
      <span class="keywd">if</span> start_value &lt; 1 <span class="keywd">then</span>
        warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
        c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
        raisesIndexError := TRUE;
      <span class="keywd">elsif</span> <span class="op">not</span> stri_is_variable <span class="op">and</span> start_value > stri_length <span class="keywd">then</span>
        warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
        c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
        raisesIndexError := TRUE;
      <span class="keywd">else</span>
        start_name := integerLiteral(start_value);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      start_name := getTempVariable(<span class="stri">"intType"</span>, <span class="stri">"start_"</span>, start, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="op">not</span> raisesIndexError <span class="keywd">then</span>
      <span class="keywd">if</span> getConstant(length, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
        length_is_variable := FALSE;
        length_value := getValue(evaluatedParam, integer);
        <span class="keywd">if</span> length_value &lt; 0 <span class="keywd">then</span>
          warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
          c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
          raisesIndexError := TRUE;
        <span class="keywd">elsif</span> <span class="op">not</span> stri_is_variable <span class="op">and</span> <span class="op">not</span> start_is_variable <span class="op">and</span>
            length_value > stri_length - start_value + 1 <span class="keywd">then</span>
          warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
          c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
          raisesIndexError := TRUE;
        <span class="keywd">else</span>
          length_name := integerLiteral(length_value);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        length_name := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"length_"</span>, length, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> <span class="op">not</span> raisesIndexError <span class="keywd">then</span>
        <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
          start_range := getIntRange(start);
          length_range := getIntRange(length);
          <span class="keywd">if</span> stri_is_variable <span class="op">or</span> start_is_variable <span class="op">or</span> length_is_variable <span class="keywd">then</span>
            incr(countIndexChecks);
            c_expr.expr &amp;:= <span class="stri">"idxChk("</span>;
            <span class="keywd">if</span> start_is_variable <span class="op">and</span> start_range.minValue &lt; 1 <span class="keywd">then</span>
              c_expr.expr &amp;:= start_name;
              c_expr.expr &amp;:= <span class="stri">"&lt;1"</span>;
              logicalOr := <span class="stri">"||"</span>;
            <span class="keywd">else</span>
              countIndexOptimizations(c_expr);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> length_is_variable <span class="op">and</span> length_range.minValue &lt; 0 <span class="keywd">then</span>
              c_expr.expr &amp;:= logicalOr;
              c_expr.expr &amp;:= length_name;
              c_expr.expr &amp;:= <span class="stri">"&lt;0"</span>;
              logicalOr := <span class="stri">"||"</span>;
            <span class="keywd">else</span>
              countIndexOptimizations(c_expr);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> start_is_variable <span class="op">or</span> stri_is_variable <span class="keywd">then</span>
              c_expr.expr &amp;:= logicalOr;
              c_expr.expr &amp;:= <span class="stri">"(uintType)"</span>;
              c_expr.expr &amp;:= start_name;
              c_expr.expr &amp;:= <span class="stri">">"</span>;
              c_expr.expr &amp;:= stri_size;
              logicalOr := <span class="stri">"||"</span>;
            <span class="keywd">else</span>
              countIndexOptimizations(c_expr);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> length_is_variable <span class="op">or</span> stri_is_variable <span class="op">or</span> start_is_variable <span class="keywd">then</span>
              c_expr.expr &amp;:= logicalOr;
              c_expr.expr &amp;:= <span class="stri">"(uintType)"</span>;
              c_expr.expr &amp;:= length_name;
              c_expr.expr &amp;:= <span class="stri">">"</span>;
              <span class="keywd">if</span> stri_is_variable <span class="op">or</span> start_is_variable <span class="keywd">then</span>
                c_expr.expr &amp;:= stri_size;
                c_expr.expr &amp;:= <span class="stri">"-(memSizeType)"</span>;
                c_expr.expr &amp;:= start_name;
                c_expr.expr &amp;:= <span class="stri">"+1"</span>;
              <span class="keywd">else</span>
                c_expr.expr &amp;:= memSizeLiteral(succ(stri_length - start_value));
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">else</span>
              countIndexOptimizations(c_expr);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            c_expr.expr &amp;:= <span class="stri">")?"</span>;
            c_expr.expr &amp;:= intRaiseError(<span class="stri">"INDEX_ERROR"</span>);
            c_expr.expr &amp;:= <span class="stri">":"</span>;
          <span class="keywd">else</span>
            countIndexOptimizations(c_expr);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          incr(countSuppressedIndexChecks);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> ccConf.WITH_STRI_CAPACITY <span class="op">and</span> FALSE <span class="keywd">then</span>
          c_expr.expr &amp;:= slice_name;
          c_expr.expr &amp;:= <span class="stri">".capacity=0, "</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="comment">(* Formula used: slice.mem = &amp;stri->mem[start - 1],
                         slice.size = (memSizeType)length *)</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        c_expr.expr &amp;:= slice_name;
        c_expr.expr &amp;:= <span class="stri">".mem = &amp;"</span>;
        c_expr.expr &amp;:= stri_name;
        c_expr.expr &amp;:= <span class="stri">"->mem["</span>;
        <span class="keywd">if</span> start_is_variable <span class="keywd">then</span>
          c_expr.expr &amp;:= start_name;
          c_expr.expr &amp;:= <span class="stri">"-1"</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= integerLiteral(pred(start_value));
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"], "</span>;
        c_expr.expr &amp;:= slice_name;
        c_expr.expr &amp;:= <span class="stri">".size = (memSizeType)"</span>;
        c_expr.expr &amp;:= length_name;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_SUBSTR_FIXLEN, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: slice_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="op">and</span>
        getValue(evaluatedParam, string) = <span class="stri">""</span> <span class="keywd">then</span>
      warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
      c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
    <span class="keywd">elsif</span> getConstant(params[5], INTOBJECT, evaluatedParam) <span class="op">and</span>
        getValue(evaluatedParam, integer) &lt;= 1 <span class="keywd">then</span>
      length := getValue(evaluatedParam, integer);
      <span class="keywd">if</span> length = 0 <span class="keywd">then</span>
        process_str_substr_fixlen0(params[1], params[3], c_expr);
      <span class="keywd">elsif</span> length = 1 <span class="keywd">then</span>
        process_str_substr_fixlen1(params[1], params[3], c_expr);
      <span class="keywd">else</span>
        incr(countOptimizations);
        warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
        c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> ccConf.ALLOW_STRITYPE_SLICES <span class="op">and</span> c_expr.demand &lt; REQUIRE_RESULT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      incr(c_expr.temp_num);
      slice_name := <span class="stri">"slice_"</span> &amp; str(c_expr.temp_num);
      c_expr.temp_decls &amp;:= <span class="stri">"struct striStruct "</span>;
      c_expr.temp_decls &amp;:= slice_name;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      <span class="keywd">if</span> inlineFunctions <span class="keywd">then</span>
        incr(countInlinedFunctions);
        process_inline_str_substr_fixlen(params[1], params[3], params[5],
                                         slice_name, c_expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"strSubstrFixLenSlice("</span>;
        getAnyParamToExpr(params[1], c_expr);
        c_expr.expr &amp;:= <span class="stri">", "</span>;
        process_expr(params[3], c_expr);
        c_expr.expr &amp;:= <span class="stri">", "</span>;
        process_expr(params[5], c_expr);
        c_expr.expr &amp;:= <span class="stri">", &amp;"</span>;
        c_expr.expr &amp;:= slice_name;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">", &amp;"</span>;
      c_expr.expr &amp;:= slice_name;
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      prepare_stri_result(c_expr);
      c_expr.result_expr := <span class="stri">"strSubstrFixLen("</span>;
      getAnyParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getStdParamToResultExpr(params[3], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getStdParamToResultExpr(params[5], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_inline_str_tail (<span class="op">in</span> <span class="type">reference</span>: stri,
    <span class="op">in</span> <span class="type">reference</span>: start, <span class="op">in</span> <span class="type">string</span>: slice_name,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: stri_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri_value <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri_size <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: start_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: start_value <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: start_is_variable <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">intRange</span>: start_range <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">boolean</span>: raisesIndexError <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(stri, STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
      stri_value := getValue(evaluatedParam, string);
      stri_name := <span class="stri">"("</span> &amp; stringLiteral(stri_value) &amp; <span class="stri">")"</span>;
      stri_size := memSizeLiteral(length(stri_value));
    <span class="keywd">else</span>
      stri_name := getParameterAsVariable(<span class="stri">"const_striType"</span>, <span class="stri">"stri_"</span>, stri, c_expr);
      stri_size := stri_name &amp; <span class="stri">"->size"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> getConstant(start, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      start_is_variable := FALSE;
      start_value := getValue(evaluatedParam, integer);
      <span class="keywd">if</span> start_value &lt; 1 <span class="keywd">then</span>
        warning(DOES_RAISE, <span class="stri">"INDEX_ERROR"</span>, c_expr);
        c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
        raisesIndexError := TRUE;
      <span class="keywd">else</span>
        start_name := integerLiteral(start_value);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      start_name := getTempVariable(<span class="stri">"intType"</span>, <span class="stri">"start_"</span>, start, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="op">not</span> raisesIndexError <span class="keywd">then</span>
      <span class="keywd">if</span> start_is_variable <span class="keywd">then</span>
        <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
          start_range := getIntRange(start);
          <span class="keywd">if</span> start_range.minValue &lt; 0 <span class="keywd">then</span>
            incr(countIndexChecks);
            c_expr.expr &amp;:= <span class="stri">"idxChk("</span>;
            c_expr.expr &amp;:= start_name;
            c_expr.expr &amp;:= <span class="stri">"&lt;1"</span>;
            c_expr.expr &amp;:= <span class="stri">")?"</span>;
            c_expr.expr &amp;:= intRaiseError(<span class="stri">"INDEX_ERROR"</span>);
            c_expr.expr &amp;:= <span class="stri">":0, "</span>;
          <span class="keywd">else</span>
            countIndexOptimizations(c_expr);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          incr(countSuppressedIndexChecks);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> ccConf.WITH_STRI_CAPACITY <span class="op">and</span> FALSE <span class="keywd">then</span>
        c_expr.expr &amp;:= slice_name;
        c_expr.expr &amp;:= <span class="stri">".capacity=0, "</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="comment">(* Formula used: slice.mem = &amp;stri->mem[start-1],
                       (uintType)start &lt;= stri->size &amp;&amp; stri->size >= 1 ?
                       slice.size = stri->size - (memSizeType)start + 1 :
                       (slice.size = 0) *)</span>
      c_expr.expr &amp;:= slice_name;
      c_expr.expr &amp;:= <span class="stri">".mem = &amp;"</span>;
      c_expr.expr &amp;:= stri_name;
      c_expr.expr &amp;:= <span class="stri">"->mem["</span>;
      <span class="keywd">if</span> start_is_variable <span class="keywd">then</span>
        c_expr.expr &amp;:= start_name;
        c_expr.expr &amp;:= <span class="stri">"-1"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= integerLiteral(pred(start_value));
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">"], (uintType)"</span>;
      c_expr.expr &amp;:= start_name;
      c_expr.expr &amp;:= <span class="stri">"&lt;="</span>;
      c_expr.expr &amp;:= stri_size;
      c_expr.expr &amp;:= <span class="stri">" &amp;&amp; "</span>;
      c_expr.expr &amp;:= stri_size;
      c_expr.expr &amp;:= <span class="stri">">=1 ?"</span>;
      c_expr.expr &amp;:= slice_name;
      c_expr.expr &amp;:= <span class="stri">".size = "</span>;
      c_expr.expr &amp;:= stri_size;
      c_expr.expr &amp;:= <span class="stri">" - (memSizeType)"</span>;
      c_expr.expr &amp;:= start_name;
      c_expr.expr &amp;:= <span class="stri">" + 1 : ("</span>;
      c_expr.expr &amp;:= slice_name;
      c_expr.expr &amp;:= <span class="stri">".size = 0)"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_TAIL, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: slice_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="op">and</span>
        getValue(evaluatedParam, string) = <span class="stri">""</span> <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"/* \"\"[n .. ] */ ("</span>;
      <span class="keywd">if</span> string_index_check <span class="keywd">then</span>
        incr(countIndexChecks);
        c_expr.expr &amp;:= <span class="stri">"idxChk(("</span>;
        process_expr(params[3], c_expr);
        c_expr.expr &amp;:= <span class="stri">")&lt;1)?"</span>;
        c_expr.expr &amp;:= strRaiseError(<span class="stri">"INDEX_ERROR"</span>);
        c_expr.expr &amp;:= <span class="stri">":"</span>;
      <span class="keywd">else</span>
        incr(countSuppressedIndexChecks);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= stringLiteral(<span class="stri">""</span>);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">elsif</span> ccConf.ALLOW_STRITYPE_SLICES <span class="op">and</span> c_expr.demand &lt; ASSIGN_RESULT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      incr(c_expr.temp_num);
      slice_name := <span class="stri">"slice_"</span> &amp; str(c_expr.temp_num);
      c_expr.temp_decls &amp;:= <span class="stri">"struct striStruct "</span>;
      c_expr.temp_decls &amp;:= slice_name;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      <span class="keywd">if</span> inlineFunctions <span class="keywd">then</span>
        incr(countInlinedFunctions);
        process_inline_str_tail(params[1], params[3], slice_name, c_expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"strTailSlice("</span>;
        getAnyParamToExpr(params[1], c_expr);
        c_expr.expr &amp;:= <span class="stri">", "</span>;
        process_expr(params[3], c_expr);
        c_expr.expr &amp;:= <span class="stri">", &amp;"</span>;
        c_expr.expr &amp;:= slice_name;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">", &amp;"</span>;
      c_expr.expr &amp;:= slice_name;
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      prepare_stri_result(c_expr);
      c_expr.result_expr := <span class="stri">"strTail("</span>;
      getAnyParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getStdParamToResultExpr(params[3], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_TOUTF8, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_stri_result(c_expr);
    c_expr.result_expr := <span class="stri">"strToUtf8("</span>;
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_TRIM, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_stri_result(c_expr);
    c_expr.result_expr := <span class="stri">"strTrim("</span>;
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Produces code to return a string converted to upper case.
 *  If the parameter is a temporary value the conversion is done
 *  with strUpTemp. The strUpTemp function returns the parameter as
 *  result of the conversion. That way the temporary of the parameter
 *  must not be freed.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: process (STR_UP, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param1 <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    prepare_stri_result(c_expr);
    prepareAnyParamTemporarys(params[1], c_param1, c_expr);
    <span class="keywd">if</span> c_param1.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.result_expr := <span class="stri">"strUpTemp("</span>;
      c_expr.result_expr &amp;:= c_param1.result_expr;
    <span class="keywd">else</span>
      c_expr.result_expr := <span class="stri">"strUp("</span>;
      c_expr.result_expr &amp;:= c_param1.expr;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_UTF8TOSTRI, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_stri_result(c_expr);
    c_expr.result_expr := <span class="stri">"strUtf8ToStri("</span>;
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (STR_VALUE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_stri_result(c_expr);
    c_expr.result_expr := <span class="stri">"strValue("</span>;
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
