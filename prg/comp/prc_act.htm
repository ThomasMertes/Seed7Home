<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../../style1.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  prc_act.s7i   Generate code for statements actions.             *)</span>
<span class="comment">(*  Copyright (C) 1990 - 1994, 2004 - 2014  Thomas Mertes           *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 compiler.                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_ARGS             <span class="keywd">is</span> action <span class="stri">"PRC_ARGS"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_BLOCK            <span class="keywd">is</span> action <span class="stri">"PRC_BLOCK"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_BLOCK_CATCH_ALL  <span class="keywd">is</span> action <span class="stri">"PRC_BLOCK"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_BLOCK_OTHERWISE  <span class="keywd">is</span> action <span class="stri">"PRC_BLOCK"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_CASE             <span class="keywd">is</span> action <span class="stri">"PRC_CASE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_CASE_DEF         <span class="keywd">is</span> action <span class="stri">"PRC_CASE_DEF"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_CASE_HASHSET     <span class="keywd">is</span> action <span class="stri">"PRC_CASE_HASHSET"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_CASE_HASHSET_DEF <span class="keywd">is</span> action <span class="stri">"PRC_CASE_HASHSET_DEF"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_CPY              <span class="keywd">is</span> action <span class="stri">"PRC_CPY"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_DYNAMIC          <span class="keywd">is</span> action <span class="stri">"PRC_DYNAMIC"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_EXIT             <span class="keywd">is</span> action <span class="stri">"PRC_EXIT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_FOR_DOWNTO       <span class="keywd">is</span> action <span class="stri">"PRC_FOR_DOWNTO"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_FOR_DOWNTO_STEP  <span class="keywd">is</span> action <span class="stri">"PRC_FOR_DOWNTO_STEP"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_FOR_TO           <span class="keywd">is</span> action <span class="stri">"PRC_FOR_TO"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_FOR_TO_STEP      <span class="keywd">is</span> action <span class="stri">"PRC_FOR_TO_STEP"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_HEAPSTAT         <span class="keywd">is</span> action <span class="stri">"PRC_HEAPSTAT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_HSIZE            <span class="keywd">is</span> action <span class="stri">"PRC_HSIZE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_IF               <span class="keywd">is</span> action <span class="stri">"PRC_IF"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_IF_ELSIF         <span class="keywd">is</span> action <span class="stri">"PRC_IF_ELSIF"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_NOOP             <span class="keywd">is</span> action <span class="stri">"PRC_NOOP"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_RAISE            <span class="keywd">is</span> action <span class="stri">"PRC_RAISE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_REPEAT           <span class="keywd">is</span> action <span class="stri">"PRC_REPEAT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_REPEAT_NOOP      <span class="keywd">is</span> action <span class="stri">"PRC_REPEAT_NOOP"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_RETURN           <span class="keywd">is</span> action <span class="stri">"PRC_RETURN"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_WHILE            <span class="keywd">is</span> action <span class="stri">"PRC_WHILE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: PRC_WHILE_NOOP       <span class="keywd">is</span> action <span class="stri">"PRC_WHILE_NOOP"</span>;


<span class="keywd">var</span> <span class="type">reference</span>: currentProfiledFunction <span class="keywd">is</span> NIL;


<span class="keywd">const</span> <span class="type">proc</span>: prc_prototypes (<span class="keywd">inout</span> <span class="type">file</span>: c_prog) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    declareExtern(c_prog, <span class="stri">"genericType hshIdxDefault0 (const const_hashType, const genericType, intType, compareType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        heapStatistic (void);"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_statements (<span class="op">in</span> <span class="type">expr_type</span>: statements, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.currentFile := statements.currentFile;
    c_expr.currentLine := statements.currentLine;
    <span class="keywd">if</span> statements.temp_num &lt;> 0 <span class="keywd">then</span>
      appendWithDiagnostic(statements.temp_decls, c_expr);
      appendWithDiagnostic(statements.temp_assigns, c_expr);
      c_expr.expr &amp;:= statements.expr;
      appendWithDiagnostic(statements.temp_frees, c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= statements.expr;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_statements (<span class="op">in</span> <span class="type">expr_type</span>: condition, <span class="op">in</span> <span class="type">expr_type</span>: statements, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.currentFile := statements.currentFile;
    c_expr.currentLine := statements.currentLine;
    <span class="keywd">if</span> statements.temp_decls &lt;> <span class="stri">""</span> <span class="op">or</span> condition.temp_decls &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      appendWithDiagnostic(statements.temp_decls, c_expr);
      <span class="keywd">if</span> condition.temp_decls &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        appendWithDiagnostic(condition.temp_frees, c_expr);
        appendWithDiagnostic(condition.temp_to_null, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      appendWithDiagnostic(statements.temp_assigns, c_expr);
      c_expr.expr &amp;:= statements.expr;
      appendWithDiagnostic(statements.temp_frees, c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= statements.expr;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_else (<span class="op">in</span> <span class="type">reference</span>: else_part, <span class="op">in</span> <span class="type">boolean</span>: insertKeyword,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">category</span>: functionCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: function <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param2 <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">string</span>: action_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> category(else_part) = MATCHOBJECT <span class="keywd">then</span>
      params := getValue(else_part, ref_list);
      function := params[1];
      params := params[2 ..];
      functionCategory := category(function);
      <span class="keywd">if</span> functionCategory = CONSTENUMOBJECT <span class="keywd">then</span>
        process_call_by_name_expr(params[2], c_param2);
        <span class="keywd">if</span> insertKeyword <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"else {\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        process_statements(c_param2, c_expr);
        <span class="keywd">if</span> insertKeyword <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> functionCategory = ACTOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> insertKeyword <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"else\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.currentFile := file(else_part);
        c_expr.currentLine := line(else_part);
        process_action(function, params, c_expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"/*!!! "</span>;
        c_expr.expr &amp;:= str(functionCategory);
        c_expr.expr &amp;:= <span class="stri">" "</span>;
        c_expr.expr &amp;:= str(function);
        c_expr.expr &amp;:= <span class="stri">" !!!*/"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"/*!! "</span>;
      c_expr.expr &amp;:= str(category(else_part));
      c_expr.expr &amp;:= <span class="stri">" "</span>;
      c_expr.expr &amp;:= str(else_part);
      c_expr.expr &amp;:= <span class="stri">" !!*/"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_prc_if (<span class="op">in</span> <span class="type">boolean</span>: condition, <span class="op">in</span> <span class="type">reference</span>: statement,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_statement <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    incr(countOptimizations);
    <span class="keywd">if</span> condition <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"/* Optimized: if TRUE */ {\n"</span>;
      process_call_by_name_expr(statement, c_statement);
      process_statements(c_statement, c_expr);
      c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"/* Optimized: if FALSE */\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_IF, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_condition <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_statement <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">string</span>: statementFile <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: statementLine <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[2], ENUMLITERALOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_prc_if(getValue(evaluatedParam, boolean), params[4], c_expr);
    <span class="keywd">else</span>
      process_expr(params[2], c_condition);
      process_call_by_name_expr(params[4], c_statement);
      <span class="keywd">if</span> c_condition.temp_num &lt;> 0 <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
        appendWithDiagnostic(c_condition.temp_decls, c_expr);
        appendWithDiagnostic(c_condition.temp_assigns, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      statementFile := c_expr.currentFile;
      statementLine := c_expr.currentLine;
      setDiagnosticLine(c_expr);
      c_expr.expr &amp;:= <span class="stri">"if ("</span>;
      c_expr.expr &amp;:= c_condition.expr;
      <span class="keywd">if</span> endsWith(c_expr.expr, <span class="stri">"\n"</span>) <span class="keywd">then</span>
        setDiagnosticLine(c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">") {\n"</span>;
      process_statements(c_statement, c_expr);
      c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
      <span class="keywd">if</span> c_condition.temp_num &lt;> 0 <span class="keywd">then</span>
        c_expr.currentFile := statementFile;
        c_expr.currentLine := statementLine;
        appendWithDiagnostic(c_condition.temp_frees, c_expr);
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_prc_if_elsif (<span class="op">in</span> <span class="type">boolean</span>: condition, <span class="op">in</span> <span class="type">reference</span>: thenPart,
    <span class="op">in</span> <span class="type">reference</span>: elsePart, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_then_part <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_else_part <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    incr(countOptimizations);
    c_expr.expr &amp;:= <span class="stri">"/* Optimized: if "</span>;
    c_expr.expr &amp;:= str(condition);
    c_expr.expr &amp;:= <span class="stri">" */ {\n"</span>;
    <span class="keywd">if</span> condition <span class="keywd">then</span>
      process_call_by_name_expr(thenPart, c_then_part);
      process_statements(c_then_part, c_expr);
    <span class="keywd">else</span>
      process_else(elsePart, FALSE, c_else_part);
      process_statements(c_else_part, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_IF_ELSIF, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_condition <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_then_part <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_else_part <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">string</span>: statementFile <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: statementLine <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[2], ENUMLITERALOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_prc_if_elsif(getValue(evaluatedParam, boolean),
          params[4], params[5], c_expr);
    <span class="keywd">else</span>
      process_expr(params[2], c_condition);
      process_call_by_name_expr(params[4], c_then_part);
      c_else_part.temp_num := c_condition.temp_num;
      process_else(params[5], TRUE, c_else_part);
      <span class="keywd">if</span> c_else_part.temp_num &lt;> 0 <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
        appendWithDiagnostic(c_condition.temp_decls, c_expr);
        appendWithDiagnostic(c_else_part.temp_decls, c_expr);
        appendWithDiagnostic(c_condition.temp_assigns, c_expr);
        appendWithDiagnostic(c_else_part.temp_assigns, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      statementFile := c_expr.currentFile;
      statementLine := c_expr.currentLine;
      setDiagnosticLine(c_expr);
      c_expr.expr &amp;:= <span class="stri">"if ("</span>;
      c_expr.expr &amp;:= c_condition.expr;
      <span class="keywd">if</span> endsWith(c_expr.expr, <span class="stri">"\n"</span>) <span class="keywd">then</span>
        setDiagnosticLine(c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">") {\n"</span>;
      process_statements(c_then_part, c_expr);
      c_expr.expr &amp;:= <span class="stri">"} "</span>;
      c_expr.expr &amp;:= c_else_part.expr;
      <span class="keywd">if</span> c_else_part.temp_num &lt;> 0 <span class="keywd">then</span>
        c_expr.currentFile := statementFile;
        c_expr.currentLine := statementLine;
        appendWithDiagnostic(c_condition.temp_frees, c_expr);
        appendWithDiagnostic(c_else_part.temp_frees, c_expr);
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_prc_if_noop (<span class="op">in</span> <span class="type">boolean</span>: condition, <span class="op">in</span> <span class="type">reference</span>: statement,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_statement <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    incr(countOptimizations);
    <span class="keywd">if</span> condition <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"/* Optimized: elsif TRUE */\n"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"/* Optimized: elsif FALSE */ {\n"</span>;
      process_call_by_name_expr(statement, c_statement);
      process_statements(c_statement, c_expr);
      c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_IF_NOOP, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_condition <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_else_part <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">string</span>: statementFile <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: statementLine <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[2], ENUMLITERALOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_prc_if_noop(getValue(evaluatedParam, boolean),
          params[4], c_expr);
    <span class="keywd">else</span>
      process_expr(params[2], c_condition);
      c_else_part.temp_num := c_condition.temp_num;
      process_else(params[4], TRUE, c_else_part);
      <span class="keywd">if</span> c_else_part.temp_num &lt;> 0 <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
        appendWithDiagnostic(c_condition.temp_decls, c_expr);
        appendWithDiagnostic(c_else_part.temp_decls, c_expr);
        appendWithDiagnostic(c_condition.temp_assigns, c_expr);
        appendWithDiagnostic(c_else_part.temp_assigns, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      statementFile := c_expr.currentFile;
      statementLine := c_expr.currentLine;
      setDiagnosticLine(c_expr);
      c_expr.expr &amp;:= <span class="stri">"if ("</span>;
      c_expr.expr &amp;:= c_condition.expr;
      <span class="keywd">if</span> endsWith(c_expr.expr, <span class="stri">"\n"</span>) <span class="keywd">then</span>
        setDiagnosticLine(c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">") { /* noop */ } "</span>;
      c_expr.expr &amp;:= c_else_part.expr;
      <span class="keywd">if</span> c_else_part.temp_num &lt;> 0 <span class="keywd">then</span>
        c_expr.currentFile := statementFile;
        c_expr.currentLine := statementLine;
        appendWithDiagnostic(c_condition.temp_frees, c_expr);
        appendWithDiagnostic(c_else_part.temp_frees, c_expr);
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_WHILE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_condition <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_statement <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">string</span>: statementFile <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: statementLine <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    c_condition.temp_num := c_expr.temp_num;
    process_call_by_name_expr(params[2], c_condition);
    c_statement.temp_num := c_condition.temp_num;
    process_call_by_name_expr(params[4], c_statement);
    c_expr.temp_num := c_statement.temp_num;
    <span class="keywd">if</span> c_condition.temp_decls &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      appendWithDiagnostic(c_condition.temp_decls, c_expr);
      appendWithDiagnostic(c_condition.temp_assigns, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    statementFile := c_expr.currentFile;
    statementLine := c_expr.currentLine;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"while ("</span>;
    c_expr.expr &amp;:= c_condition.expr;
    c_expr.expr &amp;:= <span class="stri">") {\n"</span>;
    process_statements(c_condition, c_statement, c_expr);
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">if</span> c_condition.temp_decls &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.currentFile := statementFile;
      c_expr.currentLine := statementLine;
      appendWithDiagnostic(c_condition.temp_frees, c_expr);
      c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_WHILE_NOOP, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_condition <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    c_condition.temp_num := c_expr.temp_num;
    process_call_by_name_expr(params[2], c_condition);
    c_expr.temp_num := c_condition.temp_num;
    <span class="keywd">if</span> c_condition.temp_decls &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      appendWithDiagnostic(c_condition.temp_decls, c_expr);
      appendWithDiagnostic(c_condition.temp_assigns, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"while ("</span>;
    c_expr.expr &amp;:= c_condition.expr;
    c_expr.expr &amp;:= <span class="stri">") {\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">if</span> c_condition.temp_decls &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.currentFile := file(params[2]);
      c_expr.currentLine := line(params[2]);
      appendWithDiagnostic(c_condition.temp_frees, c_expr);
      c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_REPEAT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_condition <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_statement <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    c_condition.temp_num := c_expr.temp_num;
    process_call_by_name_expr(params[4], c_condition);
    c_statement.temp_num := c_condition.temp_num;
    process_call_by_name_expr(params[2], c_statement);
    c_expr.temp_num := c_statement.temp_num;
    <span class="keywd">if</span> c_condition.temp_decls &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      appendWithDiagnostic(c_condition.temp_decls, c_expr);
      appendWithDiagnostic(c_condition.temp_assigns, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"do {\n"</span>;
    process_statements(c_condition, c_statement, c_expr);
    c_expr.expr &amp;:= diagnosticLine(params[4]);
    c_expr.expr &amp;:= <span class="stri">"} while (!("</span>;
    c_expr.expr &amp;:= c_condition.expr;
    c_expr.expr &amp;:= <span class="stri">"));\n"</span>;
    <span class="keywd">if</span> c_condition.temp_decls &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.currentFile := file(params[4]);
      c_expr.currentLine := line(params[4]);
      appendWithDiagnostic(c_condition.temp_frees, c_expr);
      c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_REPEAT_NOOP, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_condition <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    c_condition.temp_num := c_expr.temp_num;
    process_call_by_name_expr(params[3], c_condition);
    c_expr.temp_num := c_condition.temp_num;
    <span class="keywd">if</span> c_condition.temp_decls &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      appendWithDiagnostic(c_condition.temp_decls, c_expr);
      appendWithDiagnostic(c_condition.temp_assigns, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"do {\n"</span>;
    c_expr.expr &amp;:= diagnosticLine(params[3]);
    c_expr.expr &amp;:= <span class="stri">"} while (!("</span>;
    c_expr.expr &amp;:= c_condition.expr;
    c_expr.expr &amp;:= <span class="stri">"));\n"</span>;
    <span class="keywd">if</span> c_condition.temp_decls &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.currentFile := file(params[3]);
      c_expr.currentLine := line(params[3]);
      appendWithDiagnostic(c_condition.temp_frees, c_expr);
      c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: processFuncValue (<span class="op">in</span> <span class="type">string</span>: valueName, <span class="op">in</span> <span class="type">type</span>: genericFuncType,
    <span class="op">in</span> <span class="type">reference</span>: closure, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_RETURN, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: valueName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    create_name(params[2], objNumber(params[2]), valueName);
    processFuncValue(valueName, resultType(getType(function)), params[2], c_expr);
    c_expr.result_expr := c_expr.expr;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: varChangedInStatements (<span class="op">in</span> <span class="type">reference</span>: variable,
    <span class="op">in</span> <span class="type">reference</span>: statements) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: varChangedInStatements <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">category</span>: currCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">reference</span>: function <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">ref_list</span>: actualParams <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">ref_list</span>: formalParams <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reference</span>: actualParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">reference</span>: formalParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    currCategory := category(statements);
    <span class="comment"># writeln("currCategory: " &lt;&amp; str(currCategory));</span>
    <span class="keywd">if</span> currCategory = CALLOBJECT <span class="op">or</span> currCategory = MATCHOBJECT <span class="keywd">then</span>
      actualParams := getValue(statements, ref_list);
      function := actualParams[1];
      actualParams := actualParams[2 ..];
      formalParams := formalParams(function);
      <span class="keywd">for</span> actualParam <span class="keywd">range</span> actualParams <span class="keywd">do</span>
        incr(index);
        <span class="keywd">if</span> actualParam = variable <span class="keywd">then</span>
          <span class="comment"># writeln("  variable used: " &lt;&amp; file(statements) &lt;&amp; "(" &lt;&amp; line(statements) &lt;&amp; ")");</span>
          formalParam := formalParams[index];
          <span class="keywd">if</span> category(formalParam) = REFPARAMOBJECT <span class="op">and</span> isVar(formalParam) <span class="keywd">then</span>
            <span class="comment"># writeln("    ***** Variable changed");</span>
            varChangedInStatements := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> category(actualParam) = CALLOBJECT <span class="op">or</span> category(actualParam) = MATCHOBJECT <span class="keywd">then</span>
          varChangedInStatements := varChangedInStatements <span class="op">or</span>
              varChangedInStatements(variable, actualParam);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_prc_for (<span class="op">in</span> <span class="type">reference</span>: variable, <span class="op">in</span> <span class="type">reference</span>: startExpr,
    <span class="op">in</span> <span class="type">reference</span>: endExpr, <span class="op">in</span> <span class="type">reference</span>: incrStep, <span class="op">in</span> <span class="type">reference</span>: statements,
    <span class="op">in</span> <span class="type">boolean</span>: for_to, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_start_expr <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: start_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: end_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: step_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: constant_start_value <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: start_value <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: constant_end_value <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: end_value <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: raises_exception <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">intRange</span>: variableRange <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(startExpr, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      constant_start_value := TRUE;
      start_value := getValue(evaluatedParam, integer);
      start_name := integerLiteral(start_value);
    <span class="keywd">else</span>
      start_name := defineForStartVariable(<span class="stri">"intType"</span>, <span class="stri">"start_"</span>, startExpr, statement);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> getConstant(endExpr, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      constant_end_value := TRUE;
      end_value := getValue(evaluatedParam, integer);
      end_name := integerLiteral(end_value);
    <span class="keywd">else</span>
      end_name := defineTempConstant(<span class="stri">"intType"</span>, <span class="stri">"end_"</span>, endExpr, statement);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> incrStep &lt;> NIL <span class="keywd">then</span>
      <span class="keywd">if</span> getConstant(incrStep, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
        step_name := integerLiteral(getValue(evaluatedParam, integer));
      <span class="keywd">else</span>
        step_name := defineTempConstant(<span class="stri">"intType"</span>, <span class="stri">"step_"</span>, incrStep, statement);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> for_loop_variable_check <span class="op">and</span> incrStep = NIL <span class="keywd">then</span>
      <span class="keywd">if</span> constant_end_value <span class="keywd">then</span>
        <span class="keywd">if</span> for_to <span class="keywd">then</span>
          <span class="keywd">if</span> end_value = integer.last <span class="keywd">then</span>
            warning(DOES_RAISE, <span class="stri">"RANGE_ERROR"</span>, c_expr);
            statement.expr &amp;:= raiseError(<span class="stri">"RANGE_ERROR"</span>);
            statement.expr &amp;:= <span class="stri">"\n"</span>;
            raises_exception := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          <span class="keywd">if</span> end_value = integer.first <span class="keywd">then</span>
            warning(DOES_RAISE, <span class="stri">"RANGE_ERROR"</span>, c_expr);
            statement.expr &amp;:= raiseError(<span class="stri">"RANGE_ERROR"</span>);
            statement.expr &amp;:= <span class="stri">"\n"</span>;
            raises_exception := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        incr(countRangeChecks);
        statement.expr &amp;:= <span class="stri">"if (rngChk("</span>;
        statement.expr &amp;:= end_name;
        statement.expr &amp;:= <span class="stri">"=="</span>;
        <span class="keywd">if</span> for_to <span class="keywd">then</span>
          statement.expr &amp;:= integerLiteral(integer.last);
        <span class="keywd">else</span>
          statement.expr &amp;:= integerLiteral(integer.first);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        statement.expr &amp;:= <span class="stri">"))"</span>;
        statement.expr &amp;:= raiseError(<span class="stri">"RANGE_ERROR"</span>);
        statement.expr &amp;:= <span class="stri">"\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="op">not</span> raises_exception <span class="keywd">then</span>
      statement.expr &amp;:= <span class="stri">"for ("</span>;
      process_expr(variable, statement);
      statement.expr &amp;:= <span class="stri">"="</span>;
      statement.expr &amp;:= start_name;
      statement.expr &amp;:= <span class="stri">"; "</span>;
      process_expr(variable, statement);
      <span class="keywd">if</span> for_to <span class="keywd">then</span>
        statement.expr &amp;:= <span class="stri">"&lt;="</span>;
      <span class="keywd">else</span>
        statement.expr &amp;:= <span class="stri">">="</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      statement.expr &amp;:= end_name;
      statement.expr &amp;:= <span class="stri">"; ("</span>;
      process_expr(variable, statement);
      <span class="keywd">if</span> for_to <span class="keywd">then</span>
        <span class="keywd">if</span> incrStep = NIL <span class="keywd">then</span>
          statement.expr &amp;:= <span class="stri">")++) {\n"</span>;
        <span class="keywd">else</span>
          statement.expr &amp;:= <span class="stri">")+="</span>;
          statement.expr &amp;:= step_name;
          statement.expr &amp;:= <span class="stri">") {\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        <span class="keywd">if</span> incrStep = NIL <span class="keywd">then</span>
          statement.expr &amp;:= <span class="stri">")--) {\n"</span>;
        <span class="keywd">else</span>
          statement.expr &amp;:= <span class="stri">")-="</span>;
          statement.expr &amp;:= step_name;
          statement.expr &amp;:= <span class="stri">") {\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> category(variable) = LOCALVOBJECT <span class="op">and</span>
          (constant_start_value <span class="op">or</span> constant_end_value) <span class="op">and</span>
          <span class="op">not</span> varChangedInStatements(variable, statements) <span class="keywd">then</span>
        <span class="keywd">if</span> constant_start_value <span class="keywd">then</span>
          variableRange.minValue := start_value;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> constant_end_value <span class="keywd">then</span>
          variableRange.maxValue := end_value;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="comment"># write(file(statements) &lt;&amp; "(" &lt;&amp; line(statements) &lt;&amp; ") ");</span>
        <span class="comment"># writeln("for variable range: " &lt;&amp; variableRange.minValue &lt;&amp; ".." &lt;&amp; variableRange.maxValue);</span>
        intRangeOfVariable @:= [variable] variableRange;
        process_call_by_name_expr(statements, statement);
        excl(intRangeOfVariable, variable);
      <span class="keywd">else</span>
        process_call_by_name_expr(statements, statement);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      statement.expr &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    doLocalDeclsOfStatement(statement, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_FOR_DOWNTO, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    process_prc_for(params[2], params[4], params[6], NIL, params[8], FALSE, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_FOR_DOWNTO_STEP, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    process_prc_for(params[2], params[4], params[6], params[8], params[10], FALSE, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_FOR_TO, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    process_prc_for(params[2], params[4], params[6], NIL, params[8], TRUE, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_FOR_TO_STEP, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    process_prc_for(params[2], params[4], params[6], params[8], params[10], TRUE, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_bitset (<span class="op">in</span> <span class="type">bitset</span>: currentSet, <span class="op">in</span> <span class="type">string</span>: diagnosticLine,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> number <span class="keywd">range</span> currentSet <span class="keywd">do</span>
      c_expr.expr &amp;:= diagnosticLine;
      c_expr.expr &amp;:= <span class="stri">"case "</span>;
      c_expr.expr &amp;:= str(number);
      c_expr.expr &amp;:= <span class="stri">":\n"</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: allWhenValuesType <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">reference</span><span class="type">]</span> <span class="type">bitset</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_case_labels (<span class="op">in</span> <span class="type">reference</span>: current_expression,
    <span class="keywd">inout</span> <span class="type">allWhenValuesType</span>: allWhenValues, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: case_labels <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">category</span>: labelCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">bitset</span>: currentWhenValues <span class="keywd">is</span> bitset.EMPTY_SET;
    <span class="keywd">var</span> <span class="type">reference</span>: whenReference <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">bitset</span>: whenValues <span class="keywd">is</span> bitset.EMPTY_SET;
  <span class="keywd">begin</span>
    case_labels := evaluate(prog, current_expression);
    labelCategory := category(case_labels);
    <span class="keywd">if</span> labelCategory = SETOBJECT <span class="keywd">then</span>
      currentWhenValues := getValue(case_labels, bitset);
      <span class="keywd">for</span> whenValues <span class="keywd">key</span> whenReference <span class="keywd">range</span> allWhenValues <span class="keywd">do</span>
        <span class="keywd">if</span> whenValues &amp; currentWhenValues &lt;> bitset.EMPTY_SET <span class="keywd">then</span>
          error(WHEN_OVERLAPPING, whenValues &amp; currentWhenValues,
                current_expression);
          error(WHEN_PREVIOUS, whenValues &amp; currentWhenValues,
                whenReference);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      process_bitset(currentWhenValues,
          diagnosticLine(current_expression), c_expr);
      allWhenValues @:= [current_expression] currentWhenValues;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"/* case "</span>;
      c_expr.expr &amp;:= str(labelCategory);
      c_expr.expr &amp;:= <span class="stri">" */"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_when (<span class="op">in</span> <span class="type">reference</span>: when_expr,
    <span class="keywd">inout</span> <span class="type">allWhenValuesType</span>: allWhenValues, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
  <span class="keywd">begin</span>
    params := getValue(when_expr, ref_list);
    params := params[2 ..];
    process_case_labels(params[2], allWhenValues, c_expr);
    process_call_by_name_expr(params[4], c_expr);
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"break;\n"</span>;
    <span class="keywd">if</span> length(params) >= 5 <span class="keywd">then</span>
      process_when(params[5], allWhenValues, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: generate_switch (<span class="op">in</span> <span class="type">reference</span>: controlExpr,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: controlExprType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"switch ("</span>;
    controlExprType := getExprResultType(controlExpr);
    <span class="keywd">if</span> controlExprType <span class="op">in</span> typeCategory <span class="op">and</span>
        typeCategory[controlExprType] = CHAROBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"(scharType)("</span>;
      process_expr(controlExpr, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">elsif</span> ccConf.SWITCH_WORKS_FOR_INT64TYPE <span class="keywd">then</span>
      process_expr(controlExpr, c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"(int32Type)("</span>;
      process_expr(controlExpr, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">") {\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_CASE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">allWhenValuesType</span>: allWhenValues <span class="keywd">is</span> allWhenValuesType.value;
  <span class="keywd">begin</span>
    generate_switch(params[2], c_expr);
    process_when(params[4], allWhenValues, c_expr);
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_CASE_DEF, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">allWhenValuesType</span>: allWhenValues <span class="keywd">is</span> allWhenValuesType.value;
  <span class="keywd">begin</span>
    generate_switch(params[2], c_expr);
    process_when(params[4], allWhenValues, c_expr);
    c_expr.expr &amp;:= <span class="stri">"default:\n"</span>;
    process_call_by_name_expr(params[7], c_expr);
    c_expr.expr &amp;:= <span class="stri">"break;\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: caseTableType <span class="keywd">is</span> <span class="type">array</span> <span class="type">reference</span>;
<span class="keywd">const</span> <span class="type">type</span>: allCaseTablesType <span class="keywd">is</span> <span class="type">array</span> <span class="type">caseTableType</span>;

<span class="keywd">var</span> <span class="type">allCaseTablesType</span>: case_table <span class="keywd">is</span> [0 .. -1] <span class="op">times</span> 0 <span class="op">times</span> NIL;


<span class="keywd">const</span> <span class="type">proc</span>: process_hashcode (<span class="op">in</span> <span class="type">reference</span>: current_object, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">forward</span>;
<span class="keywd">const</span> <span class="type">proc</span>: object_address (<span class="op">in</span> <span class="type">reference</span>: current_object, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: compareObj (<span class="op">in</span> <span class="type">reference</span>: current_object) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">reference</span>: keyCompare <span class="keywd">is</span> NIL;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: param_list <span class="keywd">is</span> ref_list.EMPTY;
  <span class="keywd">begin</span>
    param_list := make_list(current_object);
    param_list &amp;:= make_list(current_object);
    param_list &amp;:= make_list(syobject(prog, <span class="stri">"compare"</span>));
    keyCompare := matchExpr(prog, param_list);
    keyCompare := getValue(keyCompare, ref_list)[1];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_case_labels (<span class="op">in</span> <span class="type">integer</span>: numOfCaseStmt, <span class="op">in</span> <span class="type">integer</span>: numOfWhenPart,
    <span class="op">in</span> <span class="type">reference</span>: current_expression, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: case_labels <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">category</span>: labelCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">bitset</span>: currentWhenValues <span class="keywd">is</span> bitset.EMPTY_SET;
  <span class="keywd">begin</span>
    case_labels := evaluate(prog, current_expression);
    labelCategory := category(case_labels);
    <span class="keywd">if</span> labelCategory = HASHOBJECT <span class="keywd">then</span>
      case_table[numOfCaseStmt] &amp;:= case_labels;
      c_expr.expr &amp;:= diagnosticLine(current_expression);
      c_expr.expr &amp;:= <span class="stri">"case "</span>;
      c_expr.expr &amp;:= str(numOfWhenPart);
      c_expr.expr &amp;:= <span class="stri">":\n"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"/* case "</span>;
      c_expr.expr &amp;:= str(labelCategory);
      c_expr.expr &amp;:= <span class="stri">" */"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_when (<span class="op">in</span> <span class="type">integer</span>: numOfCaseStmt, <span class="op">in</span> <span class="type">integer</span>: numOfWhenPart,
    <span class="op">in</span> <span class="type">reference</span>: when_expr, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
  <span class="keywd">begin</span>
    params := getValue(when_expr, ref_list);
    params := params[2 ..];  <span class="comment"># Skip function reference</span>
    process_case_labels(numOfCaseStmt, numOfWhenPart, params[2], c_expr);
    process_call_by_name_expr(params[4], c_expr);
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"break;\n"</span>;
    <span class="keywd">if</span> length(params) >= 5 <span class="keywd">then</span>
      process_when(numOfCaseStmt, succ(numOfWhenPart), params[5], c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_CASE_HASHSET, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: numOfCaseStmt <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reference</span>: switchValue <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    case_table &amp;:= 0 <span class="op">times</span> NIL;
    numOfCaseStmt := maxIdx(case_table);
    switchValue := getParameterAsVariable(params[2], statement);
    statement.expr &amp;:= diagnosticLine(c_expr);
    statement.expr &amp;:= <span class="stri">"switch ("</span>;
    <span class="keywd">if</span> <span class="op">not</span> ccConf.SWITCH_WORKS_FOR_INT64TYPE <span class="keywd">then</span>
      statement.expr &amp;:= <span class="stri">"(int32Type) "</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    statement.expr &amp;:= <span class="stri">"hshIdxDefault0(caseLabels["</span>;
    statement.expr &amp;:= str(numOfCaseStmt);
    statement.expr &amp;:= <span class="stri">"], "</span>;
    <span class="keywd">if</span> isNormalVariable(params[2]) <span class="keywd">then</span>
      getGenericValue(switchValue, statement);
    <span class="keywd">else</span>
      getGenericValueOfVariableObject(switchValue, statement);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    statement.expr &amp;:= <span class="stri">", "</span>;
    process_hashcode(switchValue, statement);
    statement.expr &amp;:= <span class="stri">", "</span>;
    object_address(compareObj(params[2]), statement);
    statement.expr &amp;:= <span class="stri">")) {\n"</span>;
    process_when(numOfCaseStmt, 1, params[4], statement);
    setDiagnosticLine(statement);
    statement.expr &amp;:= <span class="stri">"}\n"</span>;
    doLocalDeclsOfStatement(statement, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_CASE_HASHSET_DEF, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: numOfCaseStmt <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reference</span>: switchValue <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    case_table &amp;:= 0 <span class="op">times</span> NIL;
    numOfCaseStmt := maxIdx(case_table);
    switchValue := getParameterAsVariable(params[2], statement);
    statement.expr &amp;:= diagnosticLine(c_expr);
    statement.expr &amp;:= <span class="stri">"switch ("</span>;
    <span class="keywd">if</span> <span class="op">not</span> ccConf.SWITCH_WORKS_FOR_INT64TYPE <span class="keywd">then</span>
      statement.expr &amp;:= <span class="stri">"(int32Type) "</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    statement.expr &amp;:= <span class="stri">"hshIdxDefault0(caseLabels["</span>;
    statement.expr &amp;:= str(numOfCaseStmt);
    statement.expr &amp;:= <span class="stri">"], "</span>;
    <span class="keywd">if</span> isNormalVariable(params[2]) <span class="keywd">then</span>
      getGenericValue(switchValue, statement);
    <span class="keywd">else</span>
      getGenericValueOfVariableObject(switchValue, statement);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    statement.expr &amp;:= <span class="stri">", "</span>;
    process_hashcode(switchValue, statement);
    statement.expr &amp;:= <span class="stri">", "</span>;
    object_address(compareObj(params[2]), statement);
    statement.expr &amp;:= <span class="stri">")) {\n"</span>;
    process_when(numOfCaseStmt, 1, params[4], statement);
    statement.expr &amp;:= diagnosticLine(params[7]);
    statement.expr &amp;:= <span class="stri">"default:\n"</span>;
    process_call_by_name_expr(params[7], statement);
    setDiagnosticLine(statement);
    statement.expr &amp;:= <span class="stri">"break;\n"</span>;
    setDiagnosticLine(statement);
    statement.expr &amp;:= <span class="stri">"}\n"</span>;
    doLocalDeclsOfStatement(statement, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_BLOCK, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: current_catch <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">ref_list</span>: catch_expr <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: catch_value <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"int fail_value;\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"catch_stack_pos++;\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"if (unlikely(catch_stack_pos >= max_catch_stack)) {\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"  resize_catch_stack();\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"if (likely((fail_value = do_setjmp(catch_stack[catch_stack_pos])) == 0)) {\n"</span>;
    increaseLevelOfCatchedExceptions(params[4]);
    process_call_by_name_expr(params[2], c_expr);
    decreaseLevelOfCatchedExceptions(params[4]);
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"catch_stack_pos--;\n"</span>;
    current_catch := params[4];
    catch_expr := getValue(current_catch, ref_list);
    c_expr.expr &amp;:= diagnosticLine(current_catch);
    c_expr.expr &amp;:= <span class="stri">"} else {\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"catch_stack_pos--;\n"</span>;
    <span class="comment"># c_expr.expr &amp;:= "printf(\"catch %d\\n\", fail_value);\n";</span>
    <span class="keywd">while</span> current_catch &lt;> NIL <span class="op">and</span>
        category(current_catch) = MATCHOBJECT <span class="op">and</span>
        length(catch_expr) >= 5 <span class="keywd">do</span>
      catch_value := catch_expr[3];
      checkWarning(CATCH_WITH_SUPPRESSED_CHECK, str(catch_value), current_catch);
      c_expr.expr &amp;:= diagnosticLine(current_catch);
      c_expr.expr &amp;:= <span class="stri">"if ("</span>;
      process_expr(catch_value, c_expr);
      c_expr.expr &amp;:= <span class="stri">" == fail_value - 1) {\n"</span>;
      process_call_by_name_expr(catch_expr[5], c_expr);
      <span class="keywd">if</span> length(catch_expr) >= 6 <span class="keywd">then</span>
        c_expr.expr &amp;:= diagnosticLine(current_catch);
        c_expr.expr &amp;:= <span class="stri">"} else\n"</span>;
        current_catch := catch_expr[6];
        catch_expr := getValue(current_catch, ref_list);
      <span class="keywd">else</span>
        incr(c_expr.currentLine);
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"} else {\n"</span>;
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"  rtlRaiseError(fail_value, error_file, error_line);\n"</span>;
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
        current_catch := NIL;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_BLOCK_CATCH_ALL, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"int fail_value;\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"catch_stack_pos++;\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"if (unlikely(catch_stack_pos >= max_catch_stack)) {\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"  resize_catch_stack();\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"if (likely((fail_value = do_setjmp(catch_stack[catch_stack_pos])) == 0)) {\n"</span>;
    incr(catchAllExceptionsLevel);
    process_call_by_name_expr(params[2], c_expr);
    decr(catchAllExceptionsLevel);
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"catch_stack_pos--;\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"} else {\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"catch_stack_pos--;\n"</span>;
    checkWarning(CATCH_OTHERWISE_WITH_SUPPRESSED_CHECK, params[6]);
    process_call_by_name_expr(params[6], c_expr);
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_BLOCK_OTHERWISE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: current_catch <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">ref_list</span>: catch_expr <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: catch_value <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"int fail_value;\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"catch_stack_pos++;\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"if (unlikely(catch_stack_pos >= max_catch_stack)) {\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"  resize_catch_stack();\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"if (likely((fail_value = do_setjmp(catch_stack[catch_stack_pos])) == 0)) {\n"</span>;
    increaseLevelOfCatchedExceptions(params[4]);
    incr(catchAllExceptionsLevel);
    process_call_by_name_expr(params[2], c_expr);
    decreaseLevelOfCatchedExceptions(params[4]);
    decr(catchAllExceptionsLevel);
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"catch_stack_pos--;\n"</span>;
    current_catch := params[4];
    catch_expr := getValue(current_catch, ref_list);
    c_expr.expr &amp;:= diagnosticLine(current_catch);
    c_expr.expr &amp;:= <span class="stri">"} else {\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"catch_stack_pos--;\n"</span>;
    <span class="comment"># c_expr.expr &amp;:= "printf(\"catch %d\\n\", fail_value);\n";</span>
    <span class="keywd">while</span> current_catch &lt;> NIL <span class="op">and</span>
        category(current_catch) = MATCHOBJECT <span class="op">and</span>
        length(catch_expr) >= 5 <span class="keywd">do</span>
      catch_value := catch_expr[3];
      checkWarning(CATCH_WITH_SUPPRESSED_CHECK, str(catch_value), current_catch);
      c_expr.expr &amp;:= diagnosticLine(current_catch);
      c_expr.expr &amp;:= <span class="stri">"if ("</span>;
      process_expr(catch_value, c_expr);
      c_expr.expr &amp;:= <span class="stri">" == fail_value - 1) {\n"</span>;
      process_call_by_name_expr(catch_expr[5], c_expr);
      <span class="keywd">if</span> length(catch_expr) >= 6 <span class="keywd">then</span>
        c_expr.expr &amp;:= diagnosticLine(current_catch);
        c_expr.expr &amp;:= <span class="stri">"} else\n"</span>;
        current_catch := catch_expr[6];
        catch_expr := getValue(current_catch, ref_list);
      <span class="keywd">else</span>
        incr(c_expr.currentLine);
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"} else {\n"</span>;
        checkWarning(CATCH_OTHERWISE_WITH_SUPPRESSED_CHECK, params[7]);
        process_call_by_name_expr(params[7], c_expr);
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
        current_catch := NIL;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_func_call (<span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: actual_params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_DYNAMIC, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    process_func_call(function, params, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_EXIT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"doExit("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">");\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_HEAPSTAT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    compDataLibraryUsed := TRUE;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"heapStatistic();\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_HSIZE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"heapsize()"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_prc_semicol (<span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: statement <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">ref_list</span>: semicolParams <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">boolean</span>: finished <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    process_call_by_name_expr(params[1], c_expr);
    statement := params[3];
    <span class="keywd">repeat</span>
      <span class="keywd">if</span> category(statement) = CALLOBJECT <span class="keywd">then</span>
        semicolParams := getValue(statement, ref_list);
        <span class="keywd">if</span> length(semicolParams) = 4 <span class="op">and</span>
            category(semicolParams[1]) = ACTOBJECT <span class="op">and</span>
            str(getValue(semicolParams[1], ACTION)) = <span class="stri">"PRC_NOOP"</span> <span class="op">and</span>
            str(semicolParams[3]) = <span class="stri">";"</span> <span class="keywd">then</span>
          process_call_by_name_expr(semicolParams[2], c_expr);
          statement := semicolParams[4];
        <span class="keywd">else</span>
          process_call_by_name_expr(statement, c_expr);
          finished := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        process_call_by_name_expr(statement, c_expr);
        finished := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> finished;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: do_noop_param (<span class="op">in</span> <span class="type">reference</span>: formal_param, <span class="op">in</span> <span class="type">reference</span>: actual_param,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">category</span>: paramCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">type</span>: object_type <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    paramCategory := category(actual_param);
    <span class="keywd">if</span> paramCategory &lt;> SYMBOLOBJECT <span class="op">and</span>
        category(formal_param) &lt;> SYMBOLOBJECT <span class="keywd">then</span>
      object_type := getType(formal_param);
      <span class="keywd">if</span> isFunc(object_type) <span class="op">or</span> isVarfunc(object_type) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"/*expression*/"</span>;
<span class="comment">(*
        if getType(formal_param) &lt;> getType(actual_param) then
          PRINT("***###***\n");
        end if;
        object_type := resultType(object_type);
        TRACE(object_type); PRINT("\n");
        TRACE_OBJ(actual_param); PRINT("\n\n");
*)</span>
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"/* "</span>;
        c_expr.expr &amp;:= str(paramCategory);
        <span class="keywd">if</span> paramCategory = MATCHOBJECT <span class="keywd">then</span>
          paramCategory := category(getValue(actual_param, ref_list)[1]);
          c_expr.expr &amp;:= <span class="stri">" "</span>;
          c_expr.expr &amp;:= str(paramCategory);
          <span class="keywd">if</span> paramCategory = ACTOBJECT <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">" "</span>;
            c_expr.expr &amp;:= str(getValue(getValue(actual_param, ref_list)[1], ACTION));
          <span class="keywd">end</span> <span class="keywd">if</span>
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">" */"</span>;
        getAnyParamToExpr(actual_param, c_expr);
        c_expr.expr &amp;:= <span class="stri">";"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"/*"</span>;
      c_expr.expr &amp;:= str(actual_param);
      c_expr.expr &amp;:= <span class="stri">"*/"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: noop_params (<span class="op">in</span> <span class="type">ref_list</span>: formal_params,
    <span class="op">in</span> <span class="type">ref_list</span>: actual_params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> length(formal_params) <span class="keywd">do</span>
      <span class="keywd">if</span> number &lt;= length(actual_params) <span class="keywd">then</span>
        do_noop_param(formal_params[number], actual_params[number], c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_prc_other_noop (<span class="op">in</span> <span class="type">reference</span>: function, <span class="op">in</span> <span class="type">ref_list</span>: params,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"/*noop*/"</span>;
    noop_params(formalParams(function), params, c_expr);
    c_expr.expr &amp;:= <span class="stri">"\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_NOOP, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(params) = 3 <span class="op">and</span> str(params[2]) = <span class="stri">";"</span> <span class="keywd">then</span>
      process_prc_semicol(params, c_expr);
    <span class="keywd">else</span>
      process_prc_other_noop(function, params, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_ARGS, <span class="op">in</span> <span class="type">reference</span>: function, <span class="op">in</span> <span class="type">ref_list</span>: params,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"("</span>;
    c_expr.expr &amp;:= type_name(resultType(getType(function)));
    c_expr.expr &amp;:= <span class="stri">")(arg_v)"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_CPY, <span class="op">in</span> <span class="type">reference</span>: function, <span class="op">in</span> <span class="type">ref_list</span>: params,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">category</span>: paramCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">string</span>: valueName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    setDiagnosticLine(c_expr);
    <span class="keywd">if</span> category(params[1]) = REFPARAMOBJECT <span class="op">and</span>
        params[1] <span class="op">in</span> inlineParam <span class="op">and</span>
        inlineParam[params[1]][1].paramValue &lt;> NIL <span class="keywd">then</span>
      process_expr(inlineParam[params[1]][1].paramValue, c_expr);
    <span class="keywd">else</span>
      process_expr(params[1], c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">" = "</span>;
    <span class="keywd">if</span> isVar(params[3]) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(params[3], c_expr.expr);
    <span class="keywd">elsif</span> getType(params[1]) = resultType(getType(params[3])) <span class="keywd">then</span>
      process_expr(params[3], c_expr);
    <span class="keywd">elsif</span> getType(params[1]) = getType(params[3]) <span class="keywd">then</span>
      create_name(params[3], objNumber(params[3]), valueName);
      processFuncValue(valueName, getType(params[3]), params[3], c_expr);
    <span class="keywd">else</span>
      paramCategory := category(params[3]);
      <span class="keywd">if</span> paramCategory = MATCHOBJECT <span class="op">or</span> paramCategory = CALLOBJECT <span class="op">or</span>
          paramCategory = BLOCKOBJECT <span class="keywd">then</span>
        create_name(params[3], objNumber(params[3]), valueName);
        processFuncValue(valueName, getType(params[3]), params[3], c_expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(params[3], c_expr.expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">";\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (PRC_RAISE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> profile_function <span class="op">and</span> catchAllExceptionsLevel = 0 <span class="op">and</span>
        (str(params[2]) <span class="op">not</span> <span class="op">in</span> catchExceptionLevel <span class="op">or</span> catchExceptionLevel[str(params[2])] = 0) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"profile["</span>;
      c_expr.expr &amp;:= str(objNumber(currentProfiledFunction));
      c_expr.expr &amp;:= <span class="stri">"].depth--;\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"if (profile["</span>;
      c_expr.expr &amp;:= str(objNumber(currentProfiledFunction));
      c_expr.expr &amp;:= <span class="stri">"].depth == 0) {\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"  profile["</span>;
      c_expr.expr &amp;:= str(objNumber(currentProfiledFunction));
      c_expr.expr &amp;:= <span class="stri">"].time += timMicroSec();\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"rtlRaiseError("</span>;
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &amp;:= <span class="stri">"+1, "</span>;
    c_expr.expr &amp;:= sourceNameString(c_expr.currentFile);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    c_expr.expr &amp;:= str(c_expr.currentLine);
    c_expr.expr &amp;:= <span class="stri">");\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
