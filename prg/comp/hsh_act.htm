<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../../style1.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  hsh_act.s7i   Generate code for actions of the type hash.       *)</span>
<span class="comment">(*  Copyright (C) 1990 - 1994, 2004 - 2014  Thomas Mertes           *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 compiler.                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">const</span> <span class="type">ACTION</span>: HSH_CONTAINS      <span class="keywd">is</span> action <span class="stri">"HSH_CONTAINS"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: HSH_CPY           <span class="keywd">is</span> action <span class="stri">"HSH_CPY"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: HSH_CREATE        <span class="keywd">is</span> action <span class="stri">"HSH_CREATE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: HSH_DESTR         <span class="keywd">is</span> action <span class="stri">"HSH_DESTR"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: HSH_EXCL          <span class="keywd">is</span> action <span class="stri">"HSH_EXCL"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: HSH_FOR           <span class="keywd">is</span> action <span class="stri">"HSH_FOR"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: HSH_FOR_DATA_KEY  <span class="keywd">is</span> action <span class="stri">"HSH_FOR_DATA_KEY"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: HSH_FOR_KEY       <span class="keywd">is</span> action <span class="stri">"HSH_FOR_KEY"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: HSH_IDX           <span class="keywd">is</span> action <span class="stri">"HSH_IDX"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: HSH_IDX2          <span class="keywd">is</span> action <span class="stri">"HSH_IDX2"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: HSH_INCL          <span class="keywd">is</span> action <span class="stri">"HSH_INCL"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: HSH_KEYS          <span class="keywd">is</span> action <span class="stri">"HSH_KEYS"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: HSH_LNG           <span class="keywd">is</span> action <span class="stri">"HSH_LNG"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: HSH_RAND_KEY      <span class="keywd">is</span> action <span class="stri">"HSH_RAND_KEY"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: HSH_UPDATE        <span class="keywd">is</span> action <span class="stri">"HSH_UPDATE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: HSH_VALUES        <span class="keywd">is</span> action <span class="stri">"HSH_VALUES"</span>;


<span class="keywd">const</span> <span class="type">proc</span>: hsh_prototypes (<span class="keywd">inout</span> <span class="type">file</span>: c_prog) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    declareExtern(c_prog, <span class="stri">"boolType    hshContains (const const_hashType, const genericType, intType, compareType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        hshCpy (hashType *const, const const_hashType, const createFuncType, const destrFuncType, const createFuncType, const destrFuncType);"</span>);
    declareExtern(c_prog, <span class="stri">"hashType    hshCreate (const const_hashType, const createFuncType, const destrFuncType, const createFuncType, const destrFuncType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        hshDestr (const const_hashType, const destrFuncType, const destrFuncType);"</span>);
    declareExtern(c_prog, <span class="stri">"hashType    hshEmpty (void);"</span>);
    declareExtern(c_prog, <span class="stri">"void        hshExcl (const hashType, const genericType, intType, compareType, const destrFuncType, const destrFuncType);"</span>);
    declareExtern(c_prog, <span class="stri">"genericType hshIdx (const const_hashType, const genericType, intType, compareType);"</span>);
    declareExtern(c_prog, <span class="stri">"rtlObjectType *hshIdxAddr (const const_hashType, const genericType, intType, compareType);"</span>);
    declareExtern(c_prog, <span class="stri">"rtlObjectType *hshIdxAddr2 (const const_hashType, const genericType, intType, compareType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        hshIncl (const hashType, const genericType, const genericType, intType, compareType, const createFuncType, const createFuncType, const copyFuncType);"</span>);
    declareExtern(c_prog, <span class="stri">"arrayType   hshKeys (const const_hashType, const createFuncType, const destrFuncType);"</span>);
    declareExtern(c_prog, <span class="stri">"const_hashElemType hshRand (const const_hashType);"</span>);
    declareExtern(c_prog, <span class="stri">"genericType hshUpdate (const hashType, const genericType, const genericType, intType, compareType, const createFuncType, const createFuncType);"</span>);
    declareExtern(c_prog, <span class="stri">"arrayType   hshValues (const const_hashType, const createFuncType, const destrFuncType);"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_hsh_contains (<span class="op">in</span> <span class="type">reference</span>: aSetRef, <span class="op">in</span> <span class="type">reference</span>: keyParam,
    <span class="op">in</span> <span class="type">reference</span>: param3, <span class="op">in</span> <span class="type">reference</span>: param4, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: key_element <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> hashLength(aSetRef) = 0 <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"0/*FALSE*/"</span>;
    <span class="keywd">elsif</span> hashLength(aSetRef) = 1 <span class="keywd">then</span>
      key_element := hashKeysToList(aSetRef)[1];
      c_expr.expr &amp;:= <span class="stri">"((compareType)("</span>;
      process_expr(param4, c_expr);
      c_expr.expr &amp;:= <span class="stri">"))("</span>;
      setVar(key_element, FALSE);
      getGenericValue(key_element, c_expr);
      setVar(key_element, TRUE);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getGenericValue(keyParam, c_expr);
      c_expr.expr &amp;:= <span class="stri">") == 0"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"hshContains("</span>;
      process_expr(aSetRef, c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getGenericValue(keyParam, c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(param3, c_expr);
      c_expr.expr &amp;:= <span class="stri">", (compareType)("</span>;
      process_expr(param4, c_expr);
      c_expr.expr &amp;:= <span class="stri">"))"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (HSH_CONTAINS, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], HASHOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_hsh_contains(evaluatedParam, params[2], params[3], params[4], c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"hshContains("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getGenericValue(params[2], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">", (compareType)("</span>;
      process_expr(params[4], c_expr);
      c_expr.expr &amp;:= <span class="stri">"))"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (HSH_CPY, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: param_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param1 <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param2 <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param3_6 <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    declare_func_pointer_if_necessary(params[3], global_c_expr);
    declare_func_pointer_if_necessary(params[4], global_c_expr);
    declare_func_pointer_if_necessary(params[5], global_c_expr);
    declare_func_pointer_if_necessary(params[6], global_c_expr);
    param_type := getExprResultType(params[2]);
    process_expr(params[1], c_param1);
    c_param2.temp_num := c_param1.temp_num;
    process_expr(params[2], c_param2);
    <span class="keywd">if</span> has_temp_values(c_param2) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      appendWithDiagnostic(c_param1.temp_decls, c_expr);
      appendWithDiagnostic(c_param2.temp_decls, c_expr);
      appendWithDiagnostic(c_param1.temp_assigns, c_expr);
      appendWithDiagnostic(c_param2.temp_assigns, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> c_param2.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      setDiagnosticLine(c_expr);
      c_expr.expr &amp;:= c_param1.expr;
      c_expr.expr &amp;:= <span class="stri">"="</span>;
      c_expr.expr &amp;:= c_param2.result_expr;
      c_expr.expr &amp;:= <span class="stri">";\n"</span>;
    <span class="keywd">else</span>
      c_param3_6.expr &amp;:= <span class="stri">", (createFuncType)("</span>;
      process_expr(params[3], c_param3_6);
      c_param3_6.expr &amp;:= <span class="stri">"), (destrFuncType)("</span>;
      process_expr(params[4], c_param3_6);
      c_param3_6.expr &amp;:= <span class="stri">"), (createFuncType)("</span>;
      process_expr(params[5], c_param3_6);
      c_param3_6.expr &amp;:= <span class="stri">"), (destrFuncType)("</span>;
      process_expr(params[6], c_param3_6);
      c_param3_6.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">if</span> param_type <span class="op">not</span> <span class="op">in</span> parametersOfHshCpy <span class="keywd">then</span>
        parametersOfHshCpy @:= [param_type] c_param3_6.expr;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      setDiagnosticLine(c_expr);
      c_expr.expr &amp;:= <span class="stri">"hshCpy(&amp;("</span>;
      c_expr.expr &amp;:= c_param1.expr;
      c_expr.expr &amp;:= <span class="stri">"), "</span>;
      c_expr.expr &amp;:= c_param2.expr;
      c_expr.expr &amp;:= c_param3_6.expr;
      c_expr.expr &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> has_temp_values(c_param2) <span class="keywd">then</span>
      appendWithDiagnostic(c_param1.temp_frees, c_expr);
      appendWithDiagnostic(c_param2.temp_frees, c_expr);
      c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (HSH_CREATE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: param_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param1 <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param2 <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param3_6 <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    param_type := getExprResultType(params[2]);
<span class="comment">(*
    process_expr(params[1], c_param1);
    c_param2.temp_num := c_param1.temp_num;
    process_expr(params[2], c_param2);
    if c_param2.temp_num &lt;> 0 then
      c_expr.expr &amp;:= "{\n";
      appendWithDiagnostic(c_param1.temp_decls, c_expr);
      appendWithDiagnostic(c_param2.temp_decls, c_expr);
      appendWithDiagnostic(c_param1.temp_assigns, c_expr);
      appendWithDiagnostic(c_param2.temp_assigns, c_expr);
    end if;
*)</span>
    c_param3_6.expr &amp;:= <span class="stri">", (createFuncType)("</span>;
    process_expr(params[3], c_param3_6);
    c_param3_6.expr &amp;:= <span class="stri">"), (destrFuncType)("</span>;
    process_expr(params[4], c_param3_6);
    c_param3_6.expr &amp;:= <span class="stri">"), (createFuncType)("</span>;
    process_expr(params[5], c_param3_6);
    c_param3_6.expr &amp;:= <span class="stri">"), (destrFuncType)("</span>;
    process_expr(params[6], c_param3_6);
    c_param3_6.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">if</span> param_type <span class="op">not</span> <span class="op">in</span> parametersOfHshCreate <span class="keywd">then</span>
      parametersOfHshCreate @:= [param_type] c_param3_6.expr;
    <span class="keywd">end</span> <span class="keywd">if</span>;
<span class="comment">(*
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= c_param1.expr;
    c_expr.expr &amp;:= "=hshCreate(";
    c_expr.expr &amp;:= c_param2.expr;
    c_expr.expr &amp;:= c_param3_6.expr;
    c_expr.expr &amp;:= ");\n";
    if c_param2.temp_num &lt;> 0 then
      appendWithDiagnostic(c_param1.temp_frees, c_expr);
      appendWithDiagnostic(c_param2.temp_frees, c_expr);
      c_expr.expr &amp;:= "}\n";
    end if;
*)</span>
    c_expr.expr &amp;:= <span class="stri">"/* hshCreate implemented with create_"</span>;
    c_expr.expr &amp;:= str(typeNumber(param_type));
    c_expr.expr &amp;:= <span class="stri">" */\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (HSH_DESTR, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: param_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param2_3 <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    param_type := getExprResultType(params[1]);
    c_param2_3.expr &amp;:= <span class="stri">", (destrFuncType)("</span>;
    process_expr(params[2], c_param2_3);
    c_param2_3.expr &amp;:= <span class="stri">"), (destrFuncType)("</span>;
    process_expr(params[3], c_param2_3);
    c_param2_3.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">if</span> param_type <span class="op">not</span> <span class="op">in</span> parametersOfHshDestr <span class="keywd">then</span>
      parametersOfHshDestr @:= [param_type] c_param2_3.expr;
    <span class="keywd">end</span> <span class="keywd">if</span>;
<span class="comment">(*
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= "hshDestr(";
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= c_param2_3.expr;
    c_expr.expr &amp;:= ");\n";
*)</span>
    c_expr.expr &amp;:= <span class="stri">"/* hshDestr implemented with destr_"</span>;
    c_expr.expr &amp;:= str(typeNumber(param_type));
    c_expr.expr &amp;:= <span class="stri">" */\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (HSH_EXCL, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    declare_func_pointer_if_necessary(params[4], global_c_expr);
    declare_func_pointer_if_necessary(params[5], global_c_expr);
    declare_func_pointer_if_necessary(params[6], global_c_expr);
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"hshExcl("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    getGenericValue(params[2], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    process_expr(params[3], c_expr);
    c_expr.expr &amp;:= <span class="stri">", (compareType)("</span>;
    process_expr(params[4], c_expr);
    c_expr.expr &amp;:= <span class="stri">"), (destrFuncType)("</span>;
    process_expr(params[5], c_expr);
    c_expr.expr &amp;:= <span class="stri">"), (destrFuncType)("</span>;
    process_expr(params[6], c_expr);
    c_expr.expr &amp;:= <span class="stri">"));\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_hsh_for_generic (<span class="op">in</span> <span class="type">reference</span>: forDataVariable,
    <span class="op">in</span> <span class="type">reference</span>: forKeyVariable, <span class="op">in</span> <span class="type">reference</span>: hashTable,
    <span class="op">in</span> <span class="type">reference</span>: statement, <span class="op">in</span> <span class="type">reference</span>: dataCopyFunc,
    <span class="op">in</span> <span class="type">reference</span>: keyCopyFunc, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: hash_temp_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: counter_temp_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: table_elem_temp_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: helem_temp_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stack_temp_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    incr(c_expr.temp_num);
    hash_temp_name := <span class="stri">"hash_"</span> &amp; str(c_expr.temp_num);
    incr(c_expr.temp_num);
    counter_temp_name := <span class="stri">"counter_"</span> &amp; str(c_expr.temp_num);
    incr(c_expr.temp_num);
    table_elem_temp_name := <span class="stri">"table_elem_"</span> &amp; str(c_expr.temp_num);
    incr(c_expr.temp_num);
    helem_temp_name := <span class="stri">"helem_"</span> &amp; str(c_expr.temp_num);
    incr(c_expr.temp_num);
    stack_temp_name := <span class="stri">"stack_"</span> &amp; str(c_expr.temp_num);
    c_expr.expr &amp;:= <span class="stri">"/* hsh_for */ {\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"const_hashType "</span>;
    c_expr.expr &amp;:= hash_temp_name;
    c_expr.expr &amp;:= <span class="stri">"="</span>;
    process_expr(hashTable, c_expr);
    c_expr.expr &amp;:= <span class="stri">";\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"memSizeType "</span>;
    c_expr.expr &amp;:= counter_temp_name;
    c_expr.expr &amp;:= <span class="stri">"="</span>;
    c_expr.expr &amp;:= hash_temp_name;
    c_expr.expr &amp;:= <span class="stri">"->table_size;\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"hashElemType_const *"</span>;
    c_expr.expr &amp;:= table_elem_temp_name;
    c_expr.expr &amp;:= <span class="stri">"=&amp;"</span>;
    c_expr.expr &amp;:= hash_temp_name;
    c_expr.expr &amp;:= <span class="stri">"->table[0];\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"const_hashElemType "</span>;
    c_expr.expr &amp;:= helem_temp_name;
    c_expr.expr &amp;:= <span class="stri">";\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"hashElemListType "</span>;
    c_expr.expr &amp;:= stack_temp_name;
    c_expr.expr &amp;:= <span class="stri">"=NULL;\n"</span>;

    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"while ("</span>;
    c_expr.expr &amp;:= counter_temp_name;
    c_expr.expr &amp;:= <span class="stri">" > 0) {\n"</span>;

    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= helem_temp_name;
    c_expr.expr &amp;:= <span class="stri">"=*"</span>;
    c_expr.expr &amp;:= table_elem_temp_name;
    c_expr.expr &amp;:= <span class="stri">";\n"</span>;

    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"while ("</span>;
    c_expr.expr &amp;:= helem_temp_name;
    c_expr.expr &amp;:= <span class="stri">" != NULL) {\n"</span>;

    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"if ("</span>;
    c_expr.expr &amp;:= helem_temp_name;
    c_expr.expr &amp;:= <span class="stri">"->next_greater != NULL) {\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"push_stack("</span>;
    c_expr.expr &amp;:= stack_temp_name;
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    c_expr.expr &amp;:= helem_temp_name;
    c_expr.expr &amp;:= <span class="stri">"->next_greater);\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"} /* if */\n"</span>;

    <span class="keywd">if</span> forDataVariable &lt;> NIL <span class="keywd">then</span>
      process_cpy_declaration(getType(forDataVariable), global_c_expr);
      setDiagnosticLine(c_expr);
      process_cpy_call(getType(forDataVariable),
          normalVariable(forDataVariable, c_expr),
          helem_temp_name &amp; <span class="stri">"->data.value."</span> &amp; raw_type_value(getType(forDataVariable)),
          c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">";\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;

    <span class="keywd">if</span> forKeyVariable &lt;> NIL <span class="keywd">then</span>
      process_cpy_declaration(getType(forKeyVariable), global_c_expr);
      setDiagnosticLine(c_expr);
      process_cpy_call(getType(forKeyVariable),
          normalVariable(forKeyVariable, c_expr),
          helem_temp_name &amp; <span class="stri">"->key.value."</span> &amp; raw_type_value(getType(forKeyVariable)),
          c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">";\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;

    process_call_by_name_expr(statement, c_expr);

    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"if ("</span>;
    c_expr.expr &amp;:= helem_temp_name;
    c_expr.expr &amp;:= <span class="stri">"->next_less != NULL) {\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= helem_temp_name;
    c_expr.expr &amp;:= <span class="stri">"="</span>;
    c_expr.expr &amp;:= helem_temp_name;
    c_expr.expr &amp;:= <span class="stri">"->next_less;\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"} else {\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"pop_stack("</span>;
    c_expr.expr &amp;:= stack_temp_name;
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    c_expr.expr &amp;:= helem_temp_name;
    c_expr.expr &amp;:= <span class="stri">");\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"} /* if */\n"</span>;

    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"} /* while */\n"</span>;

    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= counter_temp_name;
    c_expr.expr &amp;:= <span class="stri">"--;\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= table_elem_temp_name;
    c_expr.expr &amp;:= <span class="stri">"++;\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"} /* while */\n"</span>;
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"} /* hsh_for */\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (HSH_FOR, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    declare_func_pointer_if_necessary(params[4], global_c_expr);
    process_hsh_for_generic(params[1], NIL, params[2], params[3], params[4], NIL, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (HSH_FOR_DATA_KEY, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    declare_func_pointer_if_necessary(params[5], global_c_expr);
    declare_func_pointer_if_necessary(params[6], global_c_expr);
    process_hsh_for_generic(params[1], params[2], params[3], params[4], params[5], params[6], c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (HSH_FOR_KEY, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    declare_func_pointer_if_necessary(params[4], global_c_expr);
    process_hsh_for_generic(NIL, params[1], params[2], params[3], NIL, params[4], c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (HSH_IDX, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: proc_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: result_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">string</span>: temp_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    declare_func_pointer_if_necessary(params[4], global_c_expr);
    proc_type := getType(function);
    result_type := resultType(proc_type);
    <span class="keywd">if</span> isVarfunc(proc_type) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"hshIdxAddr("</span>;
    <span class="keywd">else</span>
      temp_name := beginCastGeneric(result_type, c_expr);
      c_expr.expr &amp;:= <span class="stri">"hshIdx("</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    getGenericValue(params[2], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    process_expr(params[3], c_expr);
    c_expr.expr &amp;:= <span class="stri">", (compareType)("</span>;
    process_expr(params[4], c_expr);
    c_expr.expr &amp;:= <span class="stri">"))"</span>;
    <span class="keywd">if</span> isVarfunc(proc_type) <span class="keywd">then</span>
      c_expr.expr &amp;:= select_value_from_rtlObjectptr(result_type);
    <span class="keywd">else</span>
      endCastGeneric(result_type, temp_name, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (HSH_IDX2, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: proc_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: result_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">string</span>: addr_temp_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    declare_func_pointer_if_necessary(params[5], global_c_expr);
    declare_func_pointer_if_necessary(params[6], global_c_expr);
    proc_type := getType(function);
    result_type := resultType(proc_type);
    incr(c_expr.temp_num);
    addr_temp_name := <span class="stri">"addr_"</span> &amp; str(c_expr.temp_num);
    c_expr.temp_decls &amp;:= <span class="stri">"rtlObjectType *"</span>;
    c_expr.temp_decls &amp;:= addr_temp_name;
    c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"("</span>;
    c_expr.expr &amp;:= addr_temp_name;
    c_expr.expr &amp;:= <span class="stri">"=hshIdxAddr2("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    getGenericValue(params[2], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    process_expr(params[3], c_expr);
    c_expr.expr &amp;:= <span class="stri">", (compareType)("</span>;
    process_expr(params[5], c_expr);
    c_expr.expr &amp;:= <span class="stri">")),"</span>;
    c_expr.expr &amp;:= addr_temp_name;
    c_expr.expr &amp;:= <span class="stri">"!=NULL?"</span>;
    c_expr.expr &amp;:= addr_temp_name;
    c_expr.expr &amp;:= select_value_from_rtlObjectptr(result_type);
    c_expr.expr &amp;:= <span class="stri">":("</span>;
    process_expr(params[4], c_expr);
    c_expr.expr &amp;:= <span class="stri">"))"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (HSH_INCL, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    declare_func_pointer_if_necessary(params[5], global_c_expr);
    declare_func_pointer_if_necessary(params[6], global_c_expr);
    declare_func_pointer_if_necessary(params[7], global_c_expr);
    declare_func_pointer_if_necessary(params[8], global_c_expr);
    setDiagnosticLine(c_expr);
    c_expr.expr &amp;:= <span class="stri">"hshIncl("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    getGenericValue(params[2], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    getGenericValue(params[3], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    process_expr(params[4], c_expr);
    c_expr.expr &amp;:= <span class="stri">", (compareType)("</span>;
    process_expr(params[5], c_expr);
    c_expr.expr &amp;:= <span class="stri">"), (createFuncType)("</span>;
    process_expr(params[6], c_expr);
    c_expr.expr &amp;:= <span class="stri">"), (createFuncType)("</span>;
    process_expr(params[7], c_expr);
    c_expr.expr &amp;:= <span class="stri">"), (copyFuncType)("</span>;
    process_expr(params[8], c_expr);
    c_expr.expr &amp;:= <span class="stri">"));\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (HSH_KEYS, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_typed_result(resultType(getType(function)), c_expr);
    c_expr.result_expr := <span class="stri">"hshKeys("</span>;
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">", (createFuncType)("</span>;
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">"), (destrFuncType)("</span>;
    getStdParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">"))"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (HSH_LNG, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"(intType)(("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")->size)"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (HSH_RAND_KEY, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: proc_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: result_type <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    proc_type := getType(function);
    result_type := resultType(proc_type);
    c_expr.expr &amp;:= <span class="stri">"hshRand("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")->key.value."</span> &amp; raw_type_value(result_type);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (HSH_UPDATE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: result_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">string</span>: temp_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    declare_func_pointer_if_necessary(params[5], global_c_expr);
    declare_func_pointer_if_necessary(params[6], global_c_expr);
    declare_func_pointer_if_necessary(params[7], global_c_expr);
    result_type := resultType(getType(function));
    <span class="keywd">if</span> valueIsAtHeap(result_type) <span class="keywd">then</span>
      prepare_typed_result(result_type, c_expr);
      temp_name := beginCastGenericToResultExpr(result_type, c_expr);
      c_expr.result_expr &amp;:= <span class="stri">"hshUpdate("</span>;
      getAnyParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getGenericValueToResultExpr(params[2], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", (genericType)("</span>;
      getGenericTemporaryToResultExpr(params[3], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">"), "</span>;
      getAnyParamToResultExpr(params[4], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", (compareType)("</span>;
      getAnyParamToResultExpr(params[5], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">"), (createFuncType)("</span>;
      getAnyParamToResultExpr(params[6], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">"), (createFuncType)("</span>;
      getAnyParamToResultExpr(params[7], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">"))"</span>;
      endCastGenericToResultExpr(result_type, temp_name, c_expr);
    <span class="keywd">else</span>
      temp_name := beginCastGeneric(result_type, c_expr);
      c_expr.expr &amp;:= <span class="stri">"hshUpdate("</span>;
      process_expr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getGenericValue(params[2], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getGenericValue(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      process_expr(params[4], c_expr);
      c_expr.expr &amp;:= <span class="stri">", (compareType)("</span>;
      process_expr(params[5], c_expr);
      c_expr.expr &amp;:= <span class="stri">"), (createFuncType)("</span>;
      process_expr(params[6], c_expr);
      c_expr.expr &amp;:= <span class="stri">"), (createFuncType)("</span>;
      process_expr(params[7], c_expr);
      c_expr.expr &amp;:= <span class="stri">"))"</span>;
      endCastGeneric(result_type, temp_name, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (HSH_VALUES, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"hshValues("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">", (createFuncType)("</span>;
    process_expr(params[2], c_expr);
    c_expr.expr &amp;:= <span class="stri">"), (destrFuncType)("</span>;
    process_expr(params[3], c_expr);
    c_expr.expr &amp;:= <span class="stri">"))"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
