<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  intrange.s7i  Handle ranges of possible values for expressions. *)</span>
<span class="comment">(*  Copyright (C) 2020, 2021  Thomas Mertes                         *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 compiler.                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">const</span> <span class="type">type</span>: intRange <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: minValue <span class="keywd">is</span> integer.first;
    <span class="keywd">var</span> <span class="type">integer</span>: maxValue <span class="keywd">is</span> integer.last;
    <span class="keywd">var</span> <span class="type">boolean</span>: mayRaiseException <span class="keywd">is</span> TRUE;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="keywd">ref</span> <span class="type">intRange</span>: range1) = (<span class="keywd">ref</span> <span class="type">intRange</span>: range2) <span class="keywd">is</span>
  <span class="keywd">return</span> range1.minValue = range2.minValue <span class="op">and</span> range1.maxValue = range2.maxValue;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="keywd">ref</span> <span class="type">intRange</span>: range1) &lt;> (<span class="keywd">ref</span> <span class="type">intRange</span>: range2) <span class="keywd">is</span>
  <span class="keywd">return</span> range1.minValue &lt;> range2.minValue <span class="op">or</span> range1.maxValue &lt;> range2.maxValue;


<span class="keywd">const</span> <span class="type">type</span>: intRangeOfVariableHash <span class="keywd">is</span> <span class="type">hash</span><span class="type">[</span><span class="type">reference</span><span class="type">]</span> <span class="type">intRange</span>;

<span class="keywd">var</span> <span class="type">intRangeOfVariableHash</span>: intRangeOfVariable <span class="keywd">is</span> intRangeOfVariableHash.value;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getIntRange (<span class="op">in</span> <span class="type">reference</span>: intExpression) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getIntAddRange (<span class="op">in</span> <span class="type">reference</span>: summand1, <span class="op">in</span> <span class="type">reference</span>: summand2) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: valueRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: summand1Range <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">intRange</span>: summand2Range <span class="keywd">is</span> intRange.value;
  <span class="keywd">begin</span>
    summand1Range := getIntRange(summand1);
    summand2Range := getIntRange(summand2);
    <span class="keywd">if</span> summand1Range.minValue &lt; 0 <span class="keywd">then</span>
      <span class="keywd">if</span> summand2Range.minValue &lt; 0 <span class="keywd">then</span>
        <span class="keywd">if</span> summand1Range.minValue >= integer.first - summand2Range.minValue <span class="keywd">then</span>
          valueRange.minValue := summand1Range.minValue + summand2Range.minValue;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        valueRange.minValue := summand1Range.minValue + summand2Range.minValue;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      <span class="keywd">if</span> summand2Range.minValue > 0 <span class="keywd">then</span>
        <span class="keywd">if</span> summand2Range.minValue &lt;= integer.last - summand1Range.minValue <span class="keywd">then</span>
          valueRange.minValue := summand1Range.minValue + summand2Range.minValue;
        <span class="keywd">else</span>
          valueRange.minValue := integer.last;
          valueRange.maxValue := integer.first;
        <span class="keywd">end</span> <span class="keywd">if</span>
      <span class="keywd">else</span>
        valueRange.minValue := summand1Range.minValue + summand2Range.minValue;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> summand1Range.maxValue > 0 <span class="keywd">then</span>
      <span class="keywd">if</span> summand2Range.maxValue > 0 <span class="keywd">then</span>
        <span class="keywd">if</span> summand2Range.maxValue &lt;= integer.last - summand1Range.maxValue <span class="keywd">then</span>
          valueRange.maxValue := summand1Range.maxValue + summand2Range.maxValue;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        valueRange.maxValue := summand1Range.maxValue + summand2Range.maxValue;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      <span class="keywd">if</span> summand2Range.maxValue &lt; 0 <span class="keywd">then</span>
        <span class="keywd">if</span> summand2Range.maxValue >= integer.first - summand1Range.maxValue <span class="keywd">then</span>
          valueRange.maxValue := summand1Range.maxValue + summand2Range.maxValue;
        <span class="keywd">else</span>
          valueRange.minValue := integer.last;
          valueRange.maxValue := integer.first;
        <span class="keywd">end</span> <span class="keywd">if</span>
      <span class="keywd">else</span>
        valueRange.maxValue := summand1Range.maxValue + summand2Range.maxValue;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> valueRange.minValue > valueRange.maxValue <span class="keywd">then</span>
      valueRange.minValue := 0;
      valueRange.maxValue := -1;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getIntLshiftRange (<span class="op">in</span> <span class="type">reference</span>: number, <span class="op">in</span> <span class="type">reference</span>: lshift) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: valueRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: numberRange <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">intRange</span>: lshiftRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">begin</span>
    numberRange := getIntRange(number);
    lshiftRange := getIntRange(lshift);
    <span class="keywd">if</span> lshiftRange.maxValue &lt; 0 <span class="op">or</span>
        lshiftRange.minValue > bitLength(integer.last) <span class="keywd">then</span>
      valueRange.minValue := 0;
      valueRange.maxValue := -1;
    <span class="keywd">elsif</span> numberRange.minValue &lt; 0 <span class="keywd">then</span>
      <span class="keywd">if</span> lshiftRange.maxValue &lt;= bitLength(integer.last) <span class="keywd">then</span>
        <span class="keywd">if</span> numberRange.minValue >= integer.first >> lshiftRange.maxValue <span class="keywd">then</span>
          valueRange.minValue := numberRange.minValue &lt;&lt; lshiftRange.maxValue;
        <span class="keywd">else</span>
          valueRange.minValue := integer.first;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        valueRange.minValue := integer.first;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> numberRange.minValue > 0 <span class="keywd">then</span>
      <span class="keywd">if</span> lshiftRange.minValue >= 0 <span class="keywd">then</span>
        <span class="keywd">if</span> numberRange.minValue &lt;= integer.last >> lshiftRange.minValue <span class="keywd">then</span>
          valueRange.minValue := numberRange.minValue &lt;&lt; lshiftRange.minValue;
        <span class="keywd">else</span>
          valueRange.minValue := integer.last;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        valueRange.minValue := numberRange.minValue;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      valueRange.minValue := 0;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> numberRange.maxValue &lt; 0 <span class="keywd">then</span>
      <span class="keywd">if</span> lshiftRange.minValue >= 0 <span class="keywd">then</span>
        <span class="keywd">if</span> numberRange.maxValue >= integer.first >> lshiftRange.minValue <span class="keywd">then</span>
          valueRange.maxValue := numberRange.maxValue &lt;&lt; lshiftRange.minValue;
        <span class="keywd">else</span>
          valueRange.maxValue := integer.first;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        valueRange.maxValue := numberRange.maxValue;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> numberRange.maxValue > 0 <span class="keywd">then</span>
      <span class="keywd">if</span> lshiftRange.maxValue &lt;= bitLength(integer.last) <span class="keywd">then</span>
        <span class="keywd">if</span> numberRange.maxValue &lt;= integer.last >> lshiftRange.maxValue <span class="keywd">then</span>
          valueRange.maxValue := numberRange.maxValue &lt;&lt; lshiftRange.maxValue;
        <span class="keywd">elsif</span> lshiftRange.minValue > 0 <span class="keywd">then</span>
          valueRange.maxValue := integer.last >> lshiftRange.minValue &lt;&lt; lshiftRange.minValue;
        <span class="keywd">else</span>
          valueRange.maxValue := integer.last;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        valueRange.maxValue := integer.last;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      valueRange.maxValue := 0;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> valueRange.minValue > valueRange.maxValue <span class="keywd">then</span>
      valueRange.minValue := 0;
      valueRange.maxValue := -1;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getIntModRange (<span class="op">in</span> <span class="type">reference</span>: dividend, <span class="op">in</span> <span class="type">reference</span>: divisor) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: valueRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: divisorRange <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">integer</span>: dividendValue <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">intRange</span>: valueRange2 <span class="keywd">is</span> intRange.value;
  <span class="keywd">begin</span>
    divisorRange := getIntRange(divisor);
    <span class="keywd">if</span> divisorRange.minValue > 0 <span class="keywd">then</span>
      valueRange.minValue := 0;
      valueRange.maxValue := pred(divisorRange.maxValue);
    <span class="keywd">elsif</span> divisorRange.maxValue &lt; 0 <span class="keywd">then</span>
      valueRange.minValue := succ(divisorRange.minValue);
      valueRange.maxValue := 0;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> getConstant(dividend, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      dividendValue := getValue(evaluatedParam, integer);
      <span class="keywd">if</span> dividendValue = integer.first <span class="keywd">then</span>
        valueRange2.minValue := succ(integer.first) <span class="op">div</span> 2;
        valueRange2.maxValue := -2 - integer.first;
      <span class="keywd">elsif</span> dividendValue = integer.last <span class="keywd">then</span>
        valueRange2.minValue := 2 - integer.last;
        valueRange2.maxValue := pred(integer.last) <span class="op">div</span> 2;
      <span class="keywd">elsif</span> dividendValue > 0 <span class="keywd">then</span>
        <span class="keywd">if</span> integer.first + dividendValue &lt;= 2 - dividendValue <span class="keywd">then</span>
          valueRange2.minValue := integer.first + dividendValue;
        <span class="keywd">else</span>
          valueRange2.minValue := 2 - dividendValue;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        valueRange2.maxValue := dividendValue;
      <span class="keywd">elsif</span> dividendValue = 0 <span class="keywd">then</span>
        valueRange2.minValue := 0;
        valueRange2.maxValue := 0;
      <span class="keywd">else</span> <span class="comment"># dividendValue &lt; 0 then</span>
        valueRange2.minValue := dividendValue;
        <span class="keywd">if</span> integer.last + dividendValue >= -(dividendValue + 2) <span class="keywd">then</span>
          valueRange2.maxValue := integer.last + dividendValue;
        <span class="keywd">else</span>
          valueRange2.maxValue := -(dividendValue + 2);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      valueRange.minValue := max(valueRange.minValue, valueRange2.minValue);
      valueRange.maxValue := min(valueRange.maxValue, valueRange2.maxValue);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> valueRange.minValue > valueRange.maxValue <span class="keywd">then</span>
      valueRange.minValue := 0;
      valueRange.maxValue := -1;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getIntBytes2UIntRange (<span class="op">in</span> <span class="type">reference</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: valueRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    valueRange.minValue := 0;
    <span class="keywd">if</span> isActionExpression(stri, <span class="stri">"STR_SUBSTR"</span>) <span class="op">and</span>
        category(getValue(stri, ref_list)[6]) = INTOBJECT <span class="op">and</span>
        <span class="op">not</span> isVar(getValue(stri, ref_list)[6]) <span class="keywd">then</span>
      length := getValue(getValue(stri, ref_list)[6], integer);
      <span class="keywd">if</span> length >= 1 <span class="op">and</span> length &lt; 8 <span class="keywd">then</span>
        valueRange.maxValue := pred(2 ** (length * 8));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getSetRandRange (<span class="op">in</span> <span class="type">reference</span>: aSet) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: valueRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">bitset</span>: setValue <span class="keywd">is</span> {};
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(aSet, SETOBJECT, evaluatedParam) <span class="keywd">then</span>
      setValue := getValue(evaluatedParam, bitset);
      <span class="keywd">if</span> setValue = {} <span class="keywd">then</span>
        valueRange.minValue := 0;
        valueRange.maxValue := -1;
      <span class="keywd">else</span>
        valueRange.minValue := min(setValue);
        valueRange.maxValue := max(setValue);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">intRange</span>: getIntRange (<span class="op">in</span> <span class="type">reference</span>: intExpression) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: valueRange <span class="keywd">is</span> intRange.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: function <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">string</span>: actionName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">intRange</span>: argument1Range <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">intRange</span>: argument2Range <span class="keywd">is</span> intRange.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> reduceOverflowChecks <span class="keywd">then</span>
      <span class="keywd">if</span> getConstant(intExpression, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
        number := getValue(evaluatedParam, integer);
        valueRange.minValue := number;
        valueRange.maxValue := number;
        valueRange.mayRaiseException := FALSE;
        <span class="comment"># writeln("intRange of constant: " &lt;&amp; valueRange.minValue &lt;&amp; ".." &lt;&amp; valueRange.maxValue);</span>
      <span class="keywd">elsif</span> intExpression <span class="op">in</span> intRangeOfVariable <span class="keywd">then</span>
        valueRange := intRangeOfVariable[intExpression];
        valueRange.mayRaiseException := FALSE;
        <span class="comment"># writeln("intRange of variable: " &lt;&amp; valueRange.minValue &lt;&amp; ".." &lt;&amp; valueRange.maxValue);</span>
      <span class="keywd">elsif</span> category(intExpression) = CALLOBJECT <span class="keywd">then</span>
        params := getValue(intExpression, ref_list);
        function := params[1];
        params := params[2 ..];
        <span class="keywd">if</span> category(function) = ACTOBJECT <span class="keywd">then</span>
          actionName := str(getValue(function, ACTION));
          <span class="keywd">case</span> actionName <span class="keywd">of</span>
            <span class="keywd">when</span> {<span class="stri">"ARR_LNG"</span>, <span class="stri">"BST_LNG"</span>, <span class="stri">"FIL_LNG"</span>, <span class="stri">"HSH_LNG"</span>, <span class="stri">"RFL_LNG"</span>,
                  <span class="stri">"SET_CARD"</span>,
                  <span class="stri">"SQL_STMT_COLUMN_COUNT"</span>}:
              valueRange.minValue := 0;
              valueRange.maxValue := integer.last;
            <span class="keywd">when</span> {<span class="stri">"BIG_CMP"</span>, <span class="stri">"BIN_CMP"</span>, <span class="stri">"BST_CMP"</span>, <span class="stri">"CHR_CMP"</span>, <span class="stri">"DRW_CMP"</span>,
                  <span class="stri">"FLT_CMP"</span>, <span class="stri">"INT_CMP"</span>, <span class="stri">"ITF_CMP"</span>, <span class="stri">"PCS_CMP"</span>, <span class="stri">"REF_CMP"</span>,
                  <span class="stri">"SET_CMP"</span>, <span class="stri">"SQL_CMP_DB"</span>, <span class="stri">"SQL_CMP_STMT"</span>, <span class="stri">"STR_CMP"</span>,
                  <span class="stri">"TYP_CMP"</span>}:
              valueRange.minValue := -1;
              valueRange.maxValue := 1;
            <span class="keywd">when</span> {<span class="stri">"BIN_CARD"</span>}:
              valueRange.minValue := 0;
              valueRange.maxValue := ccConf.INTTYPE_SIZE;
            <span class="keywd">when</span> {<span class="stri">"BLN_ORD"</span>}:
              valueRange.minValue := 0;
              valueRange.maxValue := 1;
            <span class="keywd">when</span> {<span class="stri">"CHR_ORD"</span>}:
              <span class="keywd">if</span> ccConf.TWOS_COMPLEMENT_INTTYPE <span class="keywd">then</span>
                valueRange.minValue := -2147483648;
              <span class="keywd">else</span>
                valueRange.minValue := -2147483647;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              valueRange.maxValue := 2147483647;
            <span class="keywd">when</span> {<span class="stri">"ENU_ORD2"</span>}:
              valueRange.minValue := 0;
              valueRange.maxValue :=
                  pred(length(getValue(evaluate(prog, params[2]), ref_list)));
            <span class="keywd">when</span> {<span class="stri">"FIL_TELL"</span>}:
              valueRange.minValue := 1;
              valueRange.maxValue := integer.last;
            <span class="keywd">when</span> {<span class="stri">"INT_ABS"</span>}:
              valueRange.minValue := 0;
              argument1Range := getIntRange(params[1]);
              <span class="keywd">if</span> argument1Range &lt;> intRange.value <span class="op">and</span>
                  argument1Range.minValue > integer.first <span class="op">and</span>
                  argument1Range.maxValue > integer.first <span class="keywd">then</span>
                <span class="keywd">if</span> argument1Range.maxValue &lt; argument1Range.minValue <span class="keywd">then</span>
                  valueRange.minValue := 0;
                  valueRange.maxValue := -1;
                <span class="keywd">elsif</span> abs(argument1Range.minValue) > abs(argument1Range.maxValue) <span class="keywd">then</span>
                  valueRange.maxValue := abs(argument1Range.minValue);
                <span class="keywd">else</span>
                  valueRange.maxValue := abs(argument1Range.maxValue);
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">else</span>
                valueRange.maxValue := integer.last;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"INT_ADD"</span>}:
              valueRange := getIntAddRange(params[1], params[3]);
            <span class="keywd">when</span> {<span class="stri">"INT_BIT_LENGTH"</span>}:
              valueRange.minValue := 0;
              valueRange.maxValue := pred(ccConf.INTTYPE_SIZE);
            <span class="keywd">when</span> {<span class="stri">"INT_BYTES_BE_2_UINT"</span>,
                  <span class="stri">"INT_BYTES_LE_2_UINT"</span>}:
              valueRange := getIntBytes2UIntRange(params[1]);
            <span class="keywd">when</span> {<span class="stri">"INT_DIV"</span>}:
              <span class="keywd">if</span> getConstant(params[3], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := getValue(evaluatedParam, integer);
                <span class="keywd">if</span> number > 0 <span class="keywd">then</span>
                  valueRange.minValue := integer.first <span class="op">div</span> number;
                  valueRange.maxValue := integer.last <span class="op">div</span> number;
                <span class="keywd">elsif</span> number = -1 <span class="keywd">then</span>
                  valueRange.minValue := -integer.last;
                <span class="keywd">elsif</span> number &lt; -1 <span class="keywd">then</span>
                  valueRange.minValue := integer.last <span class="op">div</span> number;
                  valueRange.maxValue := integer.first <span class="op">div</span> number;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">elsif</span> getConstant(params[1], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := getValue(evaluatedParam, integer);
                <span class="keywd">if</span> number >= 0 <span class="keywd">then</span>
                  valueRange.minValue := -number;
                  valueRange.maxValue := number;
                <span class="keywd">elsif</span> number &lt;> integer.first <span class="keywd">then</span>
                  valueRange.minValue := number;
                  valueRange.maxValue := -number;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"INT_ICONV1"</span>}:
              valueRange := getIntRange(params[1]);
            <span class="keywd">when</span> {<span class="stri">"INT_ICONV3"</span>}:
              valueRange := getIntRange(params[3]);
            <span class="keywd">when</span> {<span class="stri">"INT_LOG10"</span>}:
              valueRange.minValue := -1;
              valueRange.maxValue := log10(integer.last);
            <span class="keywd">when</span> {<span class="stri">"INT_LOG2"</span>}:
              valueRange.minValue := -1;
              valueRange.maxValue := log2(integer.last);
            <span class="keywd">when</span> {<span class="stri">"INT_LOWEST_SET_BIT"</span>}:
              valueRange.minValue := -1;
              valueRange.maxValue := pred(ccConf.INTTYPE_SIZE);
            <span class="keywd">when</span> {<span class="stri">"INT_LSHIFT"</span>}:
              valueRange := getIntLshiftRange(params[1], params[3]);
            <span class="keywd">when</span> {<span class="stri">"INT_MDIV"</span>}:
              <span class="keywd">if</span> getConstant(params[3], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := getValue(evaluatedParam, integer);
                <span class="keywd">if</span> number > 0 <span class="keywd">then</span>
                  valueRange.minValue := integer.first <span class="op">mdiv</span> number;
                  valueRange.maxValue := integer.last <span class="op">mdiv</span> number;
                <span class="keywd">elsif</span> number = -1 <span class="keywd">then</span>
                  valueRange.minValue := -integer.last;
                <span class="keywd">elsif</span> number &lt; -1 <span class="keywd">then</span>
                  valueRange.minValue := integer.last <span class="op">mdiv</span> number;
                  valueRange.maxValue := integer.first <span class="op">mdiv</span> number;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">elsif</span> getConstant(params[1], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := getValue(evaluatedParam, integer);
                <span class="keywd">if</span> number >= 0 <span class="keywd">then</span>
                  valueRange.minValue := -number;
                  valueRange.maxValue := number;
                <span class="keywd">elsif</span> number &lt;> integer.first <span class="keywd">then</span>
                  valueRange.minValue := number;
                  valueRange.maxValue := -number;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"INT_MOD"</span>}:
              valueRange := getIntModRange(params[1], params[3]);
            <span class="keywd">when</span> {<span class="stri">"INT_MULT"</span>}:
              <span class="keywd">if</span> getConstant(params[1], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := getValue(evaluatedParam, integer);
                <span class="keywd">if</span> number >= 2 <span class="keywd">then</span>
                  argument2Range := getIntRange(params[3]);
                  <span class="keywd">if</span> argument2Range.minValue >= integer.first <span class="op">div</span> number <span class="op">and</span>
                      argument2Range.minValue &lt;= integer.last <span class="op">div</span> number <span class="keywd">then</span>
                    valueRange.minValue := argument2Range.minValue * number;
                  <span class="keywd">else</span>
                    valueRange.minValue := integer.first <span class="op">div</span> number * number;
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                  <span class="keywd">if</span> argument2Range.maxValue >= integer.first <span class="op">div</span> number <span class="op">and</span>
                      argument2Range.maxValue &lt;= integer.last <span class="op">div</span> number <span class="keywd">then</span>
                    valueRange.maxValue := argument2Range.maxValue * number;
                  <span class="keywd">else</span>
                    valueRange.maxValue := integer.last <span class="op">div</span> number * number;
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">elsif</span> getConstant(params[3], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := getValue(evaluatedParam, integer);
                <span class="keywd">if</span> number >= 2 <span class="keywd">then</span>
                  argument1Range := getIntRange(params[1]);
                  <span class="keywd">if</span> argument1Range.minValue >= integer.first <span class="op">div</span> number <span class="op">and</span>
                      argument1Range.minValue &lt;= integer.last <span class="op">div</span> number <span class="keywd">then</span>
                    valueRange.minValue := argument1Range.minValue * number;
                  <span class="keywd">else</span>
                    valueRange.minValue := integer.first <span class="op">div</span> number * number;
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                  <span class="keywd">if</span> argument1Range.maxValue >= integer.first <span class="op">div</span> number <span class="op">and</span>
                      argument1Range.maxValue &lt;= integer.last <span class="op">div</span> number <span class="keywd">then</span>
                    valueRange.maxValue := argument1Range.maxValue * number;
                  <span class="keywd">else</span>
                    valueRange.maxValue := integer.last <span class="op">div</span> number * number;
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"INT_NEGATE"</span>}:
              argument1Range := getIntRange(params[2]);
              <span class="keywd">if</span> argument1Range &lt;> intRange.value <span class="keywd">then</span>
                <span class="keywd">if</span> argument1Range.maxValue &lt; -integer.last <span class="op">or</span>
                    argument1Range.maxValue &lt; argument1Range.minValue <span class="keywd">then</span>
                  valueRange.minValue := 0;
                  valueRange.maxValue := -1;
                <span class="keywd">else</span>
                  valueRange.minValue := -argument1Range.maxValue;
                  <span class="keywd">if</span> argument1Range.minValue &lt; -integer.last <span class="keywd">then</span>
                    valueRange.maxValue := integer.last;
                  <span class="keywd">else</span>
                    valueRange.maxValue := -argument1Range.minValue;
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">else</span>
                valueRange.minValue := -integer.last;
                valueRange.maxValue := integer.last;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"INT_PRED"</span>}:
              argument1Range := getIntRange(params[1]);
              <span class="keywd">if</span> argument1Range.minValue &lt;> integer.first <span class="keywd">then</span>
                valueRange.minValue := pred(argument1Range.minValue);
              <span class="keywd">else</span>
                valueRange.minValue := integer.first;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> argument1Range.maxValue &lt;> integer.first <span class="keywd">then</span>
                valueRange.maxValue := pred(argument1Range.maxValue);
              <span class="keywd">else</span>
                valueRange.maxValue := integer.first;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> <span class="op">not</span> argument1Range.mayRaiseException <span class="op">and</span>
                  argument1Range.minValue &lt;> integer.first <span class="keywd">then</span>
                valueRange.mayRaiseException := FALSE;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"INT_RAND"</span>}:
              argument1Range := getIntRange(params[1]);
              argument2Range := getIntRange(params[2]);
              valueRange.minValue := argument1Range.minValue;
              valueRange.maxValue := argument2Range.maxValue;
              <span class="keywd">if</span> <span class="op">not</span> (argument1Range.mayRaiseException <span class="op">or</span>
                      argument2Range.mayRaiseException) <span class="op">and</span>
                  argument1Range.maxValue &lt;= argument2Range.minValue <span class="keywd">then</span>
                valueRange.mayRaiseException := FALSE;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"INT_REM"</span>}:
              <span class="keywd">if</span> getConstant(params[3], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := getValue(evaluatedParam, integer);
                <span class="keywd">if</span> number > 0 <span class="keywd">then</span>
                  valueRange.minValue := -pred(number);
                  valueRange.maxValue := pred(number);
                <span class="keywd">elsif</span> number &lt; 0 <span class="keywd">then</span>
                  valueRange.minValue := succ(number);
                  valueRange.maxValue := -succ(number);
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">elsif</span> getConstant(params[1], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := getValue(evaluatedParam, integer);
                <span class="keywd">if</span> number >= 0 <span class="keywd">then</span>
                  valueRange.minValue := 0;
                  valueRange.maxValue := number;
                <span class="keywd">elsif</span> number = 0 <span class="keywd">then</span>
                  valueRange.minValue := 0;
                  valueRange.maxValue := 0;
                <span class="keywd">else</span> <span class="comment"># number &lt; 0 then</span>
                  valueRange.minValue := number;
                  valueRange.maxValue := 0;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"INT_RSHIFT"</span>}:
              <span class="keywd">if</span> getConstant(params[3], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := getValue(evaluatedParam, integer);
                <span class="keywd">if</span> number > 0 <span class="op">and</span> number &lt; ccConf.INTTYPE_SIZE <span class="keywd">then</span>
                  valueRange.minValue := integer.first >> number;
                  valueRange.maxValue := integer.last >> number;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">elsif</span> getConstant(params[1], INTOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := getValue(evaluatedParam, integer);
                <span class="keywd">if</span> number &lt; 0 <span class="keywd">then</span>
                  valueRange.minValue := number;
                  valueRange.maxValue := -1;
                <span class="keywd">else</span>
                  valueRange.minValue := 0;
                  valueRange.maxValue := number;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"INT_SQRT"</span>}:
              valueRange.minValue := 0;
              valueRange.maxValue := sqrt(integer.last);
            <span class="keywd">when</span> {<span class="stri">"INT_SUCC"</span>}:
              argument1Range := getIntRange(params[1]);
              <span class="keywd">if</span> argument1Range.minValue &lt;> integer.last <span class="keywd">then</span>
                valueRange.minValue := succ(argument1Range.minValue);
              <span class="keywd">else</span>
                valueRange.minValue := integer.last;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> argument1Range.maxValue &lt;> integer.last <span class="keywd">then</span>
                valueRange.maxValue := succ(argument1Range.maxValue);
              <span class="keywd">else</span>
                valueRange.maxValue := integer.last;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> <span class="op">not</span> argument1Range.mayRaiseException <span class="op">and</span>
                  argument1Range.maxValue &lt;> integer.last <span class="keywd">then</span>
                valueRange.mayRaiseException := FALSE;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"SET_RAND"</span>}:
              valueRange := getSetRandRange(params[1]);
            <span class="keywd">when</span> {<span class="stri">"STR_CHIPOS"</span>, <span class="stri">"STR_CHPOS"</span>, <span class="stri">"STR_IPOS"</span>, <span class="stri">"STR_POS"</span>,
                  <span class="stri">"STR_RCHIPOS"</span>, <span class="stri">"STR_RCHPOS"</span>, <span class="stri">"STR_RIPOS"</span>, <span class="stri">"STR_RPOS"</span>}:
              <span class="keywd">if</span> getConstant(params[1], STRIOBJECT, evaluatedParam) <span class="keywd">then</span>
                number := length(getValue(evaluatedParam, string));
                valueRange.minValue := 0;
                valueRange.maxValue := number;
              <span class="keywd">elsif</span> ccConf.POINTER_SIZE > ccConf.INTTYPE_SIZE <span class="keywd">then</span>
                valueRange.minValue := 0;
                valueRange.maxValue := integer.last;
              <span class="keywd">else</span>
                valueRange.minValue := 0;
                <span class="comment"># Because of UTF-32 the available bytes are divided by four.</span>
                valueRange.maxValue := 2 ** (ccConf.POINTER_SIZE - 2);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">when</span> {<span class="stri">"STR_LNG"</span>}:
              <span class="keywd">if</span> ccConf.POINTER_SIZE > ccConf.INTTYPE_SIZE <span class="keywd">then</span>
                valueRange.minValue := 0;
                valueRange.maxValue := integer.last;
              <span class="keywd">else</span>
                valueRange.minValue := 0;
                <span class="comment"># Because of UTF-32 the available bytes are divided by four.</span>
                valueRange.maxValue := 2 ** (ccConf.POINTER_SIZE - 2);
              <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">case</span>;
          <span class="comment"># writeln(actionName &lt;&amp; ": " &lt;&amp; valueRange.minValue &lt;&amp; " " &lt;&amp; valueRange.maxValue);</span>
        <span class="keywd">elsif</span> category(function) = BLOCKOBJECT <span class="keywd">then</span>
          <span class="keywd">if</span> resultVar(function) = NIL <span class="op">and</span>
              resultInitValue(function) = NIL <span class="op">and</span>
              localConsts(function) = ref_list.EMPTY <span class="op">and</span>
              localVars(function) = ref_list.EMPTY <span class="keywd">then</span>
            valueRange := getIntRange(body(function));
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="comment"># writeln("BLOCKOBJECT: " &lt;&amp; valueRange.minValue &lt;&amp; " " &lt;&amp; valueRange.maxValue);</span>
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
