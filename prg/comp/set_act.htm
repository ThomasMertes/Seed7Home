<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../../style1.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  set_act.s7i   Generate code for actions of the type set.        *)</span>
<span class="comment">(*  Copyright (C) 1990 - 1994, 2004 - 2015  Thomas Mertes           *)</span>
<span class="comment">(*                2019 - 2022  Thomas Mertes                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 compiler.                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">const</span> <span class="type">ACTION</span>: SET_ARRLIT           <span class="keywd">is</span> action <span class="stri">"SET_ARRLIT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_BASELIT          <span class="keywd">is</span> action <span class="stri">"SET_BASELIT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_CARD             <span class="keywd">is</span> action <span class="stri">"SET_CARD"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_CMP              <span class="keywd">is</span> action <span class="stri">"SET_CMP"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_CONV1            <span class="keywd">is</span> action <span class="stri">"SET_CONV1"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_CONV3            <span class="keywd">is</span> action <span class="stri">"SET_CONV3"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_CPY              <span class="keywd">is</span> action <span class="stri">"SET_CPY"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_DIFF             <span class="keywd">is</span> action <span class="stri">"SET_DIFF"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_DIFF_ASSIGN      <span class="keywd">is</span> action <span class="stri">"SET_DIFF_ASSIGN"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_ELEM             <span class="keywd">is</span> action <span class="stri">"SET_ELEM"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_EQ               <span class="keywd">is</span> action <span class="stri">"SET_EQ"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_EXCL             <span class="keywd">is</span> action <span class="stri">"SET_EXCL"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_GE               <span class="keywd">is</span> action <span class="stri">"SET_GE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_GT               <span class="keywd">is</span> action <span class="stri">"SET_GT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_HASHCODE         <span class="keywd">is</span> action <span class="stri">"SET_HASHCODE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_ICONV1           <span class="keywd">is</span> action <span class="stri">"SET_ICONV1"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_ICONV3           <span class="keywd">is</span> action <span class="stri">"SET_ICONV3"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_INCL             <span class="keywd">is</span> action <span class="stri">"SET_INCL"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_INTERSECT        <span class="keywd">is</span> action <span class="stri">"SET_INTERSECT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_INTERSECT_ASSIGN <span class="keywd">is</span> action <span class="stri">"SET_INTERSECT_ASSIGN"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_LE               <span class="keywd">is</span> action <span class="stri">"SET_LE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_LT               <span class="keywd">is</span> action <span class="stri">"SET_LT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_MAX              <span class="keywd">is</span> action <span class="stri">"SET_MAX"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_MIN              <span class="keywd">is</span> action <span class="stri">"SET_MIN"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_NE               <span class="keywd">is</span> action <span class="stri">"SET_NE"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_NEXT             <span class="keywd">is</span> action <span class="stri">"SET_NEXT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_NOT_ELEM         <span class="keywd">is</span> action <span class="stri">"SET_NOT_ELEM"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_RAND             <span class="keywd">is</span> action <span class="stri">"SET_RAND"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_RANGELIT         <span class="keywd">is</span> action <span class="stri">"SET_RANGELIT"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_SCONV1           <span class="keywd">is</span> action <span class="stri">"SET_SCONV1"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_SCONV3           <span class="keywd">is</span> action <span class="stri">"SET_SCONV3"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_SYMDIFF          <span class="keywd">is</span> action <span class="stri">"SET_SYMDIFF"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_UNION            <span class="keywd">is</span> action <span class="stri">"SET_UNION"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_UNION_ASSIGN     <span class="keywd">is</span> action <span class="stri">"SET_UNION_ASSIGN"</span>;
<span class="keywd">const</span> <span class="type">ACTION</span>: SET_VALUE            <span class="keywd">is</span> action <span class="stri">"SET_VALUE"</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: bitset_pos (<span class="op">in</span> <span class="type">integer</span>: number) <span class="keywd">is</span>
  <span class="keywd">return</span> number >> log2(ccConf.INTTYPE_SIZE);


<span class="keywd">const</span> <span class="type">proc</span>: set_prototypes (<span class="keywd">inout</span> <span class="type">file</span>: c_prog) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    declareExtern(c_prog, <span class="stri">"setType     setArrlit (const_arrayType);"</span>);
    declareExtern(c_prog, <span class="stri">"setType     setBaselit (const intType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     setCard (const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     setCmp (const const_setType, const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     setCmpGeneric (const genericType, const genericType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        setCpy (setType *const, const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        setCpyGeneric (genericType *const, const genericType);"</span>);
    declareExtern(c_prog, <span class="stri">"setType     setCreate (const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"genericType setCreateGeneric (const genericType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        setDestr (const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        setDestrGeneric (const genericType);"</span>);
    declareExtern(c_prog, <span class="stri">"setType     setDiff (const const_setType, const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        setDiffAssign (setType *const, const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"boolType    setElem (const intType, const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"boolType    setEq (const const_setType, const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        setExcl (setType *const, const intType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     setHashCode (const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"setType     setIConv (intType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        setIncl (setType *const, const intType);"</span>);
    declareExtern(c_prog, <span class="stri">"setType     setIntersect (const const_setType, const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        setIntersectAssign (setType *const, const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"boolType    setIsEmpty (const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"boolType    setIsProperSubset (const const_setType, const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"boolType    setIsSubset (const const_setType, const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     setMax (const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     setMin (const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     setNext (const const_setType, const intType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     setRand (const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"setType     setRangelit (const intType, const intType);"</span>);
    declareExtern(c_prog, <span class="stri">"intType     setSConv (const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"setType     setSymdiff (const const_setType, const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"setType     setUnion (const const_setType, const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"void        setUnionAssign (setType *const, const const_setType);"</span>);
    declareExtern(c_prog, <span class="stri">"setType     setValue (const const_objRefType);"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: bitsetElemAsHex (<span class="op">in</span> <span class="type">bitset</span>: set1, <span class="op">in</span> <span class="type">integer</span>: start_num) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: hex_num <span class="keywd">is</span> <span class="stri">" "</span> <span class="op">mult</span> ccConf.INTTYPE_SIZE <span class="op">div</span> 4 + 2;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">string</span>: to_hex <span class="keywd">is</span> <span class="stri">"0123456789abcdef"</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: hex_digit_num <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bit_num <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: hex_digit <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: digit_idx <span class="keywd">is</span> ccConf.INTTYPE_SIZE <span class="op">div</span> 4 + 2;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> hex_digit_num <span class="keywd">range</span> start_num <span class="keywd">to</span> start_num + pred(ccConf.INTTYPE_SIZE) step 4 <span class="keywd">do</span>
      hex_digit := 0;
      <span class="keywd">for</span> bit_num <span class="keywd">range</span> 0 <span class="keywd">to</span> 3 <span class="keywd">do</span>
        <span class="keywd">if</span> hex_digit_num + bit_num <span class="op">in</span> set1 <span class="keywd">then</span>
          hex_digit +:= 2 ** bit_num;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      hex_num @:= [digit_idx] to_hex[succ(hex_digit)];
      decr(digit_idx);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    hex_num @:= [1] <span class="stri">"0x"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_ARRLIT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_set_result(resultType(getType(function)), c_expr);
    c_expr.result_expr := <span class="stri">"setArrlit("</span>;
    getAnyParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_BASELIT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_set_result(resultType(getType(function)), c_expr);
    c_expr.result_expr := <span class="stri">"setBaselit("</span>;
    getStdParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_CARD, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: argument <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">intRange</span>: argumentRange <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">string</span>: argumentName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> evaluate_const_expr >= 1 <span class="op">and</span>
        (isActionExpression(params[1], <span class="stri">"SET_ICONV1"</span>) <span class="op">or</span>
         isActionExpression(params[1], <span class="stri">"SET_ICONV3"</span>)) <span class="keywd">then</span>
      incr(countOptimizations);
      <span class="keywd">if</span> isActionExpression(params[1], <span class="stri">"SET_ICONV1"</span>) <span class="keywd">then</span>
        argument := getActionParameter(params[1], 1);
      <span class="keywd">else</span>
        argument := getActionParameter(params[1], 3);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      argumentRange := getIntRange(argument);
      <span class="keywd">if</span> argumentRange.maxValue &lt; 0 <span class="keywd">then</span>
        warning(DOES_RAISE, <span class="stri">"RANGE_ERROR"</span>, c_expr);
        c_expr.expr &amp;:= intRaiseError(<span class="stri">"RANGE_ERROR"</span>);
      <span class="keywd">elsif</span> argumentRange.minValue = argumentRange.maxValue <span class="keywd">then</span>
        c_expr.expr &amp;:= integerLiteral(card(bitset(argumentRange.minValue)));
      <span class="keywd">elsif</span> function_range_check <span class="keywd">then</span>
        <span class="keywd">if</span> argumentRange.minValue >= 0 <span class="keywd">then</span>
          <span class="comment"># This computation cannot overflow</span>
          c_expr.expr &amp;:= <span class="stri">"/*no_range_check_cardinality*/uintCard((uintType) ("</span>;
          process_expr(argument, c_expr);
          c_expr.expr &amp;:= <span class="stri">"))"</span>;
        <span class="keywd">else</span>
          incr(countRangeChecks);
          c_expr.expr &amp;:= <span class="stri">"("</span>;
          argumentName := getTempVariable(<span class="stri">"intType"</span>, <span class="stri">"tmp_"</span>, argument, c_expr);
          c_expr.expr &amp;:= <span class="stri">"rngChk("</span>;
          c_expr.expr &amp;:= argumentName;
          c_expr.expr &amp;:= <span class="stri">" &lt; "</span>;
          c_expr.expr &amp;:= integerLiteral(0);
          c_expr.expr &amp;:= <span class="stri">") ? "</span>;
          c_expr.expr &amp;:= intRaiseError(<span class="stri">"RANGE_ERROR"</span>);
          c_expr.expr &amp;:= <span class="stri">" : "</span>;
          c_expr.expr &amp;:= <span class="stri">"uintCard((uintType) ("</span>;
          c_expr.expr &amp;:= argumentName;
          c_expr.expr &amp;:= <span class="stri">")))"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        incr(countNoRangeChecks);
        c_expr.expr &amp;:= <span class="stri">"uintCard((uintType) ("</span>;
        process_expr(argument, c_expr);
        c_expr.expr &amp;:= <span class="stri">"))"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"setCard("</span>;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_CMP, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"setCmp("</span>;
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    getAnyParamToExpr(params[2], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_CONV1, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    process_expr(params[1], c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_CONV3, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    process_expr(params[3], c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_CPY, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param1 <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">expr_type</span>: c_param3 <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    process_expr(params[1], c_param1);
    c_param3.temp_num := c_param1.temp_num;
    process_expr(params[3], c_param3);
    <span class="keywd">if</span> has_temp_values(c_param3) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      appendWithDiagnostic(c_param1.temp_decls, c_expr);
      appendWithDiagnostic(c_param3.temp_decls, c_expr);
      appendWithDiagnostic(c_param1.temp_assigns, c_expr);
      appendWithDiagnostic(c_param3.temp_assigns, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> c_param3.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      setDiagnosticLine(c_expr);
      <span class="keywd">if</span> isNormalVariable(params[1]) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"setType old_set="</span>;
        c_expr.expr &amp;:= c_param1.expr;
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= c_param1.expr;
        c_expr.expr &amp;:= <span class="stri">"="</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"setType *set_ptr=&amp;("</span>;
        c_expr.expr &amp;:= c_param1.expr;
        c_expr.expr &amp;:= <span class="stri">");\n"</span>;
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"setType old_set=*set_ptr;\n"</span>;
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"*set_ptr="</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= c_param3.result_expr;
      c_expr.expr &amp;:= <span class="stri">";\n"</span>;
      setDiagnosticLine(c_expr);
      c_expr.expr &amp;:= <span class="stri">"setDestr(old_set);\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">else</span>
      setDiagnosticLine(c_expr);
      c_expr.expr &amp;:= <span class="stri">"setCpy(&amp;("</span>;
      c_expr.expr &amp;:= c_param1.expr;
      c_expr.expr &amp;:= <span class="stri">"), "</span>;
      c_expr.expr &amp;:= c_param3.expr;
      c_expr.expr &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> has_temp_values(c_param3) <span class="keywd">then</span>
      appendWithDiagnostic(c_param1.temp_frees, c_expr);
      appendWithDiagnostic(c_param3.temp_frees, c_expr);
      c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_DIFF, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], SETOBJECT, evaluatedParam) <span class="op">and</span>
        getValue(evaluatedParam, bitset) = EMPTY_SET <span class="keywd">then</span>
      c_expr.expr &amp;:= bitsetLiteral(EMPTY_SET);
    <span class="keywd">elsif</span> getConstant(params[3], SETOBJECT, evaluatedParam) <span class="op">and</span>
        getValue(evaluatedParam, bitset) = EMPTY_SET <span class="keywd">then</span>
      process_expr(params[1], c_expr);
    <span class="keywd">else</span>
      prepare_set_result(getExprResultType(params[1]), c_expr);
      c_expr.result_expr := <span class="stri">"setDiff("</span>;
      getAnyParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToResultExpr(params[3], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_DIFF_ASSIGN, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[3], SETOBJECT, evaluatedParam) <span class="op">and</span>
        getValue(evaluatedParam, bitset) = EMPTY_SET <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"/* ignore: set -:= EMPTY_SET */\n"</span>;
    <span class="keywd">else</span>
      statement.expr := <span class="stri">"setDiffAssign(&amp;("</span>;
      process_expr(params[1], statement);
      statement.expr &amp;:= <span class="stri">"), "</span>;
      getAnyParamToExpr(params[3], statement);
      statement.expr &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    doLocalDeclsOfStatement(statement, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_set_elem (<span class="op">in</span> <span class="type">reference</span>: param1, <span class="op">in</span> <span class="keywd">var</span> <span class="type">bitset</span>: aBitset,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">intRange</span>: numberRange <span class="keywd">is</span> intRange.value;
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: number_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: first_element <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">boolean</span>: isElement <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    numberRange := getIntRange(param1);
    <span class="keywd">if</span> aBitset &lt;> EMPTY_SET <span class="keywd">then</span>
      aBitset &amp;:= {max(numberRange.minValue, min(aBitset)) ..
                   min(numberRange.maxValue, max(aBitset))};
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> getConstant(param1, INTOBJECT, evaluatedParam) <span class="keywd">then</span>
      incr(countOptimizations);
      isElement := getValue(evaluatedParam, integer) <span class="op">in</span> aBitset;
      c_expr.expr &amp;:= str(ord(isElement));
      c_expr.expr &amp;:= <span class="stri">"/*"</span>;
      c_expr.expr &amp;:= str(isElement);
      c_expr.expr &amp;:= <span class="stri">"*/"</span>;
    <span class="keywd">elsif</span> aBitset = EMPTY_SET <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"0/*FALSE*/"</span>;
    <span class="keywd">elsif</span> numberRange.minValue >= min(aBitset) <span class="op">and</span>
          numberRange.maxValue &lt;= max(aBitset) <span class="op">and</span>
          {numberRange.minValue .. numberRange.maxValue} &lt;= aBitset <span class="op">and</span>
          <span class="op">not</span> numberRange.mayRaiseException <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"1/*TRUE*/"</span>;
    <span class="keywd">elsif</span> card(aBitset) = 1 <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      process_expr(param1, c_expr);
      c_expr.expr &amp;:= <span class="stri">") == "</span>;
      c_expr.expr &amp;:= integerLiteral(min(aBitset));
    <span class="keywd">elsif</span> card(aBitset) >= 3 <span class="op">and</span> max(aBitset) - min(aBitset) = pred(card(aBitset)) <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      number_name := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"tmp_"</span>, param1, c_expr);
      <span class="keywd">if</span> ccConf.TWOS_COMPLEMENT_INTTYPE <span class="op">and</span> min(aBitset) = 0 <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"(uintType)("</span>;
        c_expr.expr &amp;:= number_name;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= number_name;
        c_expr.expr &amp;:= <span class="stri">">="</span>;
        c_expr.expr &amp;:= integerLiteral(min(aBitset));
        c_expr.expr &amp;:= <span class="stri">" &amp;&amp; "</span>;
        c_expr.expr &amp;:= number_name;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">"&lt;="</span>;
      c_expr.expr &amp;:= integerLiteral(max(aBitset));
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">elsif</span> card(aBitset) = 2 <span class="op">or</span>
        card(aBitset) = 3 <span class="op">and</span> (min(aBitset) &lt; 0 <span class="op">or</span> max(aBitset) >= ccConf.INTTYPE_SIZE) <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      number_name := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"tmp_"</span>, param1, c_expr);
      <span class="keywd">for</span> number <span class="keywd">range</span> aBitset <span class="keywd">do</span>
        <span class="keywd">if</span> first_element <span class="keywd">then</span>
          first_element := FALSE;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"||"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= number_name;
        c_expr.expr &amp;:= <span class="stri">"=="</span>;
        c_expr.expr &amp;:= integerLiteral(number);
      <span class="keywd">end</span> <span class="keywd">for</span>;
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">elsif</span> min(aBitset) >= 0 <span class="op">and</span> max(aBitset) &lt; ccConf.INTTYPE_SIZE <span class="keywd">then</span>
      incr(countOptimizations);
      <span class="keywd">if</span> numberRange.minValue >= 0 <span class="op">and</span> numberRange.maxValue &lt; ccConf.INTTYPE_SIZE <span class="keywd">then</span>
        c_expr.expr &amp;:= bitsetElemAsHex(aBitset, 0);
        c_expr.expr &amp;:= <span class="stri">">>("</span>;
        process_expr(param1, c_expr);
        c_expr.expr &amp;:= <span class="stri">")&amp;1"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        number_name := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"tmp_"</span>, param1, c_expr);
        <span class="keywd">if</span> ccConf.TWOS_COMPLEMENT_INTTYPE <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"(uintType)("</span>;
          c_expr.expr &amp;:= number_name;
          c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= number_name;
          c_expr.expr &amp;:= <span class="stri">">=0&amp;&amp;"</span>;
          c_expr.expr &amp;:= number_name;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"&lt;="</span>;
        c_expr.expr &amp;:= str(max(aBitset));
        c_expr.expr &amp;:= <span class="stri">"&amp;&amp;"</span>;
        c_expr.expr &amp;:= bitsetElemAsHex(aBitset, 0);
        c_expr.expr &amp;:= <span class="stri">">>"</span>;
        c_expr.expr &amp;:= number_name;
        c_expr.expr &amp;:= <span class="stri">"&amp;1)"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> max(aBitset) - min(aBitset) &lt; ccConf.INTTYPE_SIZE <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      number_name := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"tmp_"</span>, param1, c_expr);
      <span class="keywd">if</span> max(aBitset) >= integer.first + ccConf.INTTYPE_SIZE <span class="op">and</span>
          max(aBitset) - ccConf.INTTYPE_SIZE &lt; numberRange.minValue <span class="keywd">then</span>
        <span class="keywd">if</span> numberRange.minValue &lt;= integer.last - ccConf.INTTYPE_SIZE <span class="op">and</span>
            numberRange.maxValue >= numberRange.minValue + ccConf.INTTYPE_SIZE <span class="keywd">then</span>
          c_expr.expr &amp;:= number_name;
          c_expr.expr &amp;:= <span class="stri">"&lt;="</span>;
          c_expr.expr &amp;:= integerLiteral(max(aBitset));
          c_expr.expr &amp;:= <span class="stri">"&amp;&amp;"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= bitsetElemAsHex(aBitset, numberRange.minValue);
        c_expr.expr &amp;:= <span class="stri">">>("</span>;
        c_expr.expr &amp;:= number_name;
        c_expr.expr &amp;:= <span class="stri">"-("</span>;
        c_expr.expr &amp;:= integerLiteral(numberRange.minValue);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= number_name;
        c_expr.expr &amp;:= <span class="stri">">="</span>;
        c_expr.expr &amp;:= integerLiteral(min(aBitset));
        c_expr.expr &amp;:= <span class="stri">"&amp;&amp;"</span>;
        c_expr.expr &amp;:= number_name;
        c_expr.expr &amp;:= <span class="stri">"&lt;="</span>;
        c_expr.expr &amp;:= integerLiteral(max(aBitset));
        c_expr.expr &amp;:= <span class="stri">"&amp;&amp;"</span>;
        c_expr.expr &amp;:= bitsetElemAsHex(aBitset, min(aBitset));
        c_expr.expr &amp;:= <span class="stri">">>("</span>;
        c_expr.expr &amp;:= number_name;
        c_expr.expr &amp;:= <span class="stri">"-("</span>;
        c_expr.expr &amp;:= integerLiteral(min(aBitset));
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">"))&amp;1)"</span>;
    <span class="keywd">elsif</span> inlineFunctions <span class="keywd">then</span>
      incr(countOptimizations);
      incr(countInlinedFunctions);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      number_name := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"tmp_"</span>, param1, c_expr);
      <span class="keywd">if</span> ccConf.TWOS_COMPLEMENT_INTTYPE <span class="op">and</span> bitset_pos(min(aBitset)) = 0 <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"(uintType)("</span>;
        c_expr.expr &amp;:= number_name;
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= number_name;
        c_expr.expr &amp;:= <span class="stri">">="</span>;
        c_expr.expr &amp;:= integerLiteral(min(aBitset));
        c_expr.expr &amp;:= <span class="stri">"&amp;&amp;"</span>;
        c_expr.expr &amp;:= number_name;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">"&lt;="</span>;
      c_expr.expr &amp;:= integerLiteral(max(aBitset));
      c_expr.expr &amp;:= <span class="stri">"&amp;&amp;"</span>;
      c_expr.expr &amp;:= bitsetLiteral(aBitset);
      c_expr.expr &amp;:= <span class="stri">"->bitset[(uintType)(bitset_pos("</span>;
      c_expr.expr &amp;:= number_name;
      c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">if</span> bitset_pos(min(aBitset)) &lt;> 0 <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"-"</span>;
        c_expr.expr &amp;:= integerLiteral(bitset_pos(min(aBitset)));
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">")] >> ("</span>;
      c_expr.expr &amp;:= number_name;
      c_expr.expr &amp;:= <span class="stri">" &amp; bitset_mask)&amp;1)"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"setElem("</span>;
      process_expr(param1, c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      c_expr.expr &amp;:= bitsetLiteral(aBitset);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_set_elem (<span class="op">in</span> <span class="type">reference</span>: param1, <span class="op">in</span> <span class="type">reference</span>: param3,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: number_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: position_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: set_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(param3, SETOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_set_elem(param1, getValue(evaluatedParam, bitset), c_expr);
    <span class="keywd">elsif</span> inlineFunctions <span class="keywd">then</span>
      incr(countOptimizations);
      incr(countInlinedFunctions);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      number_name := getParameterAsVariable(<span class="stri">"intType"</span>, <span class="stri">"tmp_"</span>, param1, c_expr);
      set_name := getParameterAsVariable(<span class="stri">"const_setType"</span>, <span class="stri">"tmp_"</span>, param3, c_expr);
      incr(c_expr.temp_num);
      position_name := <span class="stri">"tmp_"</span> &amp; str(c_expr.temp_num);
      c_expr.temp_decls &amp;:= <span class="stri">"intType "</span>;
      c_expr.temp_decls &amp;:= position_name;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      c_expr.expr &amp;:= position_name;
      c_expr.expr &amp;:= <span class="stri">"=bitset_pos("</span>;
      c_expr.expr &amp;:= number_name;
      c_expr.expr &amp;:= <span class="stri">"),"</span>;
      c_expr.expr &amp;:= position_name;
      c_expr.expr &amp;:= <span class="stri">">="</span>;
      c_expr.expr &amp;:= set_name;
      c_expr.expr &amp;:= <span class="stri">"->min_position&amp;&amp;"</span>;
      c_expr.expr &amp;:= position_name;
      c_expr.expr &amp;:= <span class="stri">"&lt;="</span>;
      c_expr.expr &amp;:= set_name;
      c_expr.expr &amp;:= <span class="stri">"->max_position&amp;&amp;"</span>;
      c_expr.expr &amp;:= set_name;
      c_expr.expr &amp;:= <span class="stri">"->bitset[(uintType)("</span>;
      c_expr.expr &amp;:= position_name;
      c_expr.expr &amp;:= <span class="stri">"-"</span>;
      c_expr.expr &amp;:= set_name;
      c_expr.expr &amp;:= <span class="stri">"->min_position)] >> ("</span>;
      c_expr.expr &amp;:= number_name;
      c_expr.expr &amp;:= <span class="stri">" &amp; bitset_mask)&amp;1)"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"setElem("</span>;
      process_expr(param1, c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToExpr(param3, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_ELEM, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    process_set_elem(params[1], params[3], c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_set_eq (<span class="op">in</span> <span class="type">reference</span>: param1, <span class="op">in</span> <span class="type">bitset</span>: aBitset,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">boolean</span>: isEqual <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(param1, SETOBJECT, evaluatedParam) <span class="keywd">then</span>
      incr(countOptimizations);
      isEqual := getValue(evaluatedParam, bitset) = aBitset;
      c_expr.expr &amp;:= str(ord(isEqual));
      c_expr.expr &amp;:= <span class="stri">"/*"</span>;
      c_expr.expr &amp;:= str(isEqual);
      c_expr.expr &amp;:= <span class="stri">"*/"</span>;
    <span class="keywd">elsif</span> aBitset = EMPTY_SET <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"setIsEmpty("</span>;
      getAnyParamToExpr(param1, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"setEq("</span>;
      getAnyParamToExpr(param1, c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      c_expr.expr &amp;:= bitsetLiteral(aBitset);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_EQ, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], SETOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_set_eq(params[3], getValue(evaluatedParam, bitset), c_expr);
    <span class="keywd">elsif</span> getConstant(params[3], SETOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_set_eq(params[1], getValue(evaluatedParam, bitset), c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"setEq("</span>;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToExpr(params[3], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_inline_set_excl (<span class="op">in</span> <span class="type">ref_list</span>: params,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">string</span>: number_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: position_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: set_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isNormalVariable(params[1]) <span class="keywd">then</span>
      set_name := normalVariable(params[1], statement);
    <span class="keywd">else</span>
      incr(statement.temp_num);
      set_name := <span class="stri">"tmp_"</span> &amp; str(statement.temp_num);
      statement.temp_decls &amp;:= <span class="stri">"setType "</span>;
      statement.temp_decls &amp;:= set_name;
      statement.temp_decls &amp;:= <span class="stri">";\n"</span>;
      statement.expr &amp;:= set_name;
      statement.expr &amp;:= <span class="stri">"="</span>;
      process_expr(params[1], statement);
      statement.expr &amp;:= <span class="stri">";\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> isNormalVariable(params[2]) <span class="keywd">then</span>
      number_name := normalVariable(params[2], statement);
    <span class="keywd">else</span>
      incr(statement.temp_num);
      number_name := <span class="stri">"tmp_"</span> &amp; str(statement.temp_num);
      statement.temp_decls &amp;:= <span class="stri">"intType "</span>;
      statement.temp_decls &amp;:= number_name;
      statement.temp_decls &amp;:= <span class="stri">";\n"</span>;
      statement.expr &amp;:= number_name;
      statement.expr &amp;:= <span class="stri">"="</span>;
      process_expr(params[2], statement);
      statement.expr &amp;:= <span class="stri">";\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    incr(statement.temp_num);
    position_name := <span class="stri">"tmp_"</span> &amp; str(statement.temp_num);
    statement.temp_decls &amp;:= <span class="stri">"intType "</span>;
    statement.temp_decls &amp;:= position_name;
    statement.temp_decls &amp;:= <span class="stri">";\n"</span>;
    statement.expr &amp;:= position_name;
    statement.expr &amp;:= <span class="stri">"=bitset_pos("</span>;
    statement.expr &amp;:= number_name;
    statement.expr &amp;:= <span class="stri">");\n"</span>;
    statement.expr &amp;:= <span class="stri">"if ("</span>;
    statement.expr &amp;:= position_name;
    statement.expr &amp;:= <span class="stri">">="</span>;
    statement.expr &amp;:= set_name;
    statement.expr &amp;:= <span class="stri">"->min_position&amp;&amp;"</span>;
    statement.expr &amp;:= position_name;
    statement.expr &amp;:= <span class="stri">"&lt;="</span>;
    statement.expr &amp;:= set_name;
    statement.expr &amp;:= <span class="stri">"->max_position) {\n"</span>;
    statement.expr &amp;:= set_name;
    statement.expr &amp;:= <span class="stri">"->bitset[(uintType)("</span>;
    statement.expr &amp;:= position_name;
    statement.expr &amp;:= <span class="stri">"-"</span>;
    statement.expr &amp;:= set_name;
    statement.expr &amp;:= <span class="stri">"->min_position)] &amp;= ~((bitSetType) 1 &lt;&lt; (((unsigned int) "</span>;
    statement.expr &amp;:= number_name;
    statement.expr &amp;:= <span class="stri">") &amp; bitset_mask));\n"</span>;
    statement.expr &amp;:= <span class="stri">"}\n"</span>;
    doLocalDeclsOfStatement(statement, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_EXCL, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> inlineFunctions <span class="keywd">then</span>
      incr(countOptimizations);
      incr(countInlinedFunctions);
      process_inline_set_excl(params, c_expr);
    <span class="keywd">else</span>
      statement.expr := <span class="stri">"setExcl(&amp;("</span>;
      process_expr(params[1], statement);
      statement.expr &amp;:= <span class="stri">"), "</span>;
      process_expr(params[2], statement);
      statement.expr &amp;:= <span class="stri">");\n"</span>;
      doLocalDeclsOfStatement(statement, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_GE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"setIsSubset("</span>;
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_GT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"setIsProperSubset("</span>;
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_HASHCODE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"setHashCode("</span>;
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_ICONV1, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"setIConv("</span>;
    process_expr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_ICONV3, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"setIConv("</span>;
    process_expr(params[3], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_INCL, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    statement.expr := <span class="stri">"setIncl(&amp;("</span>;
    process_expr(params[1], statement);
    statement.expr &amp;:= <span class="stri">"), "</span>;
    process_expr(params[2], statement);
    statement.expr &amp;:= <span class="stri">");\n"</span>;
    doLocalDeclsOfStatement(statement, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_INTERSECT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], SETOBJECT, evaluatedParam) <span class="op">and</span>
        getValue(evaluatedParam, bitset) = EMPTY_SET <span class="op">or</span>
        getConstant(params[3], SETOBJECT, evaluatedParam) <span class="op">and</span>
        getValue(evaluatedParam, bitset) = EMPTY_SET <span class="keywd">then</span>
      c_expr.expr &amp;:= bitsetLiteral(EMPTY_SET);
    <span class="keywd">else</span>
      prepare_set_result(getExprResultType(params[1]), c_expr);
      c_expr.result_expr := <span class="stri">"setIntersect("</span>;
      getAnyParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToResultExpr(params[3], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_INTERSECT_ASSIGN, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[3], SETOBJECT, evaluatedParam) <span class="op">and</span>
        getValue(evaluatedParam, bitset) = EMPTY_SET <span class="keywd">then</span>
      incr(countOptimizations);
      statement.expr &amp;:= <span class="stri">"setCpy(&amp;("</span>;
      process_expr(params[1], statement);
      statement.expr &amp;:= <span class="stri">"), "</span>;
      statement.expr &amp;:= bitsetLiteral(EMPTY_SET);
      statement.expr &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">else</span>
      statement.expr := <span class="stri">"setIntersectAssign(&amp;("</span>;
      process_expr(params[1], statement);
      statement.expr &amp;:= <span class="stri">"), "</span>;
      getAnyParamToExpr(params[3], statement);
      statement.expr &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    doLocalDeclsOfStatement(statement, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_LE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"setIsSubset("</span>;
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_LT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"setIsProperSubset("</span>;
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_MAX, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"setMax("</span>;
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_MIN, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"setMin("</span>;
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_NE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"!"</span>;
    process(SET_EQ, function, params, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_NEXT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"setNext("</span>;
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    process_expr(params[2], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_NOT_ELEM, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"!("</span>;
    process_set_elem(params[1], params[4], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_set_rand (<span class="op">in</span> <span class="type">bitset</span>: aBitset,
    <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> aBitset = EMPTY_SET <span class="keywd">then</span>
      incr(countOptimizations);
      warning(DOES_RAISE, <span class="stri">"RANGE_ERROR"</span>, c_expr);
      c_expr.expr &amp;:= intRaiseError(<span class="stri">"RANGE_ERROR"</span>);
    <span class="keywd">elsif</span> card(aBitset) = 1 <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= integerLiteral(min(aBitset));
    <span class="keywd">elsif</span> min(aBitset) + pred(card(aBitset)) = max(aBitset) <span class="keywd">then</span>
      process_const_int_rand(min(aBitset), max(aBitset), c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"setRand("</span>;
      c_expr.expr &amp;:= bitsetLiteral(aBitset);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_RAND, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], SETOBJECT, evaluatedParam) <span class="keywd">then</span>
      process_const_set_rand(getValue(evaluatedParam, bitset), c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"setRand("</span>;
      getAnyParamToExpr(params[1], c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_RANGELIT, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_set_result(resultType(getType(function)), c_expr);
    c_expr.result_expr := <span class="stri">"setRangelit("</span>;
    getAnyParamToResultExpr(params[2], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">", "</span>;
    getAnyParamToResultExpr(params[4], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_SCONV1, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"setSConv("</span>;
    getAnyParamToExpr(params[1], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_SCONV3, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"setSConv("</span>;
    getAnyParamToExpr(params[3], c_expr);
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_SYMDIFF, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_set_result(getExprResultType(params[1]), c_expr);
    c_expr.result_expr := <span class="stri">"setSymdiff("</span>;
    getAnyParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">", "</span>;
    getAnyParamToResultExpr(params[3], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_UNION, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[1], SETOBJECT, evaluatedParam) <span class="op">and</span>
        getValue(evaluatedParam, bitset) = EMPTY_SET <span class="keywd">then</span>
      process_expr(params[3], c_expr);
    <span class="keywd">elsif</span> getConstant(params[3], SETOBJECT, evaluatedParam) <span class="op">and</span>
        getValue(evaluatedParam, bitset) = EMPTY_SET <span class="keywd">then</span>
      process_expr(params[1], c_expr);
    <span class="keywd">else</span>
      prepare_set_result(getExprResultType(params[1]), c_expr);
      c_expr.result_expr := <span class="stri">"setUnion("</span>;
      getAnyParamToResultExpr(params[1], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">", "</span>;
      getAnyParamToResultExpr(params[3], c_expr);
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_UNION_ASSIGN, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">expr_type</span>: statement <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getConstant(params[3], SETOBJECT, evaluatedParam) <span class="op">and</span>
        getValue(evaluatedParam, bitset) = EMPTY_SET <span class="keywd">then</span>
      incr(countOptimizations);
      c_expr.expr &amp;:= <span class="stri">"/* ignore: set |:= EMPTY_SET */\n"</span>;
    <span class="keywd">else</span>
      statement.expr := <span class="stri">"setUnionAssign(&amp;("</span>;
      process_expr(params[1], statement);
      statement.expr &amp;:= <span class="stri">"), "</span>;
      getAnyParamToExpr(params[3], statement);
      statement.expr &amp;:= <span class="stri">");\n"</span>;
      doLocalDeclsOfStatement(statement, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (SET_VALUE, <span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: params, <span class="keywd">inout</span> <span class="type">expr_type</span>: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    prepare_set_result(resultType(getType(function)), c_expr);
    c_expr.result_expr := <span class="stri">"setValue("</span>;
    getStdParamToResultExpr(params[1], c_expr);
    c_expr.result_expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
