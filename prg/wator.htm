<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  wator.sd7     Planet Wator simulation with fish and sharks      *)</span>
<span class="comment">(*  Copyright (C) 2006  Thomas Mertes                               *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/seed7_05.htm">seed7_05.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/console.htm">console.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/window.htm">window.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/keybd.htm">keybd.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/float.htm">float.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/draw.htm">draw.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/stdfont9.htm">stdfont9.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/pixmap_file.htm">pixmap_file.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/editline.htm">editline.s7i</a>"</span>;

<span class="keywd">const</span> <span class="type">integer</span>: MAX_LINE <span class="keywd">is</span> 100;
<span class="keywd">const</span> <span class="type">integer</span>: MAX_COLUMN <span class="keywd">is</span> 100;
<span class="keywd">const</span> <span class="type">integer</span>: CELL_SIZE <span class="keywd">is</span> 4;
<span class="keywd">const</span> <span class="type">integer</span>: SCALE_FISH <span class="keywd">is</span> 150;
<span class="keywd">const</span> <span class="type">integer</span>: SCALE_SHARKS <span class="keywd">is</span> 40;
<span class="keywd">const</span> <span class="type">integer</span>: GRAPH_TOP <span class="keywd">is</span> CELL_SIZE * (MAX_LINE + 2);
<span class="keywd">const</span> <span class="type">integer</span>: GRAPH_BOTTOM <span class="keywd">is</span> 478;

<span class="keywd">var</span> <span class="type">integer</span>: nfish     <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">integer</span>: nsharks   <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">integer</span>: fbreed    <span class="keywd">is</span> 1;
<span class="keywd">var</span> <span class="type">integer</span>: sbreed    <span class="keywd">is</span> 1;
<span class="keywd">var</span> <span class="type">integer</span>: slife     <span class="keywd">is</span> 1;

<span class="keywd">var</span> <span class="type">integer</span>: cycle     <span class="keywd">is</span> 0;

<span class="keywd">var</span> <span class="type">integer</span>: maxfish   <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">integer</span>: minfish   <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">integer</span>: maxsharks <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">integer</span>: minsharks <span class="keywd">is</span> 0;

<span class="keywd">const</span> <span class="type">integer</span>: EMPTY <span class="keywd">is</span> 1;
<span class="keywd">const</span> <span class="type">integer</span>: FISH <span class="keywd">is</span> 2;
<span class="keywd">const</span> <span class="type">integer</span>: SHARK <span class="keywd">is</span> 3;

<span class="keywd">const</span> <span class="type">type</span>: cellType <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: content <span class="keywd">is</span> EMPTY;
    <span class="keywd">var</span> <span class="type">boolean</span>: processed <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: fish <span class="keywd">is</span> -1;
    <span class="keywd">var</span> <span class="type">integer</span>: shark <span class="keywd">is</span> -1;
    <span class="keywd">var</span> <span class="type">integer</span>: starve <span class="keywd">is</span> -1;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: fieldType <span class="keywd">is</span> <span class="type">array</span> <span class="type">array</span> cellType;

<span class="keywd">var</span> <span class="type">fieldType</span>: field <span class="keywd">is</span> MAX_LINE <span class="op">times</span> MAX_COLUMN <span class="op">times</span> cellType.value;

<span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: sumContent <span class="keywd">is</span> 3 <span class="op">times</span> 0;

<span class="keywd">var</span> <span class="type">text</span>: scr <span class="keywd">is</span> STD_NULL;
<span class="keywd">var</span> <span class="type">text</span>: info <span class="keywd">is</span> STD_NULL;


<span class="keywd">const</span> <span class="type">proc</span>: introduction <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">text</span>: intro <span class="keywd">is</span> STD_NULL;
  <span class="keywd">begin</span>
    <span class="comment"># intro := openWindow(scr, 1, 12, height(scr), width(scr) - 12);</span>
    intro := scr;
    setPos(intro, 1, 1);
    writeln(intro, <span class="stri">"W A T O R"</span>);
    setPos(intro, 3, 1);
    writeln(intro, <span class="stri">"Copyright (C) 2006  Thomas Mertes"</span>);
    setPos(intro, 5, 1);
    writeln(intro, <span class="stri">"This program is free software under the"</span>);
    setPos(intro, 6, 1);
    writeln(intro, <span class="stri">"terms of the GNU General Public License"</span>);
    setPos(intro, 8, 1);
    writeln(intro, <span class="stri">"Wator is written in the Seed7 programming language"</span>);
    setPos(intro, 9, 1);
    writeln(intro, <span class="stri">"Homepage:    http://seed7.sourceforge.net"</span>);
    setPos(intro, 12, 1);
    writeln(intro, <span class="stri">"This program simulates the planet WATOR as described in Scientific American Computer"</span>);
    writeln(intro, <span class="stri">"Recreations column, Dec 1984.  WATOR (or Wa-Tor) is a toroidal (donut-shaped) planet"</span>);
    writeln(intro, <span class="stri">"inhabited by fish and sharks.  The fish feed on a ubiquitous plankton and the sharks"</span>);
    writeln(intro, <span class="stri">"feed on the fish.  Time passes in discrete jumps or cycles.  During each cycle, fish"</span>);
    writeln(intro, <span class="stri">"move randomly to an unoccupied square,  and reproduce if old enough.  Sharks move to"</span>);
    writeln(intro, <span class="stri">"a square occupied by a fish and eat it, if possible, or move to an open square if no"</span>);
    writeln(intro, <span class="stri">"meals are available.  Sharks will also breed if old enough,  but will starve if they"</span>);
    writeln(intro, <span class="stri">"do not eat within a specified period of time."</span>);
    writeln(intro);
    writeln(intro, <span class="stri">"Parameters selected at the beginning of the run are as follows:"</span>);
    writeln(intro, <span class="stri">"  nfish:    Number of fish at start of run-distributed randomly."</span>);
    writeln(intro, <span class="stri">"  nsharks:  Number of sharks at start, also distributed randomly."</span>);
    writeln(intro, <span class="stri">"  fbreed:   Number of cycles a fish must exist before reproducing."</span>);
    writeln(intro, <span class="stri">"  sbreed:   Number of cycles sharks must exist before reproducing."</span>);
    writeln(intro, <span class="stri">"  starve:   Number of cycles a shark has to find food before starving."</span>);
    writeln(intro);
    writeln(intro, <span class="stri">"On the screen, fish are green and sharks are blue.  After the initial screen is"</span>);
    writeln(intro, <span class="stri">"displayed, press any key to start the simulation.  During the run, pressing any key"</span>);
    writeln(intro, <span class="stri">"will stop the program."</span>);
    writeln(intro);
    writeln(intro, <span class="stri">"Press any key to continue."</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: display <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: newfish <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: newsharks <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    sumContent := 3 <span class="op">times</span> 0;
    <span class="keywd">for</span> line <span class="keywd">range</span> 1 <span class="keywd">to</span> MAX_LINE <span class="keywd">do</span>
      <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> MAX_COLUMN <span class="keywd">do</span>
        <span class="keywd">if</span> field[line][column].processed <span class="keywd">then</span>
          field[line][column].processed := FALSE;
          <span class="keywd">if</span> field[line][column].content = EMPTY <span class="keywd">then</span>
            rect(CELL_SIZE * column, CELL_SIZE * line, CELL_SIZE, CELL_SIZE, black);
          <span class="keywd">elsif</span> field[line][column].content = FISH <span class="keywd">then</span>
            incr(newfish);
            rect(CELL_SIZE * column, CELL_SIZE * line, CELL_SIZE, CELL_SIZE, light_green);
          <span class="keywd">else</span> <span class="comment"># if field[line][column].content = SHARK then</span>
            incr(newsharks);
            rect(CELL_SIZE * column, CELL_SIZE * line, CELL_SIZE, CELL_SIZE, light_blue);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          incr(sumContent[field[line][column].content]);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    sumContent[FISH] +:= newfish;
    sumContent[SHARK] +:= newsharks;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: writeInfo <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    rect(CELL_SIZE * succ(MAX_LINE) + 60, 8 * lineHeight(stdFont9),
         40, lineHeight(stdFont9), black);
    setPosXY(info, 90 - width(stdFont9, str(sumContent[FISH])),
                   8 * lineHeight(stdFont9) + baseLineDelta(stdFont9));
    write(info, sumContent[FISH]);
    <span class="keywd">if</span> sumContent[FISH] &lt; minfish <span class="keywd">then</span>
      minfish := sumContent[FISH];
      rect(CELL_SIZE * succ(MAX_LINE) + 60, 9 * lineHeight(stdFont9),
           40, lineHeight(stdFont9), black);
      setPosXY(info, 90 - width(stdFont9, str(minfish)),
                     9 * lineHeight(stdFont9) + baseLineDelta(stdFont9));
      write(info, minfish);
    <span class="keywd">elsif</span> sumContent[FISH] > maxfish <span class="keywd">then</span>
      maxfish := sumContent[FISH];
      rect(CELL_SIZE * succ(MAX_LINE) + 60, 10 * lineHeight(stdFont9),
           40, lineHeight(stdFont9), black);
      setPosXY(info, 90 - width(stdFont9, str(maxfish)),
                     10 * lineHeight(stdFont9) + baseLineDelta(stdFont9));
      write(info, maxfish);
    <span class="keywd">end</span> <span class="keywd">if</span>;
      rect(CELL_SIZE * succ(MAX_LINE) + 60, 12 * lineHeight(stdFont9),
           40, lineHeight(stdFont9), black);
    setPosXY(info, 90 - width(stdFont9, str(sumContent[SHARK])),
                   12 * lineHeight(stdFont9) + baseLineDelta(stdFont9));
    write(info, sumContent[SHARK]);
    <span class="keywd">if</span> sumContent[SHARK] &lt; minsharks <span class="keywd">then</span>
      minsharks := sumContent[SHARK];
      rect(CELL_SIZE * succ(MAX_LINE) + 60, 13 * lineHeight(stdFont9),
           40, lineHeight(stdFont9), black);
      setPosXY(info, 90 - width(stdFont9, str(minsharks)),
                     13 * lineHeight(stdFont9) + baseLineDelta(stdFont9));
      write(info, minsharks);
    <span class="keywd">elsif</span> sumContent[SHARK] > maxsharks <span class="keywd">then</span>
      maxsharks := sumContent[SHARK];
      rect(CELL_SIZE * succ(MAX_LINE) + 60, 14 * lineHeight(stdFont9),
           40, lineHeight(stdFont9), black);
      setPosXY(info, 90 - width(stdFont9, str(maxsharks)),
                     14 * lineHeight(stdFont9) + baseLineDelta(stdFont9));
      write(info, maxsharks);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    rect(CELL_SIZE * succ(MAX_LINE) + 90, 16 * lineHeight(stdFont9),
         50, lineHeight(stdFont9), black);
    setPosXY(info, 130 - width(stdFont9, str(cycle)),
                   16 * lineHeight(stdFont9) + baseLineDelta(stdFont9));
    write(info, cycle);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: initInfo <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    maxfish := sumContent[FISH];
    minfish := sumContent[FISH];
    maxsharks := sumContent[SHARK];
    minsharks := sumContent[SHARK];
    setPos(info, 9, 1);
    writeln(info, <span class="stri">"Fish:"</span>);
    writeln(info, <span class="stri">" min:"</span>);
    writeln(info, <span class="stri">" max:"</span>);
    writeln(info);
    writeln(info, <span class="stri">"Sharks:"</span>);
    writeln(info, <span class="stri">" min:"</span>);
    writeln(info, <span class="stri">" max:"</span>);
    writeln(info);
    writeln(info, <span class="stri">"Generation: "</span>);
    writeInfo;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: initialize <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="comment">(* Initialize arrays, get starting parameters, set up the screen *)</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    cycle := 0;
    clear(info);
    setPos(info, 1, 1);
    writeln(info, <span class="stri">"W A T O R"</span>);
    <span class="keywd">repeat</span>
      setPos(info, 3, 1);
      write(info, <span class="stri">"nfish= "</span>);
      readln(nfish);
      <span class="keywd">if</span> nfish > MAX_LINE * MAX_COLUMN <span class="keywd">then</span>
        writeln(info, <span class="stri">"*** Too many fish ("</span> &lt;&amp; nfish &lt;&amp; <span class="stri">")"</span>);
        write(info, <span class="stri">"Maximum is "</span> &lt;&amp; MAX_LINE * MAX_COLUMN);
        setPos(info, 3, 1);
        write(info, <span class="stri">" "</span> <span class="op">mult</span> 30);
      <span class="keywd">else</span>
        writeln(info, <span class="stri">" "</span> <span class="op">mult</span> 30);
        write(info, <span class="stri">" "</span> <span class="op">mult</span> 30);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> nfish &lt;= MAX_LINE * MAX_COLUMN;
    <span class="keywd">repeat</span>
      setPos(info, 4, 1);
      write(info, <span class="stri">"nsharks= "</span>);
      readln(nsharks);
      <span class="keywd">if</span> nfish + nsharks > MAX_LINE * MAX_COLUMN <span class="keywd">then</span>
        writeln(info, <span class="stri">"*** Too many sharks ("</span> &lt;&amp; nsharks &lt;&amp; <span class="stri">")"</span>);
        write(info, <span class="stri">"Maximum is "</span> &lt;&amp; MAX_LINE * MAX_COLUMN - nfish);
        setPos(info, 4, 1);
        write(info, <span class="stri">" "</span> <span class="op">mult</span> 30);
      <span class="keywd">else</span>
        writeln(info, <span class="stri">" "</span> <span class="op">mult</span> 30);
        write(info, <span class="stri">" "</span> <span class="op">mult</span> 30);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> nfish + nsharks &lt;= MAX_LINE * MAX_COLUMN;
    setPos(info, 5, 1);
    write(info, <span class="stri">"fbreed= "</span>);
    readln(fbreed);
    write(info, <span class="stri">"sbreed= "</span>);
    readln(sbreed);
    write(info, <span class="stri">"slife= "</span>);
    readln(slife);
    <span class="keywd">for</span> line <span class="keywd">range</span> 1 <span class="keywd">to</span> MAX_LINE <span class="keywd">do</span>
      <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> MAX_COLUMN <span class="keywd">do</span>
        field[line][column].content := EMPTY;
        field[line][column].processed := FALSE;
        field[line][column].fish := -1;
        field[line][column].shark := -1;
        field[line][column].starve := -1;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> nfish <span class="keywd">do</span>
      <span class="keywd">repeat</span>
        line := rand(1, MAX_LINE);
        column := rand(1, MAX_COLUMN);
      <span class="keywd">until</span> field[line][column].content = EMPTY;
      field[line][column].content := FISH;
      field[line][column].processed := TRUE;
      field[line][column].fish := rand(0, pred(fbreed));
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> nsharks <span class="keywd">do</span>
      <span class="keywd">repeat</span>
        line := rand(1, MAX_LINE);
        column := rand(1, MAX_COLUMN);
      <span class="keywd">until</span> field[line][column].content = EMPTY;
      field[line][column].content := SHARK;
      field[line][column].processed := TRUE;
      field[line][column].shark := rand(0, pred(sbreed));
      field[line][column].starve := rand(0, pred(slife));
    <span class="keywd">end</span> <span class="keywd">for</span>;
    boxTo(CELL_SIZE - 3, CELL_SIZE - 3,
        CELL_SIZE * succ(MAX_LINE) + 2,
        CELL_SIZE * succ(MAX_LINE) + 2, white);
    display;
    initInfo;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: moveFish (<span class="keywd">inout</span> <span class="type">cellType</span>: source, <span class="keywd">inout</span> <span class="type">cellType</span>: dest) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="comment">(* Make move, fish breeds if old enough to reproduce *)</span>
  <span class="keywd">begin</span>
    dest.content := FISH;
    dest.processed := TRUE;
    <span class="keywd">if</span> source.fish = fbreed <span class="keywd">then</span>
      dest.fish := 0;
      source.fish := rand(0, pred(fbreed)); <span class="comment"># Randomize parent breed time. This was 0</span>
    <span class="keywd">else</span>
      dest.fish := succ(source.fish);
      source.content := EMPTY;
      source.processed := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: moveAllFish <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: line         <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column       <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: up_line      <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: down_line    <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: left_column  <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: right_column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column_byond <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column_step  <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: nmoves <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: moveopts <span class="keywd">is</span> 4 <span class="op">times</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> line <span class="keywd">range</span> 1 <span class="keywd">to</span> MAX_LINE <span class="keywd">do</span>
      <span class="keywd">if</span> line = 1 <span class="keywd">then</span>
        up_line := MAX_LINE;
      <span class="keywd">else</span>
        up_line := pred(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> line = MAX_LINE <span class="keywd">then</span>
        down_line := 1;
      <span class="keywd">else</span>
        down_line := succ(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> odd(line) <span class="keywd">then</span>
        column := 1;
        column_byond := succ(MAX_COLUMN);
        column_step := 1;
      <span class="keywd">else</span>
        column := MAX_COLUMN;
        column_byond := 0;
        column_step := -1;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">while</span> column &lt;> column_byond <span class="keywd">do</span>
        <span class="comment">(* Look through array for fish and check if already processed *)</span>
        <span class="keywd">if</span> field[line][column].content = FISH <span class="op">and</span> <span class="op">not</span> field[line][column].processed <span class="keywd">then</span>
          <span class="keywd">if</span> column = 1 <span class="keywd">then</span>
            left_column := MAX_COLUMN;
          <span class="keywd">else</span>
            left_column := pred(column);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> column = MAX_COLUMN <span class="keywd">then</span>
            right_column := 1;
          <span class="keywd">else</span>
            right_column := succ(column);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          nmoves := 0;
          <span class="comment">(* Look around to see where fish can be moved *)</span>
          <span class="keywd">if</span> field[line][left_column].content = EMPTY <span class="keywd">then</span>
            incr(nmoves);
            moveopts[nmoves] := 1;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> field[line][right_column].content = EMPTY <span class="keywd">then</span>
            incr(nmoves);
            moveopts[nmoves] := 2;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> field[up_line][column].content = EMPTY <span class="keywd">then</span>
            incr(nmoves);
            moveopts[nmoves] := 3;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> field[down_line][column].content = EMPTY <span class="keywd">then</span>
            incr(nmoves);
            moveopts[nmoves] := 4;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> nmoves = 0 <span class="keywd">then</span>
            <span class="comment">(* If nowhere to go they just get older *)</span>
            <span class="keywd">if</span> field[line][column].fish = fbreed <span class="keywd">then</span>
              field[line][column].fish := 0
            <span class="keywd">else</span>
              incr(field[line][column].fish);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            <span class="comment">(* Pick a move to make *)</span>
            <span class="keywd">case</span> moveopts[rand(1, nmoves)] <span class="keywd">of</span>
              <span class="keywd">when</span> {1}:
                moveFish(field[line][column], field[line][left_column]);
              <span class="keywd">when</span> {2}:
                moveFish(field[line][column], field[line][right_column]);
              <span class="keywd">when</span> {3}:
                moveFish(field[line][column], field[up_line][column]);
              <span class="keywd">when</span> {4}:
                moveFish(field[line][column], field[down_line][column]);
            <span class="keywd">end</span> <span class="keywd">case</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        column +:= column_step;
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: killFish (<span class="keywd">inout</span> <span class="type">cellType</span>: source, <span class="keywd">inout</span> <span class="type">cellType</span>: dest) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    dest.content := SHARK;
    dest.processed := TRUE;
    dest.starve := 0;
    <span class="keywd">if</span> source.shark = sbreed <span class="keywd">then</span>
      dest.shark := 0;
      source.shark := rand(0, pred(sbreed)); <span class="comment"># Randomize parent breed time. This was 0</span>
      source.starve := 0;
    <span class="keywd">else</span>
      dest.shark := succ(source.shark);
      source.content := EMPTY;
      source.processed := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: moveShark (<span class="keywd">inout</span> <span class="type">cellType</span>: source, <span class="keywd">inout</span> <span class="type">cellType</span>: dest) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    dest.content := SHARK;
    dest.processed := TRUE;
    dest.starve := succ(source.starve);
    <span class="keywd">if</span> source.shark = sbreed <span class="keywd">then</span>
      dest.shark := 0;
      source.shark := rand(0, pred(sbreed)); <span class="comment"># Randomize parent breed time. This was 0</span>
      incr(source.starve);
    <span class="keywd">else</span>
      dest.shark := succ(source.shark);
      source.content := EMPTY;
      source.processed := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: moveAllSharks <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: line         <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column       <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: up_line      <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: down_line    <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: left_column  <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: right_column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: nmoves <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: nmeals <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: moveopts <span class="keywd">is</span> 4 <span class="op">times</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> line <span class="keywd">range</span> 1 <span class="keywd">to</span> MAX_LINE <span class="keywd">do</span>
      <span class="keywd">if</span> line = 1 <span class="keywd">then</span>
        up_line := MAX_LINE;
      <span class="keywd">else</span>
        up_line := pred(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> line = MAX_LINE <span class="keywd">then</span>
        down_line := 1;
      <span class="keywd">else</span>
        down_line := succ(line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> MAX_COLUMN <span class="keywd">do</span>
        <span class="comment">(* Look through array for sharks and check if already processed *)</span>
        <span class="keywd">if</span> field[line][column].content = SHARK <span class="op">and</span> <span class="op">not</span> field[line][column].processed <span class="keywd">then</span>
          <span class="keywd">if</span> column = 1 <span class="keywd">then</span>
            left_column := MAX_COLUMN;
          <span class="keywd">else</span>
            left_column := pred(column);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> column = MAX_COLUMN <span class="keywd">then</span>
            right_column := 1;
          <span class="keywd">else</span>
            right_column := succ(column);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          nmeals := 0;
          <span class="comment">(* Look around to see where sharks can be moved *)</span>
          <span class="keywd">if</span> field[line][left_column].content = FISH <span class="keywd">then</span>
            incr(nmeals);
            moveopts[nmeals] := 1;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> field[line][right_column].content = FISH <span class="keywd">then</span>
            incr(nmeals);
            moveopts[nmeals] := 2;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> field[up_line][column].content = FISH <span class="keywd">then</span>
            incr(nmeals);
            moveopts[nmeals] := 3;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> field[down_line][column].content = FISH <span class="keywd">then</span>
            incr(nmeals);
            moveopts[nmeals] := 4;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="comment">(* If the shark finds a fish to eat, pick one and eat it, breed if possible *)</span>
          <span class="keywd">if</span> nmeals > 0 <span class="keywd">then</span>
            <span class="keywd">case</span> moveopts[rand(1, nmeals)] <span class="keywd">of</span>
              <span class="keywd">when</span> {1}:
                killFish(field[line][column], field[line][left_column]);
              <span class="keywd">when</span> {2}:
                killFish(field[line][column], field[line][right_column]);
              <span class="keywd">when</span> {3}:
                killFish(field[line][column], field[up_line][column]);
              <span class="keywd">when</span> {4}:
                killFish(field[line][column], field[down_line][column]);
            <span class="keywd">end</span> <span class="keywd">case</span>;
          <span class="keywd">elsif</span> field[line][column].starve &lt; slife <span class="keywd">then</span>
            <span class="comment">(* If no meals in vicinity, look for an empty square to move to *)</span>
            nmoves := 0;
            <span class="keywd">if</span> field[line][left_column].content = EMPTY <span class="keywd">then</span>
              incr(nmoves);
              moveopts[nmoves] := 1;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> field[line][right_column].content = EMPTY <span class="keywd">then</span>
              incr(nmoves);
              moveopts[nmoves] := 2;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> field[up_line][column].content = EMPTY <span class="keywd">then</span>
              incr(nmoves);
              moveopts[nmoves] := 3;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> field[down_line][column].content = EMPTY <span class="keywd">then</span>
              incr(nmoves);
              moveopts[nmoves] := 4;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> nmoves = 0 <span class="keywd">then</span>
              <span class="comment">(* If there is nothing to eat and no place to go the shark gets older *)</span>
              <span class="keywd">if</span> field[line][column].shark = sbreed <span class="keywd">then</span>
                field[line][column].shark := 0;
              <span class="keywd">else</span>
                incr(field[line][column].shark);
              <span class="keywd">end</span> <span class="keywd">if</span>;
              incr(field[line][column].starve);
            <span class="keywd">else</span>
              <span class="comment">(* If there is a move to make pick one from the available squares *)</span>
              <span class="keywd">case</span> moveopts[rand(1, nmoves)] <span class="keywd">of</span>
                <span class="keywd">when</span> {1}:
                  moveShark(field[line][column], field[line][left_column])
                <span class="keywd">when</span> {2}:
                  moveShark(field[line][column], field[line][right_column])
                <span class="keywd">when</span> {3}:
                  moveShark(field[line][column], field[up_line][column])
                <span class="keywd">when</span> {4}:
                  moveShark(field[line][column], field[down_line][column])
              <span class="keywd">end</span> <span class="keywd">case</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            field[line][column].content := EMPTY;
            field[line][column].processed := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: inchar <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: oldFishGraph <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: oldSharkGraph <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: newFishGraph <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: newSharkGraph <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    screen(640, 480);
    selectInput(curr_win, KEY_CLOSE, TRUE);
    clear(black);
    scr := openPixmapFontFile(curr_win, 35, 10);
    setFont(scr, stdFont9);
    color(scr, white, black);
    info := openPixmapFontFile(curr_win, CELL_SIZE * succ(MAX_LINE) + 10, 0);
    setFont(info, stdFont9);
    color(info, white, black);
    KEYBOARD := GRAPH_KEYBOARD;
    IN := openEditLine(KEYBOARD, info);
    introduction;
    inchar := upper(getc(KEYBOARD));
    <span class="keywd">while</span> inchar &lt;> <span class="stri">'Q'</span> <span class="op">and</span> inchar &lt;> KEY_CLOSE <span class="op">and</span> inchar &lt;> KEY_ESC <span class="keywd">do</span>
      clear(black);
      initialize;
      oldFishGraph := GRAPH_BOTTOM - sumContent[FISH] <span class="op">div</span> SCALE_FISH;
      oldSharkGraph := GRAPH_BOTTOM - sumContent[SHARK] <span class="op">div</span> SCALE_SHARKS;
      point(cycle <span class="op">rem</span> 640, oldFishGraph, light_green);
      point(cycle <span class="op">rem</span> 640, oldSharkGraph, light_blue);
      setPos(info, 26, 1);
      writeln(info, <span class="stri">"Simulation prepared. Press"</span>);
      writeln(info, <span class="stri">" Enter to start"</span>);
      writeln(info, <span class="stri">" N to start a new simulation"</span>);
      writeln(info, <span class="stri">" Q to Quit"</span>);
      inchar := upper(getc(KEYBOARD));
      setPos(info, 26, 1);
      erase(info, <span class="stri">"Simulation prepared. Press"</span>);
      writeln(info);
      erase(info, <span class="stri">" Enter to start"</span>);
      writeln(info);
      erase(info, <span class="stri">" N to start a new simulation"</span>);
      writeln(info);
      erase(info, <span class="stri">" Q to Quit"</span>);
      <span class="keywd">while</span> inchar <span class="op">not</span> <span class="op">in</span> {<span class="stri">'N'</span>, <span class="stri">'Q'</span>, KEY_CLOSE, KEY_ESC} <span class="keywd">do</span>
        moveAllFish;
        moveAllSharks;
        display;
        writeInfo;
        incr(cycle);
        newFishGraph := GRAPH_BOTTOM - sumContent[FISH] <span class="op">div</span> SCALE_FISH;
        <span class="keywd">if</span> newFishGraph &lt; GRAPH_TOP <span class="keywd">then</span>
          newFishGraph := GRAPH_TOP;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        newSharkGraph := GRAPH_BOTTOM - sumContent[SHARK] <span class="op">div</span> SCALE_SHARKS;
        <span class="keywd">if</span> newSharkGraph &lt; GRAPH_TOP <span class="keywd">then</span>
          newSharkGraph := GRAPH_TOP;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        rectTo(cycle <span class="op">rem</span> 640, GRAPH_TOP, cycle <span class="op">rem</span> 640 + 4, GRAPH_BOTTOM, black);
        <span class="keywd">if</span> cycle <span class="op">rem</span> 640 = 0 <span class="keywd">then</span>
          point(cycle <span class="op">rem</span> 640, newFishGraph, light_green);
          point(cycle <span class="op">rem</span> 640, newSharkGraph, light_blue);
        <span class="keywd">else</span>
          lineTo(pred(cycle <span class="op">rem</span> 640), oldFishGraph, cycle <span class="op">rem</span> 640, newFishGraph, light_green);
          lineTo(pred(cycle <span class="op">rem</span> 640), oldSharkGraph, cycle <span class="op">rem</span> 640, newSharkGraph, light_blue);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        oldFishGraph := newFishGraph;
        oldSharkGraph := newSharkGraph;
        <span class="keywd">if</span> inputReady(KEYBOARD) <span class="keywd">then</span>
          <span class="keywd">repeat</span>
            inchar := getc(KEYBOARD);
          <span class="keywd">until</span> <span class="op">not</span> inputReady(KEYBOARD);
          setPos(info, 26, 1);
          writeln(info, <span class="stri">"Simulation interrupted. Press"</span>);
          writeln(info, <span class="stri">" Enter to continue"</span>);
          writeln(info, <span class="stri">" N to start a new simulation"</span>);
          writeln(info, <span class="stri">" Q to Quit"</span>);
          inchar := upper(getc(KEYBOARD));
          setPos(info, 26, 1);
          erase(info, <span class="stri">"Simulation interrupted. Press"</span>);
          writeln(info);
          erase(info, <span class="stri">" Enter to continue"</span>);
          writeln(info);
          erase(info, <span class="stri">" N to start a new simulation"</span>);
          writeln(info);
          erase(info, <span class="stri">" Q to Quit"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
