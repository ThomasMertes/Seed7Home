<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style1.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  wiz.sd7       Find treasures and fight monsters labyrinth game  *)</span>
<span class="comment">(*  Copyright (C) 1990 - 1994, 2004, 2007, 2008  Thomas Mertes      *)</span>
<span class="comment">(*                2011, 2013, 2021  Thomas Mertes                   *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/seed7_05.htm">seed7_05.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/keybd.htm">keybd.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/console.htm">console.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/editline.htm">editline.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/wrinum.htm">wrinum.s7i</a>"</span>;

<span class="keywd">const</span> <span class="type">integer</span>: SIZE_LABY <span class="keywd">is</span> 8;
<span class="keywd">const</span> <span class="type">integer</span>: NUM_LEVELS <span class="keywd">is</span> 8;
<span class="keywd">const</span> <span class="type">integer</span>: RESTRICTED_CONNECTION_COUNT <span class="keywd">is</span> 5;
<span class="keywd">const</span> <span class="type">integer</span>: STAIRS_PER_LEVEL <span class="keywd">is</span> 3;
<span class="keywd">const</span> <span class="type">integer</span>: THINGS_PER_LEVEL <span class="keywd">is</span> 1;
<span class="keywd">const</span> <span class="type">integer</span>: VENDORS_PER_LEVEL <span class="keywd">is</span> 1;
<span class="keywd">const</span> <span class="type">integer</span>: OCCURRENCES_PER_LEVEL <span class="keywd">is</span> 1;
<span class="keywd">const</span> <span class="type">integer</span>: TRANSFERS_PER_LEVEL <span class="keywd">is</span> 1;
<span class="keywd">const</span> <span class="type">integer</span>: ARMOR_STRENGTH_FACTOR <span class="keywd">is</span> 7;


<span class="keywd">const</span> <span class="type">type</span>: speciesType <span class="keywd">is</span> new <span class="keywd">enum</span>
    HOBBIT, ELF, HUMAN, DWARF
  <span class="keywd">end</span> <span class="keywd">enum</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">speciesType</span>: species) <span class="keywd">is</span>
  <span class="keywd">return</span> lower(literal(species));

enable_output(speciesType);


<span class="keywd">const</span> <span class="type">type</span>: directType <span class="keywd">is</span> new <span class="keywd">enum</span>
    NORTH, SOUTH, EAST, WEST, UP, DOWN
  <span class="keywd">end</span> <span class="keywd">enum</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">directType</span>: direct) <span class="keywd">is</span>
  <span class="keywd">return</span> lower(literal(direct));

enable_output(directType);

<span class="keywd">const</span> <span class="type">type</span>: directSet <span class="keywd">is</span> <span class="type">set</span> <span class="type">of</span> <span class="type">directType</span>;


<span class="keywd">const</span> <span class="type">type</span>: objectType <span class="keywd">is</span> new <span class="keywd">enum</span>
    NOOBJECT, LAMP, RUBY, NORNSTONE, PEARL, OPAL, GREENGEM, BLUEFLAME,
    PALANTIR, SILMARIL, RUNESTAFF, ORBOFZOT
  <span class="keywd">end</span> <span class="keywd">enum</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">objectType</span>: anObject) <span class="keywd">is</span>
  <span class="keywd">return</span> [] (<span class="stri">"nothing"</span>, <span class="stri">"lamp"</span>, <span class="stri">"ruby red"</span>, <span class="stri">"norn Stone"</span>, <span class="stri">"pale pearl"</span>,
             <span class="stri">"opal Eye"</span>, <span class="stri">"green Gem"</span>, <span class="stri">"blue Flame"</span>, <span class="stri">"Palantir"</span>, <span class="stri">"Silmaril"</span>,
             <span class="stri">"Runestaff"</span>, <span class="stri">"*ORB OF ZOT*"</span>)[succ(ord(anObject))];

enable_output(objectType);

<span class="keywd">const</span> <span class="type">type</span>: objectSet <span class="keywd">is</span> <span class="type">set</span> <span class="type">of</span> <span class="type">objectType</span>;

<span class="keywd">const</span> <span class="type">objectSet</span>: treasureSet <span class="keywd">is</span> {RUBY, NORNSTONE, PEARL, OPAL, GREENGEM,
                                 BLUEFLAME, PALANTIR, SILMARIL};


<span class="keywd">const</span> <span class="type">type</span>: animateType <span class="keywd">is</span> new <span class="keywd">enum</span>
    NOBODY, KOBOLD, ORC, WOLF, GOBLIN, OGRE, TROLL, BEAR,
    MINOTAUR, GARGOYLE, CHIMERA, BALROG, DRAGON, VENDOR
  <span class="keywd">end</span> <span class="keywd">enum</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">animateType</span>: anAnimate) <span class="keywd">is</span>
  <span class="keywd">return</span> lower(literal(anAnimate));

enable_output(animateType);


<span class="keywd">const</span> <span class="type">type</span>: armorType <span class="keywd">is</span> new <span class="keywd">enum</span>
    NOARMOR, LEATHER, CHAINMAIL, PLATE
  <span class="keywd">end</span> <span class="keywd">enum</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">armorType</span>: anArmor) <span class="keywd">is</span>
  <span class="keywd">return</span> anArmor = NOARMOR ? <span class="stri">"no"</span> : lower(literal(anArmor));

enable_output(armorType);


<span class="keywd">const</span> <span class="type">type</span>: weaponType <span class="keywd">is</span> new <span class="keywd">enum</span>
    NOWEAPON, DAGGER, MACE, SWORD
  <span class="keywd">end</span> <span class="keywd">enum</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">weaponType</span>: aWeapon) <span class="keywd">is</span>
  <span class="keywd">return</span> aWeapon = NOWEAPON ? <span class="stri">"no"</span> : lower(literal(aWeapon));

enable_output(weaponType);


<span class="keywd">const</span> <span class="type">type</span>: commandType <span class="keywd">is</span> new <span class="keywd">enum</span>
    ILLEGAL, GO_NORTH, GO_SOUTH, GO_EAST, GO_WEST, GO_UP, GO_DOWN, WAIT,
    INVENTORY, HELP, LOOK, MAP, FLARE, USE_LAMP, ATTACK, CAST, BRIBE,
    STATUS, OPEN, READ, GAZE, TELEPORT, DRINK, SELL, BUY, QUITCOMMAND
  <span class="keywd">end</span> <span class="keywd">enum</span>;

<span class="keywd">const</span> <span class="type">type</span>: contentType <span class="keywd">is</span> new <span class="keywd">enum</span>
    EMPTYROOM, ENTRANCE, EMPTYCHEST, CHESTWITHSKELETON, CLOSEDCHEST, ORB,
    POOL, BOOK
  <span class="keywd">end</span> <span class="keywd">enum</span>;

<span class="keywd">const</span> <span class="type">type</span>: transferType <span class="keywd">is</span> new <span class="keywd">enum</span>
    NOTRANSFER, SINKHOLE, WARP
  <span class="keywd">end</span> <span class="keywd">enum</span>;

<span class="keywd">const</span> <span class="type">type</span>: occurType <span class="keywd">is</span> new <span class="keywd">enum</span>
    NOOCCURRENCE, LEECH, LETHARGY, FORGET, STEALARMOR, STEALWEAPON,
    STEALLAMP, STEALFLARES, STEALTREASURE, FINDGOLD, FINDFLARES
  <span class="keywd">end</span> <span class="keywd">enum</span>;

<span class="keywd">const</span> <span class="type">type</span>: playerType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">speciesType</span>: species <span class="keywd">is</span> HUMAN;
    <span class="keywd">var</span> <span class="type">boolean</span>: isMale <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">integer</span>: strength <span class="keywd">is</span> 2;
    <span class="keywd">var</span> <span class="type">integer</span>: intelligence <span class="keywd">is</span> 8;
    <span class="keywd">var</span> <span class="type">integer</span>: dexterity <span class="keywd">is</span> 14;
    <span class="keywd">var</span> <span class="type">integer</span>: goldPieces <span class="keywd">is</span> 10;
    <span class="keywd">var</span> <span class="type">armorType</span>: armor <span class="keywd">is</span> NOARMOR;
    <span class="keywd">var</span> <span class="type">integer</span>: armorStrength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">weaponType</span>: weapon <span class="keywd">is</span> NOWEAPON;
    <span class="keywd">var</span> <span class="type">boolean</span>: weaponBlocked <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: flares <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">objectSet</span>: possession <span class="keywd">is</span> objectSet.value;
    <span class="keywd">var</span> <span class="type">integer</span>: turns <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: mealHour <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: living <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">boolean</span>: blind <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: haveLeech <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: lethargic <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: forgetting <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: leaveCastle <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: quitDialog <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: quitProgram <span class="keywd">is</span> FALSE;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: fightStateType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: monsterCount <span class="keywd">is</span> NUM_LEVELS * 12;
    <span class="keywd">var</span> <span class="type">boolean</span>: angryVendors <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: webCount <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: aggressionOfMonster <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: monsterStrength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: monsterPresent <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: monsterWillAttack <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: bribed <span class="keywd">is</span> FALSE;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: roomType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">directSet</span>: connections <span class="keywd">is</span> {NORTH, SOUTH, EAST, WEST};
    <span class="keywd">var</span> <span class="type">transferType</span>: transfer <span class="keywd">is</span> NOTRANSFER;
    <span class="keywd">var</span> <span class="type">occurType</span>: occurrence <span class="keywd">is</span> NOOCCURRENCE;
    <span class="keywd">var</span> <span class="type">animateType</span>: roomer <span class="keywd">is</span> NOBODY;
    <span class="keywd">var</span> <span class="type">contentType</span>: contents <span class="keywd">is</span> EMPTYROOM;
    <span class="keywd">var</span> <span class="type">objectSet</span>: objects <span class="keywd">is</span> objectSet.value;
    <span class="keywd">var</span> <span class="type">boolean</span>: visited <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: zPos <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: roomRef <span class="keywd">is</span> sub object interface;

type_implements_interface(roomType, roomRef);

<span class="keywd">const</span> <span class="type">proc</span>: writePos (<span class="op">in</span> <span class="type">roomRef</span>: aRoom) <span class="keywd">is</span> DYNAMIC;
<span class="keywd">const</span> <span class="type">proc</span>: enterRoom (<span class="keywd">inout</span> <span class="type">roomRef</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
                       <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> DYNAMIC;
<span class="keywd">const</span> <span class="type">proc</span>: incident (<span class="keywd">inout</span> <span class="type">roomRef</span>: currentRoom,
                      <span class="keywd">inout</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> DYNAMIC;
<span class="keywd">const</span> <span class="type">proc</span>: teleportTo (<span class="keywd">inout</span> <span class="type">roomRef</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
                        <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> DYNAMIC;
<span class="keywd">const</span> <span class="type">proc</span>: writeFightState (<span class="op">in</span> <span class="type">roomRef</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
                             <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> DYNAMIC;
<span class="keywd">const</span> <span class="type">proc</span>: executeCommand (<span class="keywd">inout</span> <span class="type">roomRef</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
                            <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> DYNAMIC;
<span class="keywd">const</span> <span class="type">proc</span>: removeFromRoom (<span class="keywd">inout</span> <span class="type">roomRef</span>: currentRoom,
                            <span class="op">in</span> <span class="type">objectType</span>: treasure) <span class="keywd">is</span> DYNAMIC;

<span class="keywd">var</span> <span class="type">integer</span>: labyrinthNumber <span class="keywd">is</span> 0;

<span class="keywd">var</span> <span class="type">roomRef</span>: currentRoomRef <span class="keywd">is</span> roomType.value;

<span class="keywd">const</span> <span class="type">type</span>: objPlaceType <span class="keywd">is</span> <span class="type">array</span> <span class="type">[</span>objectType] roomRef;
<span class="keywd">var</span> <span class="type">objPlaceType</span>: objPlace <span class="keywd">is</span> objectType <span class="op">times</span> roomType.value;

<span class="keywd">const</span> <span class="type">type</span>: labyrinthType <span class="keywd">is</span> <span class="type">array</span> <span class="type">array</span> <span class="type">array</span> <span class="type">roomType</span>;
<span class="keywd">var</span> <span class="type">labyrinthType</span>: labyrinth <span class="keywd">is</span> SIZE_LABY <span class="op">times</span> SIZE_LABY <span class="op">times</span> NUM_LEVELS <span class="op">times</span> roomType.value;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: rangeLaby (<span class="op">in</span> <span class="type">integer</span>: number) <span class="keywd">is</span>
  <span class="keywd">return</span> succ(pred(number) <span class="op">mod</span> SIZE_LABY);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: rangeLevel (<span class="op">in</span> <span class="type">integer</span>: number) <span class="keywd">is</span>
  <span class="keywd">return</span> succ(pred(number) <span class="op">mod</span> NUM_LEVELS);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: range18 (<span class="op">in</span> <span class="type">integer</span>: number) <span class="keywd">is</span>
  <span class="keywd">return</span> number &lt;= 18 ? number: 18;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">speciesType</span>: rand (attr speciesType) <span class="keywd">is</span>
  <span class="keywd">return</span> rand(speciesType.first, speciesType.last);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">animateType</span>: rand (attr animateType) <span class="keywd">is</span>
  <span class="keywd">return</span> rand(KOBOLD, DRAGON);


<span class="keywd">const</span> <span class="type">proc</span>: startText <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln;
    writeln;
    writeln;
    writeln(<span class="stri">"*"</span> <span class="op">mult</span> 78);
    writeln;
    writeln(<span class="stri">"                       * * * THE WIZARD'S CASTLE * * *"</span>);
    writeln(<span class="stri">"                                 Version 2.0"</span>);
    writeln;
    writeln(<span class="stri">"                                  Copyright"</span>);
    writeln(<span class="stri">"               1990 - 1994, 2004, 2007, 2008, 2011, 2013, 2021"</span>);
    writeln(<span class="stri">"                                Thomas  Mertes"</span>);
    writeln;
    writeln(<span class="stri">"*"</span> <span class="op">mult</span> 78);
    writeln;
    writeln(<span class="stri">" A long time ago, in the age of the old universal empire  the  mighty  wizard"</span>);
    writeln(<span class="stri">" ZOT  lived  in  a  large  subterranean  castle, collecting a lot of fabulous"</span>);
    writeln(<span class="stri">" treasures during his long life. Feeling  the  sources  of  his  vital  power"</span>);
    writeln(<span class="stri">" draining  away, he created a great orb of power the *ORB OF ZOT*. To hide it"</span>);
    writeln(<span class="stri">" from the cretins of the  surface  beyond,  he  hired  a  group  of  esurient"</span>);
    writeln(<span class="stri">" monsters to guard the *ORB OF ZOT*. From that time onward, many a bold youth"</span>);
    writeln(<span class="stri">" has ventured into the castle, losing his  life  in  cruel  and  unimaginable"</span>);
    writeln(<span class="stri">" ways."</span>);
    writeln;
    writeln(<span class="stri">"All right, bold one."</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># startText</span>


<span class="keywd">const</span> <span class="type">proc</span>: writeHelp <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln;
    writeln(<span class="stri">"*** WIZARD'S CASTLE COMMAND AND INFORMATION SUMMARY ***"</span>);
    writeln;
    writeln(<span class="stri">"The following commands are available:"</span>);
    writeln;
    writeln(<span class="stri">"H/ELP       N/ORTH      S/OUTH      E/AST       W/EST       U/P         D/OWN"</span>);
    writeln(<span class="stri">"L/OOK       I/NVENTORY  M/AP        ST/ATUS     A/TTACK     C/AST       BR/IBE"</span>);
    writeln(<span class="stri">"O/PEN       R/EAD       G/AZE       T/ELEPORT   DR/INK      SE/LL       B/UY"</span>);
    writeln(<span class="stri">"F/LARE      LA/AMP      Q/UIT"</span>);
    writeln;
    writeln(<span class="stri">"The contents of rooms are as follows:"</span>);
    writeln;
    writeln(<span class="stri">". = EMPTY ROOM   D = WAY DOWN     G = GOLD PIECES  P = MAGIC POOL   U = WAY UP"</span>);
    writeln(<span class="stri">"B = BOOK         E = EXIT         M = MONSTER      S = SINKHOLE     V = VENDOR"</span>);
    writeln(<span class="stri">"C = CHEST        F = FLARES       O = CRYSTAL ORB  T = TREASURE     W = WARP"</span>);
    writeln;
    writeln(<span class="stri">"The benefits of having treasures are:"</span>);
    writeln;
    writeln(<span class="stri">"ruby red -    AVOID LETHARGY     pale pearl -  AVOID LEECH"</span>);
    writeln(<span class="stri">"green gem -   AVOID FORGETTING   opal eye -    CURES BLINDNESS"</span>);
    writeln(<span class="stri">"blue flame -  DISSOLVES BOOKS    norn stone -  NO BENEFIT"</span>);
    writeln(<span class="stri">"palantir -    NO BENEFIT         silmaril -    NO BENEFIT"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># writeHelp</span>


<span class="keywd">const</span> <span class="type">proc</span>: randomRoom (<span class="keywd">inout</span> <span class="type">integer</span>: xPos, <span class="keywd">inout</span> <span class="type">integer</span>: yPos,
    <span class="keywd">inout</span> <span class="type">integer</span>: zPos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    xPos := rand(1, SIZE_LABY);
    yPos := rand(1, SIZE_LABY);
    zPos := rand(1, NUM_LEVELS);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># randomRoom</span>


<span class="keywd">const</span> <span class="type">proc</span>: findUninhabitedRoom (<span class="keywd">inout</span> <span class="type">integer</span>: xPos, <span class="keywd">inout</span> <span class="type">integer</span>: yPos,
    <span class="op">in</span> <span class="type">integer</span>: zPos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      xPos := rand(1, SIZE_LABY);
      yPos := rand(1, SIZE_LABY);
    <span class="keywd">until</span> labyrinth[xPos][yPos][zPos].roomer = NOBODY <span class="op">and</span>
          labyrinth[xPos][yPos][zPos].contents &lt;> ENTRANCE;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># findUninhabitedRoom</span>


<span class="keywd">const</span> <span class="type">proc</span>: findEmptyRoom (<span class="keywd">inout</span> <span class="type">integer</span>: xPos, <span class="keywd">inout</span> <span class="type">integer</span>: yPos,
    <span class="op">in</span> <span class="type">integer</span>: zPos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      xPos := rand(1, SIZE_LABY);
      yPos := rand(1, SIZE_LABY);
    <span class="keywd">until</span> labyrinth[xPos][yPos][zPos].transfer = NOTRANSFER <span class="op">and</span>
          labyrinth[xPos][yPos][zPos].roomer = NOBODY <span class="op">and</span>
          labyrinth[xPos][yPos][zPos].contents = EMPTYROOM <span class="op">and</span>
          labyrinth[xPos][yPos][zPos].occurrence = NOOCCURRENCE <span class="op">and</span>
          labyrinth[xPos][yPos][zPos].objects = objectSet.value;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># findEmptyRoom</span>


<span class="keywd">const</span> <span class="type">proc</span>: initRoom (<span class="keywd">inout</span> <span class="type">roomType</span>: aRoom, <span class="op">in</span> <span class="type">integer</span>: xPos, <span class="op">in</span> <span class="type">integer</span>: yPos,
    <span class="op">in</span> <span class="type">integer</span>: zPos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    aRoom := roomType.value;
    aRoom.xPos := xPos;
    aRoom.yPos := yPos;
    aRoom.zPos := zPos;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># initRoom</span>


<span class="keywd">const</span> <span class="type">proc</span>: initEntrance (<span class="keywd">inout</span> <span class="type">roomType</span>: aRoom) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    aRoom.connections := {NORTH, SOUTH, EAST, WEST};
    aRoom.contents := ENTRANCE;
    aRoom.visited := TRUE;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># initEntrance</span>


<span class="keywd">const</span> <span class="type">proc</span>: initRoomConnections <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">array</span> <span class="type">directSet</span>: restrictedConnections <span class="keywd">is</span> [] (
        {       SOUTH, EAST, WEST},
        {NORTH,        EAST, WEST},
        {NORTH, SOUTH,       WEST},
        {NORTH, SOUTH, EAST      },
        {NORTH, SOUTH            },
        {NORTH,        EAST      },
        {NORTH,              WEST},
        {       SOUTH, EAST      },
        {       SOUTH,       WEST},
        {              EAST, WEST});
    <span class="keywd">var</span> <span class="type">directSet</span>: connections <span class="keywd">is</span> directSet.value;
    <span class="keywd">var</span> <span class="type">integer</span>: count <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: zPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> xPos <span class="keywd">range</span> 1 <span class="keywd">to</span> SIZE_LABY <span class="keywd">do</span>
      <span class="keywd">for</span> yPos <span class="keywd">range</span> 1 <span class="keywd">to</span> SIZE_LABY <span class="keywd">do</span>
        <span class="keywd">for</span> zPos <span class="keywd">range</span> 1 <span class="keywd">to</span> NUM_LEVELS <span class="keywd">do</span>
          initRoom(labyrinth[xPos][yPos][zPos], xPos, yPos, zPos);
        <span class="keywd">end</span> <span class="keywd">for</span>;
        write(<span class="stri">"."</span>);
        flush(OUT);
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    writeln;
    <span class="keywd">for</span> count <span class="keywd">range</span> 1 <span class="keywd">to</span> RESTRICTED_CONNECTION_COUNT <span class="keywd">do</span>
      <span class="keywd">for</span> connections <span class="keywd">range</span> restrictedConnections <span class="keywd">do</span>
        randomRoom(xPos, yPos, zPos);
        labyrinth[xPos][yPos][zPos].connections := connections;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> zPos <span class="keywd">range</span> 1 <span class="keywd">to</span> NUM_LEVELS <span class="keywd">do</span>
      xPos := rand(1, SIZE_LABY);
      yPos := rand(1, SIZE_LABY);
      labyrinth[xPos][yPos][zPos].connections := {rand(NORTH, WEST)};
    <span class="keywd">end</span> <span class="keywd">for</span>;
    initEntrance(labyrinth[rangeLaby(4)][1][1]);
    <span class="keywd">for</span> zPos <span class="keywd">range</span> 1 <span class="keywd">to</span> pred(NUM_LEVELS) <span class="keywd">do</span>
      <span class="keywd">for</span> count <span class="keywd">range</span> 1 <span class="keywd">to</span> STAIRS_PER_LEVEL <span class="keywd">do</span>
        xPos := rand(1, SIZE_LABY);
        yPos := rand(1, SIZE_LABY);
        incl(labyrinth[xPos][yPos][zPos].connections, DOWN);
        incl(labyrinth[xPos][yPos][succ(zPos)].connections, UP);
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># initRoomConnections</span>


<span class="keywd">const</span> <span class="type">proc</span>: initRoomProperties <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: count <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: zPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">contentType</span>: content <span class="keywd">is</span> EMPTYROOM;
    <span class="keywd">var</span> <span class="type">animateType</span>: animate <span class="keywd">is</span> NOBODY;
    <span class="keywd">var</span> <span class="type">objectType</span>: treasure <span class="keywd">is</span> NOOBJECT;
    <span class="keywd">var</span> <span class="type">occurType</span>: occurrence <span class="keywd">is</span> NOOCCURRENCE;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> zPos <span class="keywd">range</span> 1 <span class="keywd">to</span> NUM_LEVELS <span class="keywd">do</span>
      <span class="keywd">for</span> count <span class="keywd">range</span> 1 <span class="keywd">to</span> THINGS_PER_LEVEL <span class="keywd">do</span>
        <span class="keywd">for</span> content <span class="keywd">range</span> [](CLOSEDCHEST, ORB, POOL, BOOK) <span class="keywd">do</span>
          findEmptyRoom(xPos, yPos, zPos);
          labyrinth[xPos][yPos][zPos].contents := content;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> zPos <span class="keywd">range</span> 1 <span class="keywd">to</span> NUM_LEVELS <span class="keywd">do</span>
      <span class="keywd">for</span> animate <span class="keywd">range</span> KOBOLD <span class="keywd">to</span> DRAGON <span class="keywd">do</span>
        findUninhabitedRoom(xPos, yPos, zPos);
        labyrinth[xPos][yPos][zPos].roomer := animate;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">for</span> count <span class="keywd">range</span> 1 <span class="keywd">to</span> VENDORS_PER_LEVEL <span class="keywd">do</span>
        findUninhabitedRoom(xPos, yPos, zPos);
        labyrinth[xPos][yPos][zPos].roomer := VENDOR;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> treasure <span class="keywd">range</span> treasureSet <span class="keywd">do</span>
      randomRoom(xPos, yPos, zPos);
      incl(labyrinth[xPos][yPos][zPos].objects, treasure);
      objPlace[treasure] := labyrinth[xPos][yPos][zPos];
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> zPos <span class="keywd">range</span> 1 <span class="keywd">to</span> NUM_LEVELS <span class="keywd">do</span>
      <span class="keywd">for</span> count <span class="keywd">range</span> 1 <span class="keywd">to</span> OCCURRENCES_PER_LEVEL <span class="keywd">do</span>
        <span class="keywd">for</span> occurrence <span class="keywd">range</span> FINDGOLD <span class="keywd">to</span> FINDFLARES <span class="keywd">do</span>
          xPos := rand(1, SIZE_LABY);
          yPos := rand(1, SIZE_LABY);
          labyrinth[xPos][yPos][zPos].occurrence := occurrence;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> occurrence <span class="keywd">range</span> LEECH <span class="keywd">to</span> STEALTREASURE <span class="keywd">do</span>
      randomRoom(xPos, yPos, zPos);
      labyrinth[xPos][yPos][zPos].occurrence := occurrence;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># initRoomProperties</span>


<span class="keywd">const</span> <span class="type">proc</span>: initRoomTransfers <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: count <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: zPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    zPos := rand(1, NUM_LEVELS);
    findUninhabitedRoom(xPos, yPos, zPos);
    labyrinth[xPos][yPos][zPos].roomer := rand(animateType);
    incl(labyrinth[xPos][yPos][zPos].objects, RUNESTAFF);
    objPlace[RUNESTAFF] := labyrinth[xPos][yPos][zPos];
    zPos := rand(1, NUM_LEVELS);
    findEmptyRoom(xPos, yPos, zPos);
    labyrinth[xPos][yPos][zPos].transfer := WARP;
    labyrinth[xPos][yPos][zPos].objects := {ORBOFZOT};
    objPlace[ORBOFZOT] := labyrinth[xPos][yPos][zPos];
    <span class="keywd">for</span> zPos <span class="keywd">range</span> 1 <span class="keywd">to</span> NUM_LEVELS <span class="keywd">do</span>
      <span class="keywd">for</span> count <span class="keywd">range</span> 1 <span class="keywd">to</span> TRANSFERS_PER_LEVEL <span class="keywd">do</span>
        findEmptyRoom(xPos, yPos, zPos);
        labyrinth[xPos][yPos][zPos].transfer := SINKHOLE;
        findEmptyRoom(xPos, yPos, zPos);
        labyrinth[xPos][yPos][zPos].transfer := WARP;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># initRoomTransfers</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: aOrAn (<span class="op">in</span> <span class="type">string</span>: word) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: wordWithIndefiniteArticle <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> word &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      <span class="keywd">if</span> upper(word[1]) <span class="op">in</span> {<span class="stri">'A'</span>, <span class="stri">'E'</span>, <span class="stri">'I'</span>, <span class="stri">'O'</span>, <span class="stri">'U'</span>} <span class="keywd">then</span>
        wordWithIndefiniteArticle := <span class="stri">"an "</span> &amp; word;
      <span class="keywd">else</span>
        wordWithIndefiniteArticle := <span class="stri">"a "</span> &amp; word;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># aOrAn</span>


<span class="keywd">const</span> <span class="type">proc</span>: DECLARE_A_OR_AN (<span class="op">in</span> <span class="type">type</span>: aType) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: aOrAn (<span class="op">in</span> <span class="type">aType</span>: aValue) <span class="keywd">is</span>
      <span class="keywd">return</span> aOrAn(str(aValue));
  <span class="keywd">end</span> <span class="keywd">func</span>;

DECLARE_A_OR_AN(speciesType);
DECLARE_A_OR_AN(weaponType);
DECLARE_A_OR_AN(animateType);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: anyFood <span class="keywd">is</span>
  <span class="keywd">return</span> rand([](<span class="stri">"sandwiches"</span>, <span class="stri">"stew"</span>, <span class="stri">"soup"</span>, <span class="stri">"burgers"</span>, <span class="stri">"roast"</span>,
                 <span class="stri">"filet"</span>, <span class="stri">"tace"</span>, <span class="stri">"pie"</span>));


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: anyAdjective <span class="keywd">is</span>
  <span class="keywd">return</span> rand([](<span class="stri">"a large"</span>, <span class="stri">"a strange"</span>, <span class="stri">"an ugly"</span>, <span class="stri">"an enormous"</span>,
                 <span class="stri">"a forbidding"</span>, <span class="stri">"a horrible"</span>, <span class="stri">"an exotic"</span>,
                 <span class="stri">"an ordinary"</span>));


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: numberName (<span class="op">in</span> <span class="type">integer</span>: number) <span class="keywd">is</span>
  <span class="keywd">return</span> number &lt;= 20 ? str(ENGLISH, number) : str(number);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: sexName (<span class="op">in</span> <span class="type">boolean</span>: isMale) <span class="keywd">is</span>
  <span class="keywd">return</span> isMale ? <span class="stri">"male"</span> : <span class="stri">"female"</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: titleName (<span class="op">in</span> <span class="type">boolean</span>: isMale) <span class="keywd">is</span>
  <span class="keywd">return</span> isMale ? <span class="stri">"sir"</span> : <span class="stri">"madam"</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: countOwnedObjects (<span class="op">in</span> <span class="type">playerType</span>: player) <span class="keywd">is</span>
  <span class="keywd">return</span> card(player.possession);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: countOwnedTreasures (<span class="op">in</span> <span class="type">playerType</span>: player) <span class="keywd">is</span>
  <span class="keywd">return</span> card(player.possession &amp; treasureSet);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">objectType</span>: ownedTreasure (<span class="op">in</span> <span class="type">playerType</span>: player) <span class="keywd">is</span>
  <span class="keywd">return</span> rand(player.possession &amp; treasureSet);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: treasureNumber (<span class="op">in</span> <span class="type">objectType</span>: treasure) <span class="keywd">is</span>
  <span class="keywd">return</span> succ(ord(treasure) - ord(RUBY));


<span class="keywd">const</span> <span class="type">proc</span>: removeFromRoom (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom,
    <span class="op">in</span> <span class="type">objectType</span>: treasure) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    excl(currentRoom.objects, treasure);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># removeFromRoom</span>


<span class="keywd">const</span> <span class="type">proc</span>: writePos (<span class="op">in</span> <span class="type">roomType</span>: aRoom) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"("</span> &lt;&amp; aRoom.xPos &lt;&amp; <span class="stri">", "</span> &lt;&amp; aRoom.yPos &lt;&amp; <span class="stri">") Level: "</span> &lt;&amp; aRoom.zPos);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># writePos</span>


<span class="keywd">const</span> <span class="type">proc</span>: findGoldPieces (<span class="keywd">inout</span> <span class="type">playerType</span>: player, <span class="op">in</span> <span class="type">integer</span>: limit) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: goldPieces <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    goldPieces := rand(2, limit);
    player.goldPieces +:= goldPieces;
    writeln(numberName(goldPieces) &lt;&amp; <span class="stri">" gold pieces!"</span>);
    writeln(<span class="stri">"You now have "</span> &lt;&amp; numberName(player.goldPieces) &lt;&amp; <span class="stri">" GP'S."</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># findGoldPieces</span>


<span class="keywd">const</span> <span class="type">proc</span>: findFlares (<span class="keywd">inout</span> <span class="type">playerType</span>: player, <span class="op">in</span> <span class="type">integer</span>: limit) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: flares <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    flares := rand(2, limit);
    player.flares +:= flares;
    writeln(numberName(flares) &lt;&amp; <span class="stri">" flares. You now have "</span> &lt;&amp;
            numberName(player.flares) &lt;&amp; <span class="stri">" flares."</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># findFlares</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: roomAdjective (<span class="op">in</span> <span class="type">integer</span>: roomId) <span class="keywd">is</span>
  <span class="keywd">return</span> [0](<span class="stri">""</span>, <span class="stri">"luxurious "</span>, <span class="stri">"expensive "</span>, <span class="stri">"wonderful "</span>, <span class="stri">"good "</span>,
             <span class="stri">"worn out "</span>, <span class="stri">"fine "</span>, <span class="stri">"moss-grown "</span>, <span class="stri">"old "</span>, <span class="stri">"figured "</span>,
             <span class="stri">"patterned "</span>)[roomId <span class="op">rem</span> 11];


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: roomIdInLevel (<span class="op">in</span> <span class="type">roomType</span>: aRoom) <span class="keywd">is</span>
  <span class="keywd">return</span> 64 * pred(labyrinthNumber) + 8 * pred(aRoom.xPos) + pred(aRoom.yPos);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: roomId (<span class="op">in</span> <span class="type">roomType</span>: aRoom) <span class="keywd">is</span>
  <span class="keywd">return</span> 8 * roomIdInLevel(aRoom) + pred(aRoom.zPos);


<span class="keywd">const</span> <span class="type">proc</span>: writeRoomDescription (<span class="op">in</span> <span class="type">roomType</span>: aRoom) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: roomId <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> aRoom.contents = ENTRANCE <span class="keywd">then</span>
      writeln(<span class="stri">"the entrance hall. To the North the castle can be left."</span>);
    <span class="keywd">else</span>
      roomId := roomId(aRoom);
      <span class="keywd">case</span> roomId <span class="op">rem</span> 23 <span class="keywd">of</span>
        <span class="keywd">when</span> { 0}: write(<span class="stri">"a "</span>);
        <span class="keywd">when</span> { 1}: write(<span class="stri">"a gigantic "</span>);
        <span class="keywd">when</span> { 2}: write(<span class="stri">"a large "</span>);
        <span class="keywd">when</span> { 3}: write(<span class="stri">"a long "</span>);
        <span class="keywd">when</span> { 4}: write(<span class="stri">"a small "</span>);
        <span class="keywd">when</span> { 5}: write(<span class="stri">"a narrow "</span>);
        <span class="keywd">when</span> { 6}: write(<span class="stri">"a tiny "</span>);
        <span class="keywd">when</span> { 7}: write(<span class="stri">"a round "</span>);
        <span class="keywd">when</span> { 8}: write(<span class="stri">"an octagonal "</span>);
        <span class="keywd">when</span> { 9}: write(<span class="stri">"a hexagonal "</span>);
        <span class="keywd">when</span> {10}: write(<span class="stri">"a whitewashed "</span>);
        <span class="keywd">when</span> {11}: write(<span class="stri">"a blue painted "</span>);
        <span class="keywd">when</span> {12}: write(<span class="stri">"a black painted "</span>);
        <span class="keywd">when</span> {13}: write(<span class="stri">"a red painted "</span>);
        <span class="keywd">when</span> {14}: write(<span class="stri">"a green painted "</span>);
        <span class="keywd">when</span> {15}: write(<span class="stri">"a brown painted "</span>);
        <span class="keywd">when</span> {16}: write(<span class="stri">"a cold "</span>);
        <span class="keywd">when</span> {17}: write(<span class="stri">"a windy "</span>);
        <span class="keywd">when</span> {18}: write(<span class="stri">"a draughty "</span>);
        <span class="keywd">when</span> {19}: write(<span class="stri">"an antique "</span>);
        <span class="keywd">when</span> {20}: write(<span class="stri">"an old "</span>);
        <span class="keywd">when</span> {21}: write(<span class="stri">"a dusty "</span>);
        <span class="keywd">when</span> {22}: write(<span class="stri">"a dilapidated "</span>);
      <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">case</span> roomId <span class="op">rem</span> 7 <span class="keywd">of</span>
        <span class="keywd">when</span> {0}: write(<span class="stri">"dome "</span>);
        <span class="keywd">when</span> {1}: write(<span class="stri">"hall "</span>);
        <span class="keywd">when</span> {2}: write(<span class="stri">"room "</span>);
        <span class="keywd">when</span> {3}: write(<span class="stri">"chamber "</span>);
        <span class="keywd">when</span> {4}: write(<span class="stri">"corridor "</span>);
        <span class="keywd">when</span> {5}: write(<span class="stri">"cavern "</span>);
        <span class="keywd">when</span> {6}: write(<span class="stri">"tunnel "</span>);
      <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">case</span> roomId <span class="op">rem</span> 17 <span class="keywd">of</span>
        <span class="keywd">when</span> { 0}: write(<span class="stri">"with wooden planking."</span>);
        <span class="keywd">when</span> { 1}: write(<span class="stri">"blasted out of the rock."</span>);
        <span class="keywd">when</span> { 2}: write(<span class="stri">"that must have been a cellar."</span>);
        <span class="keywd">when</span> { 3}: write(<span class="stri">"with all walls made out of bricks."</span>);
        <span class="keywd">when</span> { 4}: write(<span class="stri">"that has a massive pillar in the centre."</span>);
        <span class="keywd">when</span> { 5}: write(<span class="stri">"with an enormous chandelier hanging down."</span>);
        <span class="keywd">when</span> { 6}: write(<span class="stri">"which has a lot of paintings on the walls."</span>);
        <span class="keywd">when</span> { 7}: write(<span class="stri">"which is totally made from rustless steel."</span>);
        <span class="keywd">when</span> { 8}: write(<span class="stri">"with lots of statues high above your head."</span>);
        <span class="keywd">when</span> { 9}: write(<span class="stri">"with "</span> &lt;&amp; aOrAn(roomAdjective(roomId)) &lt;&amp; <span class="stri">"parquet."</span>);
        <span class="keywd">when</span> {10}: write(<span class="stri">"with "</span> &lt;&amp; aOrAn(roomAdjective(roomId)) &lt;&amp;
                         <span class="stri">"stone-floor."</span>);
        <span class="keywd">when</span> {11}: write(<span class="stri">"with "</span> &lt;&amp; aOrAn(roomAdjective(roomId)) &lt;&amp;
                         <span class="stri">"rug lying on the floor."</span>);
        <span class="keywd">when</span> {12}: write(<span class="stri">"with "</span> &lt;&amp; aOrAn(roomAdjective(roomId)) &lt;&amp;
                         <span class="stri">"fresco at the wall."</span>);
        <span class="keywd">when</span> {13}: write(<span class="stri">"with "</span> &lt;&amp; roomAdjective(roomId) &lt;&amp;
                         <span class="stri">"walls made from granite."</span>);
        <span class="keywd">when</span> {14}: write(<span class="stri">"with "</span> &lt;&amp; roomAdjective(roomId) &lt;&amp;
                         <span class="stri">"panelling at the walls."</span>);
        <span class="keywd">when</span> {15}: write(<span class="stri">"with "</span> &lt;&amp; roomAdjective(roomId) &lt;&amp;
                         <span class="stri">"paintings at the ceiling."</span>);
        <span class="keywd">when</span> {16}: write(<span class="stri">"with a floor made out of "</span> &lt;&amp;
                         roomAdjective(roomId) &lt;&amp; <span class="stri">"marble."</span>);
      <span class="keywd">end</span> <span class="keywd">case</span>;
      writeln;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># writeRoomDescription</span>


<span class="keywd">const</span> <span class="type">proc</span>: writeConnections (<span class="op">in</span> <span class="type">roomType</span>: aRoom) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: roomIdInLevel <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: numConnections <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">directType</span>: direction <span class="keywd">is</span> NORTH;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> UP <span class="op">in</span> aRoom.connections <span class="op">or</span>
        DOWN <span class="op">in</span> aRoom.connections <span class="keywd">then</span>
      roomIdInLevel := roomIdInLevel(aRoom);
      <span class="keywd">case</span> roomIdInLevel <span class="op">rem</span> 9 <span class="keywd">of</span>
        <span class="keywd">when</span> {0}: write(<span class="stri">"At one wall are steps "</span>);
        <span class="keywd">when</span> {1}: write(<span class="stri">"Here is a shaky rope ladder "</span>);
        <span class="keywd">when</span> {2}: write(<span class="stri">"Here is a forbidding staircase "</span>);
        <span class="keywd">when</span> {3}: write(<span class="stri">"Here you find a steel-ladder "</span>);
        <span class="keywd">when</span> {4}: write(<span class="stri">"Here you find a very old staircase "</span>);
        <span class="keywd">when</span> {5}: write(<span class="stri">"There is a narrow spiral staircase "</span>);
        <span class="keywd">when</span> {6}: write(<span class="stri">"There is a rotten ladder "</span>);
        <span class="keywd">when</span> {7}: write(<span class="stri">"There you find a wooden staircase "</span>);
        <span class="keywd">when</span> {8}: write(<span class="stri">"There you find stone steps "</span>);
      <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">case</span> roomIdInLevel <span class="op">rem</span> 2 <span class="keywd">of</span>
        <span class="keywd">when</span> {0}: write(<span class="stri">"going "</span>);
        <span class="keywd">when</span> {1}: write(<span class="stri">"leading "</span>);
      <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">if</span> UP <span class="op">in</span> aRoom.connections <span class="keywd">then</span>
        <span class="keywd">if</span> DOWN <span class="op">in</span> aRoom.connections <span class="keywd">then</span>
          write(<span class="stri">"up and down"</span>);
        <span class="keywd">else</span>
          write(<span class="stri">"up"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        write(<span class="stri">"down"</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">case</span> roomId(aRoom) <span class="op">rem</span> 5 <span class="keywd">of</span>
        <span class="keywd">when</span> {0}: writeln(<span class="stri">" into deep darkness."</span>);
        <span class="keywd">when</span> {1}: writeln(<span class="stri">" into darkness."</span>);
        <span class="keywd">when</span> {2}: writeln(<span class="stri">"ward into darkness."</span>);
        <span class="keywd">when</span> {3}: writeln(<span class="stri">"ward."</span>);
        <span class="keywd">when</span> {4}: writeln(<span class="stri">"."</span>);
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    numConnections := card(aRoom.connections - {UP, DOWN});
    <span class="keywd">if</span> numConnections = 1 <span class="op">or</span> numConnections = 2 <span class="keywd">then</span>
      write(<span class="stri">"The room can "</span> &lt;&amp;
             card(aRoom.connections) = 1 ? <span class="stri">"only "</span> : <span class="stri">""</span> &lt;&amp;
            <span class="stri">"be left to the "</span>);
      <span class="keywd">for</span> direction <span class="keywd">range</span> NORTH <span class="keywd">to</span> WEST <span class="keywd">do</span>
        <span class="keywd">if</span> direction <span class="op">in</span> aRoom.connections <span class="keywd">then</span>
          write(direction);
          decr(numConnections);
          <span class="keywd">if</span> numConnections = 1 <span class="keywd">then</span>
            write(<span class="stri">" and "</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      writeln(<span class="stri">"."</span>);
    <span class="keywd">elsif</span> numConnections = 3 <span class="keywd">then</span>
      write(<span class="stri">"There is no way to the "</span>);
      <span class="keywd">for</span> direction <span class="keywd">range</span> NORTH <span class="keywd">to</span> WEST <span class="keywd">do</span>
        <span class="keywd">if</span> direction <span class="op">not</span> <span class="op">in</span> aRoom.connections <span class="keywd">then</span>
          write(direction);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      writeln(<span class="stri">"."</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># writeConnections</span>


<span class="keywd">const</span> <span class="type">proc</span>: writeThings (<span class="op">in</span> <span class="type">roomType</span>: aRoom) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">case</span> aRoom.contents <span class="keywd">of</span>
      <span class="keywd">when</span> {EMPTYCHEST}:        writeln(<span class="stri">"Here is an empty chest."</span>);
      <span class="keywd">when</span> {CHESTWITHSKELETON}: writeln(<span class="stri">"Here is an open chest with a skeleton in it."</span>);
      <span class="keywd">when</span> {CLOSEDCHEST}:       writeln(<span class="stri">"Here is a chest."</span>);
      <span class="keywd">when</span> {ORB}:               writeln(<span class="stri">"Here is a crystal orb."</span>);
      <span class="keywd">when</span> {POOL}:              writeln(<span class="stri">"Here is a pool."</span>);
      <span class="keywd">when</span> {BOOK}:              writeln(<span class="stri">"Here is a book."</span>);
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># writeThings</span>


<span class="keywd">const</span> <span class="type">proc</span>: writeAnimates (<span class="op">in</span> <span class="type">roomType</span>: aRoom) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> aRoom.roomer &lt;> NOBODY <span class="keywd">then</span>
      writeln(<span class="stri">"In this room is "</span> &lt;&amp; aOrAn(aRoom.roomer) &lt;&amp; <span class="stri">"."</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># writeAnimates</span>


<span class="keywd">const</span> <span class="type">proc</span>: writeObjects (<span class="op">in</span> <span class="type">roomType</span>: aRoom) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: count <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">objectType</span>: obj <span class="keywd">is</span> NOOBJECT;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> aRoom.roomer = NOBODY <span class="keywd">then</span>
      count := card(aRoom.objects);
      <span class="keywd">if</span> count > 0 <span class="keywd">then</span>
        write(<span class="stri">"This room contains "</span>);
        <span class="keywd">for</span> obj <span class="keywd">range</span> aRoom.objects <span class="keywd">do</span>
          incr(number);
          <span class="keywd">if</span> number = 1 <span class="keywd">then</span>
            write(<span class="stri">"the "</span>);
          <span class="keywd">elsif</span> number = count <span class="keywd">then</span>
            write(<span class="stri">" and the "</span>);
          <span class="keywd">else</span>
            write(<span class="stri">", the "</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          write(obj);
        <span class="keywd">end</span> <span class="keywd">for</span>;
        writeln(<span class="stri">"."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># writeObjects</span>


<span class="keywd">const</span> <span class="type">proc</span>: writeRoomDetails (<span class="op">in</span> <span class="type">roomType</span>: currentRoom) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeConnections(currentRoom);
    writeThings(currentRoom);
    writeAnimates(currentRoom);
    writeObjects(currentRoom);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># writeRoomDetails</span>


<span class="keywd">const</span> <span class="type">proc</span>: look (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom, <span class="op">in</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln;
    write(<span class="stri">"You are in "</span>);
    <span class="keywd">if</span> player.blind <span class="keywd">then</span>
      writeln(<span class="stri">"a room."</span>);
    <span class="keywd">else</span>
      writeRoomDescription(currentRoom);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeRoomDetails(currentRoom);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># look</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">char</span>: readChar <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">'\0;'</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := upper(getln(IN));
    <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      ch := stri[1];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># readChar</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">char</span>: readChoice <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    writeln;
    write(<span class="stri">"Your choice? "</span>);
    ch := readChar();
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># readChoice</span>


<span class="keywd">const</span> <span class="type">proc</span>: readNumber (<span class="keywd">inout</span> <span class="type">integer</span>: number, <span class="keywd">inout</span> <span class="type">boolean</span>: okay,
    <span class="keywd">inout</span> <span class="type">boolean</span>: quit) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    number := 0;
    okay := TRUE;
    stri := upper(getln(IN));
    <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      <span class="keywd">if</span> stri = <span class="stri">"Q"</span> <span class="keywd">then</span>
        okay := FALSE;
        quit := TRUE;
      <span class="keywd">else</span>
        <span class="keywd">block</span>
          number := integer(stri);
        exception
          catch RANGE_ERROR:
            okay := FALSE;
        <span class="keywd">end</span> <span class="keywd">block</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># readNumber</span>


<span class="keywd">const</span> <span class="type">proc</span>: readSpecies (<span class="keywd">inout</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> <span class="op">not</span> player.quitDialog <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        okay := TRUE;
        writeln;
        writeln(<span class="stri">"You may be an elf, dwarf, man, or hobbit."</span>);
        <span class="keywd">case</span> readChoice() <span class="keywd">of</span>
          <span class="keywd">when</span> {<span class="stri">'H'</span>}: player.species := HOBBIT;
          <span class="keywd">when</span> {<span class="stri">'E'</span>}: player.species := ELF;
          <span class="keywd">when</span> {<span class="stri">'M'</span>}: player.species := HUMAN;
          <span class="keywd">when</span> {<span class="stri">'D'</span>}: player.species := DWARF;
          <span class="keywd">when</span> {<span class="stri">'Q'</span>}: player.quitDialog := TRUE;
          <span class="keywd">otherwise</span>:
            okay := FALSE;
            writeln;
            writeln(<span class="stri">"** That was incorrect. Please type E, D, M, H or Q."</span>);
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">until</span> okay;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># readSpecies</span>


<span class="keywd">const</span> <span class="type">proc</span>: readSex (<span class="keywd">inout</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> <span class="op">not</span> player.quitDialog <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        okay := TRUE;
        writeln;
        write(<span class="stri">"Which sex do you prefer? "</span>);
        <span class="keywd">case</span> readChar() <span class="keywd">of</span>
          <span class="keywd">when</span> {<span class="stri">'M'</span>}: player.isMale := TRUE;
          <span class="keywd">when</span> {<span class="stri">'F'</span>}: player.isMale := FALSE;
          <span class="keywd">when</span> {<span class="stri">'Q'</span>}: player.quitDialog := TRUE;
          <span class="keywd">otherwise</span>:
            okay := FALSE;
            writeln;
            writeln(<span class="stri">"** Cute "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">", real cute. Try M, F or Q."</span>);
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">until</span> okay;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># readSex</span>


<span class="keywd">const</span> <span class="type">proc</span>: riseAttribute (<span class="keywd">inout</span> <span class="type">playerType</span>: player, <span class="op">in</span> <span class="type">string</span>: attrName,
    <span class="keywd">inout</span> <span class="type">integer</span>: attribute, <span class="keywd">inout</span> <span class="type">integer</span>: otherPoints) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: points <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      writeln;
      write(<span class="stri">"How many points do you wish to add to your "</span> &lt;&amp; attrName &lt;&amp; <span class="stri">"? "</span>);
      readNumber(points, okay, player.quitDialog);
      <span class="keywd">if</span> <span class="op">not</span> player.quitDialog <span class="keywd">then</span>
        <span class="keywd">if</span> okay <span class="keywd">then</span>
          <span class="keywd">if</span> points > otherPoints <span class="keywd">then</span>
            writeln;
            writeln(<span class="stri">"** Dear "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">", you have only "</span> &lt;&amp;
                    numberName(otherPoints) &lt;&amp; <span class="stri">" point"</span> &lt;&amp;
                    otherPoints &lt;> 1 ? <span class="stri">"s."</span> : <span class="stri">"."</span>);
            okay := FALSE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          writeln;
          writeln(<span class="stri">"** Would you please be so kind to type a number or q, "</span> &lt;&amp;
                  player.species &lt;&amp; <span class="stri">"."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> okay <span class="op">or</span> player.quitDialog;
    <span class="keywd">if</span> okay <span class="keywd">then</span>
      attribute +:= points;
      otherPoints -:= points;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># riseAttribute</span>


<span class="keywd">const</span> <span class="type">proc</span>: readAttributes (<span class="keywd">inout</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: otherPoints <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> <span class="op">not</span> player.quitDialog <span class="keywd">then</span>
      player.strength := 4 + 2 * ord(player.species);
      player.intelligence := 8;
      player.dexterity := 12 - 2 * ord(player.species);
      <span class="keywd">if</span> player.species = HOBBIT <span class="keywd">then</span>
        otherPoints := 4;
      <span class="keywd">else</span>
        otherPoints := 8;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      writeln;
      writeln(<span class="stri">"Ok, "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">", you have the following attributes:"</span>);
      writeln(<span class="stri">"STRENGTH = "</span> &lt;&amp; player.strength &lt;&amp;
              <span class="stri">"  INTELLIGENCE = "</span> &lt;&amp; player.intelligence &lt;&amp;
              <span class="stri">"  DEXTERITY = "</span> &lt;&amp; player.dexterity);
      writeln(<span class="stri">"and "</span> &lt;&amp; otherPoints &lt;&amp; <span class="stri">" other points to allocate as you wish."</span>);
      riseAttribute(player, <span class="stri">"strength"</span>, player.strength, otherPoints);
      <span class="keywd">if</span> <span class="op">not</span> player.quitDialog <span class="op">and</span> otherPoints > 0 <span class="keywd">then</span>
        riseAttribute(player, <span class="stri">"intelligence"</span>, player.intelligence, otherPoints);
        <span class="keywd">if</span> <span class="op">not</span> player.quitDialog <span class="op">and</span> otherPoints > 0 <span class="keywd">then</span>
          riseAttribute(player, <span class="stri">"dexterity"</span>, player.dexterity, otherPoints);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> <span class="op">not</span> player.quitDialog <span class="op">and</span> otherPoints > 0 <span class="keywd">then</span>
        writeln;
        write(<span class="stri">"I am sure that you can never use the saved "</span>);
        <span class="keywd">if</span> otherPoints = 1 <span class="keywd">then</span>
          writeln(<span class="stri">"point."</span>);
        <span class="keywd">else</span>
          writeln(numberName(otherPoints) &lt;&amp; <span class="stri">" points."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># readAttributes</span>


<span class="keywd">const</span> <span class="type">proc</span>: buyAttribute (<span class="keywd">inout</span> <span class="type">playerType</span>: player, <span class="op">in</span> <span class="type">string</span>: attrName,
    <span class="keywd">inout</span> <span class="type">integer</span>: attribute, <span class="op">in</span> <span class="type">integer</span>: price) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> <span class="op">not</span> player.quitDialog <span class="op">and</span> player.goldPieces >= price <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        <span class="keywd">repeat</span>
          okay := TRUE;
          writeln;
          writeln(<span class="stri">"Your "</span> &lt;&amp; attrName &lt;&amp; <span class="stri">" is now "</span> &lt;&amp; attribute &lt;&amp;
                  <span class="stri">" and you have "</span> &lt;&amp; player.goldPieces &lt;&amp; <span class="stri">" GP'S."</span>);
          write(<span class="stri">"Do you want to buy a potion of "</span> &lt;&amp; attrName &lt;&amp;
                <span class="stri">" for "</span> &lt;&amp; price &lt;&amp; <span class="stri">" GP'S? "</span>);
          ch := readChar();
          <span class="keywd">case</span> ch <span class="keywd">of</span>
            <span class="keywd">when</span> {<span class="stri">'Y'</span>}:
              player.goldPieces -:= price;
              attribute := range18(attribute + rand(1, 6));
            <span class="keywd">when</span> {<span class="stri">'N'</span>}: noop;
            <span class="keywd">when</span> {<span class="stri">'Q'</span>}:
              player.quitDialog := TRUE;
            <span class="keywd">otherwise</span>:
              okay := FALSE;
              writeln;
              writeln(<span class="stri">"** Please answer Y, N or Q."</span>);
          <span class="keywd">end</span> <span class="keywd">case</span>;
        <span class="keywd">until</span> okay;
      <span class="keywd">until</span> ch &lt;> <span class="stri">'Y'</span> <span class="op">or</span> player.goldPieces &lt; price;
      <span class="keywd">if</span> ch &lt;> <span class="stri">'Q'</span> <span class="op">and</span> player.goldPieces &lt; price <span class="keywd">then</span>
        writeln;
        writeln(<span class="stri">"Your "</span> &lt;&amp; attrName &lt;&amp; <span class="stri">" is now "</span> &lt;&amp; attribute &lt;&amp; <span class="stri">"."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># buyAttribute</span>


<span class="keywd">const</span> <span class="type">proc</span>: buyArmor (<span class="keywd">inout</span> <span class="type">playerType</span>: player, <span class="op">in</span> <span class="type">integer</span>: priceOfPlate,
    <span class="op">in</span> <span class="type">integer</span>: priceOfChainmail, <span class="op">in</span> <span class="type">integer</span>: priceOfLeather) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> <span class="op">not</span> player.quitDialog <span class="op">and</span> player.goldPieces >= priceOfLeather <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"Ok, "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">", you have "</span> &lt;&amp; player.goldPieces &lt;&amp;
              <span class="stri">" gold pieces (GP'S) and "</span> &lt;&amp; player.armor &lt;&amp; <span class="stri">" armor."</span>);
      <span class="keywd">repeat</span>
        okay := TRUE;
        writeln(<span class="stri">"These are the types of armor you can buy:"</span>);
        writeln;
        <span class="keywd">if</span> player.goldPieces >= priceOfPlate <span class="keywd">then</span>
          writeln(<span class="stri">"  P/LATE     "</span> &lt;&amp; priceOfPlate <span class="op">lpad</span> 4 &lt;&amp; <span class="stri">" GP'S"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> player.goldPieces >= priceOfChainmail <span class="keywd">then</span>
          writeln(<span class="stri">"  C/HAINMAIL "</span> &lt;&amp; priceOfChainmail <span class="op">lpad</span> 4 &lt;&amp; <span class="stri">" GP'S"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        writeln(<span class="stri">"  L/EATHER   "</span> &lt;&amp; priceOfLeather <span class="op">lpad</span> 4 &lt;&amp; <span class="stri">" GP'S"</span>);
        writeln(<span class="stri">"  N/OTHING      0 GP'S"</span>);
        ch := readChoice();
        <span class="keywd">if</span>  (ch &lt;> <span class="stri">'P'</span> <span class="op">or</span> player.goldPieces &lt; priceOfPlate) <span class="op">and</span>
            (ch &lt;> <span class="stri">'C'</span> <span class="op">or</span> player.goldPieces &lt; priceOfChainmail) <span class="op">and</span>
             ch <span class="op">not</span> <span class="op">in</span> {<span class="stri">'L'</span>, <span class="stri">'N'</span>, <span class="stri">'Q'</span>} <span class="keywd">then</span>
          okay := FALSE;
          writeln;
          writeln(<span class="stri">"** Are you "</span> &lt;&amp; aOrAn(player.species) &lt;&amp; <span class="stri">" or "</span> &lt;&amp;
                  aOrAn(rand(animateType)) &lt;&amp; <span class="stri">"?"</span>);
          writeln;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> okay;
      <span class="keywd">case</span> ch <span class="keywd">of</span>
        <span class="keywd">when</span> {<span class="stri">'P'</span>}:
          player.armor := PLATE;
          player.armorStrength := ord(player.armor) * ARMOR_STRENGTH_FACTOR;
          player.goldPieces -:= priceOfPlate;
        <span class="keywd">when</span> {<span class="stri">'C'</span>}:
          player.armor := CHAINMAIL;
          player.armorStrength := ord(player.armor) * ARMOR_STRENGTH_FACTOR;
          player.goldPieces -:= priceOfChainmail;
        <span class="keywd">when</span> {<span class="stri">'L'</span>}:
          player.armor := LEATHER;
          player.armorStrength := ord(player.armor) * ARMOR_STRENGTH_FACTOR;
          player.goldPieces -:= priceOfLeather;
        <span class="keywd">when</span> {<span class="stri">'N'</span>}: noop;
        <span class="keywd">when</span> {<span class="stri">'Q'</span>}:
          player.quitDialog := TRUE;
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># buyArmor</span>


<span class="keywd">const</span> <span class="type">proc</span>: buyWeapon (<span class="keywd">inout</span> <span class="type">playerType</span>: player, <span class="op">in</span> <span class="type">integer</span>: priceOfSword,
    <span class="op">in</span> <span class="type">integer</span>: priceOfMace, <span class="op">in</span> <span class="type">integer</span>: priceOfDagger) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> <span class="op">not</span> player.quitDialog <span class="op">and</span> player.goldPieces >= priceOfDagger <span class="keywd">then</span>
      writeln;
      write(<span class="stri">"Ok, "</span>);
      <span class="keywd">if</span> player.armor &lt;> NOARMOR <span class="keywd">then</span>
        write(<span class="stri">"bold "</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      write(player.species &lt;&amp; <span class="stri">", you have "</span> &lt;&amp; player.goldPieces &lt;&amp;
            <span class="stri">" GP'S left and "</span>);
      <span class="keywd">if</span> player.weapon = NOWEAPON <span class="keywd">then</span>
        writeln(<span class="stri">"no weapon."</span>);
      <span class="keywd">else</span>
        writeln(aOrAn(player.weapon) &lt;&amp; <span class="stri">"."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">repeat</span>
        okay := TRUE;
        writeln(<span class="stri">"These are the types of weapons you can buy:"</span>);
        writeln;
        <span class="keywd">if</span> player.goldPieces >= priceOfSword <span class="keywd">then</span>
          writeln(<span class="stri">"  S/WORD     "</span> &lt;&amp; priceOfSword <span class="op">lpad</span> 4 &lt;&amp; <span class="stri">" GP'S"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> player.goldPieces >= priceOfMace <span class="keywd">then</span>
          writeln(<span class="stri">"  M/ACE      "</span> &lt;&amp; priceOfMace <span class="op">lpad</span> 4 &lt;&amp; <span class="stri">" GP'S"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        writeln(<span class="stri">"  D/AGGER    "</span> &lt;&amp; priceOfDagger <span class="op">lpad</span> 4 &lt;&amp; <span class="stri">" GP'S"</span>);
        writeln(<span class="stri">"  N/OTHING      0 GP'S"</span>);
        ch := readChoice();
        <span class="keywd">if</span>  (ch &lt;> <span class="stri">'S'</span> <span class="op">or</span> player.goldPieces &lt; priceOfSword) <span class="op">and</span>
            (ch &lt;> <span class="stri">'M'</span> <span class="op">or</span> player.goldPieces &lt; priceOfMace) <span class="op">and</span>
             ch <span class="op">not</span> <span class="op">in</span> {<span class="stri">'D'</span>, <span class="stri">'N'</span>, <span class="stri">'Q'</span>} <span class="keywd">then</span>
          okay := FALSE;
          writeln;
          writeln(<span class="stri">"** Is your intelligence really "</span> &lt;&amp;
                  numberName(player.intelligence) &lt;&amp; <span class="stri">"?"</span>);
          writeln;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> okay;
      <span class="keywd">case</span> ch <span class="keywd">of</span>
        <span class="keywd">when</span> {<span class="stri">'S'</span>}:
          player.weapon := SWORD;
          player.goldPieces -:= priceOfSword;
        <span class="keywd">when</span> {<span class="stri">'M'</span>}:
          player.weapon := MACE;
          player.goldPieces -:= priceOfMace;
        <span class="keywd">when</span> {<span class="stri">'D'</span>}:
          player.weapon := DAGGER;
          player.goldPieces -:= priceOfDagger;
        <span class="keywd">when</span> {<span class="stri">'N'</span>}: noop;
        <span class="keywd">when</span> {<span class="stri">'Q'</span>}:
          player.quitDialog := TRUE;
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># buyWeapon</span>


<span class="keywd">const</span> <span class="type">proc</span>: buyLamp (<span class="keywd">inout</span> <span class="type">playerType</span>: player, <span class="op">in</span> <span class="type">integer</span>: price) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> <span class="op">not</span> player.quitDialog <span class="op">and</span> LAMP <span class="op">not</span> <span class="op">in</span> player.possession <span class="op">and</span>
        player.goldPieces >= price <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        okay := TRUE;
        writeln;
        write(<span class="stri">"Do you want to buy a lamp for "</span> &lt;&amp; price &lt;&amp; <span class="stri">" GP'S? "</span>);
        <span class="keywd">case</span> readChar() <span class="keywd">of</span>
          <span class="keywd">when</span> {<span class="stri">'Y'</span>}:
            <span class="keywd">if</span> price > 10 <span class="keywd">then</span>
              writeln;
              writeln(<span class="stri">"It's guaranteed to outlive you."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            incl(player.possession, LAMP);
            player.goldPieces -:= price;
          <span class="keywd">when</span> {<span class="stri">'N'</span>}: noop;
          <span class="keywd">when</span> {<span class="stri">'Q'</span>}:
            player.quitDialog := TRUE;
          <span class="keywd">otherwise</span>:
            okay := FALSE;
            writeln;
            writeln(<span class="stri">"** Please answer Y, N or Q."</span>);
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">until</span> okay;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># buyLamp</span>


<span class="keywd">const</span> <span class="type">proc</span>: buyFlares (<span class="keywd">inout</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: flares <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> <span class="op">not</span> player.quitDialog <span class="op">and</span> player.goldPieces >= 1 <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"Ok, "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">", you have "</span> &lt;&amp; player.goldPieces &lt;&amp;
              <span class="stri">" GP'S left."</span>);
      <span class="keywd">repeat</span>
        writeln;
        write(<span class="stri">"Five flares cost 1 GP. How many do you want? "</span>);
        readNumber(flares, okay, player.quitDialog);
        <span class="keywd">if</span> <span class="op">not</span> player.quitDialog <span class="keywd">then</span>
          <span class="keywd">if</span> okay <span class="keywd">then</span>
            <span class="keywd">if</span> flares > 5 * player.goldPieces <span class="keywd">then</span>
              writeln;
              writeln(<span class="stri">"** You can afford only "</span> &lt;&amp; 5 * player.goldPieces &lt;&amp; <span class="stri">"."</span>);
              okay := FALSE;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            writeln;
            writeln(<span class="stri">"** If you don't want any, just type 0 (zero)."</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> okay <span class="op">or</span> player.quitDialog;
      <span class="keywd">if</span> okay <span class="keywd">then</span>
        player.flares +:= flares;
        player.goldPieces -:= (flares + 4) <span class="op">div</span> 5;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># buyFlares</span>


<span class="keywd">const</span> <span class="type">proc</span>: buyTreasures (<span class="keywd">inout</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">objectType</span>: treasure <span class="keywd">is</span> NOOBJECT;
    <span class="keywd">var</span> <span class="type">integer</span>: treasureNumber <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: price <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> treasure <span class="keywd">range</span> treasureSet <span class="keywd">do</span>
      <span class="keywd">if</span> <span class="op">not</span> player.quitDialog <span class="op">and</span> treasure <span class="op">not</span> <span class="op">in</span> player.possession <span class="keywd">then</span>
        treasureNumber := treasureNumber(treasure);
        price := 125 * treasureNumber + rand(1, 250) +
                 250 * pred(rand(1, treasureNumber));
        <span class="keywd">if</span> price &lt;= player.goldPieces <span class="keywd">then</span>
          <span class="keywd">repeat</span>
            okay := TRUE;
            writeln;
            write(<span class="stri">"Do you want to buy the "</span> &lt;&amp; treasure &lt;&amp;
                  <span class="stri">" for "</span> &lt;&amp; price &lt;&amp; <span class="stri">" GP'S? "</span>);
            <span class="keywd">case</span> readChar() <span class="keywd">of</span>
              <span class="keywd">when</span> {<span class="stri">'Y'</span>}:
                removeFromRoom(objPlace[treasure], treasure);
                incl(player.possession, treasure);
                player.goldPieces -:= price;
              <span class="keywd">when</span> {<span class="stri">'N'</span>}: noop;
              <span class="keywd">when</span> {<span class="stri">'Q'</span>}:
                player.quitDialog := TRUE;
              <span class="keywd">otherwise</span>:
                okay := FALSE;
                writeln;
                writeln(<span class="stri">"** Please answer Y, N or Q."</span>);
            <span class="keywd">end</span> <span class="keywd">case</span>;
          <span class="keywd">until</span> okay;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># buyTreasures</span>


<span class="keywd">const</span> <span class="type">proc</span>: buy (<span class="op">in</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> currentRoom.roomer &lt;> VENDOR <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"** You can only buy from a vendor!"</span>);
    <span class="keywd">elsif</span> player.goldPieces &lt; 100 <span class="keywd">then</span>
      writeln;
      <span class="keywd">case</span> rand(1, 14) <span class="keywd">of</span>
        <span class="keywd">when</span> { 1}: writeln(<span class="stri">"I do not play with funny money."</span>);
        <span class="keywd">when</span> { 2}: writeln(<span class="stri">"You need more gold pieces to trade."</span>);
        <span class="keywd">when</span> { 3}: writeln(<span class="stri">"You haven't got enough cash on hand."</span>);
        <span class="keywd">when</span> { 4}: writeln(<span class="stri">"Earn money and then come and try again."</span>);
        <span class="keywd">when</span> { 5}: writeln(<span class="stri">"You need hard currency to trade with me."</span>);
        <span class="keywd">when</span> { 6}: writeln(<span class="stri">"In capitalism real money is needed for trading."</span>);
        <span class="keywd">when</span> { 7}: writeln(<span class="stri">"Your dungeon express card -  You left home without it."</span>);
        <span class="keywd">when</span> { 8}: writeln(<span class="stri">"I don't give alms, "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">"."</span>);
        <span class="keywd">when</span> { 9}: writeln(<span class="stri">"You're too poor to trade, "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">"."</span>);
        <span class="keywd">when</span> {10}: writeln(<span class="stri">"I don't trade with a beggar, "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">"."</span>);
        <span class="keywd">when</span> {11}: writeln(<span class="stri">"Even "</span> &lt;&amp; aOrAn(rand(animateType)) &lt;&amp;
                           <span class="stri">" knows that money is needed for trading."</span>);
        <span class="keywd">when</span> {12}: writeln(<span class="stri">"With "</span> &lt;&amp; numberName(player.goldPieces) &lt;&amp;
                           <span class="stri">" GP'S no trade can be done."</span>);
        <span class="keywd">when</span> {13}: writeln(<span class="stri">"It's typical for "</span> &lt;&amp; sexName(player.isMale) &lt;&amp;
                           <span class="stri">" "</span> &lt;&amp; player.species &lt;&amp;
                           <span class="stri">"s, that they want to trade without enough money."</span>);
        <span class="keywd">when</span> {14}: writeln(<span class="stri">"Sorry "</span> &lt;&amp; titleName(player.isMale) &lt;&amp;
                           <span class="stri">", I'm afraid I don't give credit."</span>);
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">else</span>
      player.quitDialog := FALSE;
      buyArmor(player, 200, 150, 125);
      buyWeapon(player, 200, 150, 125);
      buyAttribute(player, <span class="stri">"strength"</span>,     player.strength,     100);
      buyAttribute(player, <span class="stri">"intelligence"</span>, player.intelligence, 100);
      buyAttribute(player, <span class="stri">"dexterity"</span>,    player.dexterity,    100);
      buyLamp(player, 100);
      buyTreasures(player);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># buy</span>


<span class="keywd">const</span> <span class="type">proc</span>: sellTreasures (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom,
    <span class="keywd">inout</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">objectType</span>: treasure <span class="keywd">is</span> NOOBJECT;
    <span class="keywd">var</span> <span class="type">integer</span>: treasureNumber <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: price <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> treasure <span class="keywd">range</span> treasureSet | {RUNESTAFF, ORBOFZOT} <span class="keywd">do</span>
      <span class="keywd">if</span> <span class="op">not</span> player.quitDialog <span class="op">and</span> treasure <span class="op">in</span> player.possession <span class="keywd">then</span>
        treasureNumber := treasureNumber(treasure);
        price := rand(1, 150) + 150 * pred(rand(1, treasureNumber));
        <span class="keywd">repeat</span>
          okay := TRUE;
          writeln;
          write(<span class="stri">"Do you want to sell the "</span> &lt;&amp; treasure &lt;&amp;
                <span class="stri">" for "</span> &lt;&amp; price &lt;&amp; <span class="stri">" GP'S? "</span>);
          <span class="keywd">case</span> readChar() <span class="keywd">of</span>
            <span class="keywd">when</span> {<span class="stri">'Y'</span>}:
              excl(player.possession, treasure);
              incl(currentRoom.objects, treasure);
              objPlace[treasure] := currentRoom;
              player.goldPieces +:= price;
            <span class="keywd">when</span> {<span class="stri">'N'</span>}: noop;
            <span class="keywd">when</span> {<span class="stri">'Q'</span>}:
              player.quitDialog := TRUE;
            <span class="keywd">otherwise</span>:
              okay := FALSE;
              writeln;
              writeln(<span class="stri">"** Please answer Y, N or Q."</span>);
          <span class="keywd">end</span> <span class="keywd">case</span>;
        <span class="keywd">until</span> okay;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># sellTreasures</span>


<span class="keywd">const</span> <span class="type">proc</span>: sell (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> currentRoom.roomer &lt;> VENDOR <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"** You can only sell to a vendor!"</span>);
    <span class="keywd">elsif</span> countOwnedTreasures(player) = 0 <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"** You have nothing to offer!"</span>);
    <span class="keywd">else</span>
      player.quitDialog := FALSE;
      sellTreasures(currentRoom, player);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># sell</span>


<span class="keywd">const</span> <span class="type">proc</span>: checkArmor (<span class="keywd">inout</span> <span class="type">playerType</span>: player, <span class="op">in</span> <span class="type">integer</span>: strike) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: damage <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> player.armor = NOARMOR <span class="keywd">then</span>
      damage := strike;
    <span class="keywd">else</span>
      <span class="keywd">if</span> strike &lt; ord(player.armor) <span class="keywd">then</span>
        damage := 0;
        player.armorStrength -:= strike;
      <span class="keywd">else</span>
        damage := strike - ord(player.armor);
        player.armorStrength -:= ord(player.armor);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> player.armorStrength &lt; 0 <span class="keywd">then</span>
        player.armorStrength := 0;
        player.armor := NOARMOR;
        writeln;
        writeln(<span class="stri">"YOUR ARMOR HAS BEEN DESTROYED . . . GOOD LUCK!"</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    player.strength -:= damage;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># checkArmor</span>


<span class="keywd">const</span> <span class="type">proc</span>: vendorDies (<span class="op">in</span> <span class="type">roomType</span>: currentRoom,
    <span class="keywd">inout</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">objectType</span>: treasure <span class="keywd">is</span> NOOBJECT;
  <span class="keywd">begin</span>
    writeln;
    writeln(<span class="stri">"You get all his wares:"</span>);
    writeln(<span class="stri">"  plate armor"</span>);
    player.armor := PLATE;
    player.armorStrength := ord(player.armor) * ARMOR_STRENGTH_FACTOR;
    writeln(<span class="stri">"  a sword"</span>);
    player.weapon := SWORD;
    writeln(<span class="stri">"  a strength potion"</span>);
    player.strength := range18(player.strength + rand(1, 6));
    writeln(<span class="stri">"  an intelligence potion"</span>);
    player.intelligence := range18(player.intelligence + rand(1, 6));
    writeln(<span class="stri">"  a dexterity potion"</span>);
    player.dexterity := range18(player.dexterity + rand(1, 6));
    <span class="keywd">if</span> LAMP <span class="op">not</span> <span class="op">in</span> player.possession <span class="keywd">then</span>
      writeln(<span class="stri">"  a lamp"</span>);
      incl(player.possession, LAMP);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">for</span> treasure <span class="keywd">range</span> currentRoom.objects <span class="keywd">do</span>
      writeln(<span class="stri">"  the "</span> &lt;&amp; treasure);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># vendorDies</span>


<span class="keywd">const</span> <span class="type">proc</span>: monsterDies (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
    <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">animateType</span>: monster <span class="keywd">is</span> NOBODY;
    <span class="keywd">var</span> <span class="type">objectType</span>: treasure <span class="keywd">is</span> NOOBJECT;
  <span class="keywd">begin</span>
    monster := currentRoom.roomer;
    fightState.monsterPresent := FALSE;
    writeln;
    writeln(<span class="stri">"The "</span> &lt;&amp; monster &lt;&amp; <span class="stri">" lies dead at your feet!"</span>);
    <span class="keywd">if</span> monster <span class="op">in</span> {WOLF, BEAR, CHIMERA, BALROG, DRAGON} <span class="op">and</span>
        player.mealHour + 60 &lt;= player.turns <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"You spend an hour eating "</span> &lt;&amp; monster &lt;&amp; <span class="stri">" "</span> &lt;&amp; anyFood() &lt;&amp; <span class="stri">"."</span>);
      player.mealHour := player.turns;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> monster = VENDOR <span class="keywd">then</span>
      vendorDies(currentRoom, player);
    <span class="keywd">else</span>
      <span class="keywd">for</span> treasure <span class="keywd">range</span> currentRoom.objects <span class="keywd">do</span>
        writeln(<span class="stri">"\a"</span>);
        writeln(<span class="stri">"Great Zot! You've found the "</span> &lt;&amp; treasure &lt;&amp; <span class="stri">"!"</span>);
      <span class="keywd">end</span> <span class="keywd">for</span>;
      decr(fightState.monsterCount);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    player.possession |:= currentRoom.objects;
    currentRoom.objects := objectSet.value;
    writeln;
    write(<span class="stri">"You get his hoard of "</span>);
    findGoldPieces(player, 99);
    currentRoom.roomer := NOBODY;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># monsterDies</span>


<span class="keywd">const</span> <span class="type">proc</span>: monsterAttacks (<span class="op">in</span> <span class="type">animateType</span>: monster, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
    <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> fightState.webCount > 0 <span class="keywd">then</span>
      decr(fightState.webCount);
      <span class="keywd">if</span> fightState.webCount = 0 <span class="keywd">then</span>
        writeln;
        writeln(<span class="stri">"The web just broke!"</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln;
    write(<span class="stri">"The "</span> &lt;&amp; monster);
    <span class="keywd">if</span> fightState.webCount > 0 <span class="keywd">then</span>
      writeln(<span class="stri">" is stuck and can't attack now!"</span>);
    <span class="keywd">elsif</span> player.dexterity >= rand(3, 21) + 3 * ord(player.blind) <span class="keywd">then</span>
      writeln(<span class="stri">" attacks!  What luck, he missed you!"</span>);
    <span class="keywd">else</span>
      writeln(<span class="stri">" attacks!  Ouch! He hit you!"</span>);
      checkArmor(player, fightState.aggressionOfMonster);
      player.living := player.strength >= 1;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># monsterAttacks</span>


<span class="keywd">const</span> <span class="type">proc</span>: attackMonster (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
    <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">animateType</span>: monster <span class="keywd">is</span> NOBODY;
  <span class="keywd">begin</span>
    monster := currentRoom.roomer;
    <span class="keywd">if</span> player.weapon = NOWEAPON <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"** Pounding on "</span> &lt;&amp; aOrAn(monster) &lt;&amp; <span class="stri">" won't hurt it!"</span>);
    <span class="keywd">elsif</span> player.weaponBlocked <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"** You can't beat it to death with a book!"</span>);
    <span class="keywd">elsif</span> player.dexterity &lt; rand(1, 20) + (3 * ord(player.blind)) <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"You missed, too bad!"</span>);
    <span class="keywd">else</span>
      writeln;
      writeln(<span class="stri">"You hit the evil "</span> &lt;&amp; monster &lt;&amp; <span class="stri">"."</span>);
      fightState.monsterStrength -:= ord(player.weapon);
      <span class="keywd">if</span> monster <span class="op">in</span> {GARGOYLE, DRAGON} <span class="keywd">then</span>
        <span class="keywd">if</span> rand(1, 8) = 1 <span class="keywd">then</span>
          writeln;
          writeln(<span class="stri">"OH NO!  Your "</span> &lt;&amp; player.weapon &lt;&amp; <span class="stri">" broke!"</span>);
          player.weapon := NOWEAPON;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> fightState.monsterStrength &lt;= 0 <span class="keywd">then</span>
        monsterDies(currentRoom, player, fightState);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># attackMonster</span>


<span class="keywd">const</span> <span class="type">proc</span>: castSpell (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
    <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: damage <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    writeln;
    write(<span class="stri">"Which spell (web, fireball, deathspell)? "</span>);
    ch := readChar();
    writeln;
    <span class="keywd">if</span> ch = <span class="stri">'W'</span> <span class="keywd">then</span>
      decr(player.strength);
      fightState.webCount := rand(2, 9);
      player.living := player.strength >= 1;
    <span class="keywd">elsif</span> ch = <span class="stri">'F'</span> <span class="keywd">then</span>
      decr(player.strength);
      decr(player.intelligence);
      <span class="keywd">if</span> player.intelligence &lt; 1 <span class="op">or</span> player.strength &lt; 1 <span class="keywd">then</span>
        player.living := FALSE;
      <span class="keywd">else</span>
        damage := rand(2, 14);
        writeln;
        writeln(<span class="stri">"It does "</span> &lt;&amp; damage &lt;&amp; <span class="stri">" points worth of damage."</span>);
        fightState.monsterStrength -:= damage;
        <span class="keywd">if</span> fightState.monsterStrength &lt;= 0 <span class="keywd">then</span>
          monsterDies(currentRoom, player, fightState);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> ch = <span class="stri">'D'</span> <span class="keywd">then</span>
      write(<span class="stri">"DEATH . . . "</span>);
      <span class="keywd">if</span> player.intelligence &lt; rand(16, 19) <span class="keywd">then</span>
        writeln(<span class="stri">"YOURS!"</span>);
        player.intelligence := 0;
        player.living := FALSE;
      <span class="keywd">else</span>
        writeln(<span class="stri">"HIS!"</span>);
        fightState.monsterStrength := 0;
        monsterDies(currentRoom, player, fightState);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      writeln(<span class="stri">"** Try one of the options given."</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># castSpell</span>


<span class="keywd">const</span> <span class="type">proc</span>: bribeMonster (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
    <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">objectType</span>: treasure <span class="keywd">is</span> NOOBJECT;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    fightState.bribed := FALSE;
    <span class="keywd">if</span> countOwnedTreasures(player) = 0 <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"All I want is your life!"</span>);
    <span class="keywd">else</span>
      treasure := ownedTreasure(player);
      <span class="keywd">repeat</span>
        okay := TRUE;
        writeln;
        write(<span class="stri">"I want the "</span> &lt;&amp; treasure &lt;&amp; <span class="stri">". Will you give it to me? "</span>);
        ch := readChar();
        <span class="keywd">if</span> <span class="op">not</span> ch <span class="op">in</span> {<span class="stri">'Y'</span>, <span class="stri">'N'</span>, <span class="stri">'Q'</span>} <span class="keywd">then</span>
          okay := FALSE;
          writeln;
          writeln(<span class="stri">"** Please answer yes or no."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> okay;
      <span class="keywd">if</span> ch = <span class="stri">'Y'</span> <span class="keywd">then</span>
        excl(player.possession, treasure);
        incl(currentRoom.objects, treasure);
        objPlace[treasure] := currentRoom;
        writeln;
        writeln(<span class="stri">"Ok, just don't tell anyone else."</span>);
        <span class="keywd">if</span> currentRoom.roomer = VENDOR <span class="keywd">then</span>
          fightState.monsterPresent := FALSE;
          fightState.angryVendors := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        fightState.bribed := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># bribeMonster</span>


<span class="keywd">const</span> <span class="type">proc</span>: meetMonster (<span class="op">in</span> <span class="type">roomType</span>: currentRoom, <span class="op">in</span> <span class="type">playerType</span>: player,
    <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">animateType</span>: monster <span class="keywd">is</span> NOBODY;
  <span class="keywd">begin</span>
    monster := currentRoom.roomer;
    fightState.monsterPresent := TRUE;
    fightState.bribed := FALSE;
    fightState.webCount := 0;
    fightState.aggressionOfMonster := 1 + ord(monster) <span class="op">div</span> 2;
    fightState.monsterStrength := ord(monster) + 2;
    <span class="keywd">if</span> monster = VENDOR <span class="op">and</span> <span class="op">not</span> fightState.angryVendors <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"You'll be sorry that you did that!"</span>);
      fightState.angryVendors := TRUE;
    <span class="keywd">else</span>
      writeln(<span class="stri">"You may attack or retreat."</span>);
      <span class="keywd">if</span> countOwnedTreasures(player) &lt;> 0 <span class="keywd">then</span>
        writeln(<span class="stri">"You can also attempt a bribe."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> player.intelligence >= 15 <span class="keywd">then</span>
        writeln(<span class="stri">"You can also cast a spell."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> (player.lethargic <span class="op">and</span> RUBY <span class="op">not</span> <span class="op">in</span> player.possession) <span class="op">or</span>
        player.blind <span class="op">or</span> player.dexterity &lt; rand(1, 18) <span class="keywd">then</span>
      fightState.monsterWillAttack := TRUE;
    <span class="keywd">else</span>
      fightState.monsterWillAttack := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># meetMonster</span>


<span class="keywd">const</span> <span class="type">proc</span>: retreatFromMonster (<span class="op">in</span> <span class="type">roomType</span>: currentRoom,
    <span class="keywd">inout</span> <span class="type">playerType</span>: player, <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">animateType</span>: monster <span class="keywd">is</span> NOBODY;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> fightState.monsterPresent <span class="keywd">then</span>
      <span class="keywd">if</span> <span class="op">not</span> fightState.bribed <span class="keywd">then</span>
        monster := currentRoom.roomer;
        monsterAttacks(monster, player, fightState);
        <span class="keywd">if</span> player.living <span class="keywd">then</span>
          writeln;
          <span class="keywd">case</span> rand(1, 7) <span class="keywd">of</span>
            <span class="keywd">when</span> {1}: writeln(<span class="stri">"You fake a blow and escape."</span>);
            <span class="keywd">when</span> {2}: writeln(<span class="stri">"You have escaped by turning and running."</span>);
            <span class="keywd">when</span> {3}: writeln(<span class="stri">"You jump to the left and escape to the right."</span>);
            <span class="keywd">when</span> {4}: writeln(<span class="stri">"What a furious trick. You escaped by doing nothing."</span>);
            <span class="keywd">when</span> {5}: writeln(<span class="stri">"The "</span> &lt;&amp; monster &lt;&amp; <span class="stri">" stumbled and you escaped."</span>);
            <span class="keywd">when</span> {6}: writeln(<span class="stri">"You escaped by jumping over the "</span> &lt;&amp; monster &lt;&amp; <span class="stri">"!"</span>);
            <span class="keywd">when</span> {7}: writeln(<span class="stri">"You are lucky, you have escaped because the "</span> &lt;&amp;
                              monster &lt;&amp; <span class="stri">" was diverted by a cry."</span>);
          <span class="keywd">end</span> <span class="keywd">case</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      fightState.monsterPresent := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># retreatFromMonster</span>


<span class="keywd">const</span> <span class="type">proc</span>: attack (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
    <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> currentRoom.roomer = NOBODY <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"** There is nothing that can be attacked!"</span>);
    <span class="keywd">else</span>
      fightState.bribed := FALSE;
      <span class="keywd">if</span> <span class="op">not</span> fightState.monsterPresent <span class="keywd">then</span>  <span class="comment"># attack VENDOR</span>
        meetMonster(currentRoom, player, fightState);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      attackMonster(currentRoom, player, fightState);
      fightState.monsterWillAttack := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># attack</span>


<span class="keywd">const</span> <span class="type">proc</span>: cast (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
    <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> currentRoom.roomer = NOBODY <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"** There is nothing that can be casted!"</span>);
    <span class="keywd">elsif</span> player.intelligence &lt; 15 <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"** Your intelligence must be 15 or more to cast a spell!"</span>);
    <span class="keywd">else</span>
      fightState.bribed := FALSE;
      <span class="keywd">if</span> <span class="op">not</span> fightState.monsterPresent <span class="keywd">then</span>  <span class="comment"># cast VENDOR</span>
        meetMonster(currentRoom, player, fightState);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      castSpell(currentRoom, player, fightState);
      fightState.monsterWillAttack := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># cast</span>


<span class="keywd">const</span> <span class="type">proc</span>: bribe (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
    <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> currentRoom.roomer = NOBODY <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"** There is nobody that can be bribed!"</span>);
    <span class="keywd">elsif</span> fightState.monsterPresent <span class="keywd">then</span>
      <span class="keywd">if</span> fightState.bribed <span class="keywd">then</span>
        writeln;
        writeln(<span class="stri">"I will not give you more than your life."</span>);
      <span class="keywd">else</span>
        bribeMonster(currentRoom, player, fightState);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      writeln;
      writeln(<span class="stri">"** That does not work."</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># bribe</span>


<span class="keywd">const</span> <span class="type">proc</span>: meetVendor (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom, <span class="op">in</span> <span class="type">playerType</span>: player,
    <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> fightState.angryVendors <span class="keywd">then</span>
      meetMonster(currentRoom, player, fightState);
    <span class="keywd">else</span>
      writeln(<span class="stri">"You may buy from, sell to, attack, or ignore the vendor."</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># meetVendor</span>


<span class="keywd">const</span> <span class="type">proc</span>: enterRoom (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
    <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    currentRoom.visited := TRUE;
    writeln;
    write(<span class="stri">"You are in "</span>);
    <span class="keywd">if</span> player.blind <span class="keywd">then</span>
      writeln(<span class="stri">"a new room."</span>);
    <span class="keywd">else</span>
      writeRoomDescription(currentRoom);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">case</span> currentRoom.transfer <span class="keywd">of</span>
      <span class="keywd">when</span> {NOTRANSFER}:
        writeRoomDetails(currentRoom);
        <span class="keywd">if</span> currentRoom.roomer = VENDOR <span class="keywd">then</span>
          meetVendor(currentRoom, player, fightState);
        <span class="keywd">elsif</span> currentRoom.roomer &lt;> NOBODY <span class="keywd">then</span>
          meetMonster(currentRoom, player, fightState);
        <span class="keywd">else</span>
          <span class="keywd">if</span> currentRoom.objects &lt;> objectSet.value <span class="keywd">then</span>
            writeln;
            <span class="keywd">if</span> card(currentRoom.objects) = 1 <span class="keywd">then</span>
              writeln(<span class="stri">"It's now yours!"</span>);
            <span class="keywd">else</span>
              writeln(<span class="stri">"They're yours now!"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            player.possession |:= currentRoom.objects;
            currentRoom.objects := objectSet.value;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {SINKHOLE}:
        <span class="keywd">case</span> roomId(currentRoom) <span class="op">rem</span> 5 <span class="keywd">of</span>
          <span class="keywd">when</span> {0}: writeln(<span class="stri">"Here you fall into a sinkhole."</span>);
          <span class="keywd">when</span> {1}: writeln(<span class="stri">"Here a trap-door opens under your feet and \
                            \you fall down."</span>);
          <span class="keywd">when</span> {2}: writeln(<span class="stri">"You have stepped into a pitfall."</span>);
          <span class="keywd">when</span> {3}: writeln(<span class="stri">"You step on an open trap-door and fall down."</span>);
          <span class="keywd">when</span> {4}: writeln(<span class="stri">"You fall into a hole hidden on the ground."</span>);
        <span class="keywd">end</span> <span class="keywd">case</span>;
        currentRoomRef := labyrinth[currentRoom.xPos]
                                   [currentRoom.yPos]
                                   [rangeLevel(succ(currentRoom.zPos))];
        enterRoom(currentRoomRef, player, fightState);
      <span class="keywd">when</span> {WARP}:
        write(<span class="stri">"This room contains a warp. You have been transferred to "</span>);
        currentRoomRef := labyrinth[rand(1, SIZE_LABY)]
                                   [rand(1, SIZE_LABY)]
                                   [rand(1, NUM_LEVELS)];
        writePos(currentRoomRef);
        enterRoom(currentRoomRef, player, fightState);
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># enterRoom</span>


<span class="keywd">const</span> <span class="type">proc</span>: readCoordinate (<span class="keywd">inout</span> <span class="type">playerType</span>: player, <span class="op">in</span> <span class="type">char</span>: coordname,
    <span class="keywd">inout</span> <span class="type">integer</span>: coordinate, <span class="op">in</span> <span class="type">integer</span>: coordinateMax) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> <span class="op">not</span> player.quitDialog <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        writeln;
        write(<span class="stri">"Please enter the "</span> &lt;&amp; coordname &lt;&amp; <span class="stri">"-coordinate? "</span>);
        readNumber(coordinate, okay, player.quitDialog);
        <span class="keywd">if</span> okay <span class="keywd">then</span>
          <span class="keywd">if</span> coordinate &lt; 1 <span class="op">or</span> coordinate > coordinateMax <span class="keywd">then</span>
            writeln;
            writeln(<span class="stri">"** Try a number from 1 to "</span> &lt;&amp; coordinateMax &lt;&amp; <span class="stri">"."</span>);
            okay := FALSE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> <span class="op">not</span> player.quitDialog <span class="keywd">then</span>
          writeln;
          writeln(<span class="stri">"** Would you please be so kind to type a digit, "</span> &lt;&amp;
                  player.species &lt;&amp; <span class="stri">"."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> okay <span class="op">or</span> player.quitDialog;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># readCoordinate</span>


<span class="keywd">const</span> <span class="type">proc</span>: teleportTo (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
    <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> ORBOFZOT <span class="op">in</span> currentRoom.objects <span class="keywd">then</span>
      excl(player.possession, RUNESTAFF);
      player.possession |:= currentRoom.objects;
      currentRoom.objects := objectSet.value;
      currentRoom.visited := TRUE;
      currentRoom.transfer := NOTRANSFER;
      enterRoom(currentRoom, player, fightState);
      writeln;
      writeln(<span class="stri">"Great unmitigated Zot!"</span>);
      writeln;
      writeln(<span class="stri">"You just found the *ORB OF ZOT*!"</span>);
      writeln;
      writeln(<span class="stri">"The Runestaff has disappeared!"</span>);
    <span class="keywd">else</span>
      enterRoom(currentRoom, player, fightState);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># teleportTo</span>


<span class="keywd">const</span> <span class="type">proc</span>: teleport (<span class="op">in</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
    <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: zPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> RUNESTAFF <span class="op">not</span> <span class="op">in</span> player.possession <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"** You can't teleport without the Runestaff!"</span>);
    <span class="keywd">else</span>
      player.quitDialog := FALSE;
      readCoordinate(player, <span class="stri">'x'</span>, xPos, SIZE_LABY);
      readCoordinate(player, <span class="stri">'y'</span>, yPos, SIZE_LABY);
      readCoordinate(player, <span class="stri">'z'</span>, zPos, NUM_LEVELS);
      <span class="keywd">if</span> player.quitDialog <span class="keywd">then</span>
        writeln;
        writeln(<span class="stri">"** The Runesaff needs three coordinates, "</span> &lt;&amp;
                player.species &lt;&amp; <span class="stri">"."</span>);
      <span class="keywd">else</span>
        fightState.monsterPresent := FALSE;
        currentRoomRef := labyrinth[xPos][yPos][zPos];
        teleportTo(currentRoomRef, player, fightState);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># teleport</span>


<span class="keywd">const</span> <span class="type">proc</span>: go (<span class="op">in</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
    <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState, <span class="op">in</span> <span class="type">directType</span>: direction) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">array</span> <span class="type">[</span>directType] <span class="type">integer</span>: delta_x <span class="keywd">is</span> [directType]( 0,  0,  1, -1,  0,  0);
    <span class="keywd">const</span> <span class="type">array</span> <span class="type">[</span>directType] <span class="type">integer</span>: delta_y <span class="keywd">is</span> [directType](-1,  1,  0,  0,  0,  0);
    <span class="keywd">const</span> <span class="type">array</span> <span class="type">[</span>directType] <span class="type">integer</span>: delta_z <span class="keywd">is</span> [directType]( 0,  0,  0,  0, -1,  1);
  <span class="keywd">begin</span>
    <span class="keywd">if</span> direction = NORTH <span class="op">and</span> currentRoom.contents = ENTRANCE <span class="keywd">then</span>
      writeln;
      write(<span class="stri">"Do you really want to leave the castle? "</span>);
      <span class="keywd">if</span> readChar() &lt;> <span class="stri">'Y'</span> <span class="keywd">then</span>
        writeln;
        writeln(<span class="stri">"** Then don't say that you do!"</span>);
      <span class="keywd">else</span>
        retreatFromMonster(currentRoom, player, fightState);
        player.leaveCastle := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> direction <span class="op">in</span> currentRoom.connections <span class="keywd">then</span>
      retreatFromMonster(currentRoom, player, fightState);
      <span class="keywd">if</span> player.living <span class="keywd">then</span>
        currentRoomRef := labyrinth
            [ rangeLaby(currentRoom.xPos + delta_x[direction])]
            [ rangeLaby(currentRoom.yPos + delta_y[direction])]
            [rangeLevel(currentRoom.zPos + delta_z[direction])];
        enterRoom(currentRoomRef, player, fightState);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      writeln;
      writeln(<span class="stri">"** There is no way in this direction!"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># go</span>


<span class="keywd">const</span> <span class="type">proc</span>: status (<span class="op">in</span> <span class="type">roomType</span>: currentRoom, <span class="op">in</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln;
    <span class="keywd">if</span> <span class="op">not</span> player.blind <span class="keywd">then</span>
      write(<span class="stri">"You are at "</span>);
      writePos(currentRoom);
      writeln;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(<span class="stri">"STRENGTH = "</span> &lt;&amp; player.strength &lt;&amp;
            <span class="stri">"  INTELLIGENCE = "</span> &lt;&amp; player.intelligence &lt;&amp;
            <span class="stri">"  DEXTERITY = "</span> &lt;&amp; player.dexterity);
    writeln(<span class="stri">"OBJECTS = "</span> &lt;&amp; countOwnedObjects(player) &lt;&amp;
            <span class="stri">"  FLARES = "</span> &lt;&amp; player.flares &lt;&amp;
            <span class="stri">"  GOLD PIECES = "</span> &lt;&amp; player.goldPieces);
    writeln(<span class="stri">"weapon = "</span> &lt;&amp; player.weapon &lt;&amp; <span class="stri">"  armor = "</span> &lt;&amp; player.armor);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># status</span>


<span class="keywd">const</span> <span class="type">proc</span>: listInventory (<span class="op">in</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: anythinglisted <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">objectType</span>: obj <span class="keywd">is</span> NOOBJECT;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> player.weapon &lt;> NOWEAPON <span class="keywd">then</span>
      anythinglisted := TRUE;
      writeln(<span class="stri">"  a "</span> &lt;&amp; player.weapon);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> player.armor &lt;> NOARMOR <span class="keywd">then</span>
      anythinglisted := TRUE;
      writeln(<span class="stri">"  "</span> &lt;&amp; player.armor &lt;&amp; <span class="stri">" armor"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> player.flares > 0 <span class="keywd">then</span>
      anythinglisted := TRUE;
      writeln(<span class="stri">"  "</span> &lt;&amp; numberName(player.flares) &lt;&amp; <span class="stri">" flare"</span> &lt;&amp;
              player.flares &lt;> 1 ? <span class="stri">"s"</span> : <span class="stri">""</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> player.goldPieces > 0 <span class="keywd">then</span>
      anythinglisted := TRUE;
      writeln(<span class="stri">"  "</span> &lt;&amp; numberName(player.goldPieces) &lt;&amp; <span class="stri">" gold piece"</span> &lt;&amp;
              player.goldPieces &lt;> 1 ? <span class="stri">"s"</span> : <span class="stri">""</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">for</span> obj <span class="keywd">range</span> player.possession <span class="keywd">do</span>
      anythinglisted := TRUE;
      writeln(<span class="stri">"  the "</span> &lt;&amp; obj);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> <span class="op">not</span> anythinglisted <span class="keywd">then</span>
      writeln(<span class="stri">"  nothing"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># listInventory</span>


<span class="keywd">const</span> <span class="type">proc</span>: inventory (<span class="op">in</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln;
    writeln(<span class="stri">"You have:"</span>);
    listInventory(player);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># inventory</span>


<span class="keywd">const</span> <span class="type">proc</span>: contentInfo (<span class="op">in</span> <span class="type">roomType</span>: currentRoom, <span class="op">in</span> <span class="type">roomType</span>: aRoom) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    write(aRoom.xPos = currentRoom.xPos <span class="op">and</span>
          aRoom.yPos = currentRoom.yPos ? <span class="stri">"&lt;"</span> : <span class="stri">" "</span>);
    <span class="keywd">if</span> aRoom.visited <span class="keywd">then</span>
      <span class="keywd">case</span> aRoom.transfer <span class="keywd">of</span>
        <span class="keywd">when</span> {NOTRANSFER}:
          <span class="keywd">if</span> aRoom.roomer = NOBODY <span class="keywd">then</span>
            <span class="keywd">if</span> aRoom.contents &lt;> EMPTYROOM <span class="keywd">then</span>
              <span class="keywd">case</span> aRoom.contents <span class="keywd">of</span>
                <span class="keywd">when</span> {ENTRANCE}:          write(<span class="stri">"E"</span>);
                <span class="keywd">when</span> {EMPTYCHEST}:        write(<span class="stri">"."</span>);
                <span class="keywd">when</span> {CHESTWITHSKELETON}: write(<span class="stri">"."</span>);
                <span class="keywd">when</span> {CLOSEDCHEST}:       write(<span class="stri">"C"</span>);
                <span class="keywd">when</span> {ORB}:               write(<span class="stri">"O"</span>);
                <span class="keywd">when</span> {POOL}:              write(<span class="stri">"P"</span>);
                <span class="keywd">when</span> {BOOK}:              write(<span class="stri">"B"</span>);
              <span class="keywd">end</span> <span class="keywd">case</span>;
            <span class="keywd">elsif</span> aRoom.objects &lt;> objectSet.value <span class="keywd">then</span>
              write(<span class="stri">"T"</span>);
            <span class="keywd">elsif</span> UP <span class="op">in</span> aRoom.connections <span class="keywd">then</span>
              write(<span class="stri">"U"</span>);
            <span class="keywd">elsif</span> DOWN <span class="op">in</span> aRoom.connections <span class="keywd">then</span>
              write(<span class="stri">"D"</span>);
            <span class="keywd">elsif</span> aRoom.occurrence = FINDFLARES <span class="keywd">then</span>
              write(<span class="stri">"F"</span>);
            <span class="keywd">elsif</span> aRoom.occurrence = FINDGOLD <span class="keywd">then</span>
              write(<span class="stri">"G"</span>);
            <span class="keywd">else</span>
              write(<span class="stri">"."</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> aRoom.roomer = VENDOR <span class="keywd">then</span>
            write(<span class="stri">"V"</span>);
          <span class="keywd">else</span>
            write(<span class="stri">"M"</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {SINKHOLE}: write(<span class="stri">"S"</span>);
        <span class="keywd">when</span> {WARP}:     write(<span class="stri">"W"</span>);
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">else</span>
      write(<span class="stri">" "</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    write(aRoom.xPos = currentRoom.xPos <span class="op">and</span>
          aRoom.yPos = currentRoom.yPos ? <span class="stri">">  "</span> : <span class="stri">"   "</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># contentInfo</span>


<span class="keywd">const</span> <span class="type">proc</span>: map (<span class="op">in</span> <span class="type">roomType</span>: currentRoom, <span class="op">in</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: zPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    writeln;
    <span class="keywd">if</span> player.blind <span class="keywd">then</span>
      writeln(<span class="stri">"** You are blind, you dumb "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">"!"</span>);
    <span class="keywd">else</span>
      zPos := currentRoom.zPos;
      <span class="keywd">for</span> yPos <span class="keywd">range</span> 1 <span class="keywd">to</span> SIZE_LABY <span class="keywd">do</span>
        <span class="keywd">for</span> xPos <span class="keywd">range</span> 1 <span class="keywd">to</span> SIZE_LABY <span class="keywd">do</span>
          contentInfo(currentRoom, labyrinth[xPos][yPos][zPos]);
        <span class="keywd">end</span> <span class="keywd">for</span>;
        writeln;
        writeln;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      write(<span class="stri">"You are at "</span>);
      writePos(currentRoom);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># map</span>


<span class="keywd">const</span> <span class="type">proc</span>: flare (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: x <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: y <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: zPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    writeln;
    <span class="keywd">if</span> player.flares = 0 <span class="keywd">then</span>
      writeln(<span class="stri">"** Hey, bright one, you're out of flares!"</span>);
    <span class="keywd">elsif</span> player.blind <span class="keywd">then</span>
      writeln(<span class="stri">"** You can't see anything, you dumb "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">"!"</span>);
    <span class="keywd">else</span>
      decr(player.flares);
      zPos := currentRoom.zPos;
      <span class="keywd">for</span> y <span class="keywd">range</span> pred(currentRoom.yPos) <span class="keywd">to</span> succ(currentRoom.yPos) <span class="keywd">do</span>
        yPos := rangeLaby(y);
        <span class="keywd">for</span> x <span class="keywd">range</span> pred(currentRoom.xPos) <span class="keywd">to</span> succ(currentRoom.xPos) <span class="keywd">do</span>
          xPos := rangeLaby(x);
          labyrinth[xPos][yPos][zPos].visited := TRUE;
          contentInfo(currentRoom, labyrinth[xPos][yPos][zPos]);
        <span class="keywd">end</span> <span class="keywd">for</span>;
        writeln;
        writeln;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      write(<span class="stri">"You are at "</span>);
      writePos(currentRoom);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># flare</span>


<span class="keywd">const</span> <span class="type">proc</span>: shineIntoRoom (<span class="keywd">inout</span> <span class="type">roomType</span>: aRoom) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    aRoom.visited := TRUE;
    writeln;
    write(<span class="stri">"The lamp shines into a room at "</span>);
    writePos(aRoom);
    write(<span class="stri">"You see "</span>);
    writeRoomDescription(aRoom);
    writeRoomDetails(aRoom);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># shineIntoRoom</span>


<span class="keywd">const</span> <span class="type">proc</span>: lamp (<span class="op">in</span> <span class="type">roomType</span>: currentRoom, <span class="op">in</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: zPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    writeln;
    <span class="keywd">if</span> LAMP <span class="op">not</span> <span class="op">in</span> player.possession <span class="keywd">then</span>
      writeln(<span class="stri">"** You don't have a lamp, "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">"!"</span>);
    <span class="keywd">elsif</span> player.blind <span class="keywd">then</span>
      writeln(<span class="stri">"** You are blind, you dumb "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">"!"</span>);
    <span class="keywd">else</span>
      write(<span class="stri">"Where do you want to shine the lamp (N, S, E, W)? "</span>);
      ch := readChar();
      <span class="keywd">if</span> <span class="op">not</span> ch <span class="op">in</span> {<span class="stri">'N'</span>, <span class="stri">'S'</span>, <span class="stri">'E'</span>, <span class="stri">'W'</span>} <span class="keywd">then</span>
        writeln;
        writeln(<span class="stri">"** That's not a direction, "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">"!"</span>);
      <span class="keywd">else</span>
        xPos := currentRoom.xPos;
        yPos := currentRoom.yPos;
        zPos := currentRoom.zPos;
        <span class="keywd">case</span> ch <span class="keywd">of</span>
          <span class="keywd">when</span> {<span class="stri">'N'</span>}: yPos := rangeLaby(pred(yPos));
          <span class="keywd">when</span> {<span class="stri">'S'</span>}: yPos := rangeLaby(succ(yPos));
          <span class="keywd">when</span> {<span class="stri">'W'</span>}: xPos := rangeLaby(pred(xPos));
          <span class="keywd">when</span> {<span class="stri">'E'</span>}: xPos := rangeLaby(succ(xPos));
        <span class="keywd">end</span> <span class="keywd">case</span>;
        shineIntoRoom(labyrinth[xPos][yPos][zPos]);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># lamp</span>


<span class="keywd">const</span> <span class="type">proc</span>: drink (<span class="op">in</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">speciesType</span>: newSpecies <span class="keywd">is</span> HUMAN;
  <span class="keywd">begin</span>
    writeln;
    <span class="keywd">if</span> currentRoom.contents &lt;> POOL <span class="keywd">then</span>
      writeln(<span class="stri">"** If you want a drink, find a pool!"</span>);
    <span class="keywd">else</span>
      write(<span class="stri">"You take a drink and "</span>);
      <span class="keywd">case</span> rand(1, 8) <span class="keywd">of</span>

        <span class="keywd">when</span> {1}:
          player.strength := range18(player.strength + rand(1, 3));
          writeln(<span class="stri">"feel stronger."</span>);

        <span class="keywd">when</span> {2}:
          player.strength -:= rand(1, 3);
          writeln(<span class="stri">"feel weaker."</span>);
          player.living := player.strength >= 1 ;

        <span class="keywd">when</span> {3}:
          player.intelligence := range18(player.intelligence + rand(1, 3));
          writeln(<span class="stri">"feel smarter."</span>);

        <span class="keywd">when</span> {4}:
          player.intelligence -:= rand(1, 3);
          writeln(<span class="stri">"feel dumber."</span>);
          player.living := player.intelligence >= 1;

        <span class="keywd">when</span> {5}:
          player.dexterity := range18(player.dexterity + rand(1, 3));
          writeln(<span class="stri">"feel nimbler."</span>);

        <span class="keywd">when</span> {6}:
          player.dexterity -:= rand(1, 3);
          writeln(<span class="stri">"feel clumsier."</span>);
          player.living := player.dexterity >= 1;

        <span class="keywd">when</span> {7}:
          newSpecies := rand(speciesType.first, pred(speciesType.last));
          <span class="keywd">if</span> newSpecies >= player.species <span class="keywd">then</span>
            incr(newSpecies);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          player.species := newSpecies;
          writeln(<span class="stri">"become "</span> &lt;&amp; aOrAn(player.species) &lt;&amp; <span class="stri">"."</span>);

        <span class="keywd">when</span> {8}:
          player.isMale := <span class="op">not</span> player.isMale;
          writeln(<span class="stri">"turn into a "</span> &lt;&amp; sexName(player.isMale) &lt;&amp;
                  <span class="stri">" "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">"."</span>);
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># drink</span>


<span class="keywd">const</span> <span class="type">proc</span>: read (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln;
    <span class="keywd">if</span> currentRoom.contents &lt;> BOOK <span class="keywd">then</span>
      writeln(<span class="stri">"** There is nothing that can be read!"</span>);
    <span class="keywd">elsif</span> player.blind <span class="keywd">then</span>
      writeln(<span class="stri">"** You are blind, you dumb "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">"!"</span>);
    <span class="keywd">else</span>
      writeln(<span class="stri">"You open the book and"</span>);
      <span class="keywd">case</span> rand(1, 6) <span class="keywd">of</span>

        <span class="keywd">when</span> {1}:
          writeln(<span class="stri">"Flash! Oh no! You are now a blind "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">"!"</span>);
          player.blind := TRUE;

        <span class="keywd">when</span> {2}:
          <span class="keywd">case</span> rand(1, 4) <span class="keywd">of</span>
            <span class="keywd">when</span> {1}: writeln(<span class="stri">"It's another volume of Zot's poetry. - YECH!!"</span>);
            <span class="keywd">when</span> {2}: writeln(<span class="stri">"It's a manual of this game."</span>);
            <span class="keywd">when</span> {3}: writeln(<span class="stri">"It's a story about a dumb "</span> &lt;&amp; player.species &lt;&amp;
                              <span class="stri">" who finds a book and then dies."</span>);
            <span class="keywd">when</span> {4}: writeln(<span class="stri">"It's volume number "</span> &lt;&amp;
                              numberName(rand(1, 20)) &lt;&amp; <span class="stri">" of a novel."</span>);
          <span class="keywd">end</span> <span class="keywd">case</span>;

        <span class="keywd">when</span> {3}:
          writeln(<span class="stri">"It's an old copy of play "</span> &lt;&amp; rand(speciesType) &lt;&amp; <span class="stri">"."</span>);

        <span class="keywd">when</span> {4}:
          writeln(<span class="stri">"It's a manual of dexterity!"</span>);
          player.dexterity := 18;

        <span class="keywd">when</span> {5}:
          writeln(<span class="stri">"It's a manual of strength!"</span>);
          player.strength := 18;

        <span class="keywd">when</span> {6}:
          writeln(<span class="stri">"The book sticks to your hands -"</span>);
          writeln(<span class="stri">"Now you are unable to draw your weapon!"</span>);
          player.weaponBlocked := TRUE;
      <span class="keywd">end</span> <span class="keywd">case</span>;
      currentRoom.contents := EMPTYROOM;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># read</span>


<span class="keywd">const</span> <span class="type">proc</span>: viewRoomWithOrb (<span class="keywd">inout</span> <span class="type">roomType</span>: aRoom) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    aRoom.visited := TRUE;
    writeRoomDescription(aRoom);
    writeConnections(aRoom);
    write(<span class="stri">"You can also see that this room is at "</span>);
    writePos(aRoom);
    writeAnimates(aRoom);
    writeObjects(aRoom);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># viewRoomWithOrb</span>


<span class="keywd">const</span> <span class="type">proc</span>: gazeIntoOrb (<span class="keywd">inout</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    write(<span class="stri">"You see "</span>);
    <span class="keywd">case</span> rand(1, 6) <span class="keywd">of</span>

      <span class="keywd">when</span> {1}:
        <span class="keywd">case</span> rand(1, 10) <span class="keywd">of</span>
          <span class="keywd">when</span> { 1}: writeln(<span class="stri">"your own burial!"</span>);
          <span class="keywd">when</span> { 2}: writeln(<span class="stri">"your mouldering dead body!"</span>);
          <span class="keywd">when</span> { 3}: writeln(<span class="stri">"yourself in a bloody heap!"</span>);
          <span class="keywd">when</span> { 4}: writeln(<span class="stri">"yourself with your skull bashed in!"</span>);
          <span class="keywd">when</span> { 5}: writeln(<span class="stri">"your broken skeleton lying on the ground!"</span>);
          <span class="keywd">when</span> { 6}: writeln(<span class="stri">"a graveyard and a tombstone with your name!"</span>);
          <span class="keywd">when</span> { 7}: writeln(aOrAn(rand(animateType)) &lt;&amp; <span class="stri">" killing you!"</span>);
          <span class="keywd">when</span> { 8}: writeln(aOrAn(rand(speciesType)) &lt;&amp;
                            <span class="stri">" finding your faded bones!"</span>);
          <span class="keywd">when</span> { 9}: writeln(aOrAn(rand(speciesType)) &lt;&amp; <span class="stri">" which tells "</span> &lt;&amp;
                            aOrAn(rand(speciesType)) &lt;&amp; <span class="stri">" that you are dead!"</span>);
          <span class="keywd">when</span> {10}: writeln(<span class="stri">"a "</span> &lt;&amp; sexName(<span class="op">not</span> player.isMale) &lt;&amp;
                             <span class="stri">" "</span> &lt;&amp; player.species &lt;&amp;
                             <span class="stri">" giving flowers on your grave!"</span>);
        <span class="keywd">end</span> <span class="keywd">case</span>;
        decr(player.strength);
        write(<span class="stri">"This message makes you weaker. Your strength is now "</span>);
        <span class="keywd">if</span> player.strength &lt; 1 <span class="keywd">then</span>
          player.living := FALSE;
          writeln(<span class="stri">"zero!"</span>);
        <span class="keywd">else</span>
          writeln(numberName(player.strength) &lt;&amp; <span class="stri">"."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;

      <span class="keywd">when</span> {2}:
        <span class="keywd">case</span> rand(1, 4) <span class="keywd">of</span>
          <span class="keywd">when</span> {1}: writeln(<span class="stri">"yourself drinking from a pool and becoming "</span> &lt;&amp;
                            aOrAn(rand(animateType)) &lt;&amp; <span class="stri">"!"</span>);
          <span class="keywd">when</span> {2}: writeln(aOrAn(rand(animateType)) &lt;&amp;
                            <span class="stri">" drinking from a pool and becoming "</span> &lt;&amp;
                            aOrAn(rand(speciesType)) &lt;&amp; <span class="stri">"."</span>);
          <span class="keywd">when</span> {3}: writeln(aOrAn(rand(speciesType)) &lt;&amp;
                            <span class="stri">" drinking from a pool and becoming "</span> &lt;&amp;
                            anyAdjective() &lt;&amp; <span class="stri">" spider."</span>);
          <span class="keywd">when</span> {4}: writeln(<span class="stri">"a young "</span> &lt;&amp; rand(FALSE, TRUE) ? <span class="stri">"man"</span> : <span class="stri">"woman"</span> &lt;&amp;
                            <span class="stri">" drinking from a pool and becoming as old \
                            \as the hills."</span>);
        <span class="keywd">end</span> <span class="keywd">case</span>;

      <span class="keywd">when</span> {3}:
        <span class="keywd">case</span> rand(1, 2) <span class="keywd">of</span>
          <span class="keywd">when</span> {1}: writeln(aOrAn(rand(animateType)) &lt;&amp;
                            <span class="stri">" gazing back at you."</span>);
          <span class="keywd">when</span> {2}: writeln(<span class="stri">"that you are watched from "</span> &lt;&amp;
                            aOrAn(rand(speciesType)) &lt;&amp; <span class="stri">"."</span>);
        <span class="keywd">end</span> <span class="keywd">case</span>;

      <span class="keywd">when</span> {4}:
        viewRoomWithOrb(labyrinth[rand(1, SIZE_LABY)]
                                 [rand(1, SIZE_LABY)]
                                 [rand(1, NUM_LEVELS)]);

      <span class="keywd">when</span> {5}:
        write(<span class="stri">"the *ORB OF ZOT* at "</span>);
        <span class="keywd">if</span> rand(FALSE, TRUE) <span class="keywd">then</span>
          writePos(objPlace[ORBOFZOT]);
        <span class="keywd">else</span>
          writePos(labyrinth[rand(1, SIZE_LABY)]
                            [rand(1, SIZE_LABY)]
                            [rand(1, NUM_LEVELS)]);
        <span class="keywd">end</span> <span class="keywd">if</span>;

      <span class="keywd">when</span> {6}:
        <span class="keywd">case</span> rand(1, 10) <span class="keywd">of</span>
          <span class="keywd">when</span> { 1}: writeln(<span class="stri">"a soap opera rerun."</span>);
          <span class="keywd">when</span> { 2}: writeln(<span class="stri">"a washing powder commercial."</span>);
          <span class="keywd">when</span> { 3}: writeln(<span class="stri">"an image to test the reception of the orb."</span>);
          <span class="keywd">when</span> { 4}: writeln(<span class="stri">"somebody sitting at a computer playing this game."</span>);
          <span class="keywd">when</span> { 5}: writeln(<span class="stri">"nothing because in the moment there are atmospherics."</span>);
          <span class="keywd">when</span> { 6}: writeln(<span class="stri">"a scientist demonstrating that an orb could never work."</span>);
          <span class="keywd">when</span> { 7}: writeln(<span class="stri">"the presentation of the new generation of orb's with sound."</span>);
          <span class="keywd">when</span> { 8}: writeln(<span class="stri">"that there is a 50% chance that what you see in an orb is correct."</span>);
          <span class="keywd">when</span> { 9}: writeln(<span class="stri">"yourself looking into an orb where you see yourself looking into ..."</span>);
          <span class="keywd">when</span> {10}: writeln(aOrAn(rand(speciesType)) &lt;&amp;
                             <span class="stri">" announcing todays program of the orb."</span>);
        <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># gazeIntoOrb</span>


<span class="keywd">const</span> <span class="type">proc</span>: gaze (<span class="op">in</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
    <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln;
    <span class="keywd">if</span> player.blind <span class="keywd">then</span>
      writeln(<span class="stri">"** You can't see anything, you dumb "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">"!"</span>);
    <span class="keywd">elsif</span> currentRoom.roomer = NOBODY <span class="keywd">then</span>
      <span class="keywd">case</span> currentRoom.contents <span class="keywd">of</span>
        <span class="keywd">when</span> {EMPTYROOM}:         writeln(<span class="stri">"You are gazing at an empty wall."</span>);
        <span class="keywd">when</span> {ENTRANCE}:          writeln(<span class="stri">"You are gazing at the exit."</span>);
        <span class="keywd">when</span> {EMPTYCHEST}:        writeln(<span class="stri">"The chest does not fill with gazing at."</span>);
        <span class="keywd">when</span> {CHESTWITHSKELETON}: writeln(<span class="stri">"The skeleton looks horrible."</span>);
        <span class="keywd">when</span> {CLOSEDCHEST}:       writeln(<span class="stri">"The chest does not open with gazing at."</span>);
        <span class="keywd">when</span> {POOL}:              writeln(<span class="stri">"You see your ugly face mirror in the water."</span>);
        <span class="keywd">when</span> {BOOK}:              writeln(<span class="stri">"You are gazing at the book."</span>);
        <span class="keywd">when</span> {ORB}:               gazeIntoOrb(player);
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">elsif</span> currentRoom.roomer = VENDOR <span class="keywd">then</span>
      write(<span class="stri">"You are gazing at the Vendor. "</span>);
      <span class="keywd">if</span> player.isMale <span class="keywd">then</span>
        writeln(<span class="stri">"But the Vendor does not like male "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">"."</span>);
      <span class="keywd">else</span>
        writeln(<span class="stri">"The Vendor smiles and shows his wedding-ring."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      write(<span class="stri">"The "</span> &lt;&amp; currentRoom.roomer);
      <span class="keywd">if</span> player.isMale <span class="keywd">then</span>
        writeln(<span class="stri">" is shocked by the scowl of a strong male "</span> &lt;&amp;
                player.species &lt;&amp; <span class="stri">"."</span>);
        fightState.monsterWillAttack := FALSE;
      <span class="keywd">else</span>
        writeln(<span class="stri">" cannot be shocked by the scowl of a female "</span> &lt;&amp;
                player.species &lt;&amp; <span class="stri">"."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># gaze</span>


<span class="keywd">const</span> <span class="type">proc</span>: openChest (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
  <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">directType</span>: direct <span class="keywd">is</span> NORTH;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> currentRoom.roomer &lt;> NOBODY <span class="keywd">then</span>
      writeln(<span class="stri">"The "</span> &lt;&amp; currentRoom.roomer &lt;&amp;
              <span class="stri">" does not allow to open the chest."</span>);
    <span class="keywd">else</span>
      write(<span class="stri">"You open the chest and "</span>);
      <span class="keywd">case</span> rand(1, 2) <span class="keywd">of</span>

        <span class="keywd">when</span> {1}:
          write(<span class="stri">"find "</span>);
          findGoldPieces(player, 99);
          currentRoom.contents := EMPTYCHEST;

        <span class="keywd">when</span> {2}:
          <span class="keywd">case</span> rand(1, 7) <span class="keywd">of</span>

            <span class="keywd">when</span> {1}:
              writeln(<span class="stri">"it is totally empty."</span>);
              currentRoom.contents := EMPTYCHEST;

            <span class="keywd">when</span> {2}:
              writeln(<span class="stri">"it disappears in the moment you open it."</span>);
              currentRoom.contents := EMPTYROOM;

            <span class="keywd">when</span> {3}:
              writeln(<span class="stri">"...  KABOOOM!  It explodes!!"</span>);
              checkArmor(player, rand(1, 6));
              player.living := player.strength >= 1;
              currentRoom.contents := EMPTYROOM;

            <span class="keywd">when</span> {4}:
              player.turns +:= 20;
              direct := rand(currentRoom.connections - {UP, DOWN});
              writeln(<span class="stri">"...  GAS!!  You stagger from the room to the "</span> &lt;&amp;
                      direct &lt;&amp; <span class="stri">"!"</span>);
              currentRoom.contents := EMPTYCHEST;
              go(currentRoom, player, fightState, direct);

            <span class="keywd">when</span> {5}:
              writeln(<span class="stri">"find "</span> &lt;&amp; anyAdjective() &lt;&amp; <span class="stri">" skeleton."</span>);
              writeln(<span class="stri">"It seems that this "</span> &lt;&amp; rand(speciesType) &lt;&amp;
                      <span class="stri">" was also an adventurer."</span>);
              currentRoom.contents := CHESTWITHSKELETON;

            <span class="keywd">when</span> {6}:
              write(<span class="stri">"find "</span>);
              findFlares(player, 4);
              currentRoom.contents := EMPTYCHEST;

            <span class="keywd">when</span> {7}:
              <span class="keywd">if</span> player.armor = NOARMOR <span class="keywd">then</span>
                player.armor := LEATHER;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              writeln(<span class="stri">"find a brand new "</span> &lt;&amp; player.armor &lt;&amp; <span class="stri">" armor."</span>);
              player.armorStrength := ord(player.armor) * ARMOR_STRENGTH_FACTOR;
              currentRoom.contents := EMPTYCHEST;
          <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># openChest</span>


<span class="keywd">const</span> <span class="type">proc</span>: open (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
    <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln;
    <span class="keywd">if</span> currentRoom.contents &lt;> CLOSEDCHEST <span class="keywd">then</span>
      writeln(<span class="stri">"** The only thing opened, was your big mouth!"</span>);
    <span class="keywd">else</span>
      openChest(currentRoom, player, fightState);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># open</span>


<span class="keywd">const</span> <span class="type">proc</span>: quit (<span class="keywd">inout</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln;
    write(<span class="stri">"Do you really want to quit now? "</span>);
    <span class="keywd">if</span> readChar() &lt;> <span class="stri">'Y'</span> <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"** Then don't say that you do!"</span>);
    <span class="keywd">else</span>
      player.quitProgram := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># quit</span>


<span class="keywd">const</span> <span class="type">proc</span>: wait <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln;
    writeln(<span class="stri">"Waiting ..."</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># wait</span>


<span class="keywd">const</span> <span class="type">proc</span>: illegal (<span class="op">in</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln;
    writeln(<span class="stri">"** Silly "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">", that wasn't a valid command!"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># illegal</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">commandType</span>: readCommand <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">commandType</span>: currentCommand <span class="keywd">is</span> ILLEGAL;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">char</span>: ch1 <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">char</span>: ch2 <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    writeln;
    write(<span class="stri">" -> "</span>);
    stri := upper(getln(IN));
    <span class="keywd">if</span> stri = <span class="stri">""</span> <span class="keywd">then</span>
      currentCommand := WAIT;
    <span class="keywd">else</span>
      ch1 := stri[1];
      <span class="keywd">if</span> length(stri) >= 2 <span class="keywd">then</span>
        ch2 := stri[2];
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">case</span> ch1 <span class="keywd">of</span>
        <span class="keywd">when</span> {<span class="stri">'A'</span>}: currentCommand := ATTACK;
        <span class="keywd">when</span> {<span class="stri">'B'</span>}: <span class="keywd">if</span> ch2 = <span class="stri">' '</span> <span class="op">or</span> ch2 = <span class="stri">'U'</span> <span class="keywd">then</span>
                      currentCommand := BUY;
                    <span class="keywd">elsif</span> ch2 = <span class="stri">'R'</span> <span class="keywd">then</span>
                      currentCommand := BRIBE;
                    <span class="keywd">else</span>
                      currentCommand := ILLEGAL;
                    <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'C'</span>}: currentCommand := CAST;
        <span class="keywd">when</span> {<span class="stri">'D'</span>}: <span class="keywd">if</span> ch2 = <span class="stri">' '</span> <span class="op">or</span> ch2 = <span class="stri">'O'</span> <span class="keywd">then</span>
                      currentCommand := GO_DOWN;
                    <span class="keywd">elsif</span> ch2 = <span class="stri">'R'</span> <span class="keywd">then</span>
                      currentCommand := DRINK;
                    <span class="keywd">else</span>
                      currentCommand := ILLEGAL;
                    <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'E'</span>}: currentCommand := GO_EAST;
        <span class="keywd">when</span> {<span class="stri">'F'</span>}: currentCommand := FLARE;
        <span class="keywd">when</span> {<span class="stri">'G'</span>}: currentCommand := GAZE;
        <span class="keywd">when</span> {<span class="stri">'H'</span>}: currentCommand := HELP;
        <span class="keywd">when</span> {<span class="stri">'I'</span>}: currentCommand := INVENTORY;
        <span class="keywd">when</span> {<span class="stri">'L'</span>}: <span class="keywd">if</span> ch2 = <span class="stri">' '</span> <span class="op">or</span> ch2 = <span class="stri">'O'</span> <span class="keywd">then</span>
                      currentCommand := LOOK;
                    <span class="keywd">elsif</span> ch2 = <span class="stri">'A'</span> <span class="keywd">then</span>
                      currentCommand := USE_LAMP;
                    <span class="keywd">else</span>
                      currentCommand := ILLEGAL;
                    <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'M'</span>}: currentCommand := MAP;
        <span class="keywd">when</span> {<span class="stri">'N'</span>}: currentCommand := GO_NORTH;
        <span class="keywd">when</span> {<span class="stri">'O'</span>}: currentCommand := OPEN;
        <span class="keywd">when</span> {<span class="stri">'Q'</span>}: currentCommand := QUITCOMMAND;
        <span class="keywd">when</span> {<span class="stri">'R'</span>}: currentCommand := READ;
        <span class="keywd">when</span> {<span class="stri">'S'</span>}: <span class="keywd">if</span> ch2 = <span class="stri">' '</span> <span class="op">or</span> ch2 = <span class="stri">'O'</span> <span class="keywd">then</span>
                      currentCommand := GO_SOUTH;
                    <span class="keywd">elsif</span> ch2 = <span class="stri">'T'</span> <span class="keywd">then</span>
                      currentCommand := STATUS;
                    <span class="keywd">elsif</span> ch2 = <span class="stri">'E'</span> <span class="keywd">then</span>
                      currentCommand := SELL;
                    <span class="keywd">else</span>
                      currentCommand := ILLEGAL;
                    <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'T'</span>}: currentCommand := TELEPORT;
        <span class="keywd">when</span> {<span class="stri">'U'</span>}: currentCommand := GO_UP;
        <span class="keywd">when</span> {<span class="stri">'W'</span>}: currentCommand := GO_WEST;
        <span class="keywd">otherwise</span>:  currentCommand := ILLEGAL;
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># readCommand</span>


<span class="keywd">const</span> <span class="type">proc</span>: executeCommand (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom,
    <span class="keywd">inout</span> <span class="type">playerType</span>: player, <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">case</span> readCommand() <span class="keywd">of</span>
      <span class="keywd">when</span> {GO_NORTH}:    go(currentRoom, player, fightState, NORTH);
      <span class="keywd">when</span> {GO_SOUTH}:    go(currentRoom, player, fightState, SOUTH);
      <span class="keywd">when</span> {GO_EAST}:     go(currentRoom, player, fightState, EAST);
      <span class="keywd">when</span> {GO_WEST}:     go(currentRoom, player, fightState, WEST);
      <span class="keywd">when</span> {GO_UP}:       go(currentRoom, player, fightState, UP);
      <span class="keywd">when</span> {GO_DOWN}:     go(currentRoom, player, fightState, DOWN);
      <span class="keywd">when</span> {WAIT}:        wait;
      <span class="keywd">when</span> {INVENTORY}:   inventory(player);
      <span class="keywd">when</span> {HELP}:        writeHelp;
      <span class="keywd">when</span> {LOOK}:        look(currentRoom, player);
      <span class="keywd">when</span> {MAP}:         map(currentRoom, player);
      <span class="keywd">when</span> {FLARE}:       flare(currentRoom, player);
      <span class="keywd">when</span> {USE_LAMP}:    lamp(currentRoom, player);
      <span class="keywd">when</span> {ATTACK}:      attack(currentRoom, player, fightState);
      <span class="keywd">when</span> {CAST}:        cast(currentRoom, player, fightState);
      <span class="keywd">when</span> {BRIBE}:       bribe(currentRoom, player, fightState);
      <span class="keywd">when</span> {STATUS}:      status(currentRoom, player);
      <span class="keywd">when</span> {OPEN}:        open(currentRoom, player, fightState);
      <span class="keywd">when</span> {READ}:        read(currentRoom, player);
      <span class="keywd">when</span> {GAZE}:        gaze(currentRoom, player, fightState);
      <span class="keywd">when</span> {TELEPORT}:    teleport(currentRoom, player, fightState);
      <span class="keywd">when</span> {DRINK}:       drink(currentRoom, player);
      <span class="keywd">when</span> {SELL}:        sell(currentRoom, player);
      <span class="keywd">when</span> {BUY}:         buy(currentRoom, player);
      <span class="keywd">when</span> {QUITCOMMAND}: quit(player);
      <span class="keywd">otherwise</span>:          illegal(player);
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># executeCommand</span>


<span class="keywd">const</span> <span class="type">proc</span>: writeFightState (<span class="op">in</span> <span class="type">roomType</span>: currentRoom, <span class="keywd">inout</span> <span class="type">playerType</span>: player,
    <span class="keywd">inout</span> <span class="type">fightStateType</span>: fightState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">animateType</span>: monster <span class="keywd">is</span> NOBODY;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> fightState.monsterPresent <span class="op">and</span> <span class="op">not</span> fightState.bribed <span class="op">and</span>
        player.living <span class="op">and</span> <span class="op">not</span> player.quitProgram <span class="keywd">then</span>
      monster := currentRoom.roomer;
      <span class="keywd">if</span> fightState.monsterWillAttack <span class="keywd">then</span>
        monsterAttacks(monster, player, fightState);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      fightState.monsterWillAttack := TRUE;
      <span class="keywd">if</span> player.living <span class="keywd">then</span>
        writeln;
        writeln(<span class="stri">"You're facing "</span> &lt;&amp; aOrAn(monster) &lt;&amp; <span class="stri">"!"</span>);
        writeln(<span class="stri">"Your strength is "</span> &lt;&amp; player.strength &lt;&amp;
                <span class="stri">" and your dexterity is "</span> &lt;&amp; player.dexterity &lt;&amp; <span class="stri">"."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># writeFightState</span>


<span class="keywd">const</span> <span class="type">proc</span>: incident (<span class="keywd">inout</span> <span class="type">roomType</span>: currentRoom,
    <span class="keywd">inout</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">objectType</span>: treasure <span class="keywd">is</span> NOOBJECT;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> PEARL <span class="op">not</span> <span class="op">in</span> player.possession <span class="keywd">then</span>
      <span class="keywd">if</span> currentRoom.occurrence = LEECH <span class="keywd">then</span>
        writeln(<span class="stri">"You pocket has a leetch. Now you will lose gold pieces."</span>);
        currentRoom.occurrence := NOOCCURRENCE;
        player.haveLeech := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> player.haveLeech <span class="keywd">then</span>
        player.goldPieces -:= rand(1, 3);
        <span class="keywd">if</span> player.goldPieces &lt; 0 <span class="keywd">then</span>
          player.goldPieces := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> RUBY <span class="op">not</span> <span class="op">in</span> player.possession <span class="keywd">then</span>
      <span class="keywd">if</span> currentRoom.occurrence = LETHARGY <span class="keywd">then</span>
        writeln(<span class="stri">"You feel that you are lethargic now."</span>);
        currentRoom.occurrence := NOOCCURRENCE;
        player.lethargic := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> player.lethargic <span class="keywd">then</span>
        incr(player.turns);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> GREENGEM <span class="op">not</span> <span class="op">in</span> player.possession <span class="keywd">then</span>
      <span class="keywd">if</span> currentRoom.occurrence = FORGET <span class="keywd">then</span>
        writeln(<span class="stri">"You see a lot of strange signs on the ground, possibly runes."</span>);
        writeln(<span class="stri">"You try to read them, but you found no sense."</span>);
        writeln(<span class="stri">"You feel that the runes force you to forget the map of the castle."</span>);
        currentRoom.occurrence := NOOCCURRENCE;
        player.forgetting := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> player.forgetting <span class="keywd">then</span>
        labyrinth[rand(1, SIZE_LABY)]
                 [rand(1, SIZE_LABY)]
                 [rand(1, NUM_LEVELS)].visited := FALSE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> player.armor &lt;> NOARMOR <span class="op">and</span> currentRoom.occurrence = STEALARMOR <span class="keywd">then</span>
      writeln(<span class="stri">"You are knocked down from behind and somebody steals your "</span> &lt;&amp;
              player.armor &lt;&amp; <span class="stri">" armor."</span>);
      currentRoom.occurrence := NOOCCURRENCE;
      player.armor := NOARMOR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> player.weapon &lt;> NOWEAPON <span class="op">and</span> currentRoom.occurrence = STEALWEAPON <span class="keywd">then</span>
      writeln(<span class="stri">"You realize that somebody has stolen your "</span> &lt;&amp; player.weapon &lt;&amp; <span class="stri">"."</span>);
      currentRoom.occurrence := NOOCCURRENCE;
      player.weapon := NOWEAPON;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> LAMP <span class="op">in</span> player.possession <span class="op">and</span> currentRoom.occurrence = STEALLAMP <span class="keywd">then</span>
      writeln(<span class="stri">"You realize that somebody has stolen your lamp."</span>);
      currentRoom.occurrence := NOOCCURRENCE;
      excl(player.possession, LAMP);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> player.flares &lt;> 0 <span class="op">and</span> currentRoom.occurrence = STEALFLARES <span class="keywd">then</span>
      writeln(<span class="stri">"You realize that somebody has stolen all your flares."</span>);
      currentRoom.occurrence := NOOCCURRENCE;
      player.flares := 0;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> currentRoom.occurrence = STEALTREASURE <span class="keywd">then</span>
      <span class="keywd">if</span> countOwnedTreasures(player) &lt;> 0 <span class="keywd">then</span>
        treasure := ownedTreasure(player);
        writeln(<span class="stri">"You realize that somebody has stolen the "</span> &lt;&amp; treasure &lt;&amp; <span class="stri">"."</span>);
        currentRoom.occurrence := NOOCCURRENCE;
        excl(player.possession, treasure);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> currentRoom.occurrence = FINDGOLD <span class="keywd">then</span>
      <span class="keywd">if</span> currentRoom.roomer = NOBODY <span class="keywd">then</span>
        write(<span class="stri">"Here you find "</span>);
        findGoldPieces(player, 10);
      <span class="keywd">else</span>
        writeln(<span class="stri">"Here are "</span> &lt;&amp; numberName(rand(2, 11)) &lt;&amp;
                <span class="stri">" GP'S. But the "</span> &lt;&amp; currentRoom.roomer &lt;&amp;
                <span class="stri">" is faster and takes them."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      currentRoom.occurrence := NOOCCURRENCE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> currentRoom.occurrence = FINDFLARES <span class="keywd">then</span>
      <span class="keywd">if</span> currentRoom.roomer = NOBODY <span class="keywd">then</span>
        write(<span class="stri">"Here you find "</span>);
        findFlares(player, 4);
      <span class="keywd">else</span>
        writeln(<span class="stri">"Here are "</span> &lt;&amp; numberName(rand(2, 5)) &lt;&amp;
                <span class="stri">" flares. But the "</span> &lt;&amp; currentRoom.roomer &lt;&amp;
                <span class="stri">" is faster and takes them."</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      currentRoom.occurrence := NOOCCURRENCE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># incident</span>


<span class="keywd">const</span> <span class="type">proc</span>: curesAndDissolves (<span class="keywd">inout</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> player.blind <span class="op">and</span> OPAL <span class="op">in</span> player.possession <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"The opal Eye cures your blindness!"</span>);
      player.blind := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> player.weaponBlocked <span class="op">and</span> BLUEFLAME <span class="op">in</span> player.possession <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"The blue Flame dissolves the book!"</span>);
      player.weaponBlocked := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> player.haveLeech <span class="op">and</span> PEARL <span class="op">in</span> player.possession <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"The pale pearl fixes the leech in your pocket."</span>);
      player.haveLeech := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> player.lethargic <span class="op">and</span> RUBY <span class="op">in</span> player.possession <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"The ruby red stops your lethargy."</span>);
      player.lethargic := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> player.forgetting <span class="op">and</span> GREENGEM <span class="op">in</span> player.possession <span class="keywd">then</span>
      writeln;
      writeln(<span class="stri">"The green Gem stops the forgetting of the map."</span>);
      player.forgetting := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># curesAndDissolves</span>


<span class="keywd">const</span> <span class="type">proc</span>: writeRemark (<span class="op">in</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> rand(1, 5) = 1 <span class="keywd">then</span>
      <span class="keywd">if</span> player.blind <span class="keywd">then</span>
        number := rand(1, 4);
      <span class="keywd">else</span>
        number := rand(1, 5);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">case</span> number <span class="keywd">of</span>
        <span class="keywd">when</span> {1}:
          <span class="keywd">case</span> rand(1, 8) <span class="keywd">of</span>
            <span class="keywd">when</span> {1}: writeln(<span class="stri">"You sneezed."</span>);
            <span class="keywd">when</span> {2}: writeln(<span class="stri">"You stepped on a frog."</span>);
            <span class="keywd">when</span> {3}: writeln(<span class="stri">"You have a fit of dizziness."</span>);
            <span class="keywd">when</span> {4}: writeln(<span class="stri">"You moved your hand through a spiders net."</span>);
            <span class="keywd">when</span> {5}: writeln(<span class="stri">"There are indications that somebody must have \
                              \been here recently."</span>);
            <span class="keywd">when</span> {6}: writeln(<span class="stri">"A blast of wind blows a cloud of dust across \
                              \the room."</span>);
            <span class="keywd">when</span> {7}: writeln(<span class="stri">"You touch "</span> &lt;&amp; anyAdjective() &lt;&amp;
                              <span class="stri">" insect that immediately flies away."</span>);
            <span class="keywd">when</span> {8}:
              writeln(<span class="stri">"The smell of "</span> &lt;&amp; anyFood() &lt;&amp; <span class="stri">" is in the air."</span>);
          <span class="keywd">end</span> <span class="keywd">case</span>;
        <span class="keywd">when</span> {2}:
          write(<span class="stri">"You smell "</span>);
          <span class="keywd">case</span> rand(1, 9) <span class="keywd">of</span>
            <span class="keywd">when</span> {1}: writeln(<span class="stri">"musty air."</span>);
            <span class="keywd">when</span> {2}: writeln(<span class="stri">"rotten flesh."</span>);
            <span class="keywd">when</span> {3}: writeln(<span class="stri">"a whiff of good french perfume."</span>);
            <span class="keywd">when</span> {4}: writeln(<span class="stri">"the bad odour of a mouldering body."</span>);
            <span class="keywd">when</span> {5}: writeln(<span class="stri">"the pleasant scent of a green meadow."</span>);
            <span class="keywd">when</span> {6}: writeln(<span class="stri">"the unpleasant stench of an acid."</span>);
            <span class="keywd">when</span> {7}: writeln(<span class="stri">"mouldering bones which must lie nearby."</span>);
            <span class="keywd">when</span> {8}: writeln(aOrAn(rand(animateType)) &lt;&amp; <span class="stri">" frying."</span>);
            <span class="keywd">when</span> {9}: writeln(<span class="stri">"the presence of a "</span> &lt;&amp;
                              sexName(<span class="op">not</span> player.isMale) &lt;&amp; <span class="stri">" "</span> &lt;&amp;
                              player.species &lt;&amp; <span class="stri">"."</span>);
          <span class="keywd">end</span> <span class="keywd">case</span>;
        <span class="keywd">when</span> {3}:
          write(<span class="stri">"You feel "</span>);
          <span class="keywd">case</span> rand(1, 10) <span class="keywd">of</span>
            <span class="keywd">when</span> { 1}: writeln(<span class="stri">"like you're being watched."</span>);
            <span class="keywd">when</span> { 2}: writeln(<span class="stri">"terribly frightened."</span>);
            <span class="keywd">when</span> { 3}: writeln(<span class="stri">"drops falling on your neck."</span>);
            <span class="keywd">when</span> { 4}: writeln(<span class="stri">"something touching your shoulder."</span>);
            <span class="keywd">when</span> { 5}: writeln(<span class="stri">"that you will be killed."</span>);
            <span class="keywd">when</span> { 6}: writeln(<span class="stri">"a cold wind blowing across the room."</span>);
            <span class="keywd">when</span> { 7}: writeln(<span class="stri">"that you get hungry."</span>);
            <span class="keywd">when</span> { 8}: writeln(<span class="stri">"vibrations at the ground."</span>);
            <span class="keywd">when</span> { 9}: writeln(<span class="stri">"danger in the vicinity."</span>);
            <span class="keywd">when</span> {10}: writeln(<span class="stri">"that a "</span> &lt;&amp; sexName(<span class="op">not</span> player.isMale) &lt;&amp;
                               <span class="stri">" "</span> &lt;&amp; rand(speciesType) &lt;&amp;
                               <span class="stri">" must have been here recently."</span>);
          <span class="keywd">end</span> <span class="keywd">case</span>;
        <span class="keywd">when</span> {4}:
          write(<span class="stri">"You hear "</span>);
          <span class="keywd">case</span> rand(1, 11) <span class="keywd">of</span>
            <span class="keywd">when</span> { 1}: writeln(<span class="stri">"thunder."</span>);
            <span class="keywd">when</span> { 2}: writeln(<span class="stri">"moaning."</span>);
            <span class="keywd">when</span> { 3}: writeln(<span class="stri">"a scream."</span>);
            <span class="keywd">when</span> { 4}: writeln(<span class="stri">"a wumpus."</span>);
            <span class="keywd">when</span> { 5}: writeln(<span class="stri">"footsteps."</span>);
            <span class="keywd">when</span> { 6}: writeln(<span class="stri">"a door open."</span>);
            <span class="keywd">when</span> { 7}: writeln(<span class="stri">"a door slam."</span>);
            <span class="keywd">when</span> { 8}: writeln(<span class="stri">"rattling sounds."</span>);
            <span class="keywd">when</span> { 9}: writeln(<span class="stri">"somebody snigger."</span>);
            <span class="keywd">when</span> {10}: writeln(<span class="stri">"faint rustling noises."</span>);
            <span class="keywd">when</span> {11}: writeln(<span class="stri">"somebody whisper your name."</span>);
          <span class="keywd">end</span> <span class="keywd">case</span>;
        <span class="keywd">when</span> {5}:
          write(<span class="stri">"You see "</span>);
          <span class="keywd">case</span> rand(1, 8) <span class="keywd">of</span>
            <span class="keywd">when</span> {1}: writeln(<span class="stri">"a bat fly by."</span>);
            <span class="keywd">when</span> {2}: writeln(<span class="stri">"some flies."</span>);
            <span class="keywd">when</span> {3}: writeln(<span class="stri">"a shadow passing by."</span>);
            <span class="keywd">when</span> {4}: writeln(<span class="stri">"a rat crossing the room."</span>);
            <span class="keywd">when</span> {5}: writeln(<span class="stri">"two eyes glowing in the dark. \
                              \A moment later they disappear."</span>);
            <span class="keywd">when</span> {6}: writeln(anyAdjective() &lt;&amp; <span class="stri">" footprint."</span>);
            <span class="keywd">when</span> {7}: writeln(anyAdjective() &lt;&amp; <span class="stri">" spider running away."</span>);
            <span class="keywd">when</span> {8}: writeln(<span class="stri">"the mirage of the "</span> &lt;&amp;
                              rand(LAMP, ORBOFZOT) &lt;&amp; <span class="stri">"."</span>);
          <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># writeRemark</span>


<span class="keywd">const</span> <span class="type">proc</span>: die (<span class="op">in</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"\a"</span>);
    writeln(<span class="stri">"*"</span> <span class="op">mult</span> 78);
    writeln(<span class="stri">"A noble effort, oh formerly living "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">"!"</span>);
    writeln;
    write(<span class="stri">"You died due to lack of "</span>);
    <span class="keywd">if</span> player.strength &lt; 1 <span class="keywd">then</span>
      writeln(<span class="stri">"strength."</span>);
    <span class="keywd">elsif</span> player.intelligence &lt; 1 <span class="keywd">then</span>
      writeln(<span class="stri">"intelligence."</span>);
    <span class="keywd">elsif</span> player.dexterity &lt; 1 <span class="keywd">then</span>
      writeln(<span class="stri">"dexterity."</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln;
    writeln(<span class="stri">"At the time you died, you had:"</span>);
    listInventory(player);
    writeln;
    writeln(<span class="stri">"And it took you "</span> &lt;&amp; player.turns &lt;&amp; <span class="stri">" turns!"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># die</span>


<span class="keywd">const</span> <span class="type">proc</span>: exitCastle (<span class="keywd">inout</span> <span class="type">playerType</span>: player) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"\a"</span>);
    write(<span class="stri">"You left the castle with"</span>);
    <span class="keywd">if</span> ORBOFZOT <span class="op">not</span> <span class="op">in</span> player.possession <span class="keywd">then</span>
      write(<span class="stri">"out"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(<span class="stri">" the *ORB OF ZOT*."</span>);
    writeln;
    <span class="keywd">if</span> ORBOFZOT <span class="op">in</span> player.possession <span class="keywd">then</span>
      writeln(<span class="stri">"An incredibly glorious victory!!"</span>);
      writeln;
      writeln(<span class="stri">"In addition, you got out with the following:"</span>);
      writeln(<span class="stri">"  your life"</span>);
      excl(player.possession, ORBOFZOT);
    <span class="keywd">else</span>
      writeln(<span class="stri">"A less than awe-inspiring defeat."</span>);
      writeln;
      writeln(<span class="stri">"When you left the castle, you had:"</span>);
      writeln(<span class="stri">"  your miserable life"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    listInventory(player);
    writeln;
    writeln(<span class="stri">"And it took you "</span> &lt;&amp; player.turns &lt;&amp; <span class="stri">" turns!"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># exitCastle</span>


<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">playerType</span>: player <span class="keywd">is</span> playerType.value;
    <span class="keywd">var</span> <span class="type">fightStateType</span>: fightState <span class="keywd">is</span> fightStateType.value;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    OUT := STD_CONSOLE;
    IN := openEditLine(KEYBOARD, OUT);
    startText();
    <span class="keywd">repeat</span>
      initRoomConnections();
      initRoomProperties();
      initRoomTransfers();
      labyrinthNumber := rand(1, 50);
      player := playerType.value;
      fightState := fightStateType.value;
      readSpecies(player);
      readSex(player);
      readAttributes(player);
      buyArmor(player, 7, 5, 3);
      buyWeapon(player, 7, 5, 3);
      buyLamp(player, 2);
      buyFlares(player);
      <span class="keywd">if</span> <span class="op">not</span> player.quitDialog <span class="keywd">then</span>
        writeln;
        writeln(<span class="stri">"Ok, "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">", you are now entering the castle."</span>);
        writeln(<span class="stri">"Type H for help."</span>);
        currentRoomRef := labyrinth[rangeLaby(4)][1][1];
        enterRoom(currentRoomRef, player, fightState);
        <span class="keywd">repeat</span>
          incr(player.turns);
          incident(currentRoomRef, player);
          curesAndDissolves(player);
          writeRemark(player);
          executeCommand(currentRoomRef, player, fightState);
          writeFightState(currentRoomRef, player, fightState);
        <span class="keywd">until</span> <span class="op">not</span> player.living <span class="op">or</span> player.leaveCastle <span class="op">or</span> player.quitProgram;
        <span class="keywd">if</span> <span class="op">not</span> player.living <span class="keywd">then</span>
          die(player);
        <span class="keywd">elsif</span> player.leaveCastle <span class="keywd">then</span>
          exitCastle(player);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">repeat</span>
        writeln;
        write(<span class="stri">"Are you foolish enough to want to play again? "</span>);
        ch := readChar();
        <span class="keywd">if</span> <span class="op">not</span> ch <span class="op">in</span> {<span class="stri">'Y'</span>, <span class="stri">'N'</span>} <span class="keywd">then</span>
          writeln;
          writeln(<span class="stri">"** Please answer yes or no."</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> ch <span class="op">in</span> {<span class="stri">'Y'</span>, <span class="stri">'N'</span>};
      writeln;
      <span class="keywd">if</span> ch = <span class="stri">'Y'</span> <span class="keywd">then</span>
        writeln(<span class="stri">"Some "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">"s never learn!"</span>);
      <span class="keywd">else</span>
        writeln(<span class="stri">"Maybe dumb "</span> &lt;&amp; player.species &lt;&amp; <span class="stri">" is not so dumb after all!"</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> ch = <span class="stri">'N'</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># main</span>
</pre>
</body>
</html>
