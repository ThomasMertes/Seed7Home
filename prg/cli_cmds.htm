<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  cli_cmds.s7i  Emulate CLI commands from Unix and Dos.           *)</span>
<span class="comment">(*  Copyright (C) 2010 - 2015, 2017, 2019  Thomas Mertes            *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/osfiles.htm">osfiles.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/shell.htm">shell.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/getf.htm">getf.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/wildcard.htm">wildcard.s7i</a>"</span>;


<span class="keywd">const</span> <span class="type">set</span> <span class="type">of</span> <span class="type">char</span>: parameter_char <span class="keywd">is</span> {<span class="stri">'!'</span> .. <span class="stri">'~'</span>} - {<span class="stri">'&lt;'</span>, <span class="stri">'>'</span>, <span class="stri">'|'</span>, <span class="stri">';'</span>, <span class="stri">')'</span>};
<span class="keywd">const</span> <span class="type">set</span> <span class="type">of</span> <span class="type">char</span>: dos_parameter_char <span class="keywd">is</span> {<span class="stri">'!'</span> .. <span class="stri">'~'</span>} - {<span class="stri">'&amp;'</span>, <span class="stri">'&lt;'</span>, <span class="stri">'>'</span>, <span class="stri">'|'</span>};


<span class="comment">(**
 *  Remove files and directories.
 *  If errors occur messages are written to STD_OUT.
 *  @param fileList List of files to be removed.
 *  @param recursive TRUE if subdirectories should be
 *                   removed recursively, FALSE otherwise.
 *  @param force TRUE if absent files should not
 *               trigger error messages, FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: doRemoveCmd (<span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: fileList,
    <span class="op">in</span> <span class="type">boolean</span>: recursive, <span class="op">in</span> <span class="type">boolean</span>: force) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: fileName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> fileName <span class="keywd">range</span> fileList <span class="keywd">do</span>
      <span class="keywd">if</span> fileTypeSL(fileName) = FILE_ABSENT <span class="keywd">then</span>
        <span class="keywd">if</span> <span class="op">not</span> force <span class="keywd">then</span>
          writeln(<span class="stri">"Cannot remove "</span> &lt;&amp; fileName &lt;&amp; <span class="stri">" - No such file or directory"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        <span class="keywd">block</span>
          <span class="keywd">if</span> recursive <span class="keywd">then</span>
            removeTree(fileName);
          <span class="keywd">else</span>
            removeFile(fileName);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        exception
          catch FILE_ERROR:
            writeln(<span class="stri">"Cannot remove "</span> &lt;&amp; fileName &lt;&amp; <span class="stri">" - Not permitted"</span>);
        <span class="keywd">end</span> <span class="keywd">block</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Copy files and directories.
 *  The list of files must have at least two elements. If the
 *  last element of the list is a directory the other files
 *  are copied into this directory. If errors occur messages
 *  are written to STD_OUT.
 *  @param fileList List of files to be copied. The last
 *                  element is the destination.
 *  @param recursive TRUE if subdirectories should be
 *                   copied recursively, FALSE otherwise.
 *  @param overwriteExisting TRUE if existing files
 *                           should be overwritten,
 *                           FALSE otherwise.
 *  @param archive TRUE if file properties should be
 *                 preserved, FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: doCopyCmd (<span class="op">in</span> <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: fileList,
   <span class="op">in</span> <span class="type">boolean</span>: recursive, <span class="op">in</span> <span class="type">boolean</span>: overwriteExisting, <span class="op">in</span> <span class="type">boolean</span>: archive) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: fileName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: destination <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: destFileName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: slashPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(fileList) >= 2 <span class="keywd">then</span>
      destination := fileList[length(fileList)];
      fileList := fileList[.. pred(length(fileList))];
      <span class="keywd">if</span> fileType(destination) = FILE_DIR <span class="keywd">then</span>
        <span class="keywd">for</span> fileName <span class="keywd">range</span> fileList <span class="keywd">do</span>
          <span class="keywd">if</span> fileType(fileName) = FILE_REGULAR <span class="op">or</span>
              (recursive <span class="op">and</span> fileType(fileName) = FILE_DIR) <span class="keywd">then</span>
            slashPos := rpos(fileName, <span class="stri">"/"</span>);
            <span class="keywd">if</span> slashPos = 0 <span class="keywd">then</span>
              destFileName := destination &amp; <span class="stri">"/"</span> &amp; fileName;
            <span class="keywd">else</span>
              destFileName := destination &amp; <span class="stri">"/"</span> &amp; fileName[succ(slashPos) ..];
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> fileTypeSL(destFileName) = FILE_REGULAR <span class="op">and</span> overwriteExisting <span class="keywd">then</span>
              <span class="keywd">block</span>
                removeFile(destFileName);
              exception
                catch FILE_ERROR:
                  writeln(<span class="stri">" *** Cannot remove "</span> &lt;&amp; destFileName);
              <span class="keywd">end</span> <span class="keywd">block</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> fileType(destFileName) = FILE_ABSENT <span class="keywd">then</span>
              <span class="comment"># write("copyFile " &lt;&amp; fileName &lt;&amp; " " &lt;&amp; destination);</span>
              <span class="keywd">if</span> archive <span class="keywd">then</span>
                cloneFile(fileName, destFileName);
              <span class="keywd">else</span>
                copyFile(fileName, destFileName);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> fileType(fileName) = FILE_ABSENT <span class="keywd">then</span>
            writeln(<span class="stri">"Cannot copy non-existent file "</span> &lt;&amp; fileName);
          <span class="keywd">else</span>
            writeln(<span class="stri">"Cannot copy "</span> &lt;&amp; fileName);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">elsif</span> length(fileList) = 1 <span class="keywd">then</span>
        fileName := fileList[1];
        <span class="keywd">if</span> fileType(fileName) = FILE_REGULAR <span class="op">or</span>
            (recursive <span class="op">and</span> fileType(fileName) = FILE_DIR) <span class="keywd">then</span>
          <span class="keywd">if</span> fileTypeSL(destination) = FILE_REGULAR <span class="op">and</span> overwriteExisting <span class="keywd">then</span>
            <span class="keywd">block</span>
              removeFile(destination);
            exception
              catch FILE_ERROR:
                writeln(<span class="stri">" *** Cannot remove "</span> &lt;&amp; destination);
            <span class="keywd">end</span> <span class="keywd">block</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> fileType(destination) = FILE_ABSENT <span class="keywd">then</span>
            <span class="comment"># write("copyFile " &lt;&amp; fileName &lt;&amp; " " &lt;&amp; destination);</span>
            <span class="keywd">if</span> archive <span class="keywd">then</span>
              cloneFile(fileName, destination);
            <span class="keywd">else</span>
              copyFile(fileName, destination);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> fileType(fileName) = FILE_ABSENT <span class="keywd">then</span>
          writeln(<span class="stri">"Cannot copy non-existent file "</span> &lt;&amp; fileName);
        <span class="keywd">else</span>
          writeln(<span class="stri">"Cannot copy "</span> &lt;&amp; fileName);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        writeln(<span class="stri">"Target "</span> &lt;&amp; destination &lt;&amp; <span class="stri">" is not a directory"</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      writeln(<span class="stri">"Missing destination file"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Move files and directories.
 *  The list of files must have at least two elements. If the
 *  last element of the list is a directory the other files
 *  are moved into this directory. If errors occur messages
 *  are written to STD_OUT.
 *  @param fileList List of files to be moved. The last
 *                  element is the destination.
 *  @param overwriteExisting TRUE if existing files
 *                           should be overwritten,
 *                           FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: doMoveCmd (<span class="op">in</span> <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: fileList,
    <span class="op">in</span> <span class="type">boolean</span>: overwriteExisting) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: fileName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: destination <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: destFileName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: slashPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(fileList) >= 2 <span class="keywd">then</span>
      destination := fileList[length(fileList)];
      fileList := fileList[.. pred(length(fileList))];
      <span class="keywd">if</span> fileType(destination) = FILE_DIR <span class="keywd">then</span>
        <span class="keywd">for</span> fileName <span class="keywd">range</span> fileList <span class="keywd">do</span>
          <span class="keywd">if</span> fileType(fileName) = FILE_REGULAR <span class="op">or</span> fileType(fileName) = FILE_DIR <span class="keywd">then</span>
            slashPos := rpos(fileName, <span class="stri">"/"</span>);
            <span class="keywd">if</span> slashPos = 0 <span class="keywd">then</span>
              destFileName := destination &amp; <span class="stri">"/"</span> &amp; fileName;
            <span class="keywd">else</span>
              destFileName := destination &amp; <span class="stri">"/"</span> &amp; fileName[succ(slashPos) ..];
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> fileTypeSL(destFileName) = FILE_REGULAR <span class="op">and</span> overwriteExisting <span class="keywd">then</span>
              <span class="keywd">block</span>
                removeFile(destFileName);
              exception
                catch FILE_ERROR:
                  writeln(<span class="stri">" *** Cannot remove "</span> &lt;&amp; destFileName);
              <span class="keywd">end</span> <span class="keywd">block</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> fileType(destFileName) = FILE_ABSENT <span class="keywd">then</span>
              <span class="comment"># write("moveFile " &lt;&amp; fileName &lt;&amp; " " &lt;&amp; destination);</span>
              moveFile(fileName, destFileName);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> fileType(fileName) = FILE_ABSENT <span class="keywd">then</span>
            writeln(<span class="stri">"Cannot move non-existent file "</span> &lt;&amp; fileName);
          <span class="keywd">else</span>
            writeln(<span class="stri">"Cannot move "</span> &lt;&amp; fileName);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">elsif</span> length(fileList) = 1 <span class="keywd">then</span>
        fileName := fileList[1];
        <span class="keywd">if</span> fileType(fileName) = FILE_REGULAR <span class="op">or</span> fileType(fileName) = FILE_DIR <span class="keywd">then</span>
          <span class="keywd">if</span> fileTypeSL(destination) = FILE_REGULAR <span class="op">and</span> overwriteExisting <span class="keywd">then</span>
            <span class="keywd">block</span>
              removeFile(destination);
            exception
              catch FILE_ERROR:
                writeln(<span class="stri">" *** Cannot remove "</span> &lt;&amp; destination);
            <span class="keywd">end</span> <span class="keywd">block</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> fileType(destination) = FILE_ABSENT <span class="keywd">then</span>
            <span class="comment"># write("moveFile " &lt;&amp; fileName &lt;&amp; " " &lt;&amp; destination);</span>
            moveFile(fileName, destination);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> fileType(fileName) = FILE_ABSENT <span class="keywd">then</span>
          writeln(<span class="stri">"Cannot move non-existent file "</span> &lt;&amp; fileName);
        <span class="keywd">else</span>
          writeln(<span class="stri">"Cannot move "</span> &lt;&amp; fileName);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        writeln(<span class="stri">"Target "</span> &lt;&amp; destination &lt;&amp; <span class="stri">" is not a directory"</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      writeln(<span class="stri">"Missing destination file"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Make directories.
 *  @param fileList List of directories to be created.
 *  @param parentDirs TRUE if parent directories should
 *                    be created as needed, FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: doMkdirCmd (<span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: fileList,
    <span class="op">in</span> <span class="type">boolean</span>: parentDirs) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: fileName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> fileName <span class="keywd">range</span> fileList <span class="keywd">do</span>
      okay := TRUE;
      <span class="keywd">if</span> parentDirs <span class="keywd">then</span>
        <span class="keywd">block</span>
          makeParentDirs(fileName);
        exception
          catch FILE_ERROR:
            writeln(<span class="stri">" *** Cannot make parent directories of "</span> &lt;&amp; fileName &lt;&amp; <span class="stri">" - Element is not a directory"</span>);
            okay := FALSE;
        <span class="keywd">end</span> <span class="keywd">block</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> okay <span class="keywd">then</span>
        <span class="keywd">if</span> fileTypeSL(fileName) = FILE_ABSENT <span class="keywd">then</span>
          <span class="keywd">block</span>
            mkdir(fileName);
          exception
            catch FILE_ERROR:
              writeln(<span class="stri">" *** Cannot make directory "</span> &lt;&amp; fileName);
          <span class="keywd">end</span> <span class="keywd">block</span>;
        <span class="keywd">elsif</span> fileTypeSL(fileName) = FILE_DIR <span class="op">and</span> <span class="op">not</span> parentDirs <span class="keywd">then</span>
          writeln(<span class="stri">" *** Cannot make directory "</span> &lt;&amp; fileName &lt;&amp; <span class="stri">" - File exists"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getCommandParameter (<span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">char</span>: quotation <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: quotedPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: quotedPart <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: quoteMissing <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    leng := length(stri);
    <span class="keywd">repeat</span>
      <span class="keywd">if</span> stri[pos] = <span class="stri">'"'</span> <span class="op">or</span> stri[pos] = <span class="stri">'''</span> <span class="keywd">then</span>
        quotation := stri[pos];
        quotedPos := succ(pos);
        quotedPart := <span class="stri">""</span>;
        <span class="keywd">while</span> quotedPos &lt;= leng <span class="op">and</span> stri[quotedPos] &lt;> quotation <span class="keywd">do</span>
          quotedPart &amp;:= stri[quotedPos];
          incr(quotedPos);
        <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">if</span> quotedPos &lt;= leng <span class="keywd">then</span>
          pos := succ(quotedPos);
          symbol &amp;:= quotedPart;
        <span class="keywd">else</span>
          quoteMissing := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        <span class="keywd">repeat</span>
          symbol &amp;:= stri[pos];
          incr(pos);
        <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] <span class="op">not</span> <span class="op">in</span> parameter_char <span class="op">or</span>
            stri[pos] = <span class="stri">'"'</span> <span class="op">or</span> stri[pos] = <span class="stri">'''</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> pos > leng <span class="op">or</span> stri[pos] <span class="op">not</span> <span class="op">in</span> parameter_char <span class="op">or</span> quoteMissing;
    stri := stri[pos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Read a parameter for a Unix command from a 'string'.
 *  Unix parameters consist of unquoted and quoted parts. Quoted parts
 *  can be quoted with single quotes (') or with double quotes (").
 *  A single quoted part ends with the next single quote. A double
 *  quoted part ends with unescaped double quotes. In a double quoted
 *  part the sequences \" and \\ do not terminate the quoted part and
 *  describe a double quote (") respectively a backslash (\). In an
 *  unquoted part a backslash (\) can used to escape characters that
 *  would otherwise have a special meaning. The backslash is ignored
 *  and the character after it is added to the word. To represent a
 *  backslash it must be doubled. When the function is called it is
 *  assumed that parameters[1] contains the first character of the
 *  parameter. When the function is left ''parameters'' is empty or
 *  parameters[1] contains the character after the parameter.
 *  @return the next parameter for a Unix command.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getUnixCommandParameter (<span class="keywd">inout</span> <span class="type">string</span>: parameters) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: quotedPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: quotedPart <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: quoteMissing <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    leng := length(parameters);
    <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> parameters[pos] <span class="op">in</span> parameter_char <span class="op">and</span>
        <span class="op">not</span> quoteMissing <span class="keywd">do</span>
      <span class="keywd">if</span> parameters[pos] = <span class="stri">'"'</span> <span class="keywd">then</span>
        quotedPos := succ(pos);
        quotedPart := <span class="stri">""</span>;
        <span class="keywd">while</span> quotedPos &lt;= leng <span class="op">and</span> parameters[quotedPos] &lt;> <span class="stri">'"'</span> <span class="keywd">do</span>
          <span class="keywd">if</span> parameters[quotedPos] = <span class="stri">'\\'</span> <span class="op">and</span> quotedPos &lt; leng <span class="op">and</span>
              (parameters[succ(quotedPos)] = <span class="stri">'"'</span> <span class="op">or</span>
               parameters[succ(quotedPos)] = <span class="stri">'\\'</span>) <span class="keywd">then</span>
            incr(quotedPos);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          quotedPart &amp;:= parameters[quotedPos];
          incr(quotedPos);
        <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">if</span> quotedPos &lt;= leng <span class="keywd">then</span>
          pos := succ(quotedPos);
          symbol &amp;:= quotedPart;
        <span class="keywd">else</span>
          quoteMissing := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> parameters[pos] = <span class="stri">'''</span> <span class="keywd">then</span>
        quotedPos := succ(pos);
        quotedPart := <span class="stri">""</span>;
        <span class="keywd">while</span> quotedPos &lt;= leng <span class="op">and</span> parameters[quotedPos] &lt;> <span class="stri">'''</span> <span class="keywd">do</span>
          quotedPart &amp;:= parameters[quotedPos];
          incr(quotedPos);
        <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">if</span> quotedPos &lt;= leng <span class="keywd">then</span>
          pos := succ(quotedPos);
          symbol &amp;:= quotedPart;
        <span class="keywd">else</span>
          quoteMissing := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        <span class="keywd">repeat</span>
          <span class="keywd">if</span> parameters[pos] = <span class="stri">'\\'</span> <span class="op">and</span> pos &lt; leng <span class="keywd">then</span>
            incr(pos);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          symbol &amp;:= parameters[pos];
          incr(pos);
        <span class="keywd">until</span> pos > leng <span class="op">or</span> parameters[pos] <span class="op">not</span> <span class="op">in</span> parameter_char <span class="op">or</span>
            parameters[pos] = <span class="stri">'"'</span> <span class="op">or</span> parameters[pos] = <span class="stri">'''</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    parameters := parameters[pos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Read a parameter for a Dos command from a 'string'.
 *  Dos parameters consist of unquoted and quoted parts. Quoted parts
 *  start with a double quote (") and end with the next double quote.
 *  In an unquoted part a caret (^) can used to escape characters that
 *  would otherwise have a special meaning. The caret is ignored and
 *  the character after it is added to the word. To represent a caret
 *  it must be doubled. When the function is called it is assumed that
 *  parameters[1] contains the first character of the parameter. When
 *  the function is left 'parameters' is empty or parameters[1]
 *  contains the character after the parameter.
 *  @return the next parameter for a Dos command.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getDosCommandParameter (<span class="keywd">inout</span> <span class="type">string</span>: parameters) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: quotedPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: quotedPart <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: quoteMissing <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    leng := length(parameters);
    <span class="keywd">while</span> pos &lt;= leng <span class="op">and</span> parameters[pos] <span class="op">in</span> dos_parameter_char <span class="op">and</span>
        <span class="op">not</span> quoteMissing <span class="keywd">do</span>
      <span class="keywd">if</span> parameters[pos] = <span class="stri">'"'</span> <span class="keywd">then</span>
        quotedPos := succ(pos);
        quotedPart := <span class="stri">""</span>;
        <span class="keywd">while</span> quotedPos &lt;= leng <span class="op">and</span> parameters[quotedPos] &lt;> <span class="stri">'"'</span> <span class="keywd">do</span>
          quotedPart &amp;:= parameters[quotedPos];
          incr(quotedPos);
        <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">if</span> quotedPos &lt;= leng <span class="keywd">then</span>
          pos := succ(quotedPos);
          symbol &amp;:= quotedPart;
        <span class="keywd">else</span>
          quoteMissing := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        <span class="keywd">repeat</span>
          <span class="keywd">if</span> parameters[pos] = <span class="stri">'^'</span> <span class="keywd">then</span>
            incr(pos);
            <span class="keywd">if</span> pos &lt;= leng <span class="keywd">then</span>
              symbol &amp;:= parameters[pos];
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            symbol &amp;:= parameters[pos];
          <span class="keywd">end</span> <span class="keywd">if</span>;
          incr(pos);
        <span class="keywd">until</span> pos > leng <span class="op">or</span> parameters[pos] <span class="op">not</span> <span class="op">in</span> dos_parameter_char <span class="op">or</span>
            parameters[pos] = <span class="stri">'"'</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    parameters := parameters[pos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Read a parameter for the Dos echo command from a 'string'.
 *  Dos parameters consist of unquoted and quoted parts. Quoted parts
 *  start with a double quote (") and end with the next double quote.
 *  The starting and ending double quotes are part of the result.
 *  In an unquoted part a caret (^) can used to escape characters that
 *  would otherwise have a special meaning. The caret is ignored and
 *  the character after it is added to the word. To represent a caret
 *  it must be doubled. When the function is called it is assumed that
 *  parameters[1] contains the first character of the parameter. When
 *  the function is left 'parameters' is empty or parameters[1]
 *  contains the character after the parameter.
 *  @return the next parameter for the Dos echo command.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getDosEchoParameter (<span class="keywd">inout</span> <span class="type">string</span>: parameters) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: symbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    leng := length(parameters);
    <span class="keywd">repeat</span>
      <span class="comment"># writeln("source char: " &lt;&amp; parameters[pos]);</span>
      <span class="keywd">if</span> parameters[pos] = <span class="stri">'"'</span> <span class="keywd">then</span>
        <span class="comment"># Inside quotation mode</span>
        <span class="keywd">repeat</span>
          symbol &amp;:= parameters[pos];
          incr(pos);
        <span class="keywd">until</span> pos > leng <span class="op">or</span> parameters[pos] = <span class="stri">'"'</span>;
        <span class="keywd">if</span> pos &lt;= leng <span class="keywd">then</span>
          <span class="comment"># Consume the terminating quotation mark</span>
          symbol &amp;:= <span class="stri">'"'</span>;
          incr(pos);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        <span class="comment"># Outside quotation mode</span>
        <span class="keywd">repeat</span>
          <span class="keywd">if</span> parameters[pos] = <span class="stri">'^'</span> <span class="keywd">then</span>
            incr(pos);
            <span class="keywd">if</span> pos &lt;= leng <span class="keywd">then</span>
              symbol &amp;:= parameters[pos];
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            symbol &amp;:= parameters[pos];
          <span class="keywd">end</span> <span class="keywd">if</span>;
          incr(pos);
        <span class="keywd">until</span> pos > leng <span class="op">or</span> parameters[pos] <span class="op">not</span> <span class="op">in</span> dos_parameter_char <span class="op">or</span>
            parameters[pos] = <span class="stri">'"'</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> pos > leng <span class="op">or</span> parameters[pos] <span class="op">not</span> <span class="op">in</span> dos_parameter_char;
    parameters := parameters[pos ..];
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: doOneCommand (<span class="keywd">inout</span> <span class="type">string</span>: command,
    <span class="keywd">inout</span> <span class="type">string</span>: commandOutput) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: execCommand (<span class="keywd">inout</span> <span class="type">string</span>: command) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: backtickOutput <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: fullCommand <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">file</span>: commandFile <span class="keywd">is</span> STD_NULL;
  <span class="keywd">begin</span>
    fullCommand := command;
    <span class="keywd">if</span> <span class="op">not</span> doOneCommand(command, backtickOutput) <span class="keywd">then</span>
      <span class="comment"># writeln("command: " &lt;&amp; literal(fullCommand));</span>
      commandFile := popen(fullCommand, <span class="stri">"r"</span>);
      <span class="keywd">if</span> commandFile &lt;> STD_NULL <span class="keywd">then</span>
        backtickOutput := gets(commandFile, 999999999);
        <span class="keywd">while</span> endsWith(backtickOutput, <span class="stri">"\r\n"</span>) <span class="keywd">do</span>
          backtickOutput := backtickOutput[.. length(backtickOutput) - 2];
        <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">while</span> endsWith(backtickOutput, <span class="stri">"\n"</span>) <span class="keywd">do</span>
          backtickOutput := backtickOutput[.. pred(length(backtickOutput))];
        <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">else</span>
        backtickOutput := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: execBacktickCommands (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: withBacktickOutput <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: backtickPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: closingBacktickPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: command <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: backtickOutput <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    withBacktickOutput := stri;
    backtickPos := pos(withBacktickOutput, <span class="stri">'`'</span>);
    <span class="keywd">while</span> backtickPos &lt;> 0 <span class="keywd">do</span>
      closingBacktickPos := pos(withBacktickOutput, <span class="stri">'`'</span>, succ(backtickPos));
      <span class="keywd">if</span> closingBacktickPos &lt;> 0 <span class="keywd">then</span>
        command := withBacktickOutput[succ(backtickPos) .. pred(closingBacktickPos)];
        backtickOutput := execCommand(command);
        withBacktickOutput := withBacktickOutput[.. pred(backtickPos)] &amp; backtickOutput &amp;
                              withBacktickOutput[succ(closingBacktickPos) ..];
      <span class="keywd">end</span> <span class="keywd">if</span>;
      backtickPos := pos(withBacktickOutput, <span class="stri">'`'</span>, succ(backtickPos));
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: addToFileList (<span class="keywd">inout</span> <span class="type">array</span> <span class="type">string</span>: fileList, <span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: parameter) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: fileName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    parameter := convDosPath(parameter);
    <span class="keywd">if</span> pos(parameter, <span class="stri">"*"</span>) &lt;> 0 <span class="op">or</span> pos(parameter, <span class="stri">"?"</span>) &lt;> 0 <span class="keywd">then</span>
      <span class="keywd">for</span> fileName <span class="keywd">range</span> findMatchingFiles(parameter) <span class="keywd">do</span>
        fileList &amp;:= [] (fileName);
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">else</span>
      fileList &amp;:= [] (parameter);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Remove files and directories like the Unix rm command.
 *  The command accepts the options -r, -R and -f.
 *  @param parameters Parameters (file names and options)
 *                    of the command. The function
 *                    removes the used parameters.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: doRm (<span class="keywd">inout</span> <span class="type">string</span>: parameters) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: aParam <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">char</span>: option <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: recursive <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: force <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: optionMayFollow <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: fileList <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("doRm(" &lt;&amp; literal(parameters) &lt;&amp; ")");</span>
    skipWhiteSpace(parameters);
    aParam := getUnixCommandParameter(parameters);
    <span class="keywd">while</span> startsWith(aParam, <span class="stri">"-"</span>) <span class="op">and</span> optionMayFollow <span class="keywd">do</span>
      aParam := aParam[2 ..];
      <span class="keywd">for</span> option <span class="keywd">range</span> aParam <span class="keywd">do</span>
        <span class="keywd">case</span> option <span class="keywd">of</span>
          <span class="keywd">when</span> {<span class="stri">'r'</span>, <span class="stri">'R'</span>}: recursive := TRUE;
          <span class="keywd">when</span> {<span class="stri">'f'</span>}:      force := TRUE;
          <span class="keywd">when</span> {<span class="stri">'-'</span>}:      optionMayFollow := FALSE;
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      skipWhiteSpace(parameters);
      aParam := getUnixCommandParameter(parameters);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">while</span> aParam &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      addToFileList(fileList, aParam);
      skipWhiteSpace(parameters);
      aParam := getUnixCommandParameter(parameters);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    doRemoveCmd(fileList, recursive, force);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Remove files and directories like the DOS del command.
 *  The command accepts the option /S.
 *  @param parameters Parameters (file names and options)
 *                    of the command. The function
 *                    removes the used parameters.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: doDel (<span class="keywd">inout</span> <span class="type">string</span>: parameters) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: aParam <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: recursive <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: fileList <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("doDel(" &lt;&amp; literal(parameters) &lt;&amp; ")");</span>
    skipWhiteSpace(parameters);
    aParam := getDosCommandParameter(parameters);
    <span class="keywd">while</span> aParam &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> upper(aParam) = <span class="stri">"/S"</span> <span class="keywd">then</span>
        recursive := TRUE;
      <span class="keywd">elsif</span> <span class="op">not</span> startsWith(aParam, <span class="stri">"/"</span>) <span class="keywd">then</span>
        addToFileList(fileList, aParam);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      skipWhiteSpace(parameters);
      aParam := getDosCommandParameter(parameters);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    doRemoveCmd(fileList, recursive, FALSE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Copy files and directories like the Unix cp command.
 *  The command accepts the options -r, -R, -n, -a and -p.
 *  @param parameters Parameters (file names and options)
 *                    of the command. The function
 *                    removes the used parameters.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: doCp (<span class="keywd">inout</span> <span class="type">string</span>: parameters) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: aParam <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">char</span>: option <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: recursive <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: overwriteExisting <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">boolean</span>: archive <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: optionMayFollow <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: fileList <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("doCp(" &lt;&amp; literal(parameters) &lt;&amp; ")");</span>
    skipWhiteSpace(parameters);
    aParam := getUnixCommandParameter(parameters);
    <span class="keywd">while</span> startsWith(aParam, <span class="stri">"-"</span>) <span class="op">and</span> optionMayFollow <span class="keywd">do</span>
      aParam := aParam[2 ..];
      <span class="keywd">for</span> option <span class="keywd">range</span> aParam <span class="keywd">do</span>
        <span class="keywd">case</span> option <span class="keywd">of</span>
          <span class="keywd">when</span> {<span class="stri">'r'</span>, <span class="stri">'R'</span>}: recursive := TRUE;
          <span class="keywd">when</span> {<span class="stri">'n'</span>}:      overwriteExisting := FALSE;
          <span class="keywd">when</span> {<span class="stri">'a'</span>, <span class="stri">'p'</span>}: recursive := TRUE;
                           archive := TRUE;
          <span class="keywd">when</span> {<span class="stri">'-'</span>}:      optionMayFollow := FALSE;
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      skipWhiteSpace(parameters);
      aParam := getUnixCommandParameter(parameters);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">while</span> aParam &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      addToFileList(fileList, aParam);
      skipWhiteSpace(parameters);
      aParam := getUnixCommandParameter(parameters);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    doCopyCmd(fileList, recursive, overwriteExisting, archive);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Copy files and directories like the DOS copy command.
 *  The command accepts the option /Y.
 *  @param parameters Parameters (file names and options)
 *                    of the command. The function
 *                    removes the used parameters.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: doCopy (<span class="keywd">inout</span> <span class="type">string</span>: parameters) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: aParam <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: overwriteExisting <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: fileList <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("doCopy(" &lt;&amp; literal(parameters) &lt;&amp; ")");</span>
    skipWhiteSpace(parameters);
    aParam := getDosCommandParameter(parameters);
    <span class="keywd">while</span> aParam &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> upper(aParam) = <span class="stri">"/Y"</span> <span class="keywd">then</span>
        overwriteExisting := TRUE;
      <span class="keywd">elsif</span> <span class="op">not</span> startsWith(aParam, <span class="stri">"/"</span>) <span class="keywd">then</span>
        addToFileList(fileList, aParam);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      skipWhiteSpace(parameters);
      aParam := getDosCommandParameter(parameters);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    doCopyCmd(fileList, FALSE, overwriteExisting, FALSE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Copy files and directories like the DOS xcopy command.
 *  The command accepts the options /E, /O and /Y.
 *  @param parameters Parameters (file names and options)
 *                    of the command. The function
 *                    removes the used parameters.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: doXCopy (<span class="keywd">inout</span> <span class="type">string</span>: parameters) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: aParam <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: recursive <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: overwriteExisting <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: archive <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: fileList <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("doXCopy(" &lt;&amp; literal(parameters) &lt;&amp; ")");</span>
    skipWhiteSpace(parameters);
    aParam := getDosCommandParameter(parameters);
    <span class="keywd">while</span> aParam &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> upper(aParam) = <span class="stri">"/E"</span> <span class="keywd">then</span>
        recursive := TRUE;
      <span class="keywd">elsif</span> upper(aParam) = <span class="stri">"/O"</span> <span class="keywd">then</span>
        archive := TRUE;
      <span class="keywd">elsif</span> upper(aParam) = <span class="stri">"/Y"</span> <span class="keywd">then</span>
        overwriteExisting := TRUE;
      <span class="keywd">elsif</span> <span class="op">not</span> startsWith(aParam, <span class="stri">"/"</span>) <span class="keywd">then</span>
        addToFileList(fileList, aParam);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      skipWhiteSpace(parameters);
      aParam := getDosCommandParameter(parameters);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    doCopyCmd(fileList, recursive, overwriteExisting, archive);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Move files and directories like the Unix mv command.
 *  The command accepts the option -n.
 *  @param parameters Parameters (file names and options)
 *                    of the command. The function
 *                    removes the used parameters.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: doMv (<span class="keywd">inout</span> <span class="type">string</span>: parameters) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: aParam <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">char</span>: option <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: overwriteExisting <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">boolean</span>: optionMayFollow <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: fileList <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("doMv(" &lt;&amp; literal(parameters) &lt;&amp; ")");</span>
    skipWhiteSpace(parameters);
    aParam := getUnixCommandParameter(parameters);
    <span class="keywd">while</span> startsWith(aParam, <span class="stri">"-"</span>) <span class="op">and</span> optionMayFollow <span class="keywd">do</span>
      aParam := aParam[2 ..];
      <span class="keywd">for</span> option <span class="keywd">range</span> aParam <span class="keywd">do</span>
        <span class="keywd">case</span> option <span class="keywd">of</span>
          <span class="keywd">when</span> {<span class="stri">'n'</span>}:      overwriteExisting := FALSE;
          <span class="keywd">when</span> {<span class="stri">'-'</span>}:      optionMayFollow := FALSE;
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      skipWhiteSpace(parameters);
      aParam := getUnixCommandParameter(parameters);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">while</span> aParam &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      addToFileList(fileList, aParam);
      skipWhiteSpace(parameters);
      aParam := getUnixCommandParameter(parameters);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    doMoveCmd(fileList, overwriteExisting);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Move files and directories like the DOS move command.
 *  The command accepts the option /Y.
 *  @param parameters Parameters (file names and options)
 *                    of the command. The function
 *                    removes the used parameters.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: doMove (<span class="keywd">inout</span> <span class="type">string</span>: parameters) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: aParam <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: overwriteExisting <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: fileList <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("doMove(" &lt;&amp; literal(parameters) &lt;&amp; ")");</span>
    skipWhiteSpace(parameters);
    aParam := getDosCommandParameter(parameters);
    <span class="keywd">while</span> aParam &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> upper(aParam) = <span class="stri">"/Y"</span> <span class="keywd">then</span>
        overwriteExisting := TRUE;
      <span class="keywd">elsif</span> <span class="op">not</span> startsWith(aParam, <span class="stri">"/"</span>) <span class="keywd">then</span>
        addToFileList(fileList, aParam);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      skipWhiteSpace(parameters);
      aParam := getDosCommandParameter(parameters);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    doMoveCmd(fileList, overwriteExisting);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Make directories like the Unix mkdir command.
 *  The command accepts the option -p.
 *  @param parameters Parameters (file names and options)
 *                    of the command. The function
 *                    removes the used parameters.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: doMkdir (<span class="keywd">inout</span> <span class="type">string</span>: parameters) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: aParam <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">char</span>: option <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: parentDirs <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: optionMayFollow <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: fileList <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("doMkdir(" &lt;&amp; literal(parameters) &lt;&amp; ")");</span>
    skipWhiteSpace(parameters);
    aParam := getUnixCommandParameter(parameters);
    <span class="keywd">while</span> startsWith(aParam, <span class="stri">"-"</span>) <span class="op">and</span> optionMayFollow <span class="keywd">do</span>
      aParam := aParam[2 ..];
      <span class="keywd">for</span> option <span class="keywd">range</span> aParam <span class="keywd">do</span>
        <span class="keywd">case</span> option <span class="keywd">of</span>
          <span class="keywd">when</span> {<span class="stri">'p'</span>}: parentDirs := TRUE;
          <span class="keywd">when</span> {<span class="stri">'-'</span>}: optionMayFollow := FALSE;
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      skipWhiteSpace(parameters);
      aParam := getUnixCommandParameter(parameters);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">while</span> aParam &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      addToFileList(fileList, aParam);
      skipWhiteSpace(parameters);
      aParam := getUnixCommandParameter(parameters);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    doMkdirCmd(fileList, TRUE);  <span class="comment"># Under windows mkdir generates parent dirs.</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Make directories like the DOS md command.
 *  @param parameters Parameters (file names and options)
 *                    of the command. The function
 *                    removes the used parameters.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: doMd (<span class="keywd">inout</span> <span class="type">string</span>: parameters) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: aParam <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: fileList <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("doMd(" &lt;&amp; literal(parameters) &lt;&amp; ")");</span>
    skipWhiteSpace(parameters);
    aParam := getDosCommandParameter(parameters);
    <span class="keywd">while</span> aParam &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      <span class="keywd">if</span> <span class="op">not</span> startsWith(aParam, <span class="stri">"/"</span>) <span class="keywd">then</span>
        addToFileList(fileList, aParam);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      skipWhiteSpace(parameters);
      aParam := getDosCommandParameter(parameters);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    doMkdirCmd(fileList, TRUE);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Act like the Unix/DOS pwd (print working directory) command.
 *  @param parameters Parameters (file names and options)
 *                    of the command. The function
 *                    removes the used parameters.
 *  @return the current working directory.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: doPwd (<span class="keywd">inout</span> <span class="type">string</span>: parameters) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: commandOutput <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("doPwd(" &lt;&amp; literal(parameters) &lt;&amp; ")");</span>
    skipWhiteSpace(parameters);
    <span class="keywd">if</span> startsWith(parameters, <span class="stri">"-W"</span>) <span class="keywd">then</span>
      parameters := parameters[3 ..];
      skipWhiteSpace(parameters);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    commandOutput := getcwd &amp; <span class="stri">"\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Act like the Unix/DOS echo (write text) command.
 *  @param parameters Parameters (file names and options)
 *                    of the command. The function
 *                    removes the used parameters.
 *  @return the string that should be written.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: doEcho (<span class="keywd">inout</span> <span class="type">string</span>: parameters) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: commandOutput <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: whiteSpace <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: aParam <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("doEcho(" &lt;&amp; literal(parameters) &lt;&amp; ")");</span>
    whiteSpace := getWhiteSpace(parameters);
    <span class="keywd">if</span> parameters &lt;> <span class="stri">""</span> <span class="op">and</span> (parameters[1] = <span class="stri">'"'</span> <span class="op">or</span> parameters[1] = <span class="stri">'''</span>) <span class="keywd">then</span>
      <span class="keywd">while</span> parameters &lt;> <span class="stri">""</span> <span class="op">and</span> parameters[1] <span class="op">in</span> parameter_char <span class="keywd">do</span>
        <span class="keywd">if</span> commandOutput &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          commandOutput &amp;:= whiteSpace;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        aParam := getUnixCommandParameter(parameters);
        commandOutput &amp;:= execBacktickCommands(aParam);
        whiteSpace := getWhiteSpace(parameters);
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">else</span>
      <span class="keywd">while</span> parameters &lt;> <span class="stri">""</span> <span class="op">and</span> parameters[1] <span class="op">in</span> parameter_char <span class="keywd">do</span>
        aParam := getDosEchoParameter(parameters);
        commandOutput &amp;:= aParam;
        commandOutput &amp;:= getWhiteSpace(parameters);
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    commandOutput &amp;:= <span class="stri">"\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Change working directory like the Unix/DOS cd command.
 *  @param parameters Parameters (file names and options)
 *                    of the command. The function
 *                    removes the used parameters.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: doCd (<span class="keywd">inout</span> <span class="type">string</span>: parameters) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: aParam <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("doCd(" &lt;&amp; literal(parameters) &lt;&amp; ")");</span>
    skipWhiteSpace(parameters);
    <span class="keywd">if</span> parameters &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      aParam := getCommandParameter(parameters);
      aParam := convDosPath(aParam);
      <span class="keywd">if</span> fileType(aParam) = FILE_DIR <span class="keywd">then</span>
        chdir(aParam);
      <span class="keywd">else</span>
        writeln(<span class="stri">" *** cd "</span> &lt;&amp; aParam &lt;&amp; <span class="stri">" - No such file or directory"</span>);
        <span class="comment"># writeln(getcwd);</span>
        <span class="comment"># writeln(fileType(aParam));</span>
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Act like the Unix make command.
 *  This library just contains a forward definition.
 *  The actual definition of this function must be done
 *  outside of this library.
 *  @param parameters Parameters (file names and options)
 *                    of the command. The function
 *                    removes the used parameters.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: doMake (<span class="keywd">inout</span> <span class="type">string</span>: parameters) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: doOneCommand (<span class="keywd">inout</span> <span class="type">string</span>: command,
    <span class="keywd">inout</span> <span class="type">string</span>: commandOutput) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: done <span class="keywd">is</span> TRUE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: commandName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> command &lt;> <span class="stri">""</span> <span class="op">and</span> command[1] = <span class="stri">'#'</span> <span class="keywd">then</span>
      command := <span class="stri">""</span>;
      commandOutput := <span class="stri">""</span>;
    <span class="keywd">else</span>
      commandName := lower(getWord(command));
      <span class="comment"># writeln("doOneCommand: " &lt;&amp; commandName);</span>
      <span class="keywd">if</span> commandName = <span class="stri">"rm"</span> <span class="keywd">then</span>
        doRm(command);
        commandOutput := <span class="stri">""</span>;
      <span class="keywd">elsif</span> commandName = <span class="stri">"del"</span> <span class="op">or</span> commandName = <span class="stri">"erase"</span> <span class="keywd">then</span>
        doDel(command);
        commandOutput := <span class="stri">""</span>;
      <span class="keywd">elsif</span> commandName = <span class="stri">"cp"</span> <span class="keywd">then</span>
        doCp(command);
        commandOutput := <span class="stri">""</span>;
      <span class="keywd">elsif</span> commandName = <span class="stri">"copy"</span> <span class="keywd">then</span>
        doCopy(command);
        commandOutput := <span class="stri">""</span>;
      <span class="keywd">elsif</span> commandName = <span class="stri">"xcopy"</span> <span class="keywd">then</span>
        doXCopy(command);
        commandOutput := <span class="stri">""</span>;
      <span class="keywd">elsif</span> commandName = <span class="stri">"mv"</span> <span class="keywd">then</span>
        doMv(command);
        commandOutput := <span class="stri">""</span>;
      <span class="keywd">elsif</span> commandName = <span class="stri">"move"</span> <span class="keywd">then</span>
        doMove(command);
        commandOutput := <span class="stri">""</span>;
      <span class="keywd">elsif</span> commandName = <span class="stri">"mkdir"</span> <span class="keywd">then</span>
        doMkdir(command);
        commandOutput := <span class="stri">""</span>;
      <span class="keywd">elsif</span> commandName = <span class="stri">"md"</span> <span class="keywd">then</span>
        doMd(command);
        commandOutput := <span class="stri">""</span>;
      <span class="keywd">elsif</span> commandName = <span class="stri">"pwd"</span> <span class="keywd">then</span>
        commandOutput := doPwd(command);
      <span class="keywd">elsif</span> commandName = <span class="stri">"echo"</span> <span class="op">or</span> commandName = <span class="stri">"echo."</span> <span class="keywd">then</span>
        commandOutput := doEcho(command);
      <span class="keywd">elsif</span> commandName = <span class="stri">"cd"</span> <span class="keywd">then</span>
        doCd(command);
        commandOutput := <span class="stri">""</span>;
      <span class="keywd">elsif</span> commandName = <span class="stri">"make"</span> <span class="op">or</span> commandName = <span class="stri">"make7"</span> <span class="keywd">then</span>
        doMake(command);
        commandOutput := <span class="stri">""</span>;
      <span class="keywd">elsif</span> commandName = <span class="stri">"rem"</span> <span class="keywd">then</span>
        command := <span class="stri">""</span>;
        commandOutput := <span class="stri">""</span>;
      <span class="keywd">elsif</span> commandName = <span class="stri">"("</span> <span class="keywd">then</span>
        done := doOneCommand(command, commandOutput);
      <span class="keywd">else</span>
        done := FALSE;
        commandOutput := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: appendToFile (<span class="op">in</span> <span class="type">string</span>: file_name, <span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">file</span>: work_file <span class="keywd">is</span> STD_NULL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      work_file := open(file_name, <span class="stri">"a"</span>);
      <span class="keywd">if</span> work_file &lt;> STD_NULL <span class="keywd">then</span>
        write(work_file, stri);
        close(work_file);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: doCommands (<span class="keywd">inout</span> <span class="type">string</span>: command) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: done <span class="keywd">is</span> TRUE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: quotePos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: commandOutput <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: redirect <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: fileName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> startsWith(command, <span class="stri">"\""</span>) <span class="keywd">then</span>
      quotePos := rpos(command, <span class="stri">"\""</span>);
      <span class="keywd">if</span> quotePos &lt;> 0 <span class="op">and</span> quotePos &lt;> 1 <span class="keywd">then</span>
        command := command[2 .. pred(quotePos)] &amp; command[succ(quotePos) ..];
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">repeat</span>
      done := doOneCommand(command, commandOutput);
      <span class="keywd">if</span> done <span class="keywd">then</span>
        skipWhiteSpace(command);
        redirect := getWord(command);
        <span class="keywd">if</span> redirect = <span class="stri">">"</span> <span class="keywd">then</span>
          skipWhiteSpace(command);
          fileName := getCommandParameter(command);
          <span class="keywd">if</span> fileName &lt;> <span class="stri">"/dev/null"</span> <span class="op">and</span> fileName &lt;> <span class="stri">"NUL:"</span> <span class="op">and</span> fileName &lt;> <span class="stri">"NUL"</span> <span class="keywd">then</span>
            fileName := convDosPath(fileName);
            putf(fileName, commandOutput);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> redirect = <span class="stri">">>"</span> <span class="keywd">then</span>
          skipWhiteSpace(command);
          fileName := getCommandParameter(command);
          <span class="keywd">if</span> fileName &lt;> <span class="stri">"/dev/null"</span> <span class="op">and</span> fileName &lt;> <span class="stri">"NUL:"</span> <span class="op">and</span> fileName &lt;> <span class="stri">"NUL"</span> <span class="keywd">then</span>
            fileName := convDosPath(fileName);
            appendToFile(fileName, commandOutput);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> commandOutput &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          write(commandOutput);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        skipWhiteSpace(command);
        <span class="keywd">if</span> command &lt;> <span class="stri">""</span> <span class="op">and</span> command[1] = <span class="stri">';'</span> <span class="keywd">then</span>
          command := command[2 ..];
          skipWhiteSpace(command);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> command = <span class="stri">""</span> <span class="op">or</span> <span class="op">not</span> done;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: processCommand (<span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: command) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: commandStatus <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: fullCommand <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: gtPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: doRedirect <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: doAppend <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">string</span>: rawFileName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: fileName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">file</span>: aFile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">string</span>: commandOutput <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="comment"># writeln("process command: " &lt;&amp; command);</span>
    fullCommand := command;
    <span class="keywd">if</span> <span class="op">not</span> doCommands(command) <span class="keywd">then</span>
      gtPos := rpos(fullCommand, <span class="stri">">"</span>);
      <span class="keywd">if</span> gtPos >= 2 <span class="keywd">then</span>
        rawFileName := fullCommand[succ(gtPos) ..];
        skipWhiteSpace(rawFileName);
        fileName := getCommandParameter(rawFileName);
        skipWhiteSpace(rawFileName);
        <span class="keywd">if</span> rawFileName = <span class="stri">""</span> <span class="keywd">then</span>
          <span class="keywd">if</span> fullCommand[pred(gtPos)] = <span class="stri">'>'</span> <span class="op">and</span> gtPos >= 3 <span class="op">and</span>
              fullCommand[gtPos - 2] <span class="op">not</span> <span class="op">in</span> {<span class="stri">'\\'</span>, <span class="stri">'^'</span>} <span class="keywd">then</span>
            doAppend := TRUE;
            fullCommand := fullCommand[.. gtPos - 2];
          <span class="keywd">elsif</span> fullCommand[pred(gtPos)] <span class="op">not</span> <span class="op">in</span> {<span class="stri">'\\'</span>, <span class="stri">'^'</span>, <span class="stri">'2'</span>} <span class="keywd">then</span>
            doRedirect := TRUE;
            fullCommand := fullCommand[.. pred(gtPos)];
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> doRedirect <span class="op">or</span> doAppend <span class="keywd">then</span>
        <span class="keywd">if</span> startsWith(fullCommand, <span class="stri">"\""</span>) <span class="keywd">then</span>
          command := getQuotedText(fullCommand);
        <span class="keywd">else</span>
          command := getWord(fullCommand);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="comment"># writeln("cmd: " &lt;&amp; literal(command) &lt;&amp; " " &lt;&amp; literal(convDosPath(command)) &lt;&amp; " " &lt;&amp; literal(fullCommand));</span>
        aFile := popen(convDosPath(command), fullCommand, <span class="stri">"r"</span>);
        <span class="keywd">if</span> aFile &lt;> STD_NULL <span class="keywd">then</span>
          commandOutput := gets(aFile, 999999999);
          close(aFile);
          <span class="keywd">if</span> fileName &lt;> <span class="stri">"/dev/null"</span> <span class="op">and</span> fileName &lt;> <span class="stri">"NUL:"</span> <span class="op">and</span> fileName &lt;> <span class="stri">"NUL"</span> <span class="keywd">then</span>
            fileName := convDosPath(fileName);
            <span class="keywd">if</span> doAppend <span class="keywd">then</span>
              appendToFile(fileName, commandOutput);
            <span class="keywd">else</span>
              putf(fileName, commandOutput);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        <span class="keywd">if</span> startsWith(fullCommand, <span class="stri">"\""</span>) <span class="keywd">then</span>
          command := getQuotedText(fullCommand);
        <span class="keywd">else</span>
          command := getWord(fullCommand);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="comment"># writeln("cmd: " &lt;&amp; literal(command) &lt;&amp; " " &lt;&amp; literal(convDosPath(command)) &lt;&amp; " " &lt;&amp; literal(fullCommand));</span>
        commandStatus := shell(convDosPath(command), fullCommand);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
