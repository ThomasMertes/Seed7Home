<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  s7c.sd7       Seed7 compiler - Compiles Seed7 to C              *)</span>
<span class="comment">(*  Copyright (C) 1990 - 1994, 2004 - 2024  Thomas Mertes           *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


$ message <span class="stri">"Compiling the compiler ..."</span>;
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/seed7_05.htm">seed7_05.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/stdio.htm">stdio.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/osfiles.htm">osfiles.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/scanstri.htm">scanstri.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/unicode.htm">unicode.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bigint.htm">bigint.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/float.htm">float.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/math.htm">math.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bytedata.htm">bytedata.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bin64.htm">bin64.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/draw.htm">draw.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/keybd.htm">keybd.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/progs.htm">progs.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/shell.htm">shell.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/cc_conf.htm">cc_conf.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/inifile.htm">inifile.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/comp/config.htm">comp/config.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/comp/type.htm">comp/type.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/comp/expr.htm">comp/expr.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/comp/debug.htm">comp/debug.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/comp/literal.htm">comp/literal.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/comp/destr.htm">comp/destr.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/comp/create.htm">comp/create.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/comp/copy.htm">comp/copy.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/comp/expr_utl.htm">comp/expr_utl.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/comp/stat.htm">comp/stat.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/comp/inline.htm">comp/inline.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/comp/const.htm">comp/const.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/comp/intrange.htm">comp/intrange.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/comp/error.htm">comp/error.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/comp/library.htm">comp/library.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/comp/action.htm">comp/action.s7i</a>"</span>;

<span class="keywd">const</span> <span class="type">string</span>: temp_marker <span class="keywd">is</span> <span class="stri">"/* Seed7 compiler temp file */"</span>;

<span class="keywd">const</span> <span class="type">boolean</span>: SHOW_STATISTIC <span class="keywd">is</span> FALSE;

<span class="keywd">const</span> <span class="type">type</span>: optionHash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">string</span><span class="type">]</span> <span class="type">string</span>;

<span class="keywd">var</span> <span class="type">boolean</span>: compileLibrary <span class="keywd">is</span> FALSE;

<span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: libraryDirs <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;

<span class="keywd">var</span> <span class="type">reference</span>: main_object <span class="keywd">is</span> NIL;
<span class="keywd">var</span> <span class="type">file</span>: c_prog <span class="keywd">is</span> STD_NULL;

<span class="keywd">var</span> <span class="type">integer</span>: countDeclarations <span class="keywd">is</span> 0;
<span class="keywd">var</span> expr_type: global_init <span class="keywd">is</span> expr_type.value;

<span class="keywd">const</span> <span class="type">type</span>: globalInitHash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">reference</span><span class="type">]</span> <span class="type">string</span>;

<span class="keywd">var</span> <span class="type">globalInitHash</span>: globalInitalisations <span class="keywd">is</span> globalInitHash.EMPTY_HASH;

<span class="keywd">const</span> <span class="type">type</span>: interface_hash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">type</span><span class="type">]</span> <span class="type">array</span> type;
<span class="keywd">const</span> <span class="type">type</span>: enum_literal_hash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">type</span><span class="type">]</span> <span class="type">element_number_hash</span>;
<span class="keywd">const</span> <span class="type">type</span>: act_to_form_param_hash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">reference</span><span class="type">]</span> <span class="type">reference</span>;
<span class="keywd">const</span> <span class="type">type</span>: params_added_hash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">reference</span><span class="type">]</span> <span class="type">act_to_form_param_hash</span>;
<span class="keywd">const</span> <span class="type">type</span>: setOfCategory <span class="keywd">is</span> <span class="type">set</span> <span class="type">of</span> <span class="type">category</span>;
<span class="keywd">const</span> <span class="type">type</span>: setOfString <span class="keywd">is</span> <span class="type">set</span> <span class="type">of</span> <span class="type">string</span>;
<span class="keywd">const</span> <span class="type">type</span>: funcparam_data_hash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">reference</span><span class="type">]</span> <span class="type">string</span>;
<span class="keywd">const</span> <span class="type">type</span>: element_repeat_count_hash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">reference</span><span class="type">]</span> <span class="type">integer</span>;
<span class="keywd">const</span> <span class="type">type</span>: stringLengthHash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">integer</span><span class="type">]</span> <span class="type">integer</span>;
<span class="keywd">const</span> <span class="type">type</span>: lengthToStriNumHash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">integer</span><span class="type">]</span> <span class="type">array</span> integer;
<span class="keywd">const</span> <span class="type">type</span>: profiledFunctionsHash <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">integer</span><span class="type">]</span> <span class="type">reference</span>;

<span class="keywd">var</span> boolean_type_hash: generic_hashCode_declared <span class="keywd">is</span> boolean_type_hash.EMPTY_HASH;
<span class="keywd">var</span> boolean_type_hash: generic_cpy_declared <span class="keywd">is</span> boolean_type_hash.EMPTY_HASH;
<span class="keywd">var</span> boolean_type_hash: generic_create_declared <span class="keywd">is</span> boolean_type_hash.EMPTY_HASH;
<span class="keywd">var</span> boolean_type_hash: generic_destr_declared <span class="keywd">is</span> boolean_type_hash.EMPTY_HASH;
<span class="keywd">var</span> boolean_type_hash: generic_cmp_declared <span class="keywd">is</span> boolean_type_hash.EMPTY_HASH;
<span class="keywd">var</span> boolean_obj_hash: return_ref_to_value <span class="keywd">is</span> boolean_obj_hash.EMPTY_HASH;
<span class="keywd">var</span> boolean_obj_hash: function_declared <span class="keywd">is</span> boolean_obj_hash.EMPTY_HASH;
<span class="keywd">var</span> boolean_obj_hash: function_not_declared <span class="keywd">is</span> boolean_obj_hash.EMPTY_HASH;
<span class="keywd">var</span> boolean_obj_hash: function_var_declared <span class="keywd">is</span> boolean_obj_hash.EMPTY_HASH;
<span class="keywd">var</span> <span class="type">ref_list</span>: dynamic_functions <span class="keywd">is</span> ref_list.EMPTY;
<span class="keywd">var</span> <span class="type">interface_hash</span>: interfaceOfType <span class="keywd">is</span> interface_hash.EMPTY_HASH;
<span class="keywd">var</span> <span class="type">enum_literal_hash</span>: enum_literal <span class="keywd">is</span> enum_literal_hash.EMPTY_HASH;
<span class="keywd">var</span> <span class="type">params_added_hash</span>: params_added <span class="keywd">is</span> params_added_hash.EMPTY_HASH;
<span class="keywd">var</span> boolean_obj_hash: definedActualFuncParams <span class="keywd">is</span> boolean_obj_hash.EMPTY_HASH;
<span class="keywd">var</span> <span class="type">funcparam_data_hash</span>: funcparam_data <span class="keywd">is</span> funcparam_data_hash.EMPTY_HASH;
<span class="keywd">var</span> <span class="type">funcparam_data_hash</span>: funcparam_reference <span class="keywd">is</span> funcparam_data_hash.EMPTY_HASH;
<span class="keywd">var</span> <span class="type">element_repeat_count_hash</span>: element_repeat_count <span class="keywd">is</span> element_repeat_count_hash.EMPTY_HASH;
<span class="keywd">var</span> <span class="type">profiledFunctionsHash</span>: profiledFunctions <span class="keywd">is</span> profiledFunctionsHash.value;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isFuncParamData (<span class="op">in</span> <span class="type">reference</span>: currExpr) <span class="keywd">is</span>
  <span class="keywd">return</span> currExpr <span class="op">in</span> funcparam_data;


<span class="keywd">const</span> <span class="type">proc</span>: count_declarations (<span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    incr(countDeclarations);
    c_expr.expr &amp;:= <span class="stri">"/* "</span>;
    c_expr.expr &amp;:= str(countDeclarations);
    c_expr.expr &amp;:= <span class="stri">" */\n"</span>;
    write(OUT, countDeclarations);
    write(OUT, <span class="stri">"\r"</span>);
    flush(OUT);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_generic_hashCode_declaration (<span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">type</span>: object_type, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> object_type <span class="op">not</span> <span class="op">in</span> generic_hashCode_declared <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"static intType generic_hashCode_"</span>;
      c_expr.expr &amp;:= str(typeNumber(object_type));
      c_expr.expr &amp;:= <span class="stri">" (const genericType a)\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"return o_"</span>;
      create_name(function, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">"(((const_rtlObjectType *) &amp;a)->value."</span>;
      c_expr.expr &amp;:= raw_type_value(object_type);
      c_expr.expr &amp;:= <span class="stri">");\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"}\n\n"</span>;
      generic_hashCode_declared @:= [object_type] TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_generic_cpy_declaration (<span class="op">in</span> <span class="type">type</span>: object_type,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> object_type <span class="op">not</span> <span class="op">in</span> generic_cpy_declared <span class="keywd">then</span>
      process_cpy_declaration(object_type, c_expr);
      c_expr.expr &amp;:= <span class="stri">"static void generic_cpy_"</span>;
      c_expr.expr &amp;:= str(typeNumber(object_type));
      c_expr.expr &amp;:= <span class="stri">" (genericType *a, const genericType b)\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      process_cpy_call(object_type,
          <span class="stri">"((const_rtlObjectType *) a)->value."</span> &amp; raw_type_value(object_type),
          <span class="stri">"((const_rtlObjectType *) &amp;b)->value."</span> &amp; raw_type_value(object_type),
          c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">";\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"}\n\n"</span>;
      generic_cpy_declared @:= [object_type] TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_generic_create_declaration (<span class="op">in</span> <span class="type">type</span>: object_type,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> object_type <span class="op">not</span> <span class="op">in</span> generic_create_declared <span class="keywd">then</span>
      process_create_declaration(object_type, c_expr);
      c_expr.expr &amp;:= <span class="stri">"static genericType generic_create_"</span>;
      c_expr.expr &amp;:= str(typeNumber(object_type));
      c_expr.expr &amp;:= <span class="stri">" (const genericType b)\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"rtlObjectType result;\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"result.value."</span>;
      c_expr.expr &amp;:= raw_type_value(object_type);
      c_expr.expr &amp;:= <span class="stri">"="</span>;
      process_create_call(object_type,
          <span class="stri">"((const_rtlObjectType *) &amp;b)->value."</span> &amp; raw_type_value(object_type),
          c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">";\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"return result.value.genericValue;\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"}\n\n"</span>;
      generic_create_declared @:= [object_type] TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_generic_destr_declaration (<span class="op">in</span> <span class="type">type</span>: object_type,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> object_type <span class="op">not</span> <span class="op">in</span> generic_destr_declared <span class="keywd">then</span>
      process_destr_declaration(object_type, c_expr);
      c_expr.expr &amp;:= <span class="stri">"static void generic_destr_"</span>;
      c_expr.expr &amp;:= str(typeNumber(object_type));
      c_expr.expr &amp;:= <span class="stri">" (const genericType b)\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      process_destr_call(object_type,
          <span class="stri">"((const_rtlObjectType *) &amp;b)->value."</span> &amp; raw_type_value(object_type),
          c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">"}\n\n"</span>;
      generic_destr_declared @:= [object_type] TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_generic_cmp_declaration (<span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">type</span>: object_type, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> object_type <span class="op">not</span> <span class="op">in</span> generic_cmp_declared <span class="keywd">then</span>
      process_cpy_declaration(object_type, c_expr);
      c_expr.expr &amp;:= <span class="stri">"static intType generic_cmp_"</span>;
      c_expr.expr &amp;:= str(typeNumber(object_type));
      c_expr.expr &amp;:= <span class="stri">" (const genericType a, const genericType b)\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"return o_"</span>;
      create_name(function, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">"(((const_rtlObjectType *) &amp;a)->value."</span>;
      c_expr.expr &amp;:= raw_type_value(object_type);
      c_expr.expr &amp;:= <span class="stri">", ((const_rtlObjectType *) &amp;b)->value."</span>;
      c_expr.expr &amp;:= raw_type_value(object_type);
      c_expr.expr &amp;:= <span class="stri">");\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"}\n\n"</span>;
      generic_cmp_declared @:= [object_type] TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_big_create_call (<span class="op">in</span> <span class="type">bigInteger</span>: number, <span class="keywd">inout</span> <span class="type">string</span>: expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> number = 0_ <span class="keywd">then</span>
      incr(countOptimizations);
      expr &amp;:= <span class="stri">"bigZero(); /* 0_ */\n"</span>;
    <span class="keywd">else</span>
      expr &amp;:= <span class="stri">"bigCreate("</span>;
      expr &amp;:= bigIntegerLiteral(number);
      expr &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_str_create_call (<span class="op">in</span> <span class="type">string</span>: stri, <span class="keywd">inout</span> <span class="type">string</span>: expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 2;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> stri = <span class="stri">""</span> <span class="keywd">then</span>
      incr(countOptimizations);
      expr &amp;:= <span class="stri">"strEmpty(); /* \"\" */\n"</span>;
    <span class="keywd">elsif</span> length(stri) = 1 <span class="keywd">then</span>
      incr(countOptimizations);
      expr &amp;:= <span class="stri">"chrStr("</span>;
      expr &amp;:= charLiteral(stri[1]);
      expr &amp;:= <span class="stri">"); /* "</span>;
      expr &amp;:= literal(stri);
      expr &amp;:= <span class="stri">" */\n"</span>;
    <span class="keywd">else</span>
      ch := stri[1];
      <span class="keywd">while</span> index &lt;= length(stri) <span class="op">and</span> ch = stri[index] <span class="keywd">do</span>
        incr(index);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">if</span> index > length(stri) <span class="keywd">then</span>
        incr(countOptimizations);
        <span class="keywd">if</span> ch = <span class="stri">'\0;'</span> <span class="keywd">then</span>
          expr &amp;:= <span class="stri">"strZero("</span>;
        <span class="keywd">else</span>
          expr &amp;:= <span class="stri">"strChMult("</span>;
          expr &amp;:= charLiteral(ch);
          expr &amp;:= <span class="stri">", "</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        expr &amp;:= integerLiteral(length(stri));
        expr &amp;:= <span class="stri">");\n"</span>;
      <span class="keywd">else</span>
        expr &amp;:= <span class="stri">"strCreate("</span>;
        expr &amp;:= stringLiteral(stri);
        expr &amp;:= <span class="stri">");\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getAnyParamToTempAssigns (<span class="op">in</span> expr_type: c_param, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> c_param.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.temp_decls &amp;:= c_param.result_decl;
      c_expr.temp_frees &amp;:= c_param.result_free;
      c_expr.temp_to_null &amp;:= c_param.result_to_null;
      c_expr.temp_assigns &amp;:= c_param.result_intro;
      c_expr.temp_assigns &amp;:= c_param.result_expr;
      c_expr.temp_assigns &amp;:= c_param.result_finish;
    <span class="keywd">else</span>
      c_expr.temp_assigns &amp;:= c_param.expr;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: getAnyParamToTempAssigns (<span class="op">in</span> <span class="type">reference</span>: aParam, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">category</span>: exprCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">reference</span>: paramValue <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: variableName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> expr_type: c_param <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    prepareAnyParamTemporarys(aParam, c_param, c_expr);
    <span class="keywd">if</span> aParam <span class="op">not</span> <span class="op">in</span> funcparam_data <span class="op">and</span>
        <span class="op">not</span> isFunc(getType(aParam)) <span class="op">and</span>
        aParam <span class="op">in</span> inlineParam <span class="op">and</span>
        inlineParam[aParam][1].paramValue &lt;> NIL <span class="keywd">then</span>
      paramValue := inlineParam[aParam][1].paramValue;
      exprCategory := category(paramValue);
      <span class="keywd">if</span> <span class="op">not</span> isVar(paramValue) <span class="op">and</span>
          (exprCategory = INTOBJECT <span class="op">or</span>
           exprCategory = FLOATOBJECT <span class="op">or</span>
           exprCategory = CHAROBJECT <span class="op">or</span>
           exprCategory = STRIOBJECT <span class="op">or</span>
           exprCategory = BSTRIOBJECT <span class="op">or</span>
           exprCategory = POINTLISTOBJECT) <span class="keywd">then</span>
        incr(c_expr.temp_num);
        variableName := <span class="stri">"tmp_"</span> &amp; str(c_expr.temp_num);
        c_expr.temp_decls &amp;:= type_name(getType(paramValue));
        c_expr.temp_decls &amp;:= <span class="stri">" "</span>;
        c_expr.temp_decls &amp;:= variableName;
        c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
        c_expr.temp_assigns &amp;:= <span class="stri">"("</span>;
        c_expr.temp_assigns &amp;:= variableName;
        c_expr.temp_assigns &amp;:= <span class="stri">"="</span>;
        getAnyParamToTempAssigns(c_param, c_expr);
        c_expr.temp_assigns &amp;:= <span class="stri">", &amp;"</span>;
        c_expr.temp_assigns &amp;:= variableName;
        c_expr.temp_assigns &amp;:= <span class="stri">")"</span>;
      <span class="keywd">else</span>
        c_expr.temp_assigns &amp;:= <span class="stri">"&amp;("</span>;
        getAnyParamToTempAssigns(c_param, c_expr);
        c_expr.temp_assigns &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      c_expr.temp_assigns &amp;:= <span class="stri">"&amp;("</span>;
      getAnyParamToTempAssigns(c_param, c_expr);
      c_expr.temp_assigns &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: enum_value (<span class="op">in</span> <span class="type">reference</span>: current_object) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: enumValue <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: enum_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">string</span>: object_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    enum_type := getType(current_object);
    <span class="keywd">if</span> enum_type <span class="op">in</span> typeCategory <span class="op">and</span> typeCategory[enum_type] = BOOLOBJECT <span class="keywd">then</span>
      object_name := str(current_object);
      <span class="keywd">if</span> object_name = <span class="stri">"FALSE"</span> <span class="keywd">then</span>
        enumValue := <span class="stri">"0/*FALSE*/"</span>;
      <span class="keywd">elsif</span> object_name = <span class="stri">"TRUE"</span> <span class="keywd">then</span>
        enumValue := <span class="stri">"1/*TRUE*/"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      enumValue := <span class="stri">"/*"</span> &amp; str(current_object) &amp; <span class="stri">"*/"</span>;
      <span class="keywd">if</span> enum_type <span class="op">in</span> enum_literal <span class="op">and</span>
          current_object <span class="op">in</span> enum_literal[enum_type] <span class="keywd">then</span>
        enumValue &amp;:= str(enum_literal[enum_type][current_object]);
      <span class="keywd">else</span>
        enumValue &amp;:= str(objNumber(current_object));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: reference_value (<span class="op">in</span> <span class="type">reference</span>: current_value,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> current_value = NIL <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"NULL"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;("</span>;
      process_expr(current_value, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: ref_list_value (<span class="op">in</span> <span class="type">ref_list</span>: current_value,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: element <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">boolean</span>: first_element <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(current_value) = 0 <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"NULL"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"{"</span>;
      <span class="keywd">for</span> element <span class="keywd">range</span> current_value <span class="keywd">do</span>
        <span class="keywd">if</span> first_element <span class="keywd">then</span>
          first_element := FALSE;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">", "</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"&amp;("</span>;
        process_expr(element, c_expr);
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      c_expr.expr &amp;:= <span class="stri">"}"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: getExprValue (<span class="op">in</span> <span class="type">reference</span>: current_expression, attr string) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: exprValue <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluated_expression <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> category(current_expression) = STRIOBJECT <span class="keywd">then</span>
      exprValue := getValue(current_expression, string);
    <span class="keywd">else</span>
      evaluated_expression := evaluate(prog, current_expression);
      <span class="keywd">if</span> evaluated_expression &lt;> NIL <span class="keywd">then</span>
        exprValue := getValue(evaluated_expression, string);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isPointerParam (<span class="op">in</span> <span class="type">reference</span>: a_param) <span class="keywd">is</span>
  <span class="keywd">return</span> category(a_param) = REFPARAMOBJECT <span class="op">and</span>
        (<span class="op">not</span> valueIsAtHeap(a_param) <span class="op">or</span> isVar(a_param));


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isCopyParam (<span class="op">in</span> <span class="type">reference</span>: a_param) <span class="keywd">is</span>
  <span class="keywd">return</span> category(a_param) = VALUEPARAMOBJECT <span class="op">and</span>
        valueIsAtHeap(a_param);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isInOutParam (<span class="op">in</span> <span class="type">reference</span>: a_param) <span class="keywd">is</span>
  <span class="keywd">return</span> category(a_param) = REFPARAMOBJECT <span class="op">and</span> isVar(a_param);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: canTakeAddress (<span class="op">in</span> <span class="type">reference</span>: an_expression) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: canTakeAddress <span class="keywd">is</span> TRUE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">category</span>: exprCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">string</span>: action_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    exprCategory := category(an_expression);
    <span class="keywd">if</span> (exprCategory = INTOBJECT <span class="op">or</span>
        exprCategory = CHAROBJECT <span class="op">or</span>
        exprCategory = CONSTENUMOBJECT <span class="op">or</span>
        exprCategory = FLOATOBJECT) <span class="op">and</span>
        <span class="op">not</span> isVar(an_expression) <span class="keywd">then</span>
      canTakeAddress := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> isFunc(getType(an_expression)) <span class="keywd">then</span>
      canTakeAddress := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> exprCategory = CALLOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> category(getValue(an_expression, ref_list)[1]) = ACTOBJECT <span class="keywd">then</span>
        action_name := str(getValue(getValue(an_expression, ref_list)[1], ACTION));
        <span class="keywd">if</span>  action_name = <span class="stri">"ARR_IDX"</span> <span class="op">or</span>
            action_name = <span class="stri">"SCT_SELECT"</span> <span class="keywd">then</span>
          canTakeAddress := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_constenumobject (<span class="op">in</span> <span class="type">reference</span>: function, <span class="op">in</span> <span class="type">ref_list</span>: params,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"/*constenumobject*/"</span>;
    noop_params(formalParams(function), params, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: param_list_okay (<span class="op">in</span> <span class="type">ref_list</span>: formal_params) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> TRUE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: obj <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">category</span>: paramCategory <span class="keywd">is</span> category.value;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> obj <span class="keywd">range</span> formal_params <span class="keywd">do</span>
      paramCategory := category(obj);
      <span class="keywd">if</span> paramCategory &lt;> SYMBOLOBJECT <span class="op">and</span> paramCategory &lt;> TYPEOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> isFunc(getType(obj)) <span class="keywd">then</span>
          okay := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: containsFunctionCall (<span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">reference</span>: current_expression) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: containsCall <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">category</span>: exprCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: currentFunction <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">integer</span>: paramNum <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    exprCategory := category(current_expression);
    <span class="keywd">if</span> exprCategory = MATCHOBJECT <span class="op">or</span> exprCategory = CALLOBJECT <span class="keywd">then</span>
      params := getValue(current_expression, ref_list);
      currentFunction := params[1];
      <span class="keywd">if</span> currentFunction = function <span class="keywd">then</span>
        containsCall := TRUE;
      <span class="keywd">else</span>
        paramNum := 2;
        <span class="keywd">while</span> paramNum &lt;= length(params) <span class="op">and</span> <span class="op">not</span> containsCall <span class="keywd">do</span>
          containsCall := containsFunctionCall(function, params[paramNum]);
          incr(paramNum);
        <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = BLOCKOBJECT <span class="keywd">then</span>
      containsCall := current_expression = function;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: recursiveFunctionCall (<span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">reference</span>: current_expression) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: recursiveCall <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: obj <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    recursiveCall := containsFunctionCall(function, current_expression);
    <span class="keywd">if</span> <span class="op">not</span> recursiveCall <span class="keywd">then</span>
      <span class="keywd">for</span> obj <span class="keywd">range</span> localConsts(function) <span class="keywd">do</span>
        <span class="keywd">if</span> <span class="op">not</span> recursiveCall <span class="op">and</span> category(obj) = BLOCKOBJECT <span class="keywd">then</span>
          recursiveCall := containsFunctionCall(function, body(obj));
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: identical_values (<span class="op">in</span> <span class="type">reference</span>: object1, <span class="op">in</span> <span class="type">reference</span>: object2) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: isIdentical <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: element1 <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">ref_list</span>: element_list2 <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">integer</span>: index2 <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> category(object1) <span class="keywd">of</span>
      <span class="keywd">when</span> {INTOBJECT}:
        isIdentical := getValue(object1, integer) = getValue(object2, integer);
      <span class="keywd">when</span> {BIGINTOBJECT}:
        isIdentical := getValue(object1, bigInteger) = getValue(object2, bigInteger);
      <span class="keywd">when</span> {CHAROBJECT}:
        isIdentical := getValue(object1, char) = getValue(object2, char);
      <span class="keywd">when</span> {STRIOBJECT}:
        isIdentical := getValue(object1, string) = getValue(object2, string);
      <span class="keywd">when</span> {BSTRIOBJECT}:
        isIdentical := getValue(object1, bstring) = getValue(object2, bstring);
      <span class="keywd">when</span> {SETOBJECT}:
        isIdentical := getValue(object1, bitset) = getValue(object2, bitset);
      <span class="keywd">when</span> {FLOATOBJECT}:
        isIdentical := getValue(object1, float) = getValue(object2, float);
      <span class="keywd">when</span> {REFOBJECT}:
        isIdentical := getValue(object1, reference) = getValue(object2, reference);
      <span class="keywd">when</span> {FILEOBJECT}:
        isIdentical := getValue(object1, clib_file) = getValue(object2, clib_file);
      <span class="keywd">when</span> {POINTLISTOBJECT}:
        isIdentical := getValue(object1, pointList) = getValue(object2, pointList);
      <span class="keywd">when</span> {CONSTENUMOBJECT, VARENUMOBJECT}:
        isIdentical := getValue(object1, reference) = getValue(object2, reference);
      <span class="keywd">when</span> {ARRAYOBJECT}:
        <span class="keywd">if</span> arrayMinIdx(object1) = arrayMinIdx(object2) <span class="op">and</span>
            arrayMaxIdx(object1) = arrayMaxIdx(object2) <span class="keywd">then</span>
          isIdentical := TRUE;
          element_list2 := arrayToList(object2);
          index2 := 1;
          <span class="keywd">for</span> element1 <span class="keywd">range</span> arrayToList(object1) <span class="keywd">until</span> <span class="op">not</span> isIdentical <span class="keywd">do</span>
            isIdentical := identical_values(element1, element_list2[index2]);
            incr(index2);
          <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {STRUCTOBJECT}:
        isIdentical := TRUE;
        element_list2 := structToList(object2);
        index2 := 1;
        <span class="keywd">for</span> element1 <span class="keywd">range</span> structToList(object1) <span class="keywd">until</span> <span class="op">not</span> isIdentical <span class="keywd">do</span>
          isIdentical := identical_values(element1, element_list2[index2]);
          incr(index2);
        <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: canUseArrTimes (<span class="op">in</span> <span class="type">type</span>: objectType, <span class="op">in</span> <span class="type">reference</span>: arrayValue,
    <span class="keywd">inout</span> <span class="type">reference</span>: repeatedElement) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: canUseArrTimes <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: elementType <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">ref_list</span>: array_list <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: element <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">reference</span>: previous_element <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">integer</span>: repeat_count <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> objectType <span class="op">in</span> array_element <span class="keywd">then</span>
      elementType := array_element[objectType];
      <span class="keywd">if</span> elementType <span class="op">in</span> typeCategory <span class="op">and</span>
          typeCategory[elementType] <span class="op">in</span> simpleValueType <span class="keywd">then</span>
        array_list := arrayToList(arrayValue);
        <span class="keywd">for</span> element <span class="keywd">range</span> array_list <span class="keywd">do</span>
          <span class="keywd">if</span> previous_element &lt;> NIL <span class="keywd">then</span>
            <span class="keywd">if</span> identical_values(previous_element, element) <span class="keywd">then</span>
              incr(repeat_count);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          previous_element := element;
        <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">if</span> repeat_count = arrayLength(arrayValue) <span class="keywd">then</span>
          canUseArrTimes := TRUE;
          repeatedElement := array_list[1];
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: assignArrayValue (<span class="op">in</span> <span class="type">type</span>: objectType, <span class="op">in</span> <span class="type">reference</span>: arrayValue,
    <span class="keywd">inout</span> expr_type: c_declaration) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: arraySize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reference</span>: repeatedElement <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: variableName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param_value <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    arraySize := arrayLength(arrayValue);
    <span class="keywd">if</span> evaluate_const_expr >= 2 <span class="op">and</span>
        arrayMinIdx(arrayValue) > arrayMaxIdx(arrayValue) <span class="keywd">then</span>
      <span class="keywd">if</span> FALSE <span class="op">and</span> inlineFunctions <span class="keywd">then</span>
        incr(c_declaration.temp_num);
        variableName := <span class="stri">"new_arr"</span> &lt;&amp; c_declaration.temp_num;
        c_declaration.temp_decls &amp;:= <span class="stri">";\n"</span>;
        c_declaration.temp_decls &amp;:= <span class="stri">"arrayType "</span>;
        c_declaration.temp_decls &amp;:= variableName;
        c_declaration.temp_assigns &amp;:= <span class="stri">"("</span>;
        c_declaration.temp_assigns &amp;:= variableName;
        c_declaration.temp_assigns &amp;:= <span class="stri">" = (arrayType) malloc(sizeof(struct rtlArrayStruct) - sizeof(rtlObjectType)), (unlikely("</span>;
        c_declaration.temp_assigns &amp;:= variableName;
        c_declaration.temp_assigns &amp;:= <span class="stri">" == NULL) ? "</span>;
        c_declaration.temp_assigns &amp;:= <span class="stri">"intRaiseError(MEMORY_ERROR) "</span>;
        c_declaration.temp_assigns &amp;:= <span class="stri">": 0), "</span>;
        c_declaration.temp_assigns &amp;:= variableName;
        c_declaration.temp_assigns &amp;:= <span class="stri">"->min_position = "</span>;
        c_declaration.temp_assigns &amp;:= integerLiteral(arrayMinIdx(arrayValue));
        c_declaration.temp_assigns &amp;:= <span class="stri">", "</span>;
        c_declaration.temp_assigns &amp;:= variableName;
        c_declaration.temp_assigns &amp;:= <span class="stri">"->max_position = "</span>;
        c_declaration.temp_assigns &amp;:= integerLiteral(arrayMaxIdx(arrayValue));
        c_declaration.temp_assigns &amp;:= <span class="stri">", "</span>;
        c_declaration.temp_assigns &amp;:= variableName;
        c_declaration.temp_assigns &amp;:= <span class="stri">");\n"</span>;
      <span class="keywd">else</span>
        c_declaration.temp_assigns &amp;:= <span class="stri">"arrMalloc("</span>;
        c_declaration.temp_assigns &amp;:= integerLiteral(arrayMinIdx(arrayValue));
        c_declaration.temp_assigns &amp;:= <span class="stri">", "</span>;
        c_declaration.temp_assigns &amp;:= integerLiteral(arrayMaxIdx(arrayValue));
        c_declaration.temp_assigns &amp;:= <span class="stri">");\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> evaluate_const_expr >= 2 <span class="op">and</span>
        canUseArrTimes(objectType, arrayValue, repeatedElement) <span class="op">and</span>
        category(repeatedElement) = INTOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> getValue(repeatedElement, integer) = 0 <span class="keywd">then</span>
        incr(c_declaration.temp_num);
        variableName := <span class="stri">"new_arr"</span> &lt;&amp; c_declaration.temp_num;
        c_declaration.temp_decls &amp;:= <span class="stri">";\n"</span>;
        c_declaration.temp_decls &amp;:= <span class="stri">"arrayType "</span>;
        c_declaration.temp_decls &amp;:= variableName;
        c_declaration.temp_assigns &amp;:= <span class="stri">"("</span>;
        c_declaration.temp_assigns &amp;:= variableName;
        <span class="keywd">if</span> inlineFunctions <span class="op">and</span>
            arrayMinIdx(arrayValue) >= -100000000 <span class="op">and</span> arrayMinIdx(arrayValue) &lt;= 100000000 <span class="op">and</span>
            arraySize &lt;= 100000000 <span class="keywd">then</span>
          <span class="comment"># The indices are okay and the size given to malloc() will not overflow.</span>
          c_declaration.temp_assigns &amp;:= <span class="stri">" = (arrayType) malloc(sizeof(struct rtlArrayStruct) + "</span>;
          c_declaration.temp_assigns &amp;:= integerLiteral(pred(arraySize));
          c_declaration.temp_assigns &amp;:= <span class="stri">" * sizeof(rtlObjectType)), (unlikely("</span>;
          c_declaration.temp_assigns &amp;:= variableName;
          c_declaration.temp_assigns &amp;:= <span class="stri">" == NULL) ? "</span>;
          c_declaration.temp_assigns &amp;:= <span class="stri">"intRaiseError(MEMORY_ERROR) "</span>;
          c_declaration.temp_assigns &amp;:= <span class="stri">": 0), "</span>;
          c_declaration.temp_assigns &amp;:= variableName;
          c_declaration.temp_assigns &amp;:= <span class="stri">"->min_position = "</span>;
          c_declaration.temp_assigns &amp;:= integerLiteral(arrayMinIdx(arrayValue));
          c_declaration.temp_assigns &amp;:= <span class="stri">", "</span>;
          c_declaration.temp_assigns &amp;:= variableName;
          c_declaration.temp_assigns &amp;:= <span class="stri">"->max_position = "</span>;
          c_declaration.temp_assigns &amp;:= integerLiteral(arrayMaxIdx(arrayValue));
        <span class="keywd">else</span>
          <span class="comment"># Use arrMalloc(), as it has detailed checks for indices and array size.</span>
          c_declaration.temp_assigns &amp;:= <span class="stri">" = arrMalloc("</span>;
          c_declaration.temp_assigns &amp;:= integerLiteral(arrayMinIdx(arrayValue));
          c_declaration.temp_assigns &amp;:= <span class="stri">", "</span>;
          c_declaration.temp_assigns &amp;:= integerLiteral(arrayMaxIdx(arrayValue));
          c_declaration.temp_assigns &amp;:= <span class="stri">")"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_declaration.temp_assigns &amp;:= <span class="stri">", memset("</span>;
        c_declaration.temp_assigns &amp;:= variableName;
        c_declaration.temp_assigns &amp;:= <span class="stri">"->arr, 0, "</span>;
        c_declaration.temp_assigns &amp;:= integerLiteral(arraySize);
        c_declaration.temp_assigns &amp;:= <span class="stri">" * sizeof(rtlObjectType)), "</span>;
        c_declaration.temp_assigns &amp;:= variableName;
        c_declaration.temp_assigns &amp;:= <span class="stri">");\n"</span>;
      <span class="keywd">else</span>
        c_declaration.temp_assigns &amp;:= <span class="stri">"arrTimes("</span>;
        c_declaration.temp_assigns &amp;:= integerLiteral(arrayMinIdx(arrayValue));
        c_declaration.temp_assigns &amp;:= <span class="stri">", "</span>;
        c_declaration.temp_assigns &amp;:= integerLiteral(arrayMaxIdx(arrayValue));
        c_declaration.temp_assigns &amp;:= <span class="stri">", (genericType)("</span>;
        c_declaration.temp_assigns &amp;:= integerLiteral(getValue(repeatedElement, integer));
        c_declaration.temp_assigns &amp;:= <span class="stri">"));\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      <span class="keywd">if</span> arrayValue <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
        const_table @:= [arrayValue] length(const_table);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      process_create_declaration(objectType, global_c_expr);
      param_value := <span class="stri">"arr["</span>;
      param_value &amp;:= str(const_table[arrayValue]);
      param_value &amp;:= <span class="stri">"]"</span>;
      process_create_call(objectType,
          param_value, c_declaration.temp_assigns);
      c_declaration.temp_assigns &amp;:= <span class="stri">";\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_local_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object, <span class="op">in</span> <span class="keywd">var</span> <span class="type">reference</span>: object_value,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: objectType <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">category</span>: valueCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> expr_type: c_declaration <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> expr_type: c_value <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">string</span>: param_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: param_value <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    c_declaration.temp_num := c_expr.temp_num;
    valueCategory := category(object_value);
    objectType := getType(current_object);
    <span class="keywd">if</span> objectType = getType(object_value) <span class="op">and</span> objectType <span class="op">not</span> <span class="op">in</span> typeCategory <span class="keywd">then</span>
      typeCategory @:= [objectType] valueCategory;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    declare_type_if_necessary(objectType, global_c_expr);
    c_declaration.temp_decls &amp;:= diagnosticLine(current_object);
    c_declaration.temp_decls &amp;:= type_name(objectType);
    c_declaration.temp_decls &amp;:= <span class="stri">" o_"</span>;
    create_name(current_object, c_declaration.temp_decls);
    <span class="keywd">if</span> objectType <span class="op">in</span> typeCategory <span class="op">and</span> typeCategory[objectType] = INTERFACEOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> valueCategory = INTERFACEOBJECT <span class="keywd">then</span>
        object_value := interfaceToStruct(object_value);
        valueCategory := category(object_value);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> isVar(object_value) <span class="keywd">then</span>
        c_declaration.temp_assigns &amp;:= diagnosticLine(current_object);
        c_declaration.temp_assigns &amp;:= <span class="stri">"o_"</span>;
        create_name(current_object, c_declaration.temp_assigns);
        c_declaration.temp_assigns &amp;:= <span class="stri">"=itfCreate(o_"</span>;
        create_name(object_value, c_declaration.temp_assigns);
        c_declaration.temp_assigns &amp;:= <span class="stri">"/* "</span>;
        c_declaration.temp_assigns &amp;:= str(valueCategory);
        c_declaration.temp_assigns &amp;:= <span class="stri">" */);\n"</span>;
      <span class="keywd">else</span>
        <span class="keywd">if</span> object_value <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
          const_table @:= [object_value] length(const_table);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_declaration.temp_assigns &amp;:= diagnosticLine(current_object);
        c_declaration.temp_assigns &amp;:= <span class="stri">"o_"</span>;
        create_name(current_object, c_declaration.temp_assigns);
        c_declaration.temp_assigns &amp;:= <span class="stri">"=("</span>;
        c_declaration.temp_assigns &amp;:= type_name(objectType);
        c_declaration.temp_assigns &amp;:= <span class="stri">")(itfCreate(itf["</span>;
        c_declaration.temp_assigns &amp;:= str(const_table[object_value]);
        c_declaration.temp_assigns &amp;:= <span class="stri">"]));\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      process_destr_declaration(objectType, global_c_expr);
      param_name := <span class="stri">"o_"</span>;
      create_name(current_object, param_name);
      process_destr_call(objectType, param_name, c_declaration.temp_frees);
    <span class="keywd">elsif</span> valueCategory = TYPEOBJECT <span class="keywd">then</span>
      c_declaration.temp_decls &amp;:= <span class="stri">"="</span>;
      c_declaration.temp_decls &amp;:= typeLiteral(getValue(object_value, type));
    <span class="keywd">elsif</span> valueCategory = INTOBJECT <span class="keywd">then</span>
      c_declaration.temp_decls &amp;:= <span class="stri">"="</span>;
      c_declaration.temp_decls &amp;:= integerLiteral(getValue(object_value, integer));
    <span class="keywd">elsif</span> valueCategory = BIGINTOBJECT <span class="keywd">then</span>
      c_declaration.temp_assigns &amp;:= diagnosticLine(current_object);
      c_declaration.temp_assigns &amp;:= <span class="stri">"o_"</span>;
      create_name(current_object, c_declaration.temp_assigns);
      c_declaration.temp_assigns &amp;:= <span class="stri">"="</span>;
      process_big_create_call(getValue(object_value, bigInteger), c_declaration.temp_assigns);
      c_declaration.temp_frees &amp;:= <span class="stri">"bigDestr(o_"</span>;
      create_name(current_object, c_declaration.temp_frees);
      c_declaration.temp_frees &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">elsif</span> valueCategory = CHAROBJECT <span class="keywd">then</span>
      c_declaration.temp_decls &amp;:= <span class="stri">"="</span>;
      c_declaration.temp_decls &amp;:= charLiteral(getValue(object_value, char));
    <span class="keywd">elsif</span> valueCategory = FLOATOBJECT <span class="keywd">then</span>
      c_declaration.temp_decls &amp;:= <span class="stri">"="</span>;
      c_declaration.temp_decls &amp;:= floatLiteral(getValue(object_value, float));
    <span class="keywd">elsif</span> valueCategory = STRIOBJECT <span class="keywd">then</span>
      c_declaration.temp_assigns &amp;:= diagnosticLine(current_object);
      c_declaration.temp_assigns &amp;:= <span class="stri">"o_"</span>;
      create_name(current_object, c_declaration.temp_assigns);
      c_declaration.temp_assigns &amp;:= <span class="stri">"="</span>;
      process_str_create_call(getValue(object_value, string), c_declaration.temp_assigns);
      c_declaration.temp_frees &amp;:= <span class="stri">"strDestr(o_"</span>;
      create_name(current_object, c_declaration.temp_frees);
      c_declaration.temp_frees &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">elsif</span> valueCategory = BSTRIOBJECT <span class="keywd">then</span>
      c_declaration.temp_assigns &amp;:= diagnosticLine(current_object);
      c_declaration.temp_assigns &amp;:= <span class="stri">"o_"</span>;
      create_name(current_object, c_declaration.temp_assigns);
      c_declaration.temp_assigns &amp;:= <span class="stri">"=bstCreate("</span>;
      c_declaration.temp_assigns &amp;:= bstriLiteral(getValue(object_value, bstring));
      c_declaration.temp_assigns &amp;:= <span class="stri">");\n"</span>;
      c_declaration.temp_frees &amp;:= <span class="stri">"bstDestr(o_"</span>;
      create_name(current_object, c_declaration.temp_frees);
      c_declaration.temp_frees &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">elsif</span> valueCategory = SETOBJECT <span class="keywd">then</span>
      c_declaration.temp_assigns &amp;:= diagnosticLine(current_object);
      c_declaration.temp_assigns &amp;:= <span class="stri">"o_"</span>;
      create_name(current_object, c_declaration.temp_assigns);
      c_declaration.temp_assigns &amp;:= <span class="stri">"=setCreate("</span>;
      c_declaration.temp_assigns &amp;:= bitsetLiteral(getValue(object_value, bitset));
      c_declaration.temp_assigns &amp;:= <span class="stri">");\n"</span>;
      c_declaration.temp_frees &amp;:= <span class="stri">"setDestr(o_"</span>;
      create_name(current_object, c_declaration.temp_frees);
      c_declaration.temp_frees &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">elsif</span> valueCategory = REFOBJECT <span class="keywd">then</span>
      c_declaration.temp_decls &amp;:= <span class="stri">"="</span>;
      reference_value(getValue(object_value, reference), c_value);
      c_declaration.temp_decls &amp;:= c_value.expr;
    <span class="keywd">elsif</span> valueCategory = REFLISTOBJECT <span class="keywd">then</span>
      c_declaration.temp_decls &amp;:= <span class="stri">"="</span>;
      ref_list_value(getValue(object_value, ref_list), c_value);
      c_declaration.temp_decls &amp;:= c_value.expr;
      c_declaration.temp_frees &amp;:= <span class="stri">"rflDestr(o_"</span>;
      create_name(current_object, c_declaration.temp_frees);
      c_declaration.temp_frees &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">elsif</span> valueCategory = FILEOBJECT <span class="keywd">then</span>
      c_declaration.temp_decls &amp;:= <span class="stri">"=&amp;"</span>;
      c_declaration.temp_decls &amp;:= lower(literal(getValue(object_value, clib_file)));
      c_declaration.temp_decls &amp;:= <span class="stri">"FileRecord"</span>;
      c_declaration.temp_frees &amp;:= <span class="stri">"filDestr(o_"</span>;
      create_name(current_object, c_declaration.temp_frees);
      c_declaration.temp_frees &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">elsif</span> valueCategory = SOCKETOBJECT <span class="keywd">then</span>
      c_declaration.temp_decls &amp;:= <span class="stri">"=-1"</span>;
    <span class="keywd">elsif</span> valueCategory = POLLOBJECT <span class="keywd">then</span>
      c_declaration.temp_assigns &amp;:= diagnosticLine(current_object);
      c_declaration.temp_assigns &amp;:= <span class="stri">"o_"</span>;
      create_name(current_object, c_declaration.temp_assigns);
      c_declaration.temp_assigns &amp;:= <span class="stri">"=polEmpty();\n"</span>;
      c_declaration.temp_frees &amp;:= <span class="stri">"polDestr(o_"</span>;
      create_name(current_object, c_declaration.temp_frees);
      c_declaration.temp_frees &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">elsif</span> valueCategory = ARRAYOBJECT <span class="keywd">then</span>
      c_declaration.temp_assigns &amp;:= diagnosticLine(current_object);
      c_declaration.temp_assigns &amp;:= <span class="stri">"o_"</span>;
      create_name(current_object, c_declaration.temp_assigns);
      c_declaration.temp_assigns &amp;:= <span class="stri">"="</span>;
      assignArrayValue(objectType, object_value, c_declaration);
      process_destr_declaration(objectType, global_c_expr);
      param_name := <span class="stri">"o_"</span>;
      create_name(current_object, param_name);
      process_destr_call(objectType, param_name, c_declaration.temp_frees);
    <span class="keywd">elsif</span> valueCategory = STRUCTOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> object_value <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
        const_table @:= [object_value] length(const_table);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      process_create_declaration(objectType, global_c_expr);
      process_destr_declaration(objectType, global_c_expr);
      c_declaration.temp_assigns &amp;:= diagnosticLine(current_object);
      c_declaration.temp_assigns &amp;:= <span class="stri">"o_"</span>;
      create_name(current_object, c_declaration.temp_assigns);
      c_declaration.temp_assigns &amp;:= <span class="stri">"="</span>;
      param_value := <span class="stri">"sct["</span>;
      param_value &amp;:= str(const_table[object_value]);
      param_value &amp;:= <span class="stri">"]"</span>;
      process_create_call(objectType,
          param_value, c_declaration.temp_assigns);
      c_declaration.temp_assigns &amp;:= <span class="stri">";\n"</span>;
      param_name := <span class="stri">"o_"</span>;
      create_name(current_object, param_name);
      process_destr_call(objectType, param_name, c_declaration.temp_frees);
    <span class="keywd">elsif</span> valueCategory = HASHOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> length(hashKeysToList(object_value)) = 0 <span class="keywd">then</span>
        process_destr_declaration(objectType, global_c_expr);
        incr(countOptimizations);
        c_declaration.temp_assigns &amp;:= diagnosticLine(current_object);
        c_declaration.temp_assigns &amp;:= <span class="stri">"o_"</span>;
        create_name(current_object, c_declaration.temp_assigns);
        c_declaration.temp_assigns &amp;:= <span class="stri">"=hshEmpty();\n"</span>;
      <span class="keywd">else</span>
        <span class="keywd">if</span> object_value <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
          const_table @:= [object_value] length(const_table);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        process_create_declaration(objectType, global_c_expr);
        process_destr_declaration(objectType, global_c_expr);
        c_declaration.temp_assigns &amp;:= diagnosticLine(current_object);
        c_declaration.temp_assigns &amp;:= <span class="stri">"o_"</span>;
        create_name(current_object, c_declaration.temp_assigns);
        c_declaration.temp_assigns &amp;:= <span class="stri">"="</span>;
        param_value := <span class="stri">"hsh["</span>;
        param_value &amp;:= str(const_table[object_value]);
        param_value &amp;:= <span class="stri">"]"</span>;
        process_create_call(objectType,
            param_value, c_declaration.temp_assigns);
        c_declaration.temp_assigns &amp;:= <span class="stri">";\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      param_name := <span class="stri">"o_"</span>;
      create_name(current_object, param_name);
      process_destr_call(objectType, param_name, c_declaration.temp_frees);
    <span class="keywd">elsif</span> valueCategory = INTERFACEOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> object_value <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
        const_table @:= [object_value] length(const_table);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_declaration.temp_assigns &amp;:= diagnosticLine(current_object);
      c_declaration.temp_assigns &amp;:= <span class="stri">"o_"</span>;
      create_name(current_object, c_declaration.temp_assigns);
      c_declaration.temp_assigns &amp;:= <span class="stri">"=itf["</span>;
      c_declaration.temp_assigns &amp;:= str(const_table[object_value]);
      c_declaration.temp_assigns &amp;:= <span class="stri">"];\n"</span>;
      process_destr_declaration(objectType, global_c_expr);
      param_name := <span class="stri">"o_"</span>;
      create_name(current_object, param_name);
      process_destr_call(objectType, param_name, c_declaration.temp_frees);
    <span class="keywd">elsif</span> valueCategory = WINOBJECT <span class="keywd">then</span>
      c_declaration.temp_assigns &amp;:= diagnosticLine(current_object);
      c_declaration.temp_assigns &amp;:= <span class="stri">"o_"</span>;
      create_name(current_object, c_declaration.temp_assigns);
      c_declaration.temp_assigns &amp;:= <span class="stri">"=drwCreate("</span>;
      c_declaration.temp_assigns &amp;:= windowLiteral(getValue(object_value, PRIMITIVE_WINDOW));
      c_declaration.temp_assigns &amp;:= <span class="stri">");\n"</span>;
      c_declaration.temp_frees &amp;:= <span class="stri">"drwDestr(o_"</span>;
      create_name(current_object, c_declaration.temp_frees);
      c_declaration.temp_frees &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">elsif</span> valueCategory = POINTLISTOBJECT <span class="keywd">then</span>
      c_declaration.temp_assigns &amp;:= diagnosticLine(current_object);
      c_declaration.temp_assigns &amp;:= <span class="stri">"o_"</span>;
      create_name(current_object, c_declaration.temp_assigns);
      c_declaration.temp_assigns &amp;:= <span class="stri">"=bstCreate("</span>;
      c_declaration.temp_assigns &amp;:= pointListLiteral(getValue(object_value, pointList));
      c_declaration.temp_assigns &amp;:= <span class="stri">");\n"</span>;
      c_declaration.temp_frees &amp;:= <span class="stri">"bstDestr(o_"</span>;
      create_name(current_object, c_declaration.temp_frees);
      c_declaration.temp_frees &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">elsif</span> valueCategory = PROCESSOBJECT <span class="keywd">then</span>
      c_declaration.temp_decls &amp;:= <span class="stri">"=NULL"</span>;
      c_declaration.temp_frees &amp;:= <span class="stri">"pcsDestr(o_"</span>;
      create_name(current_object, c_declaration.temp_frees);
      c_declaration.temp_frees &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">elsif</span> valueCategory = PROGOBJECT <span class="keywd">then</span>
      c_declaration.temp_decls &amp;:= <span class="stri">"=NULL"</span>;
      c_declaration.temp_frees &amp;:= <span class="stri">"prgDestr(o_"</span>;
      create_name(current_object, c_declaration.temp_frees);
      c_declaration.temp_frees &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">elsif</span> valueCategory = DATABASEOBJECT <span class="keywd">then</span>
      c_declaration.temp_decls &amp;:= <span class="stri">"=NULL"</span>;
      c_declaration.temp_frees &amp;:= <span class="stri">"sqlDestrDb(o_"</span>;
      create_name(current_object, c_declaration.temp_frees);
      c_declaration.temp_frees &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">elsif</span> valueCategory = SQLSTMTOBJECT <span class="keywd">then</span>
      c_declaration.temp_decls &amp;:= <span class="stri">"=NULL"</span>;
      c_declaration.temp_frees &amp;:= <span class="stri">"sqlDestrStmt(o_"</span>;
      create_name(current_object, c_declaration.temp_frees);
      c_declaration.temp_frees &amp;:= <span class="stri">");\n"</span>;
    <span class="keywd">elsif</span> valueCategory = CONSTENUMOBJECT <span class="keywd">then</span>
      c_declaration.temp_decls &amp;:= <span class="stri">"="</span>;
      c_declaration.temp_decls &amp;:= enum_value(getValue(object_value, reference));
    <span class="keywd">elsif</span> valueCategory = VARENUMOBJECT <span class="keywd">then</span>
      c_declaration.temp_decls &amp;:= <span class="stri">"="</span>;
      c_declaration.temp_decls &amp;:= enum_value(getValue(object_value, reference));
    <span class="keywd">elsif</span> valueCategory = ENUMLITERALOBJECT <span class="keywd">then</span>
      c_declaration.temp_decls &amp;:= <span class="stri">"=o_"</span>;
      create_name(object_value, c_declaration.temp_decls);
    <span class="keywd">elsif</span> valueCategory = CALLOBJECT <span class="keywd">then</span>
      param_name := <span class="stri">"o_"</span>;
      create_name(current_object, param_name);
      c_value.temp_num := c_declaration.temp_num;
      getTemporaryToResultExpr(object_value, c_value);
      c_declaration.temp_num := c_value.temp_num;
      c_expr.temp_decls   &amp;:= c_value.temp_decls;
      c_expr.temp_assigns &amp;:= c_value.temp_assigns;
      c_expr.temp_frees   &amp;:= c_value.temp_frees;
      c_expr.temp_to_null &amp;:= c_value.temp_to_null;
      c_declaration.temp_assigns &amp;:= diagnosticLine(current_object);
      c_declaration.temp_assigns &amp;:= param_name;
      c_declaration.temp_assigns &amp;:= <span class="stri">"=("</span>;
      c_declaration.temp_assigns &amp;:= type_name(objectType);
      c_declaration.temp_assigns &amp;:= <span class="stri">")("</span>;
      c_declaration.temp_assigns &amp;:= c_value.result_expr;
      c_declaration.temp_assigns &amp;:= <span class="stri">");\n"</span>;
      process_destr_declaration(objectType, global_c_expr);
      process_destr_call(objectType, param_name, c_declaration.temp_frees);
    <span class="keywd">elsif</span> valueCategory = BLOCKOBJECT <span class="keywd">then</span>
      create_name(object_value, objNumber(object_value), param_name);
      c_value.temp_num := c_declaration.temp_num;
      processFuncValue(param_name, objectType, object_value, c_value);
      c_declaration.temp_num := c_value.temp_num;
      c_declaration.temp_decls &amp;:= <span class="stri">"="</span>;
      c_declaration.temp_decls &amp;:= c_value.expr;
      c_expr.temp_decls   &amp;:= c_value.temp_decls;
      c_expr.temp_assigns &amp;:= c_value.temp_assigns;
      c_expr.temp_frees   &amp;:= c_value.temp_frees;
      c_expr.temp_to_null &amp;:= c_value.temp_to_null;
      function_declared @:= [object_value] TRUE;
      function_var_declared @:= [current_object] TRUE;
    <span class="keywd">elsif</span> valueCategory = ACTOBJECT <span class="keywd">then</span>
      c_declaration.temp_decls &amp;:= <span class="stri">"=NULL"</span>;
    <span class="keywd">else</span>
      c_declaration.temp_decls &amp;:= <span class="stri">"/* "</span>;
      c_declaration.temp_decls &amp;:= str(valueCategory);
      c_declaration.temp_decls &amp;:= <span class="stri">" */"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_declaration.temp_decls &amp;:= <span class="stri">";\n"</span>;
    c_expr.temp_num := c_declaration.temp_num;
    c_expr.temp_decls   &amp;:= c_declaration.temp_decls;
    c_expr.temp_assigns &amp;:= c_declaration.temp_assigns;
    c_expr.temp_frees   &amp;:= c_declaration.temp_frees;
    c_expr.temp_to_null &amp;:= c_declaration.temp_to_null;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_local_var_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: objects <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: obj <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    objects := localVars(current_object);
    <span class="keywd">for</span> obj <span class="keywd">range</span> objects <span class="keywd">do</span>
      process_local_declaration(obj, getValue(obj, reference), c_expr);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: determineDataForActualFuncParam (<span class="op">in</span> <span class="type">reference</span>: current_expression,
    <span class="keywd">inout</span> <span class="type">ref_list</span>: data_list) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">category</span>: paramCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: aParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    paramCategory := category(current_expression);
    <span class="keywd">if</span> paramCategory = MATCHOBJECT <span class="op">or</span> paramCategory = CALLOBJECT <span class="keywd">then</span>
      params := getValue(current_expression, ref_list);
      <span class="keywd">for</span> aParam <span class="keywd">range</span> params <span class="keywd">do</span>
        determineDataForActualFuncParam(aParam, data_list);
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">elsif</span> paramCategory = LOCALVOBJECT <span class="op">or</span>
          paramCategory = VALUEPARAMOBJECT <span class="op">or</span>
          paramCategory = REFPARAMOBJECT <span class="op">or</span>
          paramCategory = RESULTOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> current_expression <span class="op">not</span> <span class="op">in</span> data_list <span class="keywd">then</span>
        data_list &amp;:= make_list(current_expression);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">ref_list</span>: determineDataForActualFuncParam (<span class="op">in</span> <span class="type">reference</span>: current_expression) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: data_list <span class="keywd">is</span> ref_list.EMPTY;
  <span class="keywd">begin</span>
    determineDataForActualFuncParam(current_expression, data_list);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: defineFunctype (<span class="op">in</span> <span class="type">string</span>: valueName, <span class="op">in</span> <span class="type">reference</span>: actual_param,
    <span class="op">in</span> <span class="type">ref_list</span>: data_list, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: dataItem <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">string</span>: data_value <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"typedef struct {\n"</span>;
    c_expr.expr &amp;:= type_name(resultType(getType(actual_param)));
    c_expr.expr &amp;:= <span class="stri">" (*func) (void *data_"</span>;
    c_expr.expr &amp;:= valueName;
    c_expr.expr &amp;:= <span class="stri">");\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"struct {\n"</span>;
    <span class="keywd">for</span> dataItem <span class="keywd">range</span> data_list <span class="keywd">do</span>
      <span class="keywd">if</span> <span class="op">not</span> isVar(dataItem) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"const "</span>;
        <span class="keywd">if</span> useConstPrefix(dataItem) <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"const_"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= type_name(getType(dataItem));
      <span class="keywd">if</span> isFunc(getType(dataItem)) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">" data_"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">" *data_"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      create_name(dataItem, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">";\n"</span>;
      <span class="keywd">if</span> isFunc(getType(dataItem)) <span class="keywd">then</span>
        data_value := <span class="stri">"((functype_"</span>;
        data_value &amp;:= valueName;
        data_value &amp;:= <span class="stri">" *) data_"</span>;
        data_value &amp;:= valueName;
        data_value &amp;:= <span class="stri">")->data.data_"</span>;
        create_name(dataItem, data_value);
        data_value &amp;:= <span class="stri">"->func(((functype_"</span>;
        data_value &amp;:= valueName;
        data_value &amp;:= <span class="stri">" *) data_"</span>;
        data_value &amp;:= valueName;
        data_value &amp;:= <span class="stri">")->data.data_"</span>;
        create_name(dataItem, data_value);
        data_value &amp;:= <span class="stri">")"</span>;
        <span class="keywd">if</span> getType(dataItem) = proctype <span class="keywd">then</span>
          data_value &amp;:= <span class="stri">";\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        data_value := <span class="stri">"*((functype_"</span>;
        data_value &amp;:= valueName;
        data_value &amp;:= <span class="stri">" *) data_"</span>;
        data_value &amp;:= valueName;
        data_value &amp;:= <span class="stri">")->data.data_"</span>;
        create_name(dataItem, data_value);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      funcparam_data @:= [dataItem] data_value;
      data_value := <span class="stri">"((functype_"</span>;
      data_value &amp;:= valueName;
      data_value &amp;:= <span class="stri">" *) data_"</span>;
      data_value &amp;:= valueName;
      data_value &amp;:= <span class="stri">")->data.data_"</span>;
      create_name(dataItem, data_value);
      funcparam_reference @:= [dataItem] data_value;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    c_expr.expr &amp;:= <span class="stri">"} data;\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"} functype_"</span>;
    c_expr.expr &amp;:= valueName;
    c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: defineActualFuncParam (<span class="op">in</span> <span class="type">type</span>: resultType, <span class="op">in</span> <span class="type">string</span>: valueName,
    <span class="op">in</span> <span class="type">reference</span>: actual_param, <span class="op">in</span> <span class="type">ref_list</span>: data_list, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">funcparam_data_hash</span>: funcparam_data_backup <span class="keywd">is</span> funcparam_data_hash.EMPTY_HASH;
    <span class="keywd">var</span> <span class="type">funcparam_data_hash</span>: funcparam_reference_backup <span class="keywd">is</span> funcparam_data_hash.EMPTY_HASH;
    <span class="keywd">var</span> expr_type: c_func_body <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    funcparam_data_backup := funcparam_data;
    funcparam_reference_backup := funcparam_reference;
    <span class="keywd">if</span> data_list &lt;> ref_list.EMPTY <span class="keywd">then</span>
      defineFunctype(valueName, actual_param, data_list, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">"static "</span>;
    c_expr.expr &amp;:= type_name(resultType);
    c_expr.expr &amp;:= <span class="stri">" func_"</span>;
    c_expr.expr &amp;:= valueName;
    c_expr.expr &amp;:= <span class="stri">" (void *data_"</span>;
    c_expr.expr &amp;:= valueName;
    c_expr.expr &amp;:= <span class="stri">")\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
    c_func_body.demand := REQUIRE_RESULT;
    <span class="keywd">if</span> category(actual_param) = BLOCKOBJECT <span class="keywd">then</span>
      process_call_by_name_expr(body(actual_param), c_func_body);
    <span class="keywd">else</span>
      process_call_by_name_expr(actual_param, c_func_body);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    appendWithDiagnostic(c_func_body.temp_decls, c_expr);
    appendWithDiagnostic(c_func_body.temp_assigns, c_expr);
    <span class="keywd">if</span> getType(actual_param) = proctype <span class="keywd">then</span>
      c_expr.expr &amp;:= c_func_body.expr;
      appendWithDiagnostic(c_func_body.temp_frees, c_expr);
    <span class="keywd">else</span>
      <span class="keywd">if</span> c_func_body.temp_frees &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        c_expr.expr &amp;:= type_name(resultType);
        c_expr.expr &amp;:= <span class="stri">" result="</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= diagnosticLine(actual_param);
        c_expr.expr &amp;:= <span class="stri">"return "</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> c_func_body.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        c_expr.expr &amp;:= c_func_body.result_expr;
      <span class="keywd">elsif</span> valueIsAtHeap(resultType) <span class="keywd">then</span>
        process_create_declaration(resultType, global_c_expr);
        process_create_call(resultType, c_func_body.expr, c_expr.expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= c_func_body.expr;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">";\n"</span>;
      <span class="keywd">if</span> c_func_body.temp_frees &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        appendWithDiagnostic(c_func_body.temp_frees, c_expr);
        c_expr.expr &amp;:= <span class="stri">"return result;\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">"}\n\n"</span>;
    funcparam_data := funcparam_data_backup;
    funcparam_reference := funcparam_reference_backup;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: defineFuncValue (<span class="op">in</span> <span class="type">string</span>: valueName, <span class="op">in</span> <span class="type">type</span>: genericFuncType,
    <span class="op">in</span> <span class="type">ref_list</span>: data_list, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: dataItem <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    incr(c_expr.temp_num);
    <span class="keywd">if</span> data_list &lt;> ref_list.EMPTY <span class="keywd">then</span>
      c_expr.temp_decls &amp;:= <span class="stri">"functype_"</span>;
      c_expr.temp_decls &amp;:= valueName;
    <span class="keywd">else</span>
      c_expr.temp_decls &amp;:= <span class="stri">"struct_"</span>;
      c_expr.temp_decls &amp;:= type_name(genericFuncType);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.temp_decls &amp;:= <span class="stri">" funcvalue_"</span>;
    c_expr.temp_decls &amp;:= valueName;
    c_expr.temp_decls &amp;:= <span class="stri">";\n\n"</span>;
    c_expr.temp_assigns &amp;:= <span class="stri">"funcvalue_"</span>;
    c_expr.temp_assigns &amp;:= valueName;
    c_expr.temp_assigns &amp;:= <span class="stri">".func = func_"</span>;
    c_expr.temp_assigns &amp;:= valueName;
    c_expr.temp_assigns &amp;:= <span class="stri">";\n"</span>;
    <span class="keywd">for</span> dataItem <span class="keywd">range</span> data_list <span class="keywd">do</span>
      c_expr.temp_assigns &amp;:= <span class="stri">"funcvalue_"</span>;
      c_expr.temp_assigns &amp;:= valueName;
      c_expr.temp_assigns &amp;:= <span class="stri">".data.data_"</span>;
      create_name(dataItem, c_expr.temp_assigns);
      c_expr.temp_assigns &amp;:= <span class="stri">" = "</span>;
      <span class="keywd">if</span> isFunc(getType(dataItem)) <span class="keywd">then</span>
        c_expr.temp_assigns &amp;:= <span class="stri">"o_"</span>;
        create_name(dataItem, c_expr.temp_assigns);
      <span class="keywd">else</span>
        getAnyParamToTempAssigns(dataItem, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.temp_assigns &amp;:= <span class="stri">";\n"</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: callActualFuncParam (<span class="op">in</span> <span class="type">string</span>: valueName, <span class="op">in</span> <span class="type">type</span>: genericFuncType,
    <span class="op">in</span> <span class="type">ref_list</span>: data_list, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> data_list &lt;> ref_list.EMPTY <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      c_expr.expr &amp;:= type_name(genericFuncType);
      c_expr.expr &amp;:= <span class="stri">" *)("</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">"&amp;funcvalue_"</span>;
    c_expr.expr &amp;:= valueName;
    <span class="keywd">if</span> data_list &lt;> ref_list.EMPTY <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: processFuncValue (<span class="op">in</span> <span class="type">string</span>: valueName, <span class="op">in</span> <span class="type">type</span>: genericFuncType,
    <span class="op">in</span> <span class="type">reference</span>: closure, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: data_list <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> expr_type: function_c_expr <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    declare_type_if_necessary(genericFuncType, global_c_expr);
    data_list := determineDataForActualFuncParam(closure);
    <span class="keywd">if</span> closure <span class="op">not</span> <span class="op">in</span> definedActualFuncParams <span class="keywd">then</span>
      function_c_expr.currentFile := file(closure);
      function_c_expr.currentLine := line(closure);
      defineActualFuncParam(resultType(genericFuncType), valueName, closure,
                            data_list, function_c_expr);
      global_c_expr.expr  &amp;:= function_c_expr.temp_decls;
      global_init.expr    &amp;:= function_c_expr.temp_assigns;
      global_c_expr.expr  &amp;:= function_c_expr.expr;
      definedActualFuncParams @:= [closure] TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    defineFuncValue(valueName, genericFuncType, data_list, c_expr);
    <span class="keywd">if</span> data_list &lt;> ref_list.EMPTY <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      c_expr.expr &amp;:= type_name(genericFuncType);
      c_expr.expr &amp;:= <span class="stri">")("</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">"&amp;funcvalue_"</span>;
    c_expr.expr &amp;:= valueName;
    <span class="keywd">if</span> data_list &lt;> ref_list.EMPTY <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: processFuncParam (<span class="op">in</span> <span class="type">reference</span>: formal_param,
    <span class="op">in</span> <span class="type">reference</span>: actual_param, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: valueName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    create_name(formal_param, objNumber(actual_param), valueName);
    processFuncValue(valueName, getType(formal_param), actual_param, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: checkParameterAliasing (<span class="op">in</span> <span class="type">ref_list</span>: formalParams,
    <span class="op">in</span> <span class="type">ref_list</span>: actualParams, <span class="op">in</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: checkedParamNumber <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reference</span>: formalParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">reference</span>: checkedActualInOutParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">integer</span>: paramNumber <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reference</span>: actualParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">bitset</span>: alreadyComplained <span class="keywd">is</span> {};
  <span class="keywd">begin</span>
    <span class="keywd">for</span> checkedParamNumber <span class="keywd">range</span> 1 <span class="keywd">to</span> length(formalParams) <span class="keywd">do</span>
      formalParam := formalParams[checkedParamNumber];
      <span class="keywd">if</span> isInOutParam(formalParam) <span class="keywd">then</span>
        checkedActualInOutParam := actualParams[checkedParamNumber];
        <span class="keywd">for</span> paramNumber <span class="keywd">range</span> 1 <span class="keywd">to</span> length(actualParams) <span class="keywd">do</span>
          actualParam := actualParams[paramNumber];
          <span class="keywd">if</span> paramNumber &lt;> checkedParamNumber <span class="op">and</span>
              actualParam = checkedActualInOutParam <span class="keywd">then</span>
            <span class="keywd">if</span> isInOutParam(formalParams[paramNumber]) <span class="keywd">then</span>
              <span class="keywd">if</span> checkedParamNumber <span class="op">not</span> <span class="op">in</span> alreadyComplained <span class="keywd">then</span>
                error(VARIABLE_USED_FOR_TWO_INOUT_PARAMETERS,
                      actualParam, formalParam, c_expr);
                incl(alreadyComplained, checkedParamNumber);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">elsif</span> category(formalParams[paramNumber]) = REFPARAMOBJECT <span class="keywd">then</span>
              error(VARIABLE_USED_AS_INOUT_AND_REF_PARAMETER,
                    actualParam, formalParam, formalParams[paramNumber], c_expr);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: call_params (<span class="op">in</span> <span class="type">ref_list</span>: formal_params,
    <span class="op">in</span> <span class="type">ref_list</span>: actual_params, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reference</span>: formal_param <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">reference</span>: actual_param <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">category</span>: paramCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">boolean</span>: first_element <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">integer</span>: temp_num <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    checkParameterAliasing(formal_params, actual_params, c_expr);
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> length(actual_params) <span class="keywd">do</span>
      formal_param := formal_params[number];
      actual_param := actual_params[number];
      paramCategory := category(formal_param);
      <span class="keywd">if</span> paramCategory &lt;> SYMBOLOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> paramCategory = TYPEOBJECT <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"/* attr t_"</span>;
          c_expr.expr &amp;:= str(typeNumber(getValue(formal_param, type)));
          c_expr.expr &amp;:= <span class="stri">" "</span>;
          c_expr.expr &amp;:= str(getValue(formal_param, type));
          c_expr.expr &amp;:= <span class="stri">"*/ "</span>;
        <span class="keywd">elsif</span> getType(formal_param) &lt;> voidtype <span class="keywd">then</span>
          <span class="keywd">if</span> first_element <span class="keywd">then</span>
            first_element := FALSE;
          <span class="keywd">else</span>
            c_expr.expr &amp;:= <span class="stri">", "</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> isPointerParam(formal_param) <span class="keywd">then</span>
            <span class="keywd">if</span> category(actual_param) = REFPARAMOBJECT <span class="keywd">then</span>
              <span class="keywd">if</span> actual_param <span class="op">in</span> inlineParam <span class="op">and</span>
                  inlineParam[actual_param][1].paramNum &lt;> 0 <span class="keywd">then</span>
                c_expr.expr &amp;:= <span class="stri">"par_"</span>;
                c_expr.expr &amp;:= str(inlineParam[actual_param][1].paramNum);
                c_expr.expr &amp;:= <span class="stri">"_"</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> actual_param <span class="op">in</span> funcparam_reference <span class="keywd">then</span>
                c_expr.expr &amp;:= funcparam_reference[actual_param];
              <span class="keywd">else</span>
                c_expr.expr &amp;:= <span class="stri">"o_"</span>;
                create_name(actual_param, c_expr.expr);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">elsif</span> category(actual_param) = MATCHOBJECT <span class="keywd">then</span>
              <span class="keywd">if</span> getValue(actual_param, ref_list)[1] <span class="op">in</span> function_var_declared <span class="keywd">then</span>
                c_expr.expr &amp;:= <span class="stri">"o_"</span>;
                create_name(getValue(actual_param, ref_list)[1], c_expr.expr);
              <span class="keywd">else</span>
                processFuncParam(formal_param, actual_param, c_expr);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">elsif</span> category(actual_param) = BLOCKOBJECT <span class="keywd">then</span>
              <span class="keywd">if</span> actual_param <span class="op">in</span> function_var_declared <span class="keywd">then</span>
                c_expr.expr &amp;:= <span class="stri">"o_"</span>;
                create_name(actual_param, c_expr.expr);
              <span class="keywd">else</span>
                processFuncParam(formal_param, actual_param, c_expr);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">elsif</span> category(actual_param) = LOCALVOBJECT <span class="op">and</span>
                actual_param <span class="op">in</span> function_var_declared <span class="keywd">then</span>
              c_expr.expr &amp;:= <span class="stri">"o_"</span>;
              create_name(actual_param, c_expr.expr);
            <span class="keywd">elsif</span> canTakeAddress(actual_param) <span class="keywd">then</span>
              c_expr.expr &amp;:= <span class="stri">"&amp;("</span>;
              process_expr(actual_param, c_expr);
              c_expr.expr &amp;:= <span class="stri">")"</span>;
            <span class="keywd">else</span>
              c_expr.expr &amp;:= <span class="stri">"/* "</span>;
              c_expr.expr &amp;:= str(category(actual_param));
              c_expr.expr &amp;:= <span class="stri">" */"</span>;
              incr(c_expr.temp_num);
              temp_num := c_expr.temp_num;
              c_expr.temp_decls &amp;:= type_name(getExprResultType(actual_param));
              c_expr.temp_decls &amp;:= <span class="stri">" tmp_"</span>;
              c_expr.temp_decls &amp;:= str(temp_num);
              c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
              c_expr.expr &amp;:= <span class="stri">"(tmp_"</span>;
              c_expr.expr &amp;:= str(temp_num);
              c_expr.expr &amp;:= <span class="stri">"=("</span>;
              c_expr.expr &amp;:= type_name(getExprResultType(actual_param));
              c_expr.expr &amp;:= <span class="stri">")("</span>;
              getAnyParamToExpr(actual_param, c_expr);
              c_expr.expr &amp;:= <span class="stri">"), &amp;tmp_"</span>;
              c_expr.expr &amp;:= str(temp_num);
              c_expr.expr &amp;:= <span class="stri">")"</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            getAnyParamToExpr(actual_param, c_expr);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_prototype_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_func_call (<span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: actual_params, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: function_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: result_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">ref_list</span>: formal_params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> expr_type: c_params <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> function <span class="op">not</span> <span class="op">in</span> prototype_declared <span class="keywd">then</span>
      process_prototype_declaration(function, global_c_expr);
      prototype_declared @:= [function] TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    function_type := getType(function);
    result_type := resultType(function_type);
    formal_params := formalParams(function);
    c_params.currentFile := c_expr.currentFile;
    c_params.currentLine := c_expr.currentLine;
    <span class="keywd">if</span> valueIsAtHeap(result_type) <span class="op">and</span>
        <span class="op">not</span> isVarfunc(function_type) <span class="op">and</span>
        function <span class="op">not</span> <span class="op">in</span> return_ref_to_value <span class="keywd">then</span>
      prepare_typed_result(result_type, c_expr);
      c_expr.result_expr := <span class="stri">"o_"</span>;
      create_name(function, c_expr.result_expr);
      c_expr.result_expr &amp;:= <span class="stri">"("</span>;
      c_params.temp_num := c_expr.temp_num;
      call_params(formal_params, actual_params, c_params);
      c_expr.temp_num := c_params.temp_num;
      c_expr.temp_decls &amp;:= c_params.temp_decls;
      c_expr.temp_assigns &amp;:= c_params.temp_assigns;
      c_expr.temp_frees &amp;:= c_params.temp_frees;
      c_expr.temp_to_null &amp;:= c_params.temp_to_null;
      c_expr.result_expr &amp;:= c_params.expr;
      c_expr.result_expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">elsif</span> result_type = voidtype <span class="keywd">then</span>
      c_params.temp_num := c_expr.temp_num;
      call_params(formal_params, actual_params, c_params);
      c_expr.temp_num := c_params.temp_num;
      <span class="keywd">if</span> c_params.temp_decls &lt;> <span class="stri">""</span> <span class="op">or</span> c_params.temp_assigns &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
        appendWithDiagnostic(c_params.temp_decls, c_expr);
        appendWithDiagnostic(c_params.temp_assigns, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      setDiagnosticLine(c_expr);
      <span class="keywd">if</span> isVarfunc(function_type) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"*o_"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      create_name(function, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      c_expr.expr &amp;:= c_params.expr;
      c_expr.expr &amp;:= <span class="stri">")"</span>;
      c_expr.expr &amp;:= <span class="stri">";\n"</span>;
      <span class="keywd">if</span> c_params.temp_decls &lt;> <span class="stri">""</span> <span class="op">or</span> c_params.temp_assigns &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        appendWithDiagnostic(c_params.temp_frees, c_expr);
        setDiagnosticLine(c_expr);
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      <span class="keywd">if</span> isVarfunc(function_type) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"*o_"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      create_name(function, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      call_params(formal_params, actual_params, c_expr);
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_func_call (<span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: actual_params, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: result_type <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isVar(function) <span class="keywd">then</span>
      <span class="keywd">if</span> getType(function) = proctype <span class="keywd">then</span>
        setDiagnosticLine(c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      result_type := resultType(getType(function));
      <span class="keywd">if</span> valueIsAtHeap(result_type) <span class="keywd">then</span>
        prepare_typed_result(result_type, c_expr);
        c_expr.result_expr &amp;:= <span class="stri">"o_"</span>;
        create_name(function, c_expr.result_expr);
        c_expr.result_expr &amp;:= <span class="stri">"->func(o_"</span>;
        create_name(function, c_expr.result_expr);
        c_expr.result_expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(function, c_expr.expr);
        c_expr.expr &amp;:= <span class="stri">"->func(o_"</span>;
        create_name(function, c_expr.expr);
        c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">if</span> getType(function) = proctype <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      process_const_func_call(function, actual_params, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_call (<span class="op">in</span> <span class="type">reference</span>: current_expression, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: function <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">category</span>: functionCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">reference</span>: obj <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">boolean</span>: first_element <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    c_expr.currentFile := file(current_expression);
    c_expr.currentLine := line(current_expression);
    params := getValue(current_expression, ref_list);
    function := params[1];
    params := params[2 ..];
    functionCategory := category(function);
    <span class="comment"># c_expr.expr &amp;:= "/* process_call ";</span>
    <span class="comment"># c_expr.expr &amp;:= str(current_expression);</span>
    <span class="comment"># c_expr.expr &amp;:= " ";</span>
    <span class="comment"># c_expr.expr &amp;:= str(function);</span>
    <span class="comment"># c_expr.expr &amp;:= " */";</span>
    <span class="keywd">if</span> functionCategory = ACTOBJECT <span class="keywd">then</span>
      process_action(function, params, c_expr);
    <span class="keywd">elsif</span> functionCategory = BLOCKOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> function <span class="op">in</span> function_not_declared <span class="op">or</span>
          (function <span class="op">not</span> <span class="op">in</span> prototype_declared <span class="op">and</span>
           isFunctionCallingSpecialAction(function)) <span class="keywd">then</span>
        process_inline(function, params, c_expr);
      <span class="keywd">else</span>
        process_func_call(function, params, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> functionCategory = LOCALVOBJECT <span class="keywd">then</span>
      process_func_call(function, params, c_expr);
    <span class="keywd">elsif</span> functionCategory = CONSTENUMOBJECT <span class="keywd">then</span>
      <span class="comment">(* process_constenumobject(function, params, c_expr); *)</span>
      process_expr(function, c_expr);
    <span class="keywd">elsif</span> functionCategory = REFPARAMOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isFunc(getType(function)) <span class="op">or</span>
          isVarfunc(getType(function)) <span class="keywd">then</span>
        <span class="keywd">if</span> function <span class="op">in</span> inlineParam <span class="keywd">then</span>
          process_inline_param(function, c_expr);
        <span class="keywd">else</span>
          <span class="keywd">if</span> getType(function) = proctype <span class="keywd">then</span>
            setDiagnosticLine(c_expr);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">"o_"</span>;
          create_name(function, c_expr.expr);
          c_expr.expr &amp;:= <span class="stri">"->func(o_"</span>;
          create_name(function, c_expr.expr);
          c_expr.expr &amp;:= <span class="stri">")"</span>;
          <span class="keywd">if</span> getType(function) = proctype <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">";\n"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        process_expr(function, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> functionCategory = VALUEPARAMOBJECT <span class="op">or</span>
          functionCategory = INTOBJECT <span class="op">or</span>
          functionCategory = BIGINTOBJECT <span class="op">or</span>
          functionCategory = FLOATOBJECT <span class="op">or</span>
          functionCategory = CHAROBJECT <span class="op">or</span>
          functionCategory = STRIOBJECT <span class="op">or</span>
          functionCategory = BSTRIOBJECT <span class="op">or</span>
          functionCategory = ARRAYOBJECT <span class="op">or</span>
          functionCategory = HASHOBJECT <span class="op">or</span>
          functionCategory = SETOBJECT <span class="op">or</span>
          functionCategory = STRUCTOBJECT <span class="op">or</span>
          functionCategory = INTERFACEOBJECT <span class="op">or</span>
          functionCategory = FILEOBJECT <span class="op">or</span>
          functionCategory = POLLOBJECT <span class="op">or</span>
          functionCategory = WINOBJECT <span class="op">or</span>
          functionCategory = POINTLISTOBJECT <span class="op">or</span>
          functionCategory = PROCESSOBJECT <span class="op">or</span>
          functionCategory = PROGOBJECT <span class="op">or</span>
          functionCategory = DATABASEOBJECT <span class="op">or</span>
          functionCategory = SQLSTMTOBJECT <span class="op">or</span>
          functionCategory = ENUMLITERALOBJECT <span class="op">or</span>
          functionCategory = TYPEOBJECT <span class="keywd">then</span>
      process_expr(function, c_expr);
    <span class="keywd">elsif</span> functionCategory = REFOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(function, c_expr.expr);
    <span class="keywd">elsif</span> functionCategory = REFLISTOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(function, c_expr.expr);
    <span class="keywd">elsif</span> functionCategory = FORWARDOBJECT <span class="keywd">then</span>
      error(FORWARD_CALLED, current_expression, function);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"/*[ "</span>;
      c_expr.expr &amp;:= str(functionCategory);
      c_expr.expr &amp;:= <span class="stri">" ]*/"</span>;
      c_expr.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(function, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      <span class="keywd">for</span> obj <span class="keywd">range</span> params <span class="keywd">do</span>
        <span class="keywd">if</span> category(obj) &lt;> SYMBOLOBJECT <span class="keywd">then</span>
          <span class="keywd">if</span> first_element <span class="keywd">then</span>
            first_element := FALSE;
          <span class="keywd">else</span>
            c_expr.expr &amp;:= <span class="stri">", "</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          process_expr(obj, c_expr);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_match (<span class="op">in</span> <span class="type">reference</span>: current_expression, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: function <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">category</span>: functionCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">reference</span>: obj <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">boolean</span>: first_element <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    c_expr.currentFile := file(current_expression);
    c_expr.currentLine := line(current_expression);
    <span class="comment"># c_expr.expr &amp;:= "/* process_match ";</span>
    <span class="comment"># c_expr.expr &amp;:= str(current_expression);</span>
    <span class="comment"># c_expr.expr &amp;:= " */";</span>
    params := getValue(current_expression, ref_list);
    function := params[1];
    params := params[2 ..];
    functionCategory := category(function);
    <span class="keywd">if</span> functionCategory = ACTOBJECT <span class="keywd">then</span>
      global_c_expr.expr &amp;:= <span class="stri">"objRefType "</span>;
      global_c_expr.expr &amp;:= lower(str(getValue(function, ACTION)));
      global_c_expr.expr &amp;:= <span class="stri">" (listType arguments);\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"&amp;"</span>;
      c_expr.expr &amp;:= lower(str(getValue(function, ACTION)));
    <span class="keywd">elsif</span> functionCategory = BLOCKOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(function, c_expr.expr);
    <span class="keywd">else</span>
      raise RANGE_ERROR;
      c_expr.expr &amp;:= <span class="stri">"/*[ "</span>;
      c_expr.expr &amp;:= str(functionCategory);
      c_expr.expr &amp;:= <span class="stri">" ]*/"</span>;
      c_expr.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(function, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      <span class="keywd">for</span> obj <span class="keywd">range</span> params <span class="keywd">do</span>
        <span class="keywd">if</span> category(obj) &lt;> SYMBOLOBJECT <span class="keywd">then</span>
          <span class="keywd">if</span> first_element <span class="keywd">then</span>
            first_element := FALSE;
          <span class="keywd">else</span>
            c_expr.expr &amp;:= <span class="stri">", "</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          process_expr(obj, c_expr);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: optimize_constant_expressions (<span class="keywd">inout</span> <span class="type">reference</span>: current_expression,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluated_expression <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> evaluate_const_expr = 3 <span class="op">and</span> isConstantExpr(current_expression) <span class="keywd">then</span>
      <span class="keywd">block</span>
        evaluated_expression := evaluate(prog, current_expression);
        <span class="keywd">if</span> evaluated_expression &lt;> NIL <span class="op">and</span> evaluated_expression &lt;> current_expression <span class="keywd">then</span>
          incr(countEvaluations);
          c_expr.expr &amp;:= <span class="stri">"/* evaluate "</span>;
          <span class="keywd">if</span> category(getValue(current_expression, ref_list)[1]) = ACTOBJECT <span class="keywd">then</span>
            c_expr.expr &amp;:= str(getValue(getValue(current_expression, ref_list)[1], ACTION));
          <span class="keywd">elsif</span> category(getValue(current_expression, ref_list)[1]) = BLOCKOBJECT <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"o_"</span>;
            create_name2(getValue(current_expression, ref_list)[1], c_expr.expr);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">" */ "</span>;
          current_expression := evaluated_expression;
          <span class="keywd">if</span> category(current_expression) = VARENUMOBJECT <span class="keywd">then</span>
            current_expression := getValue(current_expression, reference);
          <span class="keywd">else</span>
            setVar(current_expression, FALSE);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      exception
        catch NUMERIC_ERROR:  c_expr.expr &amp;:= <span class="stri">"/* NUMERIC_ERROR */ "</span>; <span class="comment"># noop;</span>
        catch OVERFLOW_ERROR: c_expr.expr &amp;:= <span class="stri">"/* OVERFLOW_ERROR */ "</span>; <span class="comment"># noop;</span>
        catch RANGE_ERROR:    c_expr.expr &amp;:= <span class="stri">"/* RANGE_ERROR */ "</span>; <span class="comment"># noop;</span>
        catch INDEX_ERROR:    c_expr.expr &amp;:= <span class="stri">"/* INDEX_ERROR */ "</span>; <span class="comment"># noop;</span>
        catch FILE_ERROR:     c_expr.expr &amp;:= <span class="stri">"/* FILE_ERROR */ "</span>; <span class="comment"># noop;</span>
        catch DATABASE_ERROR: c_expr.expr &amp;:= <span class="stri">"/* DATABASE_ERROR */ "</span>; <span class="comment"># noop;</span>
      <span class="keywd">end</span> <span class="keywd">block</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_expr (<span class="op">in</span> <span class="keywd">var</span> <span class="type">reference</span>: current_expression, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">category</span>: exprCategory <span class="keywd">is</span> category.value;
  <span class="keywd">begin</span>
    optimize_constant_expressions(current_expression, c_expr);
    exprCategory := category(current_expression);
    <span class="keywd">if</span> exprCategory = MATCHOBJECT <span class="keywd">then</span>
      process_match(current_expression, c_expr);
    <span class="keywd">elsif</span> exprCategory = CALLOBJECT <span class="keywd">then</span>
      process_call(current_expression, c_expr);
    <span class="keywd">elsif</span> exprCategory = BLOCKOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(current_expression, c_expr.expr);
      <span class="keywd">if</span> <span class="op">not</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"()"</span>;
        <span class="keywd">if</span> resultType(getType(current_expression)) = voidtype <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = ACTOBJECT <span class="keywd">then</span>
      global_c_expr.expr &amp;:= <span class="stri">"objRefType "</span>;
      global_c_expr.expr &amp;:= lower(str(getValue(current_expression, ACTION)));
      global_c_expr.expr &amp;:= <span class="stri">" (listType arguments);\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"&amp;"</span>;
      c_expr.expr &amp;:= lower(str(getValue(current_expression, ACTION)));
    <span class="keywd">elsif</span> exprCategory = LOCALVOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> current_expression <span class="op">in</span> funcparam_data <span class="keywd">then</span>
        c_expr.expr &amp;:= funcparam_data[current_expression];
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = VALUEPARAMOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> current_expression <span class="op">in</span> funcparam_data <span class="keywd">then</span>
        c_expr.expr &amp;:= funcparam_data[current_expression];
      <span class="keywd">elsif</span> current_expression <span class="op">in</span> inlineParam <span class="op">and</span>
          inlineParam[current_expression][1].paramValue &lt;> NIL <span class="keywd">then</span>
        process_expr(inlineParam[current_expression][1].paramValue, c_expr);
      <span class="keywd">else</span>
        <span class="keywd">if</span> current_expression <span class="op">in</span> inlineParam <span class="op">and</span>
            inlineParam[current_expression][1].paramNum &lt;> 0 <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"par_"</span>;
          c_expr.expr &amp;:= str(inlineParam[current_expression][1].paramNum);
          c_expr.expr &amp;:= <span class="stri">"_"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = REFPARAMOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> current_expression <span class="op">in</span> funcparam_data <span class="keywd">then</span>
        c_expr.expr &amp;:= funcparam_data[current_expression];
      <span class="keywd">elsif</span> isFunc(getType(current_expression)) <span class="op">or</span>
          isVarfunc(getType(current_expression)) <span class="keywd">then</span>
        <span class="keywd">if</span> current_expression <span class="op">in</span> inlineParam <span class="keywd">then</span>
          process_inline_param(current_expression, c_expr);
        <span class="keywd">else</span>
          <span class="keywd">if</span> getType(current_expression) = proctype <span class="keywd">then</span>
            setDiagnosticLine(c_expr);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">"o_"</span>;
          create_name(current_expression, c_expr.expr);
          c_expr.expr &amp;:= <span class="stri">"->func(o_"</span>;
          create_name(current_expression, c_expr.expr);
          c_expr.expr &amp;:= <span class="stri">")"</span>;
          <span class="keywd">if</span> getType(current_expression) = proctype <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">";\n"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> current_expression <span class="op">in</span> inlineParam <span class="op">and</span>
          inlineParam[current_expression][1].paramValue &lt;> NIL <span class="keywd">then</span>
        process_expr(inlineParam[current_expression][1].paramValue, c_expr);
      <span class="keywd">else</span>
        <span class="keywd">if</span> isPointerParam(current_expression) <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"*"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> current_expression <span class="op">in</span> inlineParam <span class="op">and</span>
            inlineParam[current_expression][1].paramNum &lt;> 0 <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"par_"</span>;
          c_expr.expr &amp;:= str(inlineParam[current_expression][1].paramNum);
          c_expr.expr &amp;:= <span class="stri">"_"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = RESULTOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> current_expression <span class="op">in</span> funcparam_data <span class="keywd">then</span>
        c_expr.expr &amp;:= funcparam_data[current_expression];
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = TYPEOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= typeLiteral(getValue(current_expression, type));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = INTOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= integerLiteral(getValue(current_expression, integer));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = BIGINTOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= bigIntegerLiteral(getValue(current_expression, bigInteger));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = FLOATOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= floatLiteral(getValue(current_expression, float));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = CHAROBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= charLiteral(getValue(current_expression, char));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = STRIOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= stringLiteral(getValue(current_expression, string));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = BSTRIOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= bstriLiteral(getValue(current_expression, bstring));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = SETOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"("</span>;
        c_expr.expr &amp;:= type_name(getType(current_expression));
        c_expr.expr &amp;:= <span class="stri">")("</span>;
        c_expr.expr &amp;:= bitsetLiteral(getValue(current_expression, bitset));
        c_expr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = REFOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        <span class="keywd">if</span> getValue(current_expression, reference) = NIL <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"NULL"</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"&amp;("</span>;
          process_expr(getValue(current_expression, reference), c_expr);
          c_expr.expr &amp;:= <span class="stri">")"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = REFLISTOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(current_expression, c_expr.expr);
    <span class="keywd">elsif</span> exprCategory = ARRAYOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        <span class="keywd">if</span> current_expression <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
          const_table @:= [current_expression] length(const_table);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"arr["</span>;
        c_expr.expr &amp;:= str(const_table[current_expression]);
        c_expr.expr &amp;:= <span class="stri">"]"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = STRUCTOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        <span class="keywd">if</span> current_expression <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
          const_table @:= [current_expression] length(const_table);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"sct["</span>;
        c_expr.expr &amp;:= str(const_table[current_expression]);
        c_expr.expr &amp;:= <span class="stri">"]"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = HASHOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        <span class="keywd">if</span> current_expression <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
          const_table @:= [current_expression] length(const_table);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"hsh["</span>;
        c_expr.expr &amp;:= str(const_table[current_expression]);
        c_expr.expr &amp;:= <span class="stri">"]"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = INTERFACEOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        <span class="keywd">if</span> current_expression <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
          const_table @:= [current_expression] length(const_table);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"itf["</span>;
        c_expr.expr &amp;:= str(const_table[current_expression]);
        c_expr.expr &amp;:= <span class="stri">"]"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = FILEOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(current_expression, c_expr.expr);
    <span class="keywd">elsif</span> exprCategory = SOCKETOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(current_expression, c_expr.expr);
    <span class="keywd">elsif</span> exprCategory = POLLOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(current_expression, c_expr.expr);
    <span class="keywd">elsif</span> exprCategory = WINOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= windowLiteral(getValue(current_expression, PRIMITIVE_WINDOW));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = POINTLISTOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= pointListLiteral(getValue(current_expression, pointList));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = PROCESSOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        <span class="keywd">if</span> getValue(current_expression, process) = process.EMPTY <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"/*process.EMPTY*/NULL"</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"o_"</span>;
          create_name(current_expression, c_expr.expr);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = PROGOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        <span class="keywd">if</span> getValue(current_expression, program) = program.EMPTY <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"/*program.EMPTY*/NULL"</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"o_"</span>;
          create_name(current_expression, c_expr.expr);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = DATABASEOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"/*database.value*/NULL"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = SQLSTMTOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"/*sqlStatement.value*/NULL"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = CONSTENUMOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= enum_value(getValue(current_expression, reference));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = VARENUMOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> current_expression <span class="op">in</span> funcparam_data <span class="keywd">then</span>
        c_expr.expr &amp;:= funcparam_data[current_expression];
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = ENUMLITERALOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> getType(current_expression) = voidtype <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"/* empty */\n"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"o_"</span>;
        create_name(current_expression, c_expr.expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = EXPROBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(current_expression, c_expr.expr);
    <span class="keywd">elsif</span> exprCategory = SYMBOLOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"/* SYMBOLOBJECT "</span>;
      c_expr.expr &amp;:= str(current_expression);
      c_expr.expr &amp;:= <span class="stri">" */"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"/* "</span>;
      c_expr.expr &amp;:= str(exprCategory);
      c_expr.expr &amp;:= <span class="stri">" */"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_call_by_name_expr (<span class="op">in</span> <span class="keywd">var</span> <span class="type">reference</span>: current_expression, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">category</span>: exprCategory <span class="keywd">is</span> category.value;
  <span class="keywd">begin</span>
    exprCategory := category(current_expression);
    <span class="keywd">if</span> exprCategory = MATCHOBJECT <span class="keywd">then</span>
      process_call(current_expression, c_expr);
    <span class="keywd">elsif</span> exprCategory = LOCALVOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> isFunc(getType(current_expression)) <span class="op">or</span>
          isVarfunc(getType(current_expression)) <span class="keywd">then</span>
        process_func_call(current_expression, ref_list.EMPTY, c_expr);
      <span class="keywd">else</span>
        process_expr(current_expression, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = BLOCKOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(current_expression, c_expr.expr);
      <span class="keywd">if</span> <span class="op">not</span> isVar(current_expression) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"()"</span>;
        <span class="keywd">if</span> resultType(getType(current_expression)) = voidtype <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> exprCategory = ACTOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"/* process_call_by_name_expr ACTOBJECT "</span>;
      c_expr.expr &amp;:= str(getValue(current_expression, ACTION));
      c_expr.expr &amp;:= <span class="stri">" */"</span>;
      process_action(current_expression, ref_list.EMPTY, c_expr);
    <span class="keywd">else</span>
      process_expr(current_expression, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: declare_types_of_params (<span class="op">in</span> <span class="type">ref_list</span>: formal_params, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: formal_param <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">category</span>: paramCategory <span class="keywd">is</span> category.value;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> formal_param <span class="keywd">range</span> formal_params <span class="keywd">do</span>
      paramCategory := category(formal_param);
      <span class="keywd">if</span> paramCategory &lt;> SYMBOLOBJECT <span class="op">and</span> paramCategory &lt;> TYPEOBJECT <span class="keywd">then</span>
        declare_type_if_necessary(getType(formal_param), c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_param_declaration (<span class="op">in</span> <span class="type">reference</span>: formal_param, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: param_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">string</span>: param_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    param_type := getType(formal_param);
    <span class="keywd">if</span> isPointerParam(formal_param) <span class="keywd">then</span>
      <span class="keywd">if</span> isFunc(param_type) <span class="op">or</span> isVarfunc(param_type) <span class="keywd">then</span>
        c_expr.expr &amp;:= type_name(param_type);
        c_expr.expr &amp;:= <span class="stri">" o_"</span>;
        create_name(formal_param, c_expr.expr);
      <span class="keywd">else</span>
        <span class="keywd">if</span> <span class="op">not</span> isVar(formal_param) <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"const "</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= type_name(param_type);
        c_expr.expr &amp;:= <span class="stri">" *const o_"</span>;
        create_name(formal_param, c_expr.expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> isCopyParam(formal_param) <span class="keywd">then</span>
      create_name(formal_param, param_name);
      c_expr.expr &amp;:= <span class="stri">"const "</span>;
      <span class="keywd">if</span> useConstPrefix(formal_param) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"const_"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= type_name(param_type);
      c_expr.expr &amp;:= <span class="stri">" value_o_"</span>;
      c_expr.expr &amp;:= param_name;
      <span class="keywd">if</span> <span class="op">not</span> isVar(formal_param) <span class="op">and</span> useConstPrefix(param_type) <span class="keywd">then</span>
        c_expr.temp_decls &amp;:= <span class="stri">"const_"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.temp_decls &amp;:= type_name(param_type);
      c_expr.temp_decls &amp;:= <span class="stri">" o_"</span>;
      c_expr.temp_decls &amp;:= param_name;
      c_expr.temp_decls &amp;:= <span class="stri">";\n"</span>;
      c_expr.temp_assigns &amp;:= <span class="stri">"o_"</span>;
      c_expr.temp_assigns &amp;:= param_name;
      c_expr.temp_assigns &amp;:= <span class="stri">"="</span>;
      process_create_declaration(param_type, global_c_expr);
      process_create_call(param_type,
          <span class="stri">"value_o_"</span> &amp; param_name, c_expr.temp_assigns);
      c_expr.temp_assigns &amp;:= <span class="stri">";\n"</span>;
      process_destr_declaration(param_type, global_c_expr);
      process_destr_call(param_type,
          <span class="stri">"o_"</span> &amp; param_name, c_expr.temp_frees);
    <span class="keywd">else</span>
      <span class="keywd">if</span> <span class="op">not</span> isVar(formal_param) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"const "</span>;
        <span class="keywd">if</span> useConstPrefix(formal_param) <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"const_"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= type_name(param_type);
      c_expr.expr &amp;:= <span class="stri">" o_"</span>;
      create_name(formal_param, c_expr.expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_param_list_declaration (<span class="op">in</span> <span class="type">ref_list</span>: formal_params, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: formal_param <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">category</span>: paramCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">boolean</span>: first_element <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> formal_param <span class="keywd">range</span> formal_params <span class="keywd">do</span>
      paramCategory := category(formal_param);
      <span class="keywd">if</span> paramCategory &lt;> SYMBOLOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> paramCategory = TYPEOBJECT <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"/* attr t_"</span>;
          c_expr.expr &amp;:= str(typeNumber(getValue(formal_param, type)));
          c_expr.expr &amp;:= <span class="stri">" "</span>;
          c_expr.expr &amp;:= str(getValue(formal_param, type));
          c_expr.expr &amp;:= <span class="stri">"*/ "</span>;
        <span class="keywd">elsif</span> getType(formal_param) &lt;> voidtype <span class="keywd">then</span>
          <span class="keywd">if</span> first_element <span class="keywd">then</span>
            first_element := FALSE;
          <span class="keywd">else</span>
            c_expr.expr &amp;:= <span class="stri">", "</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          process_param_declaration(formal_param, c_expr);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> first_element <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"void"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_result_declaration (<span class="op">in</span> <span class="type">reference</span>: result_object,
    <span class="op">in</span> <span class="keywd">var</span> <span class="type">reference</span>: result_init, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: evaluatedExpr <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> result_object &lt;> NIL <span class="keywd">then</span>
      <span class="keywd">if</span> evaluate_const_expr >= 2 <span class="op">and</span> isConstant(result_init) <span class="keywd">then</span>
        <span class="keywd">block</span>
          evaluatedExpr := evaluate(prog, result_init);
          <span class="keywd">if</span> evaluatedExpr &lt;> NIL <span class="keywd">then</span>
            incr(countEvaluations);
            result_init := evaluatedExpr;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        exception
          catch NUMERIC_ERROR:  noop;
          catch OVERFLOW_ERROR: noop;
          catch RANGE_ERROR:    noop;
          catch INDEX_ERROR:    noop;
          catch FILE_ERROR:     noop;
          catch DATABASE_ERROR: noop;
        <span class="keywd">end</span> <span class="keywd">block</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      process_local_declaration(result_object, result_init, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_return (<span class="op">in</span> <span class="type">reference</span>: result_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> result_object &lt;> NIL <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"return o_"</span>;
      create_name(result_object, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">";\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_return_value (<span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">type</span>: result_type, <span class="op">in</span> expr_type: c_func_body,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> isVarfunc(getType(function)) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;("</span>;
      <span class="keywd">if</span> c_func_body.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        c_expr.expr &amp;:= c_func_body.result_expr;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= c_func_body.expr;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"("</span>;
      <span class="keywd">if</span> c_func_body.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        c_expr.expr &amp;:= c_func_body.result_expr;
      <span class="keywd">else</span>
        <span class="keywd">if</span> function <span class="op">in</span> prototype_declared <span class="keywd">then</span>
          process_create_declaration(result_type, global_c_expr);
          process_create_call(result_type, c_func_body.expr, c_expr.expr);
        <span class="keywd">else</span>
          <span class="keywd">if</span> valueIsAtHeap(result_type) <span class="keywd">then</span>
            return_ref_to_value @:= [function] TRUE;
            c_expr.expr &amp;:= <span class="stri">"/*ref_to_value*/ "</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= c_func_body.expr;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">")"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_local_consts (<span class="op">in</span> <span class="type">reference</span>: function,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_const_func_declaration (<span class="op">in</span> <span class="type">reference</span>: function,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> expr_type: c_local_consts <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> expr_type: c_param_list <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> expr_type: c_result <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> expr_type: c_local_vars <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> expr_type: c_func_body <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">type</span>: function_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: result_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">ref_list</span>: param_list <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: result_object <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">reference</span>: result_init <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    function_type := getType(function);
    result_type := resultType(function_type);
    param_list := formalParams(function);
    result_object := resultVar(function);
    <span class="keywd">if</span> param_list_okay(param_list) <span class="op">or</span>
        recursiveFunctionCall(function, body(function)) <span class="op">or</span>
        result_object &lt;> NIL <span class="keywd">then</span>
      <span class="comment"># Try to process the function declaration always.</span>
      <span class="comment"># The variable write_object_declaration is used to</span>
      <span class="comment"># decide if the function declaration should be written</span>
      function_declared @:= [function] TRUE;
      declare_types_of_params(param_list, global_c_expr);
      c_local_consts.currentFile := c_expr.currentFile;
      c_local_consts.currentLine := c_expr.currentLine;
      process_local_consts(function, c_local_consts);
      global_c_expr.expr  &amp;:= c_local_consts.temp_decls;
      global_init.expr    &amp;:= c_local_consts.temp_assigns;
      global_c_expr.expr  &amp;:= c_local_consts.expr;
      c_expr.expr &amp;:= diagnosticLine(function);
      c_expr.expr &amp;:= <span class="stri">"static "</span>;
      c_expr.expr &amp;:= type_name(result_type);
      <span class="keywd">if</span> isVarfunc(getType(function)) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">" /*varfunc*/ *o_"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">" o_"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      create_name(function, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">" ("</span>;
      process_param_list_declaration(param_list, c_param_list);
      c_expr.expr &amp;:= c_param_list.expr;
      c_expr.expr &amp;:= <span class="stri">")\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      <span class="keywd">if</span> function_type &lt;> proctype <span class="op">and</span> result_object = NIL <span class="keywd">then</span>
        <span class="keywd">if</span> isFunctionCallingSpecialAction(function) <span class="keywd">then</span>
          write_object_declaration := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_func_body.demand := REQUIRE_RESULT;
        currentProfiledFunction := function;
        process_expr(body(function), c_func_body);
        <span class="keywd">if</span> c_param_list.temp_decls &lt;> <span class="stri">""</span> <span class="op">or</span> c_func_body.temp_decls &lt;> <span class="stri">""</span> <span class="op">or</span>
            trace_function <span class="op">or</span> profile_function <span class="keywd">then</span>
          c_expr.currentFile := file(body(function));
          c_expr.currentLine := line(body(function));
          setDiagnosticLine(c_expr);
          c_expr.expr &amp;:= type_name(result_type);
          <span class="keywd">if</span> isVarfunc(getType(function)) <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">" *result;\n"</span>;
          <span class="keywd">else</span>
            c_expr.expr &amp;:= <span class="stri">" result;\n"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          appendWithDiagnostic(c_param_list.temp_decls, c_expr);
          appendWithDiagnostic(c_func_body.temp_decls, c_expr);
          <span class="keywd">if</span> trace_function <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"fprintf("</span>;
            c_expr.expr &amp;:= trace_output;
            c_expr.expr &amp;:= <span class="stri">", \"-> "</span>;
            create_name(function, c_expr.expr);
            c_expr.expr &amp;:= <span class="stri">"\\n\");\n"</span>;
            <span class="keywd">if</span> flush_trace_output <span class="keywd">then</span>
              c_expr.expr &amp;:= <span class="stri">"fflush("</span>;
              c_expr.expr &amp;:= trace_output;
              c_expr.expr &amp;:= <span class="stri">");\n"</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> profile_function <span class="keywd">then</span>
            profiledFunctions @:= [objNumber(function)] function;
            c_expr.expr &amp;:= <span class="stri">"profile["</span>;
            c_expr.expr &amp;:= str(objNumber(function));
            c_expr.expr &amp;:= <span class="stri">"].count++;\n"</span>;
            c_expr.expr &amp;:= <span class="stri">"if (profile["</span>;
            c_expr.expr &amp;:= str(objNumber(function));
            c_expr.expr &amp;:= <span class="stri">"].depth == 0) {\n"</span>;
            c_expr.expr &amp;:= <span class="stri">"  profile["</span>;
            c_expr.expr &amp;:= str(objNumber(function));
            c_expr.expr &amp;:= <span class="stri">"].time -= timMicroSec();\n"</span>;
            c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
            c_expr.expr &amp;:= <span class="stri">"profile["</span>;
            c_expr.expr &amp;:= str(objNumber(function));
            c_expr.expr &amp;:= <span class="stri">"].depth++;\n"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          appendWithDiagnostic(c_param_list.temp_assigns, c_expr);
          appendWithDiagnostic(c_func_body.temp_assigns, c_expr);
          setDiagnosticLine(c_expr);
          c_expr.expr &amp;:= <span class="stri">"result=("</span>;
          c_expr.expr &amp;:= type_name(result_type);
          <span class="keywd">if</span> isVarfunc(getType(function)) <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">" *"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">")("</span>;
          process_return_value(function, result_type, c_func_body, c_expr);
          c_expr.expr &amp;:= <span class="stri">");\n"</span>;
          appendWithDiagnostic(c_param_list.temp_frees, c_expr);
          appendWithDiagnostic(c_func_body.temp_frees, c_expr);
          <span class="keywd">if</span> profile_function <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"profile["</span>;
            c_expr.expr &amp;:= str(objNumber(function));
            c_expr.expr &amp;:= <span class="stri">"].depth--;\n"</span>;
            c_expr.expr &amp;:= <span class="stri">"if (profile["</span>;
            c_expr.expr &amp;:= str(objNumber(function));
            c_expr.expr &amp;:= <span class="stri">"].depth == 0) {\n"</span>;
            c_expr.expr &amp;:= <span class="stri">"  profile["</span>;
            c_expr.expr &amp;:= str(objNumber(function));
            c_expr.expr &amp;:= <span class="stri">"].time += timMicroSec();\n"</span>;
            c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> trace_function <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"fprintf("</span>;
            c_expr.expr &amp;:= trace_output;
            c_expr.expr &amp;:= <span class="stri">", \"&lt;- "</span>;
            create_name(function, c_expr.expr);
            c_expr.expr &amp;:= <span class="stri">"\\n\");\n"</span>;
            <span class="keywd">if</span> flush_trace_output <span class="keywd">then</span>
              c_expr.expr &amp;:= <span class="stri">"fflush("</span>;
              c_expr.expr &amp;:= trace_output;
              c_expr.expr &amp;:= <span class="stri">");\n"</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          setDiagnosticLine(c_expr);
          c_expr.expr &amp;:= <span class="stri">"return result;\n"</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= diagnosticLine(body(function));
          c_expr.expr &amp;:= <span class="stri">"return ("</span>;
          c_expr.expr &amp;:= type_name(result_type);
          <span class="keywd">if</span> isVarfunc(getType(function)) <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">" *"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">")("</span>;
          process_return_value(function, result_type, c_func_body, c_expr);
          c_expr.expr &amp;:= <span class="stri">");\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        result_init := resultInitValue(function);
        c_result.temp_num := c_expr.temp_num;
        process_result_declaration(result_object, result_init, c_result);
        c_local_vars.temp_num := c_result.temp_num;
        process_local_var_declaration(function, c_local_vars);
        c_expr.temp_num := c_local_vars.temp_num;
        currentProfiledFunction := function;
        process_expr(body(function), c_func_body);
        c_expr.currentFile := file(function);
        c_expr.currentLine := line(function);
        appendWithDiagnostic(c_param_list.temp_decls, c_expr);
        c_expr.expr &amp;:= c_result.temp_decls;
        c_expr.expr &amp;:= c_local_vars.temp_decls;
        appendWithDiagnostic(c_func_body.temp_decls, c_expr);
        <span class="keywd">if</span> trace_function <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"fprintf("</span>;
          c_expr.expr &amp;:= trace_output;
          c_expr.expr &amp;:= <span class="stri">", \"-> "</span>;
          create_name(function, c_expr.expr);
          c_expr.expr &amp;:= <span class="stri">"\\n\");\n"</span>;
          <span class="keywd">if</span> flush_trace_output <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"fflush("</span>;
            c_expr.expr &amp;:= trace_output;
            c_expr.expr &amp;:= <span class="stri">");\n"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> profile_function <span class="keywd">then</span>
          profiledFunctions @:= [objNumber(function)] function;
          c_expr.expr &amp;:= <span class="stri">"profile["</span>;
          c_expr.expr &amp;:= str(objNumber(function));
          c_expr.expr &amp;:= <span class="stri">"].count++;\n"</span>;
          c_expr.expr &amp;:= <span class="stri">"if (profile["</span>;
          c_expr.expr &amp;:= str(objNumber(function));
          c_expr.expr &amp;:= <span class="stri">"].depth == 0) {\n"</span>;
          c_expr.expr &amp;:= <span class="stri">"  profile["</span>;
          c_expr.expr &amp;:= str(objNumber(function));
          c_expr.expr &amp;:= <span class="stri">"].time -= timMicroSec();\n"</span>;
          c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
          c_expr.expr &amp;:= <span class="stri">"profile["</span>;
          c_expr.expr &amp;:= str(objNumber(function));
          c_expr.expr &amp;:= <span class="stri">"].depth++;\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        appendWithDiagnostic(c_param_list.temp_assigns, c_expr);
        c_expr.expr &amp;:= c_result.temp_assigns;
        c_expr.expr &amp;:= c_local_vars.temp_assigns;
        appendWithDiagnostic(c_func_body.temp_assigns, c_expr);
        c_expr.expr &amp;:= c_func_body.expr;
        appendWithDiagnostic(c_param_list.temp_frees, c_expr);
        appendWithDiagnostic(c_local_vars.temp_frees, c_expr);
        appendWithDiagnostic(c_func_body.temp_frees, c_expr);
        <span class="keywd">if</span> profile_function <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"profile["</span>;
          c_expr.expr &amp;:= str(objNumber(function));
          c_expr.expr &amp;:= <span class="stri">"].depth--;\n"</span>;
          c_expr.expr &amp;:= <span class="stri">"if (profile["</span>;
          c_expr.expr &amp;:= str(objNumber(function));
          c_expr.expr &amp;:= <span class="stri">"].depth == 0) {\n"</span>;
          c_expr.expr &amp;:= <span class="stri">"  profile["</span>;
          c_expr.expr &amp;:= str(objNumber(function));
          c_expr.expr &amp;:= <span class="stri">"].time += timMicroSec();\n"</span>;
          c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> trace_function <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"fprintf("</span>;
          c_expr.expr &amp;:= trace_output;
          c_expr.expr &amp;:= <span class="stri">", \"&lt;- "</span>;
          create_name(function, c_expr.expr);
          c_expr.expr &amp;:= <span class="stri">"\\n\");\n"</span>;
          <span class="keywd">if</span> flush_trace_output <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"fflush("</span>;
            c_expr.expr &amp;:= trace_output;
            c_expr.expr &amp;:= <span class="stri">");\n"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        process_return(result_object, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
      c_expr.expr &amp;:= noDiagnosticLine;
      c_expr.expr &amp;:= <span class="stri">"\n"</span>;
      <span class="keywd">if</span> write_object_declaration <span class="keywd">then</span>
        prototype_declared @:= [function] TRUE;
        count_declarations(c_expr);
      <span class="keywd">else</span>
        excl(function_declared, function);
        function_not_declared @:= [function] TRUE;
        c_expr.expr &amp;:= <span class="stri">"/* declare inline o_"</span>;
        create_name2(function, c_expr.expr);
        c_expr.expr &amp;:= <span class="stri">"*/\n\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      function_not_declared @:= [function] TRUE;
      c_expr.expr &amp;:= <span class="stri">"/* declare inline o_"</span>;
      create_name2(function, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">"*/\n\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_library_initialisation (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: libraryName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    libraryName := name(prog);
    c_expr.expr &amp;:= <span class="stri">"void init_"</span>;
    c_expr.expr &amp;:= libraryName;
    c_expr.expr &amp;:= <span class="stri">" (void)\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"init_values();\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"init_globals();\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"\n"</span>;
    prototype_declared @:= [current_object] TRUE;
    count_declarations(c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: declare_exception_name (<span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: exceptionRef <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">type</span>: enumType <span class="keywd">is</span> void;
    <span class="keywd">var</span> number_element_hash: enumsByIntValue <span class="keywd">is</span> number_element_hash.value;
    <span class="keywd">var</span> <span class="type">integer</span>: intValueOfEnum <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reference</span>: enumLiteral <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    exceptionRef := sysVar(prog, <span class="stri">"memory_error"</span>);
    enumType := getType(exceptionRef);
    c_expr.expr &amp;:=  <span class="stri">"static const char *exception_name[] = {\n"</span>;
    c_expr.expr &amp;:=  <span class="stri">"    \"OKAY_NO_ERROR\",\n"</span>;
    enumsByIntValue := flip(enum_literal[enumType]);
    <span class="comment"># Sort by integer values to always produce the same C code</span>
    <span class="keywd">for</span> intValueOfEnum <span class="keywd">range</span> sort(keys(enumsByIntValue)) <span class="keywd">do</span>
      <span class="comment"># If the enums are correct there will only be one per integer value</span>
      enumLiteral := enumsByIntValue[intValueOfEnum][1];
      c_expr.expr &amp;:= <span class="stri">"    "</span>;
      c_expr.expr &amp;:= c_literal(str(enumLiteral));
      c_expr.expr &amp;:= <span class="stri">",\n"</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    c_expr.expr &amp;:=  <span class="stri">"  };\n\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_main_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> expr_type: c_local_vars <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> expr_type: c_func_body <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">string</span>: main_prolog <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: main_epilog <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> category(current_object) = BLOCKOBJECT <span class="keywd">then</span>
      function_declared @:= [current_object] TRUE;
      process_local_consts(current_object, c_expr);
      c_local_vars.temp_num := c_expr.temp_num;
      process_local_var_declaration(current_object, c_local_vars);
      currentProfiledFunction := main_object;
      c_func_body.temp_num := c_local_vars.temp_num;
      process_expr(body(current_object), c_func_body);
      c_expr.temp_num := c_func_body.temp_num;
    <span class="keywd">elsif</span> category(current_object) = ACTOBJECT <span class="keywd">then</span>
      <span class="keywd">if</span> str(getValue(current_object, ACTION)) &lt;> <span class="stri">"PRC_NOOP"</span> <span class="keywd">then</span>
        currentProfiledFunction := main_object;
        c_func_body.temp_num := c_expr.temp_num;
        process_expr(current_object, c_func_body);
        c_expr.temp_num := c_func_body.temp_num;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    declare_exception_name(c_expr);
    c_expr.currentFile := file(current_object);
    c_expr.currentLine := line(current_object);
    <span class="keywd">if</span> ccConf.USE_WMAIN <span class="keywd">then</span>
      main_prolog := <span class="stri">"int wmain (int argc, wchar_t **argv)\n"</span>;
    <span class="keywd">elsif</span> ccConf.USE_WINMAIN <span class="keywd">then</span>
      main_prolog := <span class="stri">"int WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, char *lpCmdLine, int nShowCmd)\n"</span>;
    <span class="keywd">elsif</span> ccConf.USE_START_MAIN <span class="keywd">then</span>
      main_prolog := <span class="stri">"typedef int (*tp_startMain) (int argc, char **argv);\n"</span>;
      main_prolog &amp;:= <span class="stri">"int executeStartMainOnButtonClick (tp_startMain startMain, int argc, char **argv);\n"</span>;
      main_prolog &amp;:= <span class="stri">"int startMain (int argc, char **argv);\n\n"</span>;
      main_prolog &amp;:= <span class="stri">"int main (int argc, char **argv)\n"</span>;
      main_prolog &amp;:= <span class="stri">"\n"</span>;
      main_prolog &amp;:= <span class="stri">"{\n"</span>;
      main_prolog &amp;:= <span class="stri">"  return executeStartMainOnButtonClick(startMain, argc, argv);\n"</span>;
      main_prolog &amp;:= <span class="stri">"}\n\n"</span>;
      main_prolog &amp;:= <span class="stri">"int startMain (int argc, char **argv)\n"</span>;
    <span class="keywd">else</span>
      main_prolog := <span class="stri">"int main (int argc, char **argv)\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    main_prolog &amp;:= <span class="stri">"\n"</span>;
    main_prolog &amp;:= <span class="stri">"{\n"</span>;
    main_prolog &amp;:= <span class="stri">"int fail_value;\n"</span>;
    main_prolog &amp;:= <span class="stri">"catch_stack_pos = 0;\n"</span>;
    main_prolog &amp;:= <span class="stri">"max_catch_stack = 128;\n"</span>;
    <span class="keywd">if</span> trace_function <span class="keywd">then</span>
      main_prolog &amp;:= <span class="stri">"fprintf("</span>;
      main_prolog &amp;:= trace_output;
      main_prolog &amp;:= <span class="stri">", \"-> main\\n\");\n"</span>;
      <span class="keywd">if</span> flush_trace_output <span class="keywd">then</span>
        main_prolog &amp;:= <span class="stri">"fflush("</span>;
        main_prolog &amp;:= trace_output;
        main_prolog &amp;:= <span class="stri">");\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> profile_function <span class="keywd">then</span>
      main_prolog &amp;:= <span class="stri">"initProfile();\n"</span>;
      profiledFunctions @:= [objNumber(main_object)] main_object;
      main_prolog &amp;:= <span class="stri">"profile["</span>;
      main_prolog &amp;:= str(objNumber(main_object));
      main_prolog &amp;:= <span class="stri">"].count++;\n"</span>;
      main_prolog &amp;:= <span class="stri">"if (profile["</span>;
      main_prolog &amp;:= str(objNumber(main_object));
      main_prolog &amp;:= <span class="stri">"].depth == 0) {\n"</span>;
      main_prolog &amp;:= <span class="stri">"  profile["</span>;
      main_prolog &amp;:= str(objNumber(main_object));
      main_prolog &amp;:= <span class="stri">"].time -= timMicroSec();\n"</span>;
      main_prolog &amp;:= <span class="stri">"}\n"</span>;
      main_prolog &amp;:= <span class="stri">"profile["</span>;
      main_prolog &amp;:= str(objNumber(main_object));
      main_prolog &amp;:= <span class="stri">"].depth++;\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    main_prolog &amp;:= <span class="stri">"catch_stack = (catch_type *)(malloc(max_catch_stack * sizeof(catch_type)));\n"</span>;
    main_prolog &amp;:= <span class="stri">"if ((fail_value = do_setjmp(catch_stack[catch_stack_pos])) == 0) {\n"</span>;
    main_prolog &amp;:= <span class="stri">"setupStack("</span> &lt;&amp; stack_size &lt;&amp; <span class="stri">");\n"</span>;
    main_prolog &amp;:= <span class="stri">"setupRand();\n"</span>;
    main_prolog &amp;:= <span class="stri">"setupFiles();\n"</span>;
    <span class="keywd">if</span> ccConf.USE_WINMAIN <span class="keywd">then</span>
      main_prolog &amp;:= <span class="stri">"arg_v = getArgv(0, NULL, &amp;arg_0, &amp;programName, &amp;programPath);\n"</span>;
    <span class="keywd">else</span>
      main_prolog &amp;:= <span class="stri">"arg_v = getArgv(argc, argv, &amp;arg_0, &amp;programName, &amp;programPath);\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    main_prolog &amp;:= <span class="stri">"setupFloat();\n"</span>;
    main_prolog &amp;:= <span class="stri">"setupBig();\n"</span>;
    <span class="keywd">if</span> drawLibraryUsed <span class="keywd">then</span>
      main_prolog &amp;:= <span class="stri">"drawInit();\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> compilerLibraryUsed <span class="keywd">then</span>
      main_prolog &amp;:= <span class="stri">"init_primitiv();\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    main_prolog &amp;:= <span class="stri">"init_values();\n"</span>;
    main_prolog &amp;:= <span class="stri">"setupSignalHandlers(1, "</span> &lt;&amp; ord(trace_signal) &lt;&amp;  <span class="stri">", "</span> &lt;&amp;
                                         ord(ccConf.OVERFLOW_SIGNAL &lt;> <span class="stri">""</span>) &lt;&amp;
                                         <span class="stri">", 1, NULL);\n"</span>;
    main_prolog &amp;:= <span class="stri">"init_globals();\n"</span>;
    main_prolog &amp;:= <span class="stri">"{\n"</span>;

    <span class="keywd">if</span> ccConf.USE_WINMAIN <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"typedef struct {\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"    int dummy;\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"  } HINSTANCE__;\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"typedef HINSTANCE__* HINSTANCE;\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    appendWithDiagnostic(main_prolog, c_expr);
    c_expr.expr &amp;:= c_local_vars.temp_decls;
    appendWithDiagnostic(c_func_body.temp_decls, c_expr);
    c_expr.expr &amp;:= c_local_vars.temp_assigns;
    appendWithDiagnostic(c_func_body.temp_assigns, c_expr);
    c_expr.expr &amp;:= c_func_body.expr;
    appendWithDiagnostic(c_local_vars.temp_frees, c_expr);
    appendWithDiagnostic(c_func_body.temp_frees, c_expr);
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    c_expr.expr &amp;:= global_init.temp_frees;

    <span class="keywd">if</span> profile_function <span class="keywd">then</span>
      main_epilog &amp;:= <span class="stri">"profile["</span>;
      main_epilog &amp;:= str(objNumber(main_object));
      main_epilog &amp;:= <span class="stri">"].depth--;\n"</span>;
      main_epilog &amp;:= <span class="stri">"if (profile["</span>;
      main_epilog &amp;:= str(objNumber(main_object));
      main_epilog &amp;:= <span class="stri">"].depth == 0) {\n"</span>;
      main_epilog &amp;:= <span class="stri">"  profile["</span>;
      main_epilog &amp;:= str(objNumber(main_object));
      main_epilog &amp;:= <span class="stri">"].time += timMicroSec();\n"</span>;
      main_epilog &amp;:= <span class="stri">"}\n"</span>;
      main_epilog &amp;:= <span class="stri">"{\n"</span>;
      main_epilog &amp;:= <span class="stri">"  FILE *profile_file;\n"</span>;
      main_epilog &amp;:= <span class="stri">"  int index;\n"</span>;
      main_epilog &amp;:= <span class="stri">"  profile_file = fopen(\"profile_out\", \"wb\");\n"</span>;
      main_epilog &amp;:= <span class="stri">"  if (profile_file != NULL) {\n"</span>;
      main_epilog &amp;:= <span class="stri">"    qsort(profile, profile_size, sizeof(struct profileElement),\n"</span>;
      main_epilog &amp;:= <span class="stri">"          cmpProfileElement);\n"</span>;
      main_epilog &amp;:= <span class="stri">"    fprintf(profile_file, \"usecs\\tcalls\\tplace\\tname\\n\");\n"</span>;
      main_epilog &amp;:= <span class="stri">"    for (index = 0; index &lt; profile_size; index++) {\n"</span>;
      main_epilog &amp;:= <span class="stri">"      if (profile[index].count != 0) {\n"</span>;
      main_epilog &amp;:= <span class="stri">"        if (profile[index].depth == 0) {\n"</span>;
      main_epilog &amp;:= <span class="stri">"          fprintf(profile_file, \"%ld\\t%ld\\t%s(%lu)\\t%s\\n\",\n"</span>;
      main_epilog &amp;:= <span class="stri">"                  (long) profile[index].time, (long) profile[index].count,\n"</span>;
      main_epilog &amp;:= <span class="stri">"                  profile[index].file, (long unsigned) profile[index].line,\n"</span>;
      main_epilog &amp;:= <span class="stri">"                  profile[index].name);\n"</span>;
      main_epilog &amp;:= <span class="stri">"        } else {\n"</span>;
      main_epilog &amp;:= <span class="stri">"          fprintf(profile_file, \"*%ld\\t%ld\\t%s(%lu)\\t%s\\n\",\n"</span>;
      main_epilog &amp;:= <span class="stri">"                  (long) (profile[index].time + timMicroSec()), (long) profile[index].count,\n"</span>;
      main_epilog &amp;:= <span class="stri">"                  profile[index].file, (long unsigned) profile[index].line,\n"</span>;
      main_epilog &amp;:= <span class="stri">"                  profile[index].name);\n"</span>;
      main_epilog &amp;:= <span class="stri">"        }\n"</span>;
      main_epilog &amp;:= <span class="stri">"      }\n"</span>;
      main_epilog &amp;:= <span class="stri">"    }\n"</span>;
      main_epilog &amp;:= <span class="stri">"    fclose(profile_file);\n"</span>;
      main_epilog &amp;:= <span class="stri">"  }\n"</span>;
      main_epilog &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> trace_function <span class="keywd">then</span>
      main_epilog &amp;:= <span class="stri">"fprintf("</span>;
      main_epilog &amp;:= trace_output;
      main_epilog &amp;:= <span class="stri">", \"&lt;- main\\n\");\n"</span>;
      <span class="keywd">if</span> flush_trace_output <span class="keywd">then</span>
        main_epilog &amp;:= <span class="stri">"fflush("</span>;
        main_epilog &amp;:= trace_output;
        main_epilog &amp;:= <span class="stri">");\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> ccConf.USE_DO_EXIT <span class="keywd">then</span>
      main_epilog &amp;:= <span class="stri">"doExit(0);\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    main_epilog &amp;:= <span class="stri">"return 0;\n"</span>;
    main_epilog &amp;:= <span class="stri">"} else {\n"</span>;
    main_epilog &amp;:= <span class="stri">"  printf(\"\\n*** Uncaught exception \");\n"</span>;
    main_epilog &amp;:= <span class="stri">"  if (fail_value >= 0 &amp;&amp; fail_value &lt; sizeof(exception_name) / sizeof(char *)) {\n"</span>;
    main_epilog &amp;:= <span class="stri">"    printf(\"%s\", exception_name[fail_value]);\n"</span>;
    main_epilog &amp;:= <span class="stri">"  } else {\n"</span>;
    main_epilog &amp;:= <span class="stri">"    printf(\"%d\", fail_value);\n"</span>;
    main_epilog &amp;:= <span class="stri">"  }\n"</span>;
    main_epilog &amp;:= <span class="stri">"  printf(\" raised\");\n"</span>;
    main_epilog &amp;:= <span class="stri">"  if (error_file != NULL) {\n"</span>;
    main_epilog &amp;:= <span class="stri">"    printf(\" at %s(%d)\", error_file, error_line);\n"</span>;
    main_epilog &amp;:= <span class="stri">"  }\n"</span>;
    main_epilog &amp;:= <span class="stri">"  printf(\"\\n\");\n"</span>;
    <span class="keywd">if</span> databaseLibraryUsed <span class="keywd">then</span>
      main_epilog &amp;:= <span class="stri">"  if (fail_value == 6 /*DATABASE_ERROR*/) {\n"</span>;
      main_epilog &amp;:= <span class="stri">"    striType message;\n"</span>;
      main_epilog &amp;:= <span class="stri">"    message = sqlErrMessage();\n"</span>;
      main_epilog &amp;:= <span class="stri">"    printf(\"\\nMessage from the DATABASE_ERROR exception:\\n\");\n"</span>;
      <span class="keywd">if</span> consoleLibraryUsed <span class="keywd">then</span>
        main_epilog &amp;:= <span class="stri">"    conWrite(message);\n"</span>;
      <span class="keywd">else</span>
        main_epilog &amp;:= <span class="stri">"    ut8Write(&amp;stdoutFileRecord, message);\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      main_epilog &amp;:= <span class="stri">"    printf(\"\\n\");\n"</span>;
      main_epilog &amp;:= <span class="stri">"    strDestr(message);\n"</span>;
      main_epilog &amp;:= <span class="stri">"  }\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> ccConf.USE_DO_EXIT <span class="keywd">then</span>
      main_epilog &amp;:= <span class="stri">"  doExit(1);\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    main_epilog &amp;:= <span class="stri">"  return 1;\n"</span>;
    main_epilog &amp;:= <span class="stri">"}\n"</span>;
    main_epilog &amp;:= <span class="stri">"}\n"</span>;

    appendWithDiagnostic(main_epilog, c_expr);
    c_expr.expr &amp;:= noDiagnosticLine;
    c_expr.expr &amp;:= <span class="stri">"\n"</span>;
    prototype_declared @:= [current_object] TRUE;
    count_declarations(c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_var_func_declaration (<span class="op">in</span> <span class="type">reference</span>: function,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> expr_type: c_value <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">string</span>: valueName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    declare_type_if_necessary(getType(function), global_c_expr);
    create_name(function, objNumber(function), valueName);
    processFuncValue(valueName, getType(function), function, c_value);
    c_expr.expr &amp;:= c_value.temp_decls;
    global_init.expr &amp;:= diagnosticLine(function);
    global_init.expr &amp;:= c_value.temp_assigns;
    c_expr.expr &amp;:= type_name(getType(function));
    c_expr.expr &amp;:= <span class="stri">" o_"</span>;
    create_name(function, c_expr.expr);
    c_expr.expr &amp;:= <span class="stri">" = "</span>;
    c_expr.expr &amp;:= c_value.expr;
    c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
    function_declared @:= [function] TRUE;
    function_var_declared @:= [function] TRUE;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_func_declaration (<span class="op">in</span> <span class="type">reference</span>: function,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> isVar(function) <span class="keywd">then</span>
      process_var_func_declaration(function, c_expr);
    <span class="keywd">else</span>
      process_const_func_declaration(function, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_prototype_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> expr_type: c_param_list <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">type</span>: current_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: result_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">ref_list</span>: param_list <span class="keywd">is</span> ref_list.EMPTY;
  <span class="keywd">begin</span>
    current_type := getType(current_object);
    <span class="keywd">if</span> isFunc(current_type) <span class="op">or</span> isVarfunc(current_type) <span class="keywd">then</span>
      result_type := resultType(current_type);
      param_list := formalParams(current_object);
      function_declared @:= [current_object] TRUE;
      declare_types_of_params(param_list, global_c_expr);
      c_expr.expr &amp;:= <span class="stri">"static "</span>;
      c_expr.expr &amp;:= type_name(result_type);
      <span class="keywd">if</span> isVarfunc(current_type) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">" *o_"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">" o_"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      create_name(current_object, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">" ("</span>;
      process_param_list_declaration(param_list, c_param_list);
      c_expr.expr &amp;:= c_param_list.expr;
      c_expr.expr &amp;:= <span class="stri">");\n\n"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"extern "</span>;
      c_expr.expr &amp;:= type_name(current_type);
      c_expr.expr &amp;:= <span class="stri">" o_"</span>;
      create_name(current_object, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_forward_declaration (<span class="op">in</span> <span class="type">reference</span>: fwd_ref,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: function <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    function := getValue(fwd_ref, reference);
    <span class="keywd">if</span> function <span class="op">not</span> <span class="op">in</span> prototype_declared <span class="keywd">then</span>
      process_prototype_declaration(function, c_expr);
      prototype_declared @:= [function] TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_type_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: aType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isVar(current_object) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"typeType o_"</span>;
      create_name(current_object, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
      global_init.expr &amp;:= diagnosticLine(current_object);
      global_init.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(current_object, global_init.expr);
      global_init.expr &amp;:= <span class="stri">"="</span>;
      global_init.expr &amp;:= typeLiteral(getValue(current_object, type));
      global_init.expr &amp;:= <span class="stri">";\n"</span>;
    <span class="keywd">else</span>
      aType := getValue(current_object, type);
      declare_type_if_necessary(aType, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    count_declarations(c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_int_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: param_list <span class="keywd">is</span> ref_list.EMPTY;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isVar(current_object) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"intType o_"</span>;
      create_name(current_object, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">"="</span>;
      c_expr.expr &amp;:= integerLiteral(getValue(current_object, integer));
      c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
      count_declarations(c_expr);
    <span class="keywd">elsif</span> optimizeFixedSizeArrays <span class="keywd">then</span>
      param_list := formalParams(current_object);
      <span class="keywd">if</span> param_list &lt;> ref_list.EMPTY <span class="keywd">then</span>
        <span class="keywd">if</span> length(param_list) = 2 <span class="op">and</span>
            category(param_list[1]) = TYPEOBJECT <span class="op">and</span>
            category(param_list[2]) = SYMBOLOBJECT <span class="keywd">then</span>
          <span class="keywd">case</span> str(param_list[2]) <span class="keywd">of</span>
            <span class="keywd">when</span> {<span class="stri">"minIdx"</span>}: array_minIdx @:= [getValue(param_list[1], type)] getValue(current_object, integer);
            <span class="keywd">when</span> {<span class="stri">"maxIdx"</span>}: array_maxIdx @:= [getValue(param_list[1], type)] getValue(current_object, integer);
          <span class="keywd">end</span> <span class="keywd">case</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_bigint_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> isVar(current_object) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"bigIntType o_"</span>;
      create_name(current_object, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
      global_init.expr &amp;:= diagnosticLine(current_object);
      global_init.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(current_object, global_init.expr);
      global_init.expr &amp;:= <span class="stri">"="</span>;
      process_big_create_call(getValue(current_object, bigInteger), global_init.expr);
      count_declarations(c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_char_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> isVar(current_object) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"charType o_"</span>;
      create_name(current_object, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">"="</span>;
      c_expr.expr &amp;:= charLiteral(getValue(current_object, char));
      c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
      count_declarations(c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_stri_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> isVar(current_object) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"striType o_"</span>;
      create_name(current_object, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
      global_init.expr &amp;:= diagnosticLine(current_object);
      global_init.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(current_object, global_init.expr);
      global_init.expr &amp;:= <span class="stri">"="</span>;
      process_str_create_call(getValue(current_object, string), global_init.expr);
      count_declarations(c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_bstri_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> isVar(current_object) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"bstriType o_"</span>;
      create_name(current_object, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
      global_init.expr &amp;:= diagnosticLine(current_object);
      global_init.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(current_object, global_init.expr);
      global_init.expr &amp;:= <span class="stri">"=bstCreate("</span>;
      global_init.expr &amp;:= bstriLiteral(getValue(current_object, bstring));
      global_init.expr &amp;:= <span class="stri">");\n"</span>;
      count_declarations(c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_float_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> isVar(current_object) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"floatType o_"</span>;
      create_name(current_object, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">"="</span>;
      c_expr.expr &amp;:= floatLiteral(getValue(current_object, float));
      c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
      count_declarations(c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: action_address (<span class="op">in</span> <span class="type">reference</span>: function, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ACTION</span>: current_action <span class="keywd">is</span> action <span class="stri">"PRC_NOOP"</span>;
    <span class="keywd">var</span> <span class="type">string</span>: action_name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">type</span>: object_type <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    current_action := getValue(function, ACTION);
    action_name := str(current_action);
    <span class="keywd">if</span> action_name = <span class="stri">"ARR_CPY"</span> <span class="keywd">then</span>
      object_type := getType(formalParams(function)[1]);
      process_generic_cpy_declaration(object_type, global_c_expr);
      c_expr.expr &amp;:= <span class="stri">"&amp;generic_cpy_"</span>;
      c_expr.expr &amp;:= str(typeNumber(object_type));
    <span class="keywd">elsif</span> action_name = <span class="stri">"ARR_CREATE"</span> <span class="keywd">then</span>
      object_type := getType(formalParams(function)[1]);
      typeCategory @:= [object_type] ARRAYOBJECT;
      process_generic_create_declaration(object_type, global_c_expr);
      c_expr.expr &amp;:= <span class="stri">"&amp;generic_create_"</span>;
      c_expr.expr &amp;:= str(typeNumber(object_type));
    <span class="keywd">elsif</span> action_name = <span class="stri">"ARR_DESTR"</span> <span class="keywd">then</span>
      object_type := getType(formalParams(function)[1]);
      process_generic_destr_declaration(object_type, global_c_expr);
      c_expr.expr &amp;:= <span class="stri">"&amp;generic_destr_"</span>;
      c_expr.expr &amp;:= str(typeNumber(object_type));
    <span class="keywd">elsif</span> action_name = <span class="stri">"BIG_CMP"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;bigCmpGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"BIG_CPY"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;bigCpyGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"BIG_CREATE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;bigCreateGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"BIG_DESTR"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;bigDestrGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"BIG_HASHCODE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;bigHashCodeGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"BIN_CMP"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;uintCmpGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"BLN_ORD"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;genericHashCode"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"BLN_CPY"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;genericCpy"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"BLN_CREATE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;genericCreate"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"BST_CMP"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;bstCmpGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"BST_CPY"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;bstCpyGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"BST_CREATE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;bstCreateGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"BST_DESTR"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;bstDestrGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"BST_HASHCODE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;bstHashCodeGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"CHR_CMP"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;chrCmpGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"CHR_CPY"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;genericCpy"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"CHR_CREATE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;genericCreate"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"CHR_HASHCODE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;genericHashCode"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"DRW_CMP"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;ptrCmpGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"DRW_CPY"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;drwCpyGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"DRW_CREATE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;drwCreateGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"DRW_DESTR"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;drwDestrGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"DRW_HASHCODE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;ptrHashCodeGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"ENU_CPY"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;genericCpy"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"ENU_CREATE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;genericCreate"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"FIL_CPY"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;filCpyGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"FIL_CREATE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;filCreateGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"FIL_DESTR"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;filDestrGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"FLT_CMP"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;fltCmpGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"FLT_CPY"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;fltCpyGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"FLT_CREATE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;genericCreate"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"FLT_HASHCODE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;genericHashCode"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"GEN_DESTR"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;genericDestr"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"INT_CMP"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;intCmpGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"INT_CPY"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;genericCpy"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"INT_CREATE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;genericCreate"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"INT_HASHCODE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;genericHashCode"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"ITF_CMP"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;ptrCmpGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"ITF_CPY"</span> <span class="keywd">then</span>
      object_type := getType(formalParams(function)[1]);
      process_generic_cpy_declaration(object_type, global_c_expr);
      c_expr.expr &amp;:= <span class="stri">"&amp;generic_cpy_"</span>;
      c_expr.expr &amp;:= str(typeNumber(object_type));
    <span class="keywd">elsif</span> action_name = <span class="stri">"ITF_CREATE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;itfCreateGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"ITF_DESTR"</span> <span class="keywd">then</span>
      object_type := getType(formalParams(function)[1]);
      process_generic_destr_declaration(object_type, global_c_expr);
      c_expr.expr &amp;:= <span class="stri">"&amp;generic_destr_"</span>;
      c_expr.expr &amp;:= str(typeNumber(object_type));
    <span class="keywd">elsif</span> action_name = <span class="stri">"ITF_HASHCODE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;ptrHashCodeGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"PCS_CMP"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;pcsCmpGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"PCS_CPY"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;pcsCpyGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"PCS_CREATE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;pcsCreateGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"PCS_DESTR"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;pcsDestrGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"PCS_HASHCODE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;pcsHashCodeGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"PLT_CMP"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;bstCmpGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"PLT_CPY"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;bstCpyGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"PLT_CREATE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;bstCreateGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"PLT_DESTR"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;bstDestrGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"PLT_HASHCODE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;bstHashCodeGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"PRC_NOOP"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;prcNoop"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"REF_CMP"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;ptrCmpGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"REF_CPY"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;ptrCpyGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"REF_CREATE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;ptrCreateGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"REF_HASHCODE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;ptrHashCodeGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"RFL_CMP"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;rflCmpGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"RFL_CPY"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;rflCpyGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"RFL_CREATE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;rflCreateGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"RFL_DESTR"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;rflDestrGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"SCT_CPY"</span> <span class="keywd">then</span>
      object_type := getType(formalParams(function)[1]);
      process_generic_cpy_declaration(object_type, global_c_expr);
      c_expr.expr &amp;:= <span class="stri">"&amp;generic_cpy_"</span>;
      c_expr.expr &amp;:= str(typeNumber(object_type));
    <span class="keywd">elsif</span> action_name = <span class="stri">"SCT_CREATE"</span> <span class="keywd">then</span>
      object_type := getType(formalParams(function)[1]);
      typeCategory @:= [object_type] STRUCTOBJECT;
      process_generic_create_declaration(object_type, global_c_expr);
      c_expr.expr &amp;:= <span class="stri">"&amp;generic_create_"</span>;
      c_expr.expr &amp;:= str(typeNumber(object_type));
    <span class="keywd">elsif</span> action_name = <span class="stri">"SCT_DESTR"</span> <span class="keywd">then</span>
      object_type := getType(formalParams(function)[1]);
      process_generic_destr_declaration(object_type, global_c_expr);
      c_expr.expr &amp;:= <span class="stri">"&amp;generic_destr_"</span>;
      c_expr.expr &amp;:= str(typeNumber(object_type));
    <span class="keywd">elsif</span> action_name = <span class="stri">"SET_CMP"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;setCmpGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"SET_CPY"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;setCpyGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"SET_CREATE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;setCreateGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"SET_DESTR"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;setDestrGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"SET_HASHCODE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;setHashCodeGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"SQL_CMP_DB"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;ptrCmpGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"SQL_CPY_DB"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;sqlCpyDbGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"SQL_CREATE_DB"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;sqlCreateDbGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"SQL_DESTR_DB"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;sqlDestrDbGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"SQL_CMP_STMT"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;ptrCmpGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"SQL_CPY_STMT"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;sqlCpyStmtGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"SQL_CREATE_STMT"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;sqlCreateStmtGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"SQL_DESTR_STMT"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;sqlDestrStmtGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"STR_CMP"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;strCmpGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"STR_CPY"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;strCpyGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"STR_CREATE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;strCreateGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"STR_DESTR"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;strDestrGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"STR_HASHCODE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;strHashCodeGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"TYP_CMP"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;typCmpGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"TYP_CPY"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;ptrCpyGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"TYP_CREATE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;ptrCreateGeneric"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"TYP_DESTR"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;genericDestr"</span>;
    <span class="keywd">elsif</span> action_name = <span class="stri">"TYP_HASHCODE"</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;ptrHashCodeGeneric"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"NULL /* ACTOBJECT { "</span>;
      c_expr.expr &amp;:= action_name;
      c_expr.expr &amp;:= <span class="stri">" }*/"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: block_address (<span class="op">in</span> <span class="type">reference</span>: function, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: formal_params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: formal_param <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">type</span>: object_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">boolean</span>: address_written <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    formal_params := formalParams(function);
    <span class="keywd">if</span> length(formal_params) = 2 <span class="op">and</span> category(formal_params[2]) = SYMBOLOBJECT <span class="op">and</span>
        str(formal_params[2]) = <span class="stri">"hashCode"</span> <span class="keywd">then</span>
      formal_param := formal_params[1];
      object_type := getType(formal_param);
      process_generic_hashCode_declaration(function, object_type, global_c_expr);
      c_expr.expr &amp;:= <span class="stri">"&amp;generic_hashCode_"</span>;
      c_expr.expr &amp;:= str(typeNumber(object_type));
      address_written := TRUE;
    <span class="keywd">elsif</span> length(formal_params) = 3 <span class="op">and</span> category(formal_params[2]) = SYMBOLOBJECT <span class="op">and</span>
        str(formal_params[2]) = <span class="stri">":="</span> <span class="keywd">then</span>
      formal_param := formal_params[1];
      object_type := getType(formal_param);
      process_generic_cpy_declaration(object_type, global_c_expr);
      c_expr.expr &amp;:= <span class="stri">"&amp;generic_cpy_"</span>;
      c_expr.expr &amp;:= str(typeNumber(object_type));
      address_written := TRUE;
    <span class="keywd">elsif</span> length(formal_params) = 3 <span class="op">and</span> category(formal_params[2]) = SYMBOLOBJECT <span class="op">and</span>
        str(formal_params[2]) = <span class="stri">"::="</span> <span class="keywd">then</span>
      formal_param := formal_params[1];
      object_type := getType(formal_param);
      process_generic_create_declaration(object_type, global_c_expr);
      c_expr.expr &amp;:= <span class="stri">"&amp;generic_create_"</span>;
      c_expr.expr &amp;:= str(typeNumber(object_type));
      address_written := TRUE;
    <span class="keywd">elsif</span> length(formal_params) = 2 <span class="op">and</span> category(formal_params[2]) = SYMBOLOBJECT <span class="op">and</span>
        str(formal_params[2]) = <span class="stri">"destroy"</span> <span class="keywd">then</span>
      formal_param := formal_params[1];
      object_type := getType(formal_param);
      process_generic_destr_declaration(object_type, global_c_expr);
      c_expr.expr &amp;:= <span class="stri">"&amp;generic_destr_"</span>;
      c_expr.expr &amp;:= str(typeNumber(object_type));
      address_written := TRUE;
    <span class="keywd">elsif</span> length(formal_params) = 3 <span class="op">and</span> category(formal_params[3]) = SYMBOLOBJECT <span class="op">and</span>
        str(formal_params[3]) = <span class="stri">"compare"</span> <span class="keywd">then</span>
      formal_param := formal_params[1];
      object_type := getType(formal_param);
      process_generic_cmp_declaration(function, object_type, global_c_expr);
      c_expr.expr &amp;:= <span class="stri">"&amp;generic_cmp_"</span>;
      c_expr.expr &amp;:= str(typeNumber(object_type));
      address_written := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="op">not</span> address_written <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;o_"</span>;
      create_name(function, c_expr.expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: object_address (<span class="op">in</span> <span class="type">reference</span>: curr_expr, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">category</span>: exprCategory <span class="keywd">is</span> category.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> curr_expr = NIL <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"NULL"</span>;
    <span class="keywd">else</span>
      exprCategory := category(curr_expr);
      <span class="keywd">if</span> exprCategory = ACTOBJECT <span class="keywd">then</span>
        action_address(curr_expr, c_expr);
      <span class="keywd">elsif</span> exprCategory = BLOCKOBJECT <span class="keywd">then</span>
        block_address(curr_expr, c_expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"/* "</span>;
        c_expr.expr &amp;:= str(exprCategory);
        c_expr.expr &amp;:= <span class="stri">" */"</span>;
        <span class="keywd">block</span>
          c_expr.expr &amp;:= <span class="stri">"&amp;("</span>;
          process_expr(curr_expr, c_expr);
          c_expr.expr &amp;:= <span class="stri">")"</span>;
        exception
          catch RANGE_ERROR:
            c_expr.expr &amp;:= <span class="stri">"/*RANGE_ERROR*/"</span>;
            writeln(<span class="stri">"] "</span>);
            TRACE(curr_expr);
            writeln;
        <span class="keywd">end</span> <span class="keywd">block</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_reference_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="comment">(* if isVar(current_object) then *)</span>
      c_expr.expr &amp;:= <span class="stri">"/* "</span>;
      c_expr.expr &amp;:= type_name2(getType(current_object));
      c_expr.expr &amp;:= <span class="stri">" */ "</span>;
      <span class="keywd">if</span> useFunctype(current_object) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"intfunctype o_"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"objRefType o_"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      create_name(current_object, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">"="</span>;
      <span class="keywd">if</span> useFunctype(current_object) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"(intfunctype)("</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"(objRefType)("</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      object_address(getValue(current_object, reference), c_expr);
      c_expr.expr &amp;:= <span class="stri">");\n\n"</span>;
      function_pointer_declared @:= [current_object] TRUE;
      count_declarations(c_expr);
    <span class="comment">(* end if; *)</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_ref_list_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: refListValue <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    refListValue := getValue(current_object, ref_list);
    <span class="keywd">for</span> index <span class="keywd">range</span> length(refListValue) <span class="keywd">downto</span> 1 <span class="keywd">do</span>
      c_expr.expr &amp;:= <span class="stri">"struct listStruct rec_"</span>;
      c_expr.expr &amp;:= str(objNumber(current_object));
      c_expr.expr &amp;:= <span class="stri">"_"</span>;
      c_expr.expr &amp;:= str(index);
      c_expr.expr &amp;:= <span class="stri">"={"</span>;
      <span class="keywd">if</span> index = length(refListValue) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"NULL"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"&amp;rec_"</span>;
        c_expr.expr &amp;:= str(objNumber(current_object));
        c_expr.expr &amp;:= <span class="stri">"_"</span>;
        c_expr.expr &amp;:= str(succ(index));
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">", (objRefType) &amp;("</span>;
      process_expr(refListValue[index], c_expr);
      c_expr.expr &amp;:= <span class="stri">")};\n"</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    c_expr.expr &amp;:= <span class="stri">"\n"</span>;
    c_expr.expr &amp;:= type_name(getType(current_object));
    c_expr.expr &amp;:= <span class="stri">" o_"</span>;
    create_name(current_object, c_expr.expr);
    c_expr.expr &amp;:= <span class="stri">"="</span>;
    <span class="keywd">if</span> length(refListValue) = 0 <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"NULL"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"&amp;rec_"</span>;
      c_expr.expr &amp;:= str(objNumber(current_object));
      c_expr.expr &amp;:= <span class="stri">"_1"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
    count_declarations(c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_file_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"fileType o_"</span>;
    create_name(current_object, c_expr.expr);
    c_expr.expr &amp;:= <span class="stri">"=&amp;"</span>;
    c_expr.expr &amp;:= lower(literal(getValue(current_object, clib_file)));
    c_expr.expr &amp;:= <span class="stri">"FileRecord;\n\n"</span>;
    count_declarations(c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_socket_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"socketType o_"</span>;
    create_name(current_object, c_expr.expr);
    c_expr.expr &amp;:= <span class="stri">" = (socketType) -1;\n\n"</span>;
    count_declarations(c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_poll_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"pollType o_"</span>;
    create_name(current_object, c_expr.expr);
    c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
    global_init.expr &amp;:= diagnosticLine(current_object);
    global_init.expr &amp;:= <span class="stri">"o_"</span>;
    create_name(current_object, global_init.expr);
    global_init.expr &amp;:= <span class="stri">"=polEmpty();\n"</span>;
    count_declarations(c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_array_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: param_value <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    typeCategory @:= [getType(current_object)] ARRAYOBJECT;
    <span class="keywd">if</span> isVar(current_object) <span class="keywd">then</span>
      c_expr.expr &amp;:= type_name(getType(current_object));
      c_expr.expr &amp;:= <span class="stri">" o_"</span>;
      create_name(current_object, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
      <span class="keywd">if</span> current_object <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
        const_table @:= [current_object] length(const_table);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      global_init.expr &amp;:= diagnosticLine(current_object);
      global_init.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(current_object, global_init.expr);
      global_init.expr &amp;:= <span class="stri">"="</span>;
      param_value := <span class="stri">"("</span>;
      param_value &amp;:= type_name(getType(current_object));
      param_value &amp;:= <span class="stri">")(arr["</span>;
      param_value &amp;:= str(const_table[current_object]);
      param_value &amp;:= <span class="stri">"])"</span>;
      process_create_declaration(getType(current_object), global_c_expr);
      process_create_call(getType(current_object),
          param_value, global_init.expr);
      global_init.expr &amp;:= <span class="stri">";\n"</span>;
      count_declarations(c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_hash_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: param_value <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    typeCategory @:= [getType(current_object)] HASHOBJECT;
    c_expr.expr &amp;:= type_name(getType(current_object));
    c_expr.expr &amp;:= <span class="stri">" o_"</span>;
    create_name(current_object, c_expr.expr);
    c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
    <span class="keywd">if</span> current_object <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
      const_table @:= [current_object] length(const_table);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    global_init.expr &amp;:= diagnosticLine(current_object);
    global_init.expr &amp;:= <span class="stri">"o_"</span>;
    create_name(current_object, global_init.expr);
    global_init.expr &amp;:= <span class="stri">"="</span>;
    param_value := <span class="stri">"("</span>;
    param_value &amp;:= type_name(getType(current_object));
    param_value &amp;:= <span class="stri">")(hsh["</span>;
    param_value &amp;:= str(const_table[current_object]);
    param_value &amp;:= <span class="stri">"])"</span>;
    <span class="keywd">if</span> isVar(current_object) <span class="keywd">then</span>
      process_create_declaration(getType(current_object), global_c_expr);
      process_create_call(getType(current_object),
          param_value, global_init.expr);
    <span class="keywd">else</span>
      global_init.expr &amp;:= param_value;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    global_init.expr &amp;:= <span class="stri">";\n"</span>;
    count_declarations(c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_set_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> isVar(current_object) <span class="keywd">then</span>
      c_expr.expr &amp;:= type_name(getType(current_object));
      c_expr.expr &amp;:= <span class="stri">" o_"</span>;
      create_name(current_object, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
      global_init.expr &amp;:= diagnosticLine(current_object);
      global_init.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(current_object, global_init.expr);
      global_init.expr &amp;:= <span class="stri">"=setCreate("</span>;
      global_init.expr &amp;:= bitsetLiteral(getValue(current_object, bitset));
      global_init.expr &amp;:= <span class="stri">");\n"</span>;
      count_declarations(c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_struct_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: param_value <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: init_expr <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    declare_type_if_necessary(getType(current_object), c_expr);
    c_expr.expr &amp;:= type_name(getType(current_object));
    c_expr.expr &amp;:= <span class="stri">" o_"</span>;
    create_name(current_object, c_expr.expr);
    c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
    <span class="keywd">if</span> current_object <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
      const_table @:= [current_object] length(const_table);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    init_expr &amp;:= diagnosticLine(current_object);
    init_expr &amp;:= <span class="stri">"o_"</span>;
    create_name(current_object, init_expr);
    init_expr &amp;:= <span class="stri">"="</span>;
    param_value := <span class="stri">"("</span>;
    param_value &amp;:= type_name(getType(current_object));
    param_value &amp;:= <span class="stri">")(sct["</span>;
    param_value &amp;:= str(const_table[current_object]);
    param_value &amp;:= <span class="stri">"])"</span>;
    <span class="keywd">if</span> isVar(current_object) <span class="keywd">then</span>
      process_create_declaration(getType(current_object), global_c_expr);
      process_create_call(getType(current_object),
          param_value, init_expr);
    <span class="keywd">else</span>
      init_expr &amp;:= param_value;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    init_expr &amp;:= <span class="stri">";\n"</span>;
    <span class="keywd">if</span> current_object <span class="op">in</span> globalInitalisations <span class="keywd">then</span>
      globalInitalisations @:= [current_object] globalInitalisations[current_object] &amp; init_expr;
    <span class="keywd">else</span>
      globalInitalisations @:= [current_object] init_expr;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    count_declarations(c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_interface_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= type_name(getType(current_object));
    c_expr.expr &amp;:= <span class="stri">" o_"</span>;
    create_name(current_object, c_expr.expr);
    c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
    <span class="keywd">if</span> current_object <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
      const_table @:= [current_object] length(const_table);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    global_init.expr &amp;:= diagnosticLine(current_object);
    global_init.expr &amp;:= <span class="stri">"o_"</span>;
    create_name(current_object, global_init.expr);
    global_init.expr &amp;:= <span class="stri">"=("</span>;
    global_init.expr &amp;:= type_name(getType(current_object));
    global_init.expr &amp;:= <span class="stri">")(itfCreate(itf["</span>;
    global_init.expr &amp;:= str(const_table[current_object]);
    global_init.expr &amp;:= <span class="stri">"]));\n"</span>;
    count_declarations(c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_win_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> isVar(current_object) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"winType o_"</span>;
      create_name(current_object, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
      global_init.expr &amp;:= diagnosticLine(current_object);
      global_init.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(current_object, global_init.expr);
      global_init.expr &amp;:= <span class="stri">"=drwCreate("</span>;
      global_init.expr &amp;:= windowLiteral(getValue(current_object, PRIMITIVE_WINDOW));
      global_init.expr &amp;:= <span class="stri">");\n"</span>;
      count_declarations(c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_plist_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> isVar(current_object) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"bstriType o_"</span>;
      create_name(current_object, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
      global_init.expr &amp;:= diagnosticLine(current_object);
      global_init.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(current_object, global_init.expr);
      global_init.expr &amp;:= <span class="stri">"=bstCreate("</span>;
      global_init.expr &amp;:= pointListLiteral(getValue(current_object, pointList));
      global_init.expr &amp;:= <span class="stri">");\n"</span>;
      count_declarations(c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_process_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> isVar(current_object) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"processType o_"</span>;
      create_name(current_object, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">"=NULL;\n\n"</span>;
      count_declarations(c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_prog_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> isVar(current_object) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"progType o_"</span>;
      create_name(current_object, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">"=NULL;\n\n"</span>;
      count_declarations(c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_enum_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> isVar(current_object) <span class="op">or</span> <span class="op">not</span> isFunc(getType(current_object)) <span class="keywd">then</span>
      <span class="keywd">if</span> getType(current_object) = voidtype <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"/* do not declare void variable or constant o_"</span>;
        create_name2(current_object, c_expr.expr);
        c_expr.expr &amp;:= <span class="stri">" */\n\n"</span>;
      <span class="keywd">else</span>
        <span class="keywd">if</span> <span class="op">not</span> isVar(current_object) <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"const "</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        declare_type_if_necessary(getType(current_object), c_expr);
        c_expr.expr &amp;:= type_name(getType(current_object));
        c_expr.expr &amp;:= <span class="stri">" o_"</span>;
        create_name(current_object, c_expr.expr);
        c_expr.expr &amp;:= <span class="stri">"="</span>;
        c_expr.expr &amp;:= enum_value(getValue(current_object, reference));
        c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    count_declarations(c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_enum_literal_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: enum_type <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    enum_type := getType(current_object);
    <span class="keywd">if</span> enum_type = voidtype <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"/* do not declare: void o_4_empty */\n\n"</span>;
    <span class="keywd">else</span>
      <span class="keywd">if</span> enum_type <span class="op">not</span> <span class="op">in</span> enum_literal <span class="keywd">then</span>
        enum_literal @:= [enum_type] element_number_hash.EMPTY_HASH;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> current_object <span class="op">not</span> <span class="op">in</span> enum_literal[enum_type] <span class="keywd">then</span>
        enum_literal[enum_type] @:= [current_object] length(enum_literal[enum_type]);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">"const "</span>;
      declare_type_if_necessary(enum_type, c_expr);
      c_expr.expr &amp;:= type_name(enum_type);
      c_expr.expr &amp;:= <span class="stri">" o_"</span>;
      create_name(current_object, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">"="</span>;
      c_expr.expr &amp;:= enum_value(current_object);
      c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    count_declarations(c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: print_parameter_list (<span class="op">in</span> <span class="type">ref_list</span>: formal_params,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: formal_param <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">category</span>: paramCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">boolean</span>: first_element <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">type</span>: param_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: implementationType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> formal_param <span class="keywd">range</span> formal_params <span class="keywd">do</span>
      paramCategory := category(formal_param);
      <span class="keywd">if</span> paramCategory &lt;> SYMBOLOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> first_element <span class="keywd">then</span>
          first_element := FALSE;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">" printf(\", \");\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        param_type := getType(formal_param);
        <span class="keywd">if</span> param_type <span class="op">in</span> implements <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">" /*# "</span>;
          <span class="keywd">for</span> implementationType <span class="keywd">range</span> implements[param_type] <span class="keywd">do</span>
            c_expr.expr &amp;:= type_name2(implementationType);
            c_expr.expr &amp;:= <span class="stri">"  "</span>;
          <span class="keywd">end</span> <span class="keywd">for</span>;
          c_expr.expr &amp;:= <span class="stri">" */ "</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"printf("</span>;
        c_expr.expr &amp;:= c_literal(str(paramCategory) &amp; <span class="stri">" "</span>);
        c_expr.expr &amp;:= <span class="stri">"); "</span>;
        <span class="keywd">if</span> param_type <span class="op">in</span> typeCategory <span class="keywd">then</span>
          <span class="keywd">case</span> typeCategory[param_type] <span class="keywd">of</span>
            <span class="keywd">when</span> {INTOBJECT}:
              c_expr.expr &amp;:= <span class="stri">"printf(\"intType \"); "</span>;
              c_expr.expr &amp;:= <span class="stri">"printf(\"%ld\", "</span>;
            <span class="keywd">when</span> {FLOATOBJECT}:
              c_expr.expr &amp;:= <span class="stri">"printf(\"floatType \"); "</span>;
              c_expr.expr &amp;:= <span class="stri">"printf(\"%f\", "</span>;
            <span class="keywd">when</span> {CHAROBJECT}:
              c_expr.expr &amp;:= <span class="stri">"printf(\"charType \"); "</span>;
              c_expr.expr &amp;:= <span class="stri">"printf(\"%c\", "</span>;
            <span class="keywd">when</span> {STRIOBJECT}:
              c_expr.expr &amp;:= <span class="stri">"printf(\"striType \"); "</span>;
              c_expr.expr &amp;:= <span class="stri">"filPrint("</span>;
            <span class="keywd">when</span> {TYPEOBJECT}:
              c_expr.expr &amp;:= <span class="stri">"printf(\"typeType \"); "</span>;
              c_expr.expr &amp;:= <span class="stri">"printf(\"%X\", "</span>;
            <span class="keywd">otherwise</span>:
              c_expr.expr &amp;:= <span class="stri">"printf(\""</span>;
              c_expr.expr &amp;:= type_name(param_type);
              c_expr.expr &amp;:= <span class="stri">" \"); "</span>;
              c_expr.expr &amp;:= <span class="stri">"printf(\"%X\", "</span>;
          <span class="keywd">end</span> <span class="keywd">case</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"printf(\""</span>;
          c_expr.expr &amp;:= type_name(param_type);
          c_expr.expr &amp;:= <span class="stri">" \"); "</span>;
          c_expr.expr &amp;:= <span class="stri">"printf(\"%X\", "</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> isPointerParam(formal_param) <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"(o_"</span>;
          create_name(formal_param, c_expr.expr);
          c_expr.expr &amp;:= <span class="stri">"?*o_"</span>;
          create_name(formal_param, c_expr.expr);
          c_expr.expr &amp;:= <span class="stri">":0)"</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"o_"</span>;
          create_name(formal_param, c_expr.expr);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">");"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_dynamic_parameter_list (<span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: actual_params, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: formal_params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: formal_param <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">reference</span>: actual_param <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">category</span>: formalCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">category</span>: paramCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">boolean</span>: first_element <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    formal_params := formalParams(function);
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> length(formal_params) <span class="keywd">do</span>
      formal_param := formal_params[number];
      actual_param := actual_params[number];
      formalCategory := category(formal_param);
      paramCategory := category(actual_param);
      <span class="keywd">if</span> paramCategory &lt;> SYMBOLOBJECT <span class="op">and</span>
          formalCategory &lt;> SYMBOLOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> formalCategory = TYPEOBJECT <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"/* attr t_"</span>;
          c_expr.expr &amp;:= str(typeNumber(getValue(formal_param, type)));
          c_expr.expr &amp;:= <span class="stri">" "</span>;
          c_expr.expr &amp;:= str(getValue(formal_param, type));
          c_expr.expr &amp;:= <span class="stri">"*/ "</span>;
        <span class="keywd">else</span>
          <span class="keywd">if</span> first_element <span class="keywd">then</span>
            first_element := FALSE;
          <span class="keywd">else</span>
            c_expr.expr &amp;:= <span class="stri">", "</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> <span class="op">not</span> isVar(actual_param) <span class="op">and</span> isInOutParam(formal_param) <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"/* SHOULD NOT HAPPEN &amp;o_"</span>;
            create_name(actual_param, c_expr.expr);
            c_expr.expr &amp;:= <span class="stri">" */"</span>;
          <span class="keywd">elsif</span> isPointerParam(actual_param) = isPointerParam(formal_param) <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"o_"</span>;
            create_name(actual_param, c_expr.expr);
          <span class="keywd">elsif</span> isPointerParam(actual_param) <span class="op">and</span> <span class="op">not</span> isPointerParam(formal_param) <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"*o_"</span>;
            create_name(actual_param, c_expr.expr);
          <span class="keywd">else</span> <span class="comment"># if isVar(actual_param) or not isInOutParam(formal_param) then</span>
            c_expr.expr &amp;:= <span class="stri">"&amp;o_"</span>;
            create_name(actual_param, c_expr.expr);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_dynamic_function_call (<span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: actual_params, <span class="op">in</span> <span class="type">reference</span>: interface_object, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> expr_type: resultExpr <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    resultExpr.currentFile := file(interface_object);
    resultExpr.currentLine := line(interface_object);
    resultExpr.temp_num := c_expr.temp_num;
    <span class="keywd">if</span> function <span class="op">in</span> function_not_declared <span class="keywd">then</span>
      process_inline(function, actual_params, resultExpr);
      <span class="keywd">if</span> resultExpr.result_expr = <span class="stri">""</span> <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"/* copy ref_to_value */ "</span>;
        process_create_declaration(resultType(getType(interface_object)), global_c_expr);
        process_create_call(resultType(getType(interface_object)),
            resultExpr.expr, c_expr.expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= resultExpr.result_expr;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      resultExpr.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(function, resultExpr.expr);
      resultExpr.expr &amp;:= <span class="stri">"("</span>;
      process_dynamic_parameter_list(function, actual_params, resultExpr);
      resultExpr.expr &amp;:= <span class="stri">")"</span>;
      <span class="keywd">if</span> function <span class="op">in</span> return_ref_to_value <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"/* copy ref_to_value */ "</span>;
        process_create_declaration(resultType(getType(interface_object)), global_c_expr);
        process_create_call(resultType(getType(interface_object)),
            resultExpr.expr, c_expr.expr);
      <span class="keywd">else</span>
        c_expr.expr &amp;:= resultExpr.expr;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.temp_num := resultExpr.temp_num;
    c_expr.temp_decls &amp;:= resultExpr.temp_decls;
    c_expr.temp_assigns &amp;:= resultExpr.temp_assigns;
    c_expr.temp_frees &amp;:= resultExpr.temp_frees;
    c_expr.temp_to_null &amp;:= resultExpr.temp_to_null;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_dynamic_action_call (<span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: actual_params, <span class="op">in</span> <span class="type">reference</span>: interface_object, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> expr_type: c_action_expr <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    <span class="comment"># c_expr.expr &amp;:= "/* ";</span>
    <span class="comment"># c_expr.expr &amp;:= str(getValue(function, ACTION));</span>
    <span class="comment"># c_expr.expr &amp;:= " */ ";</span>
    c_action_expr.currentFile := file(interface_object);
    c_action_expr.currentLine := line(interface_object);
    c_action_expr.temp_num := c_expr.temp_num;
    process_action(function, actual_params, c_action_expr);
    c_expr.temp_num := c_action_expr.temp_num;
    c_expr.temp_decls &amp;:= c_action_expr.temp_decls;
    c_expr.temp_assigns &amp;:= c_action_expr.temp_assigns;
    c_expr.temp_frees &amp;:= c_action_expr.temp_frees;
    c_expr.temp_to_null &amp;:= c_action_expr.temp_to_null;
    <span class="keywd">if</span> c_action_expr.result_expr &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      c_expr.expr &amp;:= c_action_expr.result_expr;
    <span class="keywd">else</span>
      <span class="keywd">if</span> isVarfunc(getType(interface_object)) <span class="op">or</span>
          getType(interface_object) = proctype <span class="keywd">then</span>
        c_expr.expr &amp;:= c_action_expr.expr;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"/* copy ref_to_value */ "</span>;
        process_create_declaration(resultType(getType(interface_object)), global_c_expr);
        process_create_call(resultType(getType(interface_object)),
            c_action_expr.expr, c_expr.expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_dynamic_call (<span class="op">in</span> <span class="type">reference</span>: function,
    <span class="op">in</span> <span class="type">ref_list</span>: actual_params, <span class="op">in</span> <span class="type">reference</span>: interface_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">category</span>: objectCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> expr_type: resultExpr <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> function = interface_object <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"/* ENDLESS RECURSION */\n"</span>;
      c_expr.expr &amp;:= diagnosticLine(interface_object);
      c_expr.expr &amp;:= <span class="stri">"raiseError(ACTION_ERROR);\n"</span>;
    <span class="keywd">elsif</span> function &lt;> NIL <span class="keywd">then</span>
      c_expr.expr &amp;:= diagnosticLine(interface_object);
      objectCategory := category(function);
      <span class="keywd">if</span> objectCategory = BLOCKOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> resultType(getType(interface_object)) &lt;> voidtype <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"return "</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        process_dynamic_function_call(function, actual_params, interface_object, c_expr);
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
      <span class="keywd">elsif</span> objectCategory = ACTOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> resultType(getType(interface_object)) &lt;> voidtype <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"return "</span>;
          <span class="keywd">if</span> isVarfunc(getType(interface_object)) <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"&amp;("</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        process_dynamic_action_call(function, actual_params, interface_object, c_expr);
        <span class="keywd">if</span> resultType(getType(interface_object)) &lt;> voidtype <span class="keywd">then</span>
          <span class="keywd">if</span> isVarfunc(getType(interface_object)) <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">")"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> objectCategory = INTOBJECT <span class="op">or</span>
          objectCategory = BIGINTOBJECT <span class="op">or</span>
          objectCategory = FLOATOBJECT <span class="op">or</span>
          objectCategory = CHAROBJECT <span class="op">or</span>
          objectCategory = STRIOBJECT <span class="op">or</span>
          objectCategory = BSTRIOBJECT <span class="op">or</span>
          objectCategory = ARRAYOBJECT <span class="op">or</span>
          objectCategory = STRUCTOBJECT <span class="op">or</span>
          objectCategory = SETOBJECT <span class="op">or</span>
          objectCategory = WINOBJECT <span class="op">or</span>
          objectCategory = POINTLISTOBJECT <span class="op">or</span>
          objectCategory = PROCESSOBJECT <span class="op">or</span>
          objectCategory = CONSTENUMOBJECT <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"return "</span>;
        getAnyParamToExpr(function, resultExpr);
        process_create_declaration(getType(function), global_c_expr);
        process_create_call(getType(function),
            resultExpr.expr, c_expr.expr);
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"/* "</span>;
        c_expr.expr &amp;:= str(objectCategory);
        c_expr.expr &amp;:= <span class="stri">" */\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"/* NOT FOUND */\n"</span>;
      c_expr.expr &amp;:= diagnosticLine(interface_object);
      c_expr.expr &amp;:= <span class="stri">"raiseError(ACTION_ERROR);\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_dynamic_condition (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> <span class="type">ref_list</span>: formal_params, <span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: paramNum,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">forward</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_dynamic_param_implements (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> <span class="type">ref_list</span>: formal_params, <span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: paramNum,
    <span class="op">in</span> <span class="type">type</span>: param_type, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: formal_param <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">type</span>: implementationType <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">bitset</span>: usedCaseLabels <span class="keywd">is</span> {};
  <span class="keywd">begin</span>
    formal_param := formal_params[paramNum];
    c_expr.expr &amp;:= diagnosticLine(current_object);
    c_expr.expr &amp;:= <span class="stri">"switch (((interfaceType) "</span>;
    <span class="keywd">if</span> isPointerParam(formal_param) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"*o_"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"o_"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    create_name(formal_param, c_expr.expr);
    c_expr.expr &amp;:= <span class="stri">")->type_num) {\n"</span>;
    <span class="keywd">for</span> implementationType <span class="keywd">range</span> implements[param_type] <span class="keywd">do</span>
      <span class="keywd">if</span> typeNumber(implementationType) <span class="op">not</span> <span class="op">in</span> usedCaseLabels <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"case "</span>;
        c_expr.expr &amp;:= str(typeNumber(implementationType));
        c_expr.expr &amp;:= <span class="stri">"/*"</span>;
        c_expr.expr &amp;:= str(implementationType);
        c_expr.expr &amp;:= <span class="stri">"*/"</span>;
        c_expr.expr &amp;:= <span class="stri">":\n"</span>;
        setType(formal_params[paramNum], implementationType);
        process_dynamic_condition(current_object,
            formal_params, paramNum, c_expr);
        setType(formal_params[paramNum], param_type);
        c_expr.expr &amp;:= diagnosticLine(current_object);
        c_expr.expr &amp;:= <span class="stri">"break;\n"</span>;
        incl(usedCaseLabels, typeNumber(implementationType));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    c_expr.expr &amp;:= <span class="stri">"default:\n"</span>;
    c_expr.expr &amp;:= diagnosticLine(current_object);
    c_expr.expr &amp;:= <span class="stri">"raiseError(ACTION_ERROR);\n"</span>;
    <span class="comment">(*
    c_expr.expr &amp;:= diagnosticLine(current_object);
    c_expr.expr &amp;:= "printf(\"type_num=%d\\n\", ";
    if isPointerParam(formal_param) then
      c_expr.expr &amp;:= "((interfaceType) *o_";
    else
      c_expr.expr &amp;:= "((interfaceType) o_";
    end if;
    create_name(formal_param, c_expr.expr);
    c_expr.expr &amp;:= ")->type_num);\n";
    c_expr.expr &amp;:= diagnosticLine(current_object);
    c_expr.expr &amp;:= "printf(\"o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &amp;:= "(\");\n";
    c_expr.expr &amp;:= diagnosticLine(current_object);
    print_parameter_list(formal_params, c_expr);
    c_expr.expr &amp;:= "printf(\")\\n\");\n";
    *)</span>
    c_expr.expr &amp;:= diagnosticLine(current_object);
    c_expr.expr &amp;:= <span class="stri">"break;\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_dynamic_param_enumeration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> <span class="type">ref_list</span>: formal_params, <span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: paramNum,
    <span class="op">in</span> <span class="type">type</span>: param_type, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: formal_param <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> number_element_hash: enumsByIntValue <span class="keywd">is</span> number_element_hash.value;
    <span class="keywd">var</span> <span class="type">integer</span>: intValueOfEnum <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reference</span>: enumLiteral <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">reference</span>: backupParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    formal_param := formal_params[paramNum];
    c_expr.expr &amp;:= diagnosticLine(current_object);
    c_expr.expr &amp;:= <span class="stri">"switch ("</span>;
    <span class="keywd">if</span> isPointerParam(formal_param) <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"*o_"</span>;
      create_name(formal_param, c_expr.expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"o_"</span>;
      create_name(formal_param, c_expr.expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">") {\n"</span>;
    enumsByIntValue := flip(enum_literal[param_type]);
    <span class="comment"># Sort by integer values to always produce the same C code</span>
    <span class="keywd">for</span> intValueOfEnum <span class="keywd">range</span> sort(keys(enumsByIntValue)) <span class="keywd">do</span>
      c_expr.expr &amp;:= diagnosticLine(current_object);
      c_expr.expr &amp;:= <span class="stri">"case "</span>;
      c_expr.expr &amp;:= str(intValueOfEnum);
      c_expr.expr &amp;:= <span class="stri">": {\n"</span>;
      <span class="comment"># If the enums are correct there will only be one per integer value</span>
      enumLiteral := enumsByIntValue[intValueOfEnum][1];
      backupParam := formal_params[paramNum];
      formal_params @:= [paramNum] enumLiteral;
      process_dynamic_condition(current_object,
          formal_params, paramNum, c_expr);
      formal_params @:= [paramNum] backupParam;
      c_expr.expr &amp;:= diagnosticLine(current_object);
      c_expr.expr &amp;:= <span class="stri">"} break;\n"</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    c_expr.expr &amp;:= diagnosticLine(current_object);
    c_expr.expr &amp;:= <span class="stri">"default: {\n"</span>;
    c_expr.expr &amp;:= diagnosticLine(current_object);
    c_expr.expr &amp;:= <span class="stri">"raiseError(ACTION_ERROR);\n"</span>;
    <span class="comment">(*
    c_expr.expr &amp;:= "printf(\"literal_num=%d\\n\", ";
    if isPointerParam(formal_param) then
      c_expr.expr &amp;:= "*o_";
      create_name(formal_param, c_expr.expr);
    else
      c_expr.expr &amp;:= "o_";
      create_name(formal_param, c_expr.expr);
    end if;
    c_expr.expr &amp;:= ");\n";
    c_expr.expr &amp;:= "printf(\"o_";
    create_name(current_object, c_expr.expr);
    c_expr.expr &amp;:= "(\");\n";
    print_parameter_list(formal_params, c_expr);
    c_expr.expr &amp;:= "printf(\")\\n\");\n";
    *)</span>
    c_expr.expr &amp;:= <span class="stri">"} break;\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_dynamic_condition (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> <span class="type">ref_list</span>: formal_params, <span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: paramNum,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: formal_param <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">category</span>: paramCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">type</span>: param_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">ref_list</span>: param_list <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: matched_object <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    incr(paramNum);
    <span class="keywd">if</span> paramNum &lt;= length(formal_params) <span class="keywd">then</span>
      formal_param := formal_params[paramNum];
      paramCategory := category(formal_param);
      <span class="keywd">if</span> paramCategory &lt;> SYMBOLOBJECT <span class="keywd">then</span>
        param_type := getType(formal_param);
        <span class="keywd">if</span> param_type <span class="op">in</span> implements <span class="keywd">then</span>
          process_dynamic_param_implements(current_object,
              formal_params, paramNum, param_type, c_expr);
        <span class="keywd">elsif</span> param_type <span class="op">in</span> enum_literal <span class="keywd">then</span>
          process_dynamic_param_enumeration(current_object,
              formal_params, paramNum, param_type, c_expr);
        <span class="keywd">else</span>
          process_dynamic_condition(current_object,
              formal_params, paramNum, c_expr);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        process_dynamic_condition(current_object,
            formal_params, paramNum, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      param_list := formal_params;
      matched_object := match(prog, param_list);
      <span class="comment">(*
      if matched_object = NIL then
        c_expr.expr &amp;:= "printf(\"NOT FOUND:\\n\");\n";
        for formal_param range formal_params do
          paramCategory := category(formal_param);
          if paramCategory &lt;> SYMBOLOBJECT then
            param_type := getType(formal_param);
            if param_type in implements then
              c_expr.expr &amp;:= "printf(\"type_num=%d\\n\", ";
              if isPointerParam(formal_param) then
                c_expr.expr &amp;:= "((interfaceType) *o_";
              else
                c_expr.expr &amp;:= "((interfaceType) o_";
              end if;
              create_name(formal_param, c_expr.expr);
              c_expr.expr &amp;:= ")->type_num);\n";
            elsif param_type in enum_literal then
              c_expr.expr &amp;:= "printf(\"literal_num=%d\\n\", ";
              if isPointerParam(formal_param) then
                c_expr.expr &amp;:= "*o_";
              else
                c_expr.expr &amp;:= "o_";
              end if;
              create_name(formal_param, c_expr.expr);
              c_expr.expr &amp;:= ");\n";
            else
              c_expr.expr &amp;:= "printf(\"other param_type\\n\");\n";
            end if;
          else
            c_expr.expr &amp;:= "printf(\"" &lt;&amp; toUtf8(str(formal_param)) &lt;&amp; "\\n\");\n";
          end if;
        end for;
      end if;
      *)</span>
      process_dynamic_call(matched_object, formal_params, current_object, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_dynamic_decision (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> expr_type: c_param_list <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> expr_type: c_func_body <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">type</span>: object_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: result_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">ref_list</span>: param_list <span class="keywd">is</span> ref_list.EMPTY;
  <span class="keywd">begin</span>
    object_type := getType(current_object);
    <span class="keywd">if</span> isFunc(object_type) <span class="op">or</span> isVarfunc(object_type) <span class="keywd">then</span>
      result_type := resultType(object_type);
      declare_types_of_params(param_list, global_c_expr);
      c_expr.expr &amp;:= diagnosticLine(current_object);
      c_expr.expr &amp;:= <span class="stri">"/* DYNAMIC */ static "</span>;
      c_expr.expr &amp;:= type_name(result_type);
      <span class="keywd">if</span> isVarfunc(object_type) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">" *o_"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">" o_"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      create_name(current_object, c_expr.expr);
      param_list := formalParams(current_object);
      c_expr.expr &amp;:= <span class="stri">" ("</span>;
      process_param_list_declaration(param_list, c_param_list);
      c_expr.expr &amp;:= c_param_list.expr;
      c_expr.expr &amp;:= <span class="stri">")\n"</span>;
      c_expr.expr &amp;:= diagnosticLine(current_object);
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      process_dynamic_condition(current_object,
          param_list, 0, c_func_body);
      appendWithDiagnostic(c_param_list.temp_decls, c_expr);
      appendWithDiagnostic(c_func_body.temp_decls, c_expr);
      c_expr.expr &amp;:= c_param_list.temp_assigns;
      <span class="keywd">if</span> trace_dynamic_calls <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"fprintf("</span>;
        c_expr.expr &amp;:= trace_output;
        c_expr.expr &amp;:= <span class="stri">", \"DYNAMIC "</span>;
        create_name(current_object, c_expr.expr);
        c_expr.expr &amp;:= <span class="stri">"\\n\");\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"fflush("</span>;
        c_expr.expr &amp;:= trace_output;
        c_expr.expr &amp;:= <span class="stri">");\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      appendWithDiagnostic(c_func_body.temp_assigns, c_expr);
      c_expr.expr &amp;:= c_func_body.expr;
      appendWithDiagnostic(c_param_list.temp_frees, c_expr);
      appendWithDiagnostic(c_func_body.temp_frees, c_expr);
      c_expr.expr &amp;:= diagnosticLine(current_object);
      c_expr.expr &amp;:= <span class="stri">"}\n\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_dynamic_decisions (<span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: current_object <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> current_object <span class="keywd">range</span> dynamic_functions <span class="keywd">do</span>
      process_dynamic_decision(current_object, c_expr);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_dynamic_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> expr_type: c_param_list <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">type</span>: object_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: result_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">ref_list</span>: param_list <span class="keywd">is</span> ref_list.EMPTY;
  <span class="keywd">begin</span>
    object_type := getType(current_object);
    <span class="keywd">if</span> isFunc(object_type) <span class="op">or</span> isVarfunc(object_type) <span class="keywd">then</span>
      result_type := resultType(object_type);
      dynamic_functions &amp;:= make_list(current_object);
      declare_types_of_params(param_list, global_c_expr);
      c_expr.expr &amp;:= <span class="stri">"/* DYNAMIC */ static "</span>;
      c_expr.expr &amp;:= type_name(result_type);
      <span class="keywd">if</span> isVarfunc(object_type) <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">" *o_"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">" o_"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      create_name(current_object, c_expr.expr);
      param_list := formalParams(current_object);
      c_expr.expr &amp;:= <span class="stri">" ("</span>;
      process_param_list_declaration(param_list, c_param_list);
      c_expr.expr &amp;:= c_param_list.expr;
      c_expr.expr &amp;:= <span class="stri">");\n"</span>;
      prototype_declared @:= [current_object] TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: declare_literal_function_of_enum (<span class="op">in</span> <span class="type">type</span>: enumType,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> number_element_hash: enumsByIntValue <span class="keywd">is</span> number_element_hash.value;
    <span class="keywd">var</span> <span class="type">integer</span>: intValueOfEnum <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reference</span>: enumLiteral <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    c_expr.expr &amp;:= noDiagnosticLine;
    c_expr.expr &amp;:= <span class="stri">"static striType lit_"</span>;
    c_expr.expr &amp;:= str(typeNumber(enumType));
    c_expr.expr &amp;:= <span class="stri">" ("</span>;
    c_expr.expr &amp;:= type_name(enumType);
    c_expr.expr &amp;:= <span class="stri">" enumValue)\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
    c_expr.expr &amp;:= noDiagnosticLine;
    c_expr.expr &amp;:= <span class="stri">"switch (enumValue) {\n"</span>;
    enumsByIntValue := flip(enum_literal[enumType]);
    <span class="comment"># Sort by integer values to always produce the same C code</span>
    <span class="keywd">for</span> intValueOfEnum <span class="keywd">range</span> sort(keys(enumsByIntValue)) <span class="keywd">do</span>
      <span class="comment"># If the enums are correct there will only be one per integer value</span>
      enumLiteral := enumsByIntValue[intValueOfEnum][1];
      c_expr.expr &amp;:= diagnosticLine(enumLiteral);
      c_expr.expr &amp;:= <span class="stri">"case "</span>;
      c_expr.expr &amp;:= str(intValueOfEnum);
      c_expr.expr &amp;:= <span class="stri">": return "</span>;
      c_expr.expr &amp;:= stringLiteral(str(enumLiteral));
      c_expr.expr &amp;:= <span class="stri">"; break;\n"</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    c_expr.expr &amp;:= noDiagnosticLine;
    c_expr.expr &amp;:= <span class="stri">"default: "</span>;
    c_expr.expr &amp;:= raiseError(<span class="stri">"RANGE_ERROR"</span>);
    c_expr.expr &amp;:= <span class="stri">" return NULL; break;\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: declare_literal_function_of_enums (<span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: enumType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> <span class="keywd">key</span> enumType <span class="keywd">range</span> enum_literal <span class="keywd">do</span>
      <span class="keywd">if</span> enumType <span class="op">in</span> literal_function_of_enum_used <span class="keywd">then</span>
        declare_literal_function_of_enum(enumType, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_hashcode (<span class="op">in</span> <span class="type">reference</span>: current_object, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: param_list <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: expression <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    param_list := make_list(current_object);
    param_list &amp;:= make_list(syobject(prog, <span class="stri">"hashCode"</span>));
    expression := matchExpr(prog, param_list);
    <span class="comment"># TRACE_REF(expression);</span>
    setCategory(expression, CALLOBJECT);
    process_expr(expression, c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: keyCreateObj (<span class="op">in</span> <span class="type">type</span>: hash_type) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">reference</span>: keyCreate <span class="keywd">is</span> NIL;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: param_list <span class="keywd">is</span> ref_list.EMPTY;
  <span class="keywd">begin</span>
    param_list := make_list(typeObject(hash_type));
    param_list &amp;:= make_list(syobject(prog, <span class="stri">"."</span>));
    param_list &amp;:= make_list(syobject(prog, <span class="stri">"keyCreate"</span>));
    keyCreate := match(prog, param_list);
    keyCreate := getValue(keyCreate, reference);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: keyCompareObj (<span class="op">in</span> <span class="type">type</span>: hash_type) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">reference</span>: keyCompare <span class="keywd">is</span> NIL;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: param_list <span class="keywd">is</span> ref_list.EMPTY;
  <span class="keywd">begin</span>
    param_list := make_list(typeObject(hash_type));
    param_list &amp;:= make_list(syobject(prog, <span class="stri">"."</span>));
    param_list &amp;:= make_list(syobject(prog, <span class="stri">"keyCompare"</span>));
    keyCompare := match(prog, param_list);
    keyCompare := getValue(keyCompare, reference);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: dataCreateObj (<span class="op">in</span> <span class="type">type</span>: hash_type) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">reference</span>: dataCreate <span class="keywd">is</span> NIL;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: param_list <span class="keywd">is</span> ref_list.EMPTY;
  <span class="keywd">begin</span>
    param_list := make_list(typeObject(hash_type));
    param_list &amp;:= make_list(syobject(prog, <span class="stri">"."</span>));
    param_list &amp;:= make_list(syobject(prog, <span class="stri">"dataCreate"</span>));
    dataCreate := match(prog, param_list);
    dataCreate := getValue(dataCreate, reference);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">reference</span>: dataCopyObj (<span class="op">in</span> <span class="type">type</span>: hash_type) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">reference</span>: dataCopy <span class="keywd">is</span> NIL;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: param_list <span class="keywd">is</span> ref_list.EMPTY;
  <span class="keywd">begin</span>
    param_list := make_list(typeObject(hash_type));
    param_list &amp;:= make_list(syobject(prog, <span class="stri">"."</span>));
    param_list &amp;:= make_list(syobject(prog, <span class="stri">"dataCopy"</span>));
    dataCopy := match(prog, param_list);
    dataCopy := getValue(dataCopy, reference);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_arr_cpy_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">type</span>: arrayType <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: elementType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    params := formalParams(current_object);
    <span class="keywd">if</span> length(params) >= 1 <span class="keywd">then</span>
      arrayType := getType(params[1]);
      copyFunction @:= [arrayType] current_object;
      typeCategory @:= [arrayType] ARRAYOBJECT;
      elementType := base_type(arrayType);
      <span class="keywd">if</span> elementType &lt;> void <span class="keywd">then</span>
        <span class="keywd">if</span> arrayType <span class="op">not</span> <span class="op">in</span> array_element <span class="keywd">then</span>
          array_element @:= [arrayType] elementType;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> elementType <span class="op">not</span> <span class="op">in</span> array_type <span class="keywd">then</span>
          array_type @:= [elementType] arrayType;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_arr_create_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">type</span>: arrayType <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: elementType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    params := formalParams(current_object);
    <span class="keywd">if</span> length(params) >= 1 <span class="keywd">then</span>
      arrayType := getType(params[1]);
      createFunction @:= [arrayType] current_object;
      typeCategory @:= [arrayType] ARRAYOBJECT;
      elementType := base_type(arrayType);
      <span class="keywd">if</span> elementType &lt;> void <span class="keywd">then</span>
        <span class="keywd">if</span> arrayType <span class="op">not</span> <span class="op">in</span> array_element <span class="keywd">then</span>
          array_element @:= [arrayType] elementType;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> elementType <span class="op">not</span> <span class="op">in</span> array_type <span class="keywd">then</span>
          array_type @:= [elementType] arrayType;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_arr_destr_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">type</span>: arrayType <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: elementType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    params := formalParams(current_object);
    <span class="keywd">if</span> length(params) >= 1 <span class="keywd">then</span>
      arrayType := getType(params[1]);
      destrFunction @:= [arrayType] current_object;
      typeCategory @:= [arrayType] ARRAYOBJECT;
      elementType := base_type(arrayType);
      <span class="keywd">if</span> elementType &lt;> void <span class="keywd">then</span>
        <span class="keywd">if</span> arrayType <span class="op">not</span> <span class="op">in</span> array_element <span class="keywd">then</span>
          array_element @:= [arrayType] elementType;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> elementType <span class="op">not</span> <span class="op">in</span> array_type <span class="keywd">then</span>
          array_type @:= [elementType] arrayType;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_arr_gen_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">type</span>: arrayType <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: elementType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    params := formalParams(current_object);
    <span class="keywd">if</span> length(params) >= 1 <span class="keywd">then</span>
      arrayType := resultType(getType(current_object));
      elementType := getType(params[1]);
      <span class="keywd">if</span> arrayType <span class="op">not</span> <span class="op">in</span> array_element <span class="keywd">then</span>
        array_element @:= [arrayType] elementType;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> elementType <span class="op">not</span> <span class="op">in</span> array_type <span class="keywd">then</span>
        array_type @:= [elementType] arrayType;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">"/* ACTION ARR_GEN for type "</span>;
      c_expr.expr &amp;:= type_name2(arrayType);
      c_expr.expr &amp;:= <span class="stri">" element is "</span>;
      c_expr.expr &amp;:= type_name2(elementType);
      c_expr.expr &amp;:= <span class="stri">" */\n\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_arr_idx_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">type</span>: arrayType <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: elementType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    params := formalParams(current_object);
    <span class="keywd">if</span> length(params) >= 1 <span class="keywd">then</span>
      arrayType := getType(params[1]);
      elementType := resultType(getType(current_object));
      <span class="keywd">if</span> arrayType <span class="op">not</span> <span class="op">in</span> array_element <span class="keywd">then</span>
        array_element @:= [arrayType] elementType;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> elementType <span class="op">not</span> <span class="op">in</span> array_type <span class="keywd">then</span>
        array_type @:= [elementType] arrayType;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">"/* ACTION ARR_IDX for type "</span>;
      c_expr.expr &amp;:= type_name2(arrayType);
      c_expr.expr &amp;:= <span class="stri">" element is "</span>;
      c_expr.expr &amp;:= type_name2(elementType);
      c_expr.expr &amp;:= <span class="stri">" */\n\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_arr_times_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: diagnosticLine <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">type</span>: arrayType <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: elementType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    diagnosticLine := diagnosticLine(current_object);
    params := formalParams(current_object);
    <span class="keywd">if</span> length(params) >= 3 <span class="keywd">then</span>
      arrayType := resultType(getType(current_object));
      elementType := getType(params[3]);
      <span class="keywd">if</span> elementType <span class="op">in</span> typeCategory <span class="op">and</span>
          typeCategory[elementType] <span class="op">in</span> simpleValueType <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"/* times_"</span>;
        c_expr.expr &amp;:= str(typeNumber(arrayType));
        c_expr.expr &amp;:= <span class="stri">" not defined because arrTimes() is used instead. */\n"</span>;
      <span class="keywd">else</span>
        process_create_declaration(elementType, c_expr);
        c_expr.expr &amp;:= diagnosticLine;
        <span class="comment"># c_expr.expr &amp;:= type_name(arrayType);</span>
        c_expr.expr &amp;:= <span class="stri">"static arrayType times_"</span>;
        c_expr.expr &amp;:= str(typeNumber(arrayType));
        c_expr.expr &amp;:= <span class="stri">" (intType n, const "</span>;
        <span class="keywd">if</span> useConstPrefix(elementType) <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"const_"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= type_name(elementType);
        c_expr.expr &amp;:= <span class="stri">" b)\n"</span>;
        c_expr.expr &amp;:= diagnosticLine;
        times_prototype_declared @:= [arrayType] TRUE;
        c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
        c_expr.expr &amp;:= diagnosticLine;
        c_expr.expr &amp;:= <span class="stri">"arrayType a;\n"</span>;
        c_expr.expr &amp;:= diagnosticLine;
        c_expr.expr &amp;:= <span class="stri">"memSizeType i;\n"</span>;
        c_expr.expr &amp;:= diagnosticLine;
        c_expr.expr &amp;:= <span class="stri">"a=arrMalloc(1, n);\n"</span>;
        c_expr.expr &amp;:= diagnosticLine;
        c_expr.expr &amp;:= <span class="stri">"for (i = 0; i &lt; (memSizeType)(n); i++) {\n"</span>;
        c_expr.expr &amp;:= diagnosticLine;
        c_expr.expr &amp;:= <span class="stri">"a->arr[i]"</span>;
        c_expr.expr &amp;:= select_value_from_rtlObjectStruct(elementType);
        c_expr.expr &amp;:= <span class="stri">"="</span>;
        process_create_call(elementType, <span class="stri">"b"</span>, c_expr.expr);
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        c_expr.expr &amp;:= diagnosticLine;
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
        c_expr.expr &amp;:= diagnosticLine;
        c_expr.expr &amp;:= <span class="stri">"return a;\n"</span>;
        c_expr.expr &amp;:= diagnosticLine;
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
        c_expr.expr &amp;:= noDiagnosticLine;
        c_expr.expr &amp;:= <span class="stri">"\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: defineParam1TypeCategory (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="op">in</span> <span class="type">category</span>: param1Category) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">type</span>: param1Type <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    params := formalParams(current_object);
    <span class="keywd">if</span> length(params) >= 1 <span class="keywd">then</span>
      param1Type := getType(params[1]);
      typeCategory @:= [param1Type] param1Category;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: addImplementationToInterface (<span class="op">in</span> <span class="type">type</span>: implementationType, <span class="op">in</span> <span class="type">type</span>: interfaceType) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> interfaceType <span class="op">in</span> implements <span class="keywd">then</span>
      implements[interfaceType] &amp;:= implementationType;
    <span class="keywd">else</span>
      implements @:= [interfaceType] [] (implementationType);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> implementationType <span class="op">in</span> interfaceOfType <span class="keywd">then</span>
      interfaceOfType[implementationType] &amp;:= interfaceType;
    <span class="keywd">else</span>
      interfaceOfType @:= [implementationType] [] (interfaceType);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_itf_cpy2_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">type</span>: interfaceType <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: implementationType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    params := formalParams(current_object);
    <span class="keywd">if</span> length(params) >= 1 <span class="keywd">then</span>
      interfaceType := getType(params[1]);
      implementationType := getType(params[3]);
      addImplementationToInterface(implementationType, interfaceType);
      c_expr.expr &amp;:= <span class="stri">"/* itf_cpy2: "</span>;
      c_expr.expr &amp;:= type_name2(interfaceType);
      c_expr.expr &amp;:= <span class="stri">" := "</span>;
      c_expr.expr &amp;:= type_name2(implementationType);
      c_expr.expr &amp;:= <span class="stri">" */\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_itf_next_file_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">type</span>: object_type <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    object_type := getType(current_object);
    <span class="keywd">if</span> isFunc(object_type) <span class="op">or</span> isVarfunc(object_type) <span class="keywd">then</span>
      fileInterfaceType := resultType(object_type);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_hsh_cpy_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">type</span>: hashType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    params := formalParams(current_object);
    <span class="keywd">if</span> length(params) >= 1 <span class="keywd">then</span>
      hashType := getType(params[1]);
      copyFunction @:= [hashType] current_object;
      typeCategory @:= [hashType] HASHOBJECT;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_hsh_create_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">type</span>: hashType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    params := formalParams(current_object);
    <span class="keywd">if</span> length(params) >= 1 <span class="keywd">then</span>
      hashType := getType(params[1]);
      createFunction @:= [hashType] current_object;
      typeCategory @:= [hashType] HASHOBJECT;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_hsh_destr_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">type</span>: hashType <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    params := formalParams(current_object);
    <span class="keywd">if</span> length(params) >= 1 <span class="keywd">then</span>
      hashType := getType(params[1]);
      destrFunction @:= [hashType] current_object;
      typeCategory @:= [hashType] HASHOBJECT;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: addStructElem (<span class="op">in</span> <span class="type">type</span>: structType, <span class="op">in</span> <span class="type">type</span>: elemType, <span class="op">in</span> <span class="type">reference</span>: elementOfStruct) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: elementIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> element_idx_hash: element_index <span class="keywd">is</span> element_idx_hash.EMPTY_HASH;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> structType <span class="op">in</span> struct_element_idx <span class="keywd">then</span>
      elementIndex := struct_size[structType];
      struct_element_idx[structType] @:= [elementOfStruct] elementIndex;
      struct_element_type[structType] &amp;:= elemType;
      struct_element[structType] &amp;:= elementOfStruct;
      struct_size @:= [structType] succ(elementIndex);
    <span class="keywd">else</span>
      struct_size @:= [structType] 1;
      element_index @:= [elementOfStruct] 0;
      struct_element_idx @:= [structType] element_index;
      struct_element_type @:= [structType] [0] elemType;
      struct_element @:= [structType] [0] elementOfStruct;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_ref_select_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">type</span>: elemType <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: structType <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">reference</span>: elementOfStruct <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    params := formalParams(current_object);
    <span class="keywd">if</span> length(params) >= 3 <span class="op">and</span> <span class="op">not</span> isVar(params[1]) <span class="keywd">then</span>
      structType := getType(params[1]);
      elementOfStruct := params[3];
      elemType := resultType(getType(current_object));
      addStructElem(structType, elemType, elementOfStruct);
      c_expr.expr &amp;:= <span class="stri">"/* ref struct element "</span>;
      c_expr.expr &amp;:= type_name2(elemType);
      c_expr.expr &amp;:= <span class="stri">" ** "</span>;
      c_expr.expr &amp;:= type_name2(structType);
      c_expr.expr &amp;:= <span class="stri">"->o_"</span>;
      create_name2(elementOfStruct, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">" = "</span>;
      c_expr.expr &amp;:= str(struct_element_idx[structType][elementOfStruct]);
      c_expr.expr &amp;:= <span class="stri">" */\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_sct_cpy_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">type</span>: sct_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: meta_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: interfaceType <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">integer</span>: structIndex <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    params := formalParams(current_object);
    <span class="keywd">if</span> length(params) >= 1 <span class="keywd">then</span>
      sct_type := getType(params[1]);
      copyFunction @:= [sct_type] current_object;
      typeCategory @:= [sct_type] STRUCTOBJECT;
      <span class="keywd">if</span> isDerived(sct_type) <span class="keywd">then</span>
        meta_type := meta(sct_type);
        <span class="keywd">if</span> meta_type <span class="op">in</span> struct_element_idx <span class="keywd">then</span>
          <span class="keywd">for</span> structIndex <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(struct_size[meta_type]) <span class="keywd">do</span>
            addStructElem(sct_type, struct_element_type[meta_type][structIndex],
                          struct_element[meta_type][structIndex]);
          <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> meta_type <span class="op">in</span> interfaceOfType <span class="keywd">then</span>
          <span class="keywd">for</span> interfaceType <span class="keywd">range</span> interfaceOfType[meta_type] <span class="keywd">do</span>
            addImplementationToInterface(sct_type, interfaceType);
          <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_sct_create_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">type</span>: object_type <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    params := formalParams(current_object);
    object_type := getType(params[1]);
    createFunction @:= [object_type] current_object;
    typeCategory @:= [object_type] STRUCTOBJECT;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_sct_destr_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">type</span>: object_type <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    params := formalParams(current_object);
    object_type := getType(params[1]);
    destrFunction @:= [object_type] current_object;
    typeCategory @:= [object_type] STRUCTOBJECT;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_sct_select_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">type</span>: elemType <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: structType <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">reference</span>: elementOfStruct <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    params := formalParams(current_object);
    <span class="keywd">if</span> length(params) >= 3 <span class="op">and</span> <span class="op">not</span> isVar(params[1]) <span class="keywd">then</span>
      structType := getType(params[1]);
      elementOfStruct := params[3];
      elemType := resultType(getType(current_object));
      addStructElem(structType, elemType, elementOfStruct);
      c_expr.expr &amp;:= <span class="stri">"/* struct element "</span>;
      c_expr.expr &amp;:= type_name2(elemType);
      c_expr.expr &amp;:= <span class="stri">" ** "</span>;
      c_expr.expr &amp;:= type_name2(structType);
      c_expr.expr &amp;:= <span class="stri">"->o_"</span>;
      create_name2(elementOfStruct, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">" = "</span>;
      c_expr.expr &amp;:= str(struct_element_idx[structType][elementOfStruct]);
      c_expr.expr &amp;:= <span class="stri">" */\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_var_action_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> expr_type: c_value <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">string</span>: valueName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    create_name(current_object, objNumber(current_object), valueName);
    processFuncValue(valueName, getType(current_object), current_object, c_value);
    c_expr.expr &amp;:= c_value.temp_decls;
    global_init.expr &amp;:= diagnosticLine(current_object);
    global_init.expr &amp;:= c_value.temp_assigns;
    c_expr.expr &amp;:= type_name(getType(current_object));
    c_expr.expr &amp;:= <span class="stri">" o_"</span>;
    create_name(current_object, c_expr.expr);
    c_expr.expr &amp;:= <span class="stri">" = "</span>;
    c_expr.expr &amp;:= c_value.expr;
    c_expr.expr &amp;:= <span class="stri">";\n\n"</span>;
    function_declared @:= [current_object] TRUE;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_action_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ACTION</span>: current_action <span class="keywd">is</span> action <span class="stri">"PRC_NOOP"</span>;
    <span class="keywd">var</span> <span class="type">string</span>: action_name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isVar(current_object) <span class="keywd">then</span>
      process_var_action_declaration(current_object, c_expr);
    <span class="keywd">else</span>
      current_action := getValue(current_object, ACTION);
      action_name := str(current_action);
      <span class="keywd">if</span> action_name = <span class="stri">"PRC_DYNAMIC"</span> <span class="keywd">then</span>
        process_dynamic_declaration(current_object, c_expr);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"ACT_CPY"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, ACTOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"ARR_CPY"</span> <span class="keywd">then</span>
        process_arr_cpy_declaration(current_object);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"ARR_CREATE"</span> <span class="keywd">then</span>
        process_arr_create_declaration(current_object);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"ARR_DESTR"</span> <span class="keywd">then</span>
        process_arr_destr_declaration(current_object);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"ARR_GEN"</span> <span class="keywd">then</span>
        process_arr_gen_declaration(current_object, c_expr);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"ARR_IDX"</span> <span class="keywd">then</span>
        process_arr_idx_declaration(current_object, c_expr);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"ARR_TIMES"</span> <span class="keywd">then</span>
        process_arr_times_declaration(current_object, c_expr);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"BIG_CPY"</span> <span class="op">or</span> action_name = <span class="stri">"BIG_CREATE"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, BIGINTOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"BLN_CPY"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, BOOLOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"BST_CPY"</span> <span class="op">or</span> action_name = <span class="stri">"BST_CREATE"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, BSTRIOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"DRW_CPY"</span> <span class="op">or</span> action_name = <span class="stri">"DRW_CREATE"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, WINOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"PLT_CPY"</span> <span class="op">or</span> action_name = <span class="stri">"PLT_CREATE"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, POINTLISTOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"PCS_CPY"</span> <span class="op">or</span> action_name = <span class="stri">"PCS_CREATE"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, PROCESSOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"ENU_CPY"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, ENUMOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"FIL_CPY"</span> <span class="op">or</span> action_name = <span class="stri">"FIL_CREATE"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, FILEOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"FLT_CPY"</span> <span class="op">or</span> action_name = <span class="stri">"FLT_CREATE"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, FLOATOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"HSH_CONCAT_KEY_VALUE"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, HASHELEMOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"HSH_CPY"</span> <span class="keywd">then</span>
        process_hsh_cpy_declaration(current_object);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"HSH_CREATE"</span> <span class="keywd">then</span>
        process_hsh_create_declaration(current_object);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"HSH_DESTR"</span> <span class="keywd">then</span>
        process_hsh_destr_declaration(current_object);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"INT_CPY"</span> <span class="op">or</span> action_name = <span class="stri">"INT_CREATE"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, INTOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"ITF_CPY"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, INTERFACEOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"ITF_CPY2"</span> <span class="keywd">then</span>
        process_itf_cpy2_declaration(current_object, c_expr);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"POL_CPY"</span> <span class="op">or</span> action_name = <span class="stri">"POL_CREATE"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, POLLOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"POL_NEXT_FILE"</span> <span class="keywd">then</span>
        process_itf_next_file_declaration(current_object);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"PRG_CPY"</span> <span class="op">or</span> action_name = <span class="stri">"PRG_CREATE"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, PROGOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"REF_CPY"</span> <span class="op">or</span> action_name = <span class="stri">"REF_CREATE"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, REFOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"REF_SELECT"</span> <span class="keywd">then</span>
        process_ref_select_declaration(current_object, c_expr);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"RFL_CPY"</span> <span class="op">or</span> action_name = <span class="stri">"RFL_CREATE"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, REFLISTOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"SCT_CPY"</span> <span class="keywd">then</span>
        process_sct_cpy_declaration(current_object);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"SCT_CREATE"</span> <span class="keywd">then</span>
        process_sct_create_declaration(current_object);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"SCT_DESTR"</span> <span class="keywd">then</span>
        process_sct_destr_declaration(current_object);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"SCT_SELECT"</span> <span class="keywd">then</span>
        process_sct_select_declaration(current_object, c_expr);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"SET_CPY"</span> <span class="op">or</span> action_name = <span class="stri">"SET_CREATE"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, SETOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"SOC_CPY"</span> <span class="op">or</span> action_name = <span class="stri">"SOC_CREATE"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, SOCKETOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"SQL_CPY_DB"</span> <span class="op">or</span> action_name = <span class="stri">"SQL_CREATE_DB"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, DATABASEOBJECT);
        count_declarations(c_expr);
      <span class="keywd">elsif</span> action_name = <span class="stri">"SQL_CPY_STMT"</span> <span class="op">or</span> action_name = <span class="stri">"SQL_CREATE_STMT"</span> <span class="keywd">then</span>
        defineParam1TypeCategory(current_object, SQLSTMTOBJECT);
        count_declarations(c_expr);
<span class="comment">(*
      else
        c_expr.expr &amp;:= "/* ACTION ";
        c_expr.expr &amp;:= action_name;
        c_expr.expr &amp;:= " */";
*)</span>
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_object_declaration (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">category</span>: objectCategory <span class="keywd">is</span> category.value;
  <span class="keywd">begin</span>
    objectCategory := category(current_object);
    <span class="keywd">if</span> current_object = main_object <span class="keywd">then</span>
      <span class="keywd">if</span> category(current_object) = FORWARDOBJECT <span class="keywd">then</span>
        process_library_initialisation(current_object, c_expr);
      <span class="keywd">else</span>
        process_main_declaration(current_object, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> objectCategory = BLOCKOBJECT <span class="keywd">then</span>
      process_func_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = TYPEOBJECT <span class="keywd">then</span>
      process_type_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = INTOBJECT <span class="keywd">then</span>
      process_int_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = BIGINTOBJECT <span class="keywd">then</span>
      process_bigint_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = CHAROBJECT <span class="keywd">then</span>
      process_char_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = STRIOBJECT <span class="keywd">then</span>
      process_stri_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = BSTRIOBJECT <span class="keywd">then</span>
      process_bstri_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = FLOATOBJECT <span class="keywd">then</span>
      process_float_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = REFOBJECT <span class="keywd">then</span>
      process_reference_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = REFLISTOBJECT <span class="keywd">then</span>
      process_ref_list_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = FILEOBJECT <span class="keywd">then</span>
      process_file_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = SOCKETOBJECT <span class="keywd">then</span>
      process_socket_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = POLLOBJECT <span class="keywd">then</span>
      process_poll_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = ARRAYOBJECT <span class="keywd">then</span>
      process_array_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = HASHOBJECT <span class="keywd">then</span>
      process_hash_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = SETOBJECT <span class="keywd">then</span>
      process_set_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = STRUCTOBJECT <span class="keywd">then</span>
      process_struct_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = INTERFACEOBJECT <span class="keywd">then</span>
      process_interface_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = WINOBJECT <span class="keywd">then</span>
      process_win_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = POINTLISTOBJECT <span class="keywd">then</span>
      process_plist_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = PROCESSOBJECT <span class="keywd">then</span>
      process_process_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = PROGOBJECT <span class="keywd">then</span>
      process_prog_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = CONSTENUMOBJECT <span class="keywd">then</span>
      process_enum_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = VARENUMOBJECT <span class="keywd">then</span>
      process_enum_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = ENUMLITERALOBJECT <span class="keywd">then</span>
      process_enum_literal_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = ACTOBJECT <span class="keywd">then</span>
      process_action_declaration(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = FWDREFOBJECT <span class="keywd">then</span>
      process_forward_declaration(current_object, c_expr);
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"/* "</span>;
      c_expr.expr &amp;:= str(objectCategory);
      c_expr.expr &amp;:= <span class="stri">": "</span>;
      create_name2(current_object, c_expr.expr);
      c_expr.expr &amp;:= <span class="stri">" */\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: replaceLocalsFromOutside (<span class="op">in</span> <span class="type">reference</span>: local_function,
    <span class="keywd">inout</span> <span class="type">reference</span>: current_expression, <span class="op">in</span> <span class="type">ref_list</span>: local_objects,
    <span class="keywd">inout</span> <span class="type">ref_list</span>: additional_act_params, <span class="keywd">inout</span> <span class="type">ref_list</span>: additional_form_params) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">integer</span>: paramNum <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reference</span>: aParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">category</span>: paramCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">reference</span>: formalRefParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    params := getValue(current_expression, ref_list);
    <span class="keywd">for</span> paramNum <span class="keywd">range</span> 2 <span class="keywd">to</span> length(params) <span class="keywd">do</span>
      aParam := params[paramNum];
      paramCategory := category(aParam);
      <span class="keywd">if</span> paramCategory = MATCHOBJECT <span class="op">or</span> paramCategory = CALLOBJECT <span class="keywd">then</span>
        replaceLocalsFromOutside(local_function, aParam, local_objects,
            additional_act_params, additional_form_params);
      <span class="keywd">elsif</span> paramCategory = LOCALVOBJECT <span class="op">or</span>
            paramCategory = VALUEPARAMOBJECT <span class="op">or</span>
            paramCategory = REFPARAMOBJECT <span class="op">or</span>
            paramCategory = RESULTOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> aParam <span class="op">not</span> <span class="op">in</span> local_objects <span class="keywd">then</span>
          <span class="keywd">if</span> aParam <span class="op">in</span> additional_act_params <span class="keywd">then</span>
            formalRefParam := additional_form_params[pos(additional_act_params, aParam)];
          <span class="keywd">elsif</span> local_function <span class="op">in</span> params_added <span class="op">and</span>
              aParam <span class="op">in</span> params_added[local_function] <span class="keywd">then</span>
            formalRefParam := params_added[local_function][aParam];
          <span class="keywd">else</span>
            additional_act_params &amp;:= make_list(aParam);
            formalRefParam := alloc(aParam);
            setCategory(formalRefParam, REFPARAMOBJECT);
            additional_form_params &amp;:= make_list(formalRefParam);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          params @:= [paramNum] formalRefParam;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    setValue(current_expression, params);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: changeCallsOfLocalFunction (<span class="keywd">inout</span> <span class="type">reference</span>: current_expression,
    <span class="op">in</span> <span class="type">reference</span>: local_function, <span class="op">in</span> <span class="type">ref_list</span>: additional_params) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">integer</span>: paramNum <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reference</span>: aParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">category</span>: paramCategory <span class="keywd">is</span> category.value;
  <span class="keywd">begin</span>
    params := getValue(current_expression, ref_list);
    <span class="keywd">for</span> paramNum <span class="keywd">range</span> 2 <span class="keywd">to</span> length(params) <span class="keywd">do</span>
      aParam := params[paramNum];
      paramCategory := category(aParam);
      <span class="keywd">if</span> paramCategory = MATCHOBJECT <span class="op">or</span> paramCategory = CALLOBJECT <span class="keywd">then</span>
        changeCallsOfLocalFunction(aParam, local_function, additional_params);
      <span class="keywd">elsif</span> aParam = local_function <span class="keywd">then</span>
        aParam := alloc(aParam);
        setCategory(aParam, MATCHOBJECT);
        setValue(aParam, make_list(params[paramNum]) &amp; additional_params);
        params @:= [paramNum] aParam;
        setValue(current_expression, params);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> params[1] = local_function <span class="keywd">then</span>
      params &amp;:= additional_params;
      setValue(current_expression, params);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: changeCallsFromSubFunctions (<span class="op">in</span> <span class="type">reference</span>: parent_function,
    <span class="op">in</span> <span class="type">reference</span>: local_function, <span class="op">in</span> <span class="type">ref_list</span>: additional_params) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: parent_body <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">reference</span>: obj <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> parent_function &lt;> local_function <span class="keywd">then</span>
      parent_body := body(parent_function);
      changeCallsOfLocalFunction(parent_body, local_function, additional_params);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">for</span> obj <span class="keywd">range</span> localConsts(parent_function) <span class="keywd">do</span>
      <span class="keywd">if</span> category(obj) = BLOCKOBJECT <span class="keywd">then</span>
        changeCallsFromSubFunctions(obj, local_function, additional_params);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: adjustParamsToAdd (<span class="op">in</span> <span class="type">reference</span>: local_function,
    <span class="keywd">inout</span> <span class="type">ref_list</span>: additional_act_params, <span class="keywd">inout</span> <span class="type">ref_list</span>: additional_form_params) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: paramNum <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reference</span>: actParam <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">reference</span>: formParam <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(additional_act_params) &lt;> 0 <span class="keywd">then</span>
      <span class="keywd">if</span> local_function <span class="op">not</span> <span class="op">in</span> params_added <span class="keywd">then</span>
        params_added @:= [local_function] act_to_form_param_hash.value;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      paramNum := 1;
      <span class="keywd">while</span> paramNum &lt;= length(additional_act_params) <span class="keywd">do</span>
        actParam := additional_act_params[paramNum];
        <span class="keywd">if</span> actParam <span class="op">in</span> params_added[local_function] <span class="keywd">then</span>
          additional_act_params := additional_act_params[.. pred(paramNum)] &amp;
                                   additional_act_params[succ(paramNum) ..];
          additional_form_params := additional_form_params[.. pred(paramNum)] &amp;
                                    additional_form_params[succ(paramNum) ..];
        <span class="keywd">else</span>
          incr(paramNum);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">for</span> paramNum <span class="keywd">range</span> 1 <span class="keywd">to</span> length(additional_act_params) <span class="keywd">do</span>
        actParam := additional_act_params[paramNum];
        formParam := additional_form_params[paramNum];
        <span class="keywd">if</span> actParam <span class="op">not</span> <span class="op">in</span> params_added[local_function] <span class="keywd">then</span>
          params_added[local_function] @:= [actParam] formParam;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: fixLocalFunction (<span class="op">in</span> <span class="type">reference</span>: parent_function,
    <span class="op">in</span> <span class="type">reference</span>: local_function) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: fix_done <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: body_expression <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">category</span>: bodyCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">ref_list</span>: local_objects <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">ref_list</span>: additional_act_params <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">ref_list</span>: additional_form_params <span class="keywd">is</span> ref_list.EMPTY;
  <span class="keywd">begin</span>
    body_expression := body(local_function);
    bodyCategory := category(body_expression);
    <span class="keywd">if</span> bodyCategory = MATCHOBJECT <span class="op">or</span> bodyCategory = CALLOBJECT <span class="keywd">then</span>
      local_objects := formalParams(local_function) &amp; localVars(local_function) &amp;
          make_list(resultVar(local_function));
      replaceLocalsFromOutside(local_function, body_expression, local_objects,
          additional_act_params, additional_form_params);
      adjustParamsToAdd(local_function, additional_act_params, additional_form_params);
      <span class="keywd">if</span> length(additional_act_params) &lt;> 0 <span class="keywd">then</span>
        setFormalParams(local_function, formalParams(local_function) &amp; additional_form_params);
        changeCallsOfLocalFunction(body_expression, local_function, additional_form_params);
        changeCallsFromSubFunctions(parent_function, local_function, additional_act_params);
        fix_done := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: processLocalFunctions (<span class="op">in</span> <span class="type">reference</span>: current_object) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: objects <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: obj <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">boolean</span>: fix_done <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    objects := localConsts(current_object);
    <span class="keywd">repeat</span>
      fix_done := FALSE;
      <span class="keywd">for</span> obj <span class="keywd">range</span> objects <span class="keywd">do</span>
        <span class="keywd">if</span> category(obj) = BLOCKOBJECT <span class="keywd">then</span>
          processLocalFunctions(obj);
          <span class="keywd">if</span> fixLocalFunction(current_object, obj) <span class="keywd">then</span>
            fix_done := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">until</span> <span class="op">not</span> fix_done;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: addTypeCategoryForLocalVars (<span class="op">in</span> <span class="type">reference</span>: function) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: objects <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: obj <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">reference</span>: object_value <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">type</span>: objectType <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">category</span>: valueCategory <span class="keywd">is</span> category.value;
  <span class="keywd">begin</span>
    objects := localVars(function);
    <span class="keywd">for</span> obj <span class="keywd">range</span> objects <span class="keywd">do</span>
      object_value := getValue(obj, reference);
      valueCategory := category(object_value);
      objectType := getType(obj);
      <span class="keywd">if</span> objectType = getType(object_value) <span class="op">and</span> objectType <span class="op">not</span> <span class="op">in</span> typeCategory <span class="keywd">then</span>
        typeCategory @:= [objectType] valueCategory;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_local_consts (<span class="op">in</span> <span class="type">reference</span>: function,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: objects <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: obj <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    addTypeCategoryForLocalVars(function);
    processLocalFunctions(function);
    objects := localConsts(function);
    <span class="keywd">for</span> obj <span class="keywd">range</span> objects <span class="keywd">do</span>
      <span class="keywd">if</span> category(obj) &lt;> FWDREFOBJECT <span class="keywd">then</span>
        declare_type_if_necessary(getType(obj), global_c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      process_object_declaration(obj, c_expr);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_object (<span class="op">in</span> <span class="type">reference</span>: current_object) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> expr_type: c_expr <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    write_object_declaration := TRUE;
    process_object_declaration(current_object, c_expr);
    write(c_prog, global_c_expr.expr);
    <span class="keywd">if</span> write_object_declaration <span class="keywd">then</span>
      <span class="comment"># writeln(c_prog, "/* " &lt;&amp; countDeclarations &lt;&amp; " */");</span>
      write(c_prog, c_expr.expr);
<span class="comment">(*
    else
      write(c_prog, "#ifdef WRITE_OBJECT_DECLARATION\n");
      write(c_prog, c_expr.expr);
      write(c_prog, "#endif\n");
*)</span>
    <span class="keywd">end</span> <span class="keywd">if</span>;
    flush(c_prog);
    global_c_expr := expr_type.value;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_library_import_object (<span class="op">in</span> <span class="type">reference</span>: current_object) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> expr_type: c_expr <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    process_object_declaration(current_object, c_expr);
    global_c_expr := expr_type.value;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: write_file_head <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    writeln(c_prog, temp_marker);
    writeln(c_prog, <span class="stri">"#include &lt;stdlib.h>"</span>);
    writeln(c_prog, <span class="stri">"#include &lt;stdio.h>"</span>);
    writeln(c_prog, <span class="stri">"#include &lt;string.h>"</span>);
    writeln(c_prog, <span class="stri">"#include &lt;math.h>"</span>);
    writeln(c_prog, <span class="stri">"#include &lt;setjmp.h>"</span>);
    writeln(c_prog, <span class="stri">"#include &lt;signal.h>"</span>);
    writeln(c_prog, <span class="stri">"typedef short int          int16Type;"</span>);
    writeln(c_prog, <span class="stri">"typedef unsigned short int uint16Type;"</span>);
    writeln(c_prog, <span class="stri">"typedef "</span> &lt;&amp; ccConf.INT32TYPE &lt;&amp; <span class="stri">" int32Type;"</span>);
    writeln(c_prog, <span class="stri">"typedef "</span> &lt;&amp; ccConf.UINT32TYPE &lt;&amp; <span class="stri">" uint32Type;"</span>);
    writeln(c_prog, <span class="stri">"typedef "</span> &lt;&amp; ccConf.INT64TYPE &lt;&amp; <span class="stri">" int64Type;"</span>);
    writeln(c_prog, <span class="stri">"typedef "</span> &lt;&amp; ccConf.UINT64TYPE &lt;&amp; <span class="stri">" uint64Type;"</span>);
    <span class="keywd">if</span> ccConf.INT128TYPE &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"typedef "</span> &lt;&amp; ccConf.INT128TYPE &lt;&amp; <span class="stri">" int128Type;"</span>);
      writeln(c_prog, <span class="stri">"typedef "</span> &lt;&amp; ccConf.UINT128TYPE &lt;&amp; <span class="stri">" uint128Type;"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> ccConf.TWOS_COMPLEMENT_INTTYPE <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"#define INT32TYPE_MIN ((int32Type) -2147483648"</span> &lt;&amp;
          ccConf.INT32TYPE_LITERAL_SUFFIX &lt;&amp; <span class="stri">")"</span>);
    <span class="keywd">else</span>
      writeln(c_prog, <span class="stri">"#define INT32TYPE_MIN             (-2147483647"</span> &lt;&amp;
          ccConf.INT32TYPE_LITERAL_SUFFIX &lt;&amp; <span class="stri">")"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(c_prog, <span class="stri">"#define INT32TYPE_MAX               2147483647"</span> &lt;&amp;
        ccConf.INT32TYPE_LITERAL_SUFFIX);
    <span class="keywd">if</span> ccConf.INTTYPE_SIZE = 64 <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"#define INTTYPE_DECIMAL_SIZE 20"</span>);
      writeln(c_prog, <span class="stri">"typedef int64Type intType;"</span>);
      writeln(c_prog, <span class="stri">"typedef uint64Type uintType;"</span>);
      <span class="keywd">if</span> ccConf.INT128TYPE &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        writeln(c_prog, <span class="stri">"typedef int128Type doubleIntType;"</span>);
        writeln(c_prog, <span class="stri">"typedef uint128Type doubleUintType;"</span>);
        writeln(c_prog, <span class="stri">"#define inIntTypeRange(num) ((doubleIntType) (intType) (num) == (num))"</span>);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> ccConf.INTTYPE_SIZE = 32 <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"#define INTTYPE_DECIMAL_SIZE 11"</span>);
      writeln(c_prog, <span class="stri">"typedef int32Type intType;"</span>);
      writeln(c_prog, <span class="stri">"typedef uint32Type uintType;"</span>);
      writeln(c_prog, <span class="stri">"typedef int64Type doubleIntType;"</span>);
      writeln(c_prog, <span class="stri">"typedef uint64Type doubleUintType;"</span>);
      writeln(c_prog, <span class="stri">"#define inIntTypeRange(num) ((doubleIntType) (intType) (num) == (num))"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(c_prog, <span class="stri">"typedef "</span> &lt;&amp; ccConf.BOOLTYPE &lt;&amp; <span class="stri">" boolType;"</span>);
    writeln(c_prog, <span class="stri">"typedef int enumType;"</span>);
    <span class="keywd">if</span> ccConf.FLOATTYPE_DOUBLE <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"typedef double floatType;"</span>);
    <span class="keywd">else</span>
      writeln(c_prog, <span class="stri">"typedef float floatType;"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(c_prog, <span class="stri">"typedef uint32Type charType;"</span>);
    writeln(c_prog, <span class="stri">"typedef int32Type scharType;"</span>);
    writeln(c_prog, <span class="stri">"typedef uint32Type strElemType;"</span>);
    writeln(c_prog, <span class="stri">"typedef uintType bitSetType;"</span>);
    writeln(c_prog, <span class="stri">"typedef uint"</span> &lt;&amp; ccConf.POINTER_SIZE &lt;&amp; <span class="stri">"Type memSizeType;"</span>);
    writeln(c_prog, <span class="stri">"typedef FILE *cFileType;"</span>);
    writeln(c_prog, <span class="stri">"typedef unsigned char *ustriType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const unsigned char *const_ustriType;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct striStruct {"</span>);
    writeln(c_prog, <span class="stri">"  memSizeType size;"</span>);
    <span class="keywd">if</span> ccConf.WITH_STRI_CAPACITY <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"  memSizeType capacity;"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> ccConf.ALLOW_STRITYPE_SLICES <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"  strElemType *mem;"</span>);
      writeln(c_prog, <span class="stri">"  strElemType  mem1[1];"</span>);
    <span class="keywd">else</span>
      writeln(c_prog, <span class="stri">"  strElemType mem[1];"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(c_prog, <span class="stri">"} *striType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const struct striStruct  *const_striType;"</span>);
    writeln(c_prog, <span class="stri">"#define SIZ_STRI(len) ((sizeof(struct striStruct) - sizeof(strElemType)) + (len) * sizeof(strElemType))"</span>);
    writeln(c_prog, <span class="stri">"typedef struct bstriStruct {"</span>);
    writeln(c_prog, <span class="stri">"  memSizeType size;"</span>);
    <span class="keywd">if</span> ccConf.ALLOW_BSTRITYPE_SLICES <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"  unsigned char *mem;"</span>);
      writeln(c_prog, <span class="stri">"  unsigned char  mem1[1];"</span>);
    <span class="keywd">else</span>
      writeln(c_prog, <span class="stri">"  unsigned char mem[1];"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(c_prog, <span class="stri">"} *bstriType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const struct bstriStruct  *const_bstriType;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct fileStruct {"</span>);
    writeln(c_prog, <span class="stri">"  cFileType cFile;"</span>);
    writeln(c_prog, <span class="stri">"  uintType usage_count;"</span>);
    writeln(c_prog, <span class="stri">"} *fileType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const struct fileStruct  *const_fileType;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct setStruct {"</span>);
    writeln(c_prog, <span class="stri">"  intType min_position;"</span>);
    writeln(c_prog, <span class="stri">"  intType max_position;"</span>);
    writeln(c_prog, <span class="stri">"  bitSetType bitset[1];"</span>);
    writeln(c_prog, <span class="stri">"} *setType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const struct setStruct  *const_setType;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct {"</span>);
    writeln(c_prog, <span class="stri">"  int dummy;"</span>);
    writeln(c_prog, <span class="stri">"} bigIntRecord;"</span>);
    writeln(c_prog, <span class="stri">"typedef bigIntRecord *bigIntType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const bigIntRecord *const_bigIntType;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct pollStruct {"</span>);
    writeln(c_prog, <span class="stri">"  int dummy;"</span>);
    writeln(c_prog, <span class="stri">"} *pollType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const struct pollStruct *const_pollType;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct winStruct {"</span>);
    writeln(c_prog, <span class="stri">"  uintType usage_count;"</span>);
    writeln(c_prog, <span class="stri">"} *winType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const struct winStruct *const_winType;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct processStruct {"</span>);
    writeln(c_prog, <span class="stri">"  uintType usage_count;"</span>);
    writeln(c_prog, <span class="stri">"  fileType stdIn;"</span>);
    writeln(c_prog, <span class="stri">"  fileType stdOut;"</span>);
    writeln(c_prog, <span class="stri">"  fileType stdErr;"</span>);
    writeln(c_prog, <span class="stri">"} *processType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const struct processStruct *const_processType;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct databaseStruct {"</span>);
    writeln(c_prog, <span class="stri">"  uintType usage_count;"</span>);
    writeln(c_prog, <span class="stri">"} *databaseType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const struct databaseStruct *const_databaseType;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct sqlStmtStruct {"</span>);
    writeln(c_prog, <span class="stri">"  uintType usage_count;"</span>);
    writeln(c_prog, <span class="stri">"} *sqlStmtType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const struct sqlStmtStruct *const_sqlStmtType;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct progStruct {"</span>);
    writeln(c_prog, <span class="stri">"  uintType usage_count;"</span>);
    writeln(c_prog, <span class="stri">"} *progType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const struct progStruct *const_progType;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct typeStruct *typeType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const struct typeStruct *const_typeType;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct rtlArrayStruct *arrayType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const struct rtlArrayStruct *const_arrayType;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct rtlHashStruct *hashType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const struct rtlHashStruct *const_hashType;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct rtlStructStruct *structType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const struct rtlStructStruct *const_structType;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct rtlStructStruct *interfaceType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const struct rtlStructStruct *const_interfaceType;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct objectStruct *objRefType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const struct objectStruct *const_objRefType;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct listStruct *listType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const struct listStruct *const_listType;"</span>);
    writeln(c_prog, <span class="stri">"typedef objRefType (*actType) (listType);"</span>);
    writeln(c_prog, <span class="stri">"typedef int socketType;"</span>);
    writeln(c_prog, <span class="stri">"typedef uint"</span> &lt;&amp; ccConf.GENERIC_SIZE &lt;&amp; <span class="stri">"Type genericType;"</span>);
    writeln(c_prog, <span class="stri">"typedef union {"</span>);
    writeln(c_prog, <span class="stri">"  genericType   genericValue;"</span>);
    writeln(c_prog, <span class="stri">"  typeType      typeValue;"</span>);
    writeln(c_prog, <span class="stri">"  boolType      boolValue;"</span>);
    writeln(c_prog, <span class="stri">"  enumType      enumValue;"</span>);
    writeln(c_prog, <span class="stri">"  intType       intValue;"</span>);
    writeln(c_prog, <span class="stri">"  bigIntType    bigIntValue;"</span>);
    writeln(c_prog, <span class="stri">"  floatType     floatValue;"</span>);
    writeln(c_prog, <span class="stri">"  charType      charValue;"</span>);
    writeln(c_prog, <span class="stri">"  striType      striValue;"</span>);
    writeln(c_prog, <span class="stri">"  bstriType     bstriValue;"</span>);
    writeln(c_prog, <span class="stri">"  fileType      fileValue;"</span>);
    writeln(c_prog, <span class="stri">"  socketType    socketValue;"</span>);
    writeln(c_prog, <span class="stri">"  pollType      pollValue;"</span>);
    writeln(c_prog, <span class="stri">"  setType       setValue;"</span>);
    writeln(c_prog, <span class="stri">"  winType       winValue;"</span>);
    writeln(c_prog, <span class="stri">"  processType   processValue;"</span>);
    writeln(c_prog, <span class="stri">"  progType      progValue;"</span>);
    writeln(c_prog, <span class="stri">"  databaseType  databaseValue;"</span>);
    writeln(c_prog, <span class="stri">"  sqlStmtType   sqlStmtValue;"</span>);
    writeln(c_prog, <span class="stri">"  arrayType     arrayValue;"</span>);
    writeln(c_prog, <span class="stri">"  hashType      hashValue;"</span>);
    writeln(c_prog, <span class="stri">"  structType    structValue;"</span>);
    writeln(c_prog, <span class="stri">"  interfaceType interfaceValue;"</span>);
    writeln(c_prog, <span class="stri">"  objRefType    objRefValue;"</span>);
    writeln(c_prog, <span class="stri">"  listType      listValue;"</span>);
    writeln(c_prog, <span class="stri">"  actType       actValue;"</span>);
    writeln(c_prog, <span class="stri">"} rtlValueUnion;"</span>);
    writeln(c_prog, <span class="stri">"typedef union {"</span>);
    writeln(c_prog, <span class="stri">"  genericType         genericValue;"</span>);
    writeln(c_prog, <span class="stri">"  const_typeType      typeValue;"</span>);
    writeln(c_prog, <span class="stri">"  boolType            boolValue;"</span>);
    writeln(c_prog, <span class="stri">"  enumType            enumValue;"</span>);
    writeln(c_prog, <span class="stri">"  intType             intValue;"</span>);
    writeln(c_prog, <span class="stri">"  const_bigIntType    bigIntValue;"</span>);
    writeln(c_prog, <span class="stri">"  floatType           floatValue;"</span>);
    writeln(c_prog, <span class="stri">"  charType            charValue;"</span>);
    writeln(c_prog, <span class="stri">"  const_striType      striValue;"</span>);
    writeln(c_prog, <span class="stri">"  const_bstriType     bstriValue;"</span>);
    writeln(c_prog, <span class="stri">"  fileType            fileValue;"</span>);
    writeln(c_prog, <span class="stri">"  socketType          socketValue;"</span>);
    writeln(c_prog, <span class="stri">"  const_pollType      pollValue;"</span>);
    writeln(c_prog, <span class="stri">"  const_setType       setValue;"</span>);
    writeln(c_prog, <span class="stri">"  const_winType       winValue;"</span>);
    writeln(c_prog, <span class="stri">"  const_processType   processValue;"</span>);
    writeln(c_prog, <span class="stri">"  const_progType      progValue;"</span>);
    writeln(c_prog, <span class="stri">"  const_arrayType     arrayValue;"</span>);
    writeln(c_prog, <span class="stri">"  const_hashType      hashValue;"</span>);
    writeln(c_prog, <span class="stri">"  const_structType    structValue;"</span>);
    writeln(c_prog, <span class="stri">"  const_interfaceType interfaceValue;"</span>);
    writeln(c_prog, <span class="stri">"  const_objRefType    objRefValue;"</span>);
    writeln(c_prog, <span class="stri">"  const_listType      listValue;"</span>);
    writeln(c_prog, <span class="stri">"  actType             actValue;"</span>);
    writeln(c_prog, <span class="stri">"} const_rtlValueUnion;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct rtlObjectStruct {"</span>);
    writeln(c_prog, <span class="stri">"  rtlValueUnion value;"</span>);
    writeln(c_prog, <span class="stri">"} rtlObjectType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const struct rtlObjectStruct const_rtlObjectType;"</span>);
    writeln(c_prog, <span class="stri">"typedef intType (*intfunctype)();"</span>);
    writeln(c_prog, <span class="stri">"typedef uint16Type categoryType;"</span>);
    writeln(c_prog, <span class="stri">"struct objectStruct {"</span>);
    writeln(c_prog, <span class="stri">"  typeType type_of;"</span>);
    writeln(c_prog, <span class="stri">"  uint"</span> &lt;&amp; ccConf.POINTER_SIZE &lt;&amp; <span class="stri">"Type descriptor;"</span>);
    writeln(c_prog, <span class="stri">"  rtlValueUnion value;"</span>);
    writeln(c_prog, <span class="stri">"  categoryType objcategory;"</span>);
    writeln(c_prog, <span class="stri">"};"</span>);
    writeln(c_prog, <span class="stri">"struct typeStruct {"</span>);
    writeln(c_prog, <span class="stri">"  objRefType match_obj;"</span>);
    writeln(c_prog, <span class="stri">"  typeType meta;"</span>);
    writeln(c_prog, <span class="stri">"  typeType func_type;"</span>);
    writeln(c_prog, <span class="stri">"  typeType varfunc_type;"</span>);
    writeln(c_prog, <span class="stri">"  typeType result_type;"</span>);
    writeln(c_prog, <span class="stri">"  boolType is_varfunc_type;"</span>);
    writeln(c_prog, <span class="stri">"  void *interfaces;"</span>);
    writeln(c_prog, <span class="stri">"  void *name;"</span>);
    writeln(c_prog, <span class="stri">"};"</span>);
    writeln(c_prog, <span class="stri">"struct listStruct {"</span>);
    writeln(c_prog, <span class="stri">"  listType next;"</span>);
    writeln(c_prog, <span class="stri">"  objRefType obj;"</span>);
    writeln(c_prog, <span class="stri">"};"</span>);
    writeln(c_prog, <span class="stri">"struct rtlArrayStruct {"</span>);
    writeln(c_prog, <span class="stri">"  intType min_position;"</span>);
    writeln(c_prog, <span class="stri">"  intType max_position;"</span>);
    <span class="keywd">if</span> ccConf.WITH_RTL_ARRAY_CAPACITY <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"  memSizeType capacity;"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(c_prog, <span class="stri">"  rtlObjectType arr[1];"</span>);
    writeln(c_prog, <span class="stri">"};"</span>);
    writeln(c_prog, <span class="stri">"struct rtlStructStruct {"</span>);
    writeln(c_prog, <span class="stri">"  memSizeType usage_count;"</span>);
    writeln(c_prog, <span class="stri">"  uint32Type type_num;"</span>);
    writeln(c_prog, <span class="stri">"  rtlObjectType stru[1];"</span>);
    writeln(c_prog, <span class="stri">"};"</span>);
    writeln(c_prog, <span class="stri">"typedef struct freeListElemStruct {"</span>);
    writeln(c_prog, <span class="stri">"  struct freeListElemStruct *next;"</span>);
    writeln(c_prog, <span class="stri">"} *freeListElemType;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct rtlHashElemStruct *hashElemType;"</span>);
    writeln(c_prog, <span class="stri">"typedef const struct rtlHashElemStruct *const_hashElemType;"</span>);
    writeln(c_prog, <span class="stri">"typedef struct rtlHashElemStruct *const hashElemType_const;"</span>);
    writeln(c_prog, <span class="stri">"struct rtlHashElemStruct {"</span>);
    writeln(c_prog, <span class="stri">"  hashElemType next_less;"</span>);
    writeln(c_prog, <span class="stri">"  hashElemType next_greater;"</span>);
    writeln(c_prog, <span class="stri">"  rtlObjectType key;"</span>);
    writeln(c_prog, <span class="stri">"  rtlObjectType data;"</span>);
    writeln(c_prog, <span class="stri">"};"</span>);
    writeln(c_prog, <span class="stri">"struct rtlHashStruct {"</span>);
    writeln(c_prog, <span class="stri">"  unsigned int bits;"</span>);
    writeln(c_prog, <span class="stri">"  unsigned int mask;"</span>);
    writeln(c_prog, <span class="stri">"  unsigned int table_size;"</span>);
    writeln(c_prog, <span class="stri">"  memSizeType size;"</span>);
    writeln(c_prog, <span class="stri">"  hashElemType table[1];"</span>);
    writeln(c_prog, <span class="stri">"};"</span>);
    writeln(c_prog, <span class="stri">"typedef struct hashElemListStruct {"</span>);
    writeln(c_prog, <span class="stri">"  struct hashElemListStruct *next;"</span>);
    writeln(c_prog, <span class="stri">"  hashElemType obj;"</span>);
    writeln(c_prog, <span class="stri">"} *hashElemListType;"</span>);
    writeln(c_prog, <span class="stri">"typedef union {"</span>);
    writeln(c_prog, <span class="stri">"  uint32Type bits;"</span>);
    writeln(c_prog, <span class="stri">"  float aFloat;"</span>);
    writeln(c_prog, <span class="stri">"} float2BitsUnion;"</span>);
    writeln(c_prog, <span class="stri">"typedef union {"</span>);
    writeln(c_prog, <span class="stri">"  uint64Type bits;"</span>);
    writeln(c_prog, <span class="stri">"  double aDouble;"</span>);
    writeln(c_prog, <span class="stri">"} double2BitsUnion;"</span>);
    writeln(c_prog, <span class="stri">"typedef intType (*hashCodeFuncType) (genericType);"</span>);
    writeln(c_prog, <span class="stri">"typedef intType (*compareType) (genericType, genericType);"</span>);
    writeln(c_prog, <span class="stri">"typedef genericType (*createFuncType) (genericType);"</span>);
    writeln(c_prog, <span class="stri">"typedef void (*destrFuncType) (genericType);"</span>);
    writeln(c_prog, <span class="stri">"typedef void (*copyFuncType) (genericType *, genericType);"</span>);
    writeln(c_prog, <span class="stri">"#define bitset_shift "</span> &lt;&amp; log2(ccConf.INTTYPE_SIZE));
    writeln(c_prog, <span class="stri">"#define bitset_mask  ((1 &lt;&lt; bitset_shift) - 1)"</span>);
    <span class="keywd">if</span> ccConf.RSHIFT_DOES_SIGN_EXTEND <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"#define bitset_pos(number) ((number)>>bitset_shift)"</span>);
    <span class="keywd">else</span>
      writeln(c_prog, <span class="stri">"#define bitset_pos(number) ((number)&lt;0?~(~(number)>>bitset_shift):(number)>>bitset_shift)"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(c_prog, <span class="stri">"striType          arg_0;"</span>);
    writeln(c_prog, <span class="stri">"striType          programName;"</span>);
    writeln(c_prog, <span class="stri">"striType          programPath;"</span>);
    writeln(c_prog, <span class="stri">"arrayType         arg_v;"</span>);
    <span class="keywd">if</span> ccConf.ALLOW_STRITYPE_SLICES <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"extern struct striStruct str[];"</span>);
    <span class="keywd">else</span>
      writeln(c_prog, <span class="stri">"extern striType   str[];"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> ccConf.ALLOW_BSTRITYPE_SLICES <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"extern struct bstriStruct bst[];"</span>);
    <span class="keywd">else</span>
      writeln(c_prog, <span class="stri">"extern bstriType  bst[];"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(c_prog, <span class="stri">"extern setType          set[];"</span>);
    writeln(c_prog, <span class="stri">"extern typeType         typ[];"</span>);
    writeln(c_prog, <span class="stri">"extern double2BitsUnion nanValue[];"</span>);
    writeln(c_prog, <span class="stri">"bigIntType             *big;"</span>);
    writeln(c_prog, <span class="stri">"winType                *win;"</span>);
    writeln(c_prog, <span class="stri">"bstriType              *plist;"</span>);
    writeln(c_prog, <span class="stri">"arrayType              *arr;"</span>);
    writeln(c_prog, <span class="stri">"structType             *sct;"</span>);
    writeln(c_prog, <span class="stri">"hashType               *hsh;"</span>);
    writeln(c_prog, <span class="stri">"interfaceType          *itf;"</span>);
    writeln(c_prog, <span class="stri">"hashType               *caseLabels;"</span>);
    writeln(c_prog, <span class="stri">"rtlValueUnion           flt2int;"</span>);
    writeln(c_prog, <span class="stri">"extern memSizeType hs;"</span>);
    writeln(c_prog);
    writeln(c_prog, <span class="stri">"static const intType fact[] = {"</span>);
    writeln(c_prog, <span class="stri">"    1, 1, 2, 6, 24, 120, 720, 5040, 40320,"</span>);
    writeln(c_prog, <span class="stri">"    362880, 3628800, 39916800, 479001600,"</span>);
    <span class="keywd">if</span> ccConf.INTTYPE_SIZE = 64 <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"    6227020800, 87178291200, 1307674368000, 20922789888000,"</span>);
      writeln(c_prog, <span class="stri">"    355687428096000, 6402373705728000, 121645100408832000,"</span>);
      writeln(c_prog, <span class="stri">"    2432902008176640000"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(c_prog, <span class="stri">"  };"</span>);
    <span class="keywd">if</span> ccConf.FLOAT_ZERO_DIV_ERROR <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"extern const rtlValueUnion f_const[];"</span>);
      writeln(c_prog, <span class="stri">"#define NOT_A_NUMBER      f_const[0].floatValue"</span>);
      writeln(c_prog, <span class="stri">"#define POSITIVE_INFINITY f_const[1].floatValue"</span>);
      writeln(c_prog, <span class="stri">"#define NEGATIVE_INFINITY f_const[2].floatValue"</span>);
    <span class="keywd">else</span>
      writeln(c_prog, <span class="stri">"#define NOT_A_NUMBER      ( 0.0 / 0.0)"</span>);
      writeln(c_prog, <span class="stri">"#define POSITIVE_INFINITY ( 1.0 / 0.0)"</span>);
      writeln(c_prog, <span class="stri">"#define NEGATIVE_INFINITY (-1.0 / 0.0)"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(c_prog, <span class="stri">"extern const floatType negativeZero;"</span>);
    writeln(c_prog, <span class="stri">"extern struct fileStruct nullFileRecord;"</span>);
    writeln(c_prog, <span class="stri">"extern struct fileStruct stdinFileRecord;"</span>);
    writeln(c_prog, <span class="stri">"extern struct fileStruct stdoutFileRecord;"</span>);
    writeln(c_prog, <span class="stri">"extern struct fileStruct stderrFileRecord;"</span>);
    writeln(c_prog, <span class="stri">"typedef int errInfoType;"</span>);
    writeln(c_prog, <span class="stri">"#define OKAY_NO_ERROR   0"</span>);
    writeln(c_prog, <span class="stri">"#define MEMORY_ERROR    1"</span>);
    writeln(c_prog, <span class="stri">"#define NUMERIC_ERROR   2"</span>);
    writeln(c_prog, <span class="stri">"#define OVERFLOW_ERROR  3"</span>);
    writeln(c_prog, <span class="stri">"#define RANGE_ERROR     4"</span>);
    writeln(c_prog, <span class="stri">"#define INDEX_ERROR     5"</span>);
    writeln(c_prog, <span class="stri">"#define FILE_ERROR      6"</span>);
    writeln(c_prog, <span class="stri">"#define DATABSE_ERROR   7"</span>);
    writeln(c_prog, <span class="stri">"#define GRAPHIC_ERROR   8"</span>);
    writeln(c_prog, <span class="stri">"#define ACTION_ERROR    9"</span>);
    writeln(c_prog, <span class="stri">"#define CREATE_ERROR   10"</span>);
    writeln(c_prog, <span class="stri">"#define DESTROY_ERROR  11"</span>);
    writeln(c_prog, <span class="stri">"#define COPY_ERROR     12"</span>);
    writeln(c_prog, <span class="stri">"#define IN_ERROR       13"</span>);
    writeln(c_prog, ccConf.MACRO_DEFS);
    writeln(c_prog, <span class="stri">"#define ovfChk(x) unlikely(x)"</span>);
    writeln(c_prog, <span class="stri">"#define divChk(x) unlikely(x)"</span>);
    writeln(c_prog, <span class="stri">"#define numChk(x) unlikely(x)"</span>);
    writeln(c_prog, <span class="stri">"#define idxChk(x) unlikely(x)"</span>);
    writeln(c_prog, <span class="stri">"#define rngChk(x) unlikely(x)"</span>);
    writeln(c_prog, <span class="stri">"#define push_stack(stack,elem) \\"</span>);
    writeln(c_prog, <span class="stri">"{\\"</span>);
    writeln(c_prog, <span class="stri">"  hashElemListType new_head = (hashElemListType)(malloc(sizeof(struct hashElemListStruct)));\\"</span>);
    writeln(c_prog, <span class="stri">"  if (new_head == NULL) {\\"</span>);
    writeln(c_prog, <span class="stri">"    raiseError(MEMORY_ERROR);\\"</span>);
    writeln(c_prog, <span class="stri">"  } else {\\"</span>);
    writeln(c_prog, <span class="stri">"    new_head->next = stack;\\"</span>);
    writeln(c_prog, <span class="stri">"    new_head->obj = elem;\\"</span>);
    writeln(c_prog, <span class="stri">"    stack = new_head;\\"</span>);
    writeln(c_prog, <span class="stri">"  }\\"</span>);
    writeln(c_prog, <span class="stri">"}"</span>);
    writeln(c_prog, <span class="stri">"#define pop_stack(stack,elem) \\"</span>);
    writeln(c_prog, <span class="stri">"{\\"</span>);
    writeln(c_prog, <span class="stri">"  hashElemListType old_head = stack;\\"</span>);
    writeln(c_prog, <span class="stri">"  if (old_head == NULL) {\\"</span>);
    writeln(c_prog, <span class="stri">"    elem = NULL;\\"</span>);
    writeln(c_prog, <span class="stri">"  } else {\\"</span>);
    writeln(c_prog, <span class="stri">"    stack = old_head->next;\\"</span>);
    writeln(c_prog, <span class="stri">"    elem = old_head->obj;\\"</span>);
    writeln(c_prog, <span class="stri">"    free(old_head);\\"</span>);
    writeln(c_prog, <span class="stri">"  }\\"</span>);
    writeln(c_prog, <span class="stri">"}"</span>);
    <span class="keywd">if</span> ccConf.HAS_SIGSETJMP <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"#define do_setjmp(jump_buf) sigsetjmp(jump_buf, 1)"</span>);
      writeln(c_prog, <span class="stri">"typedef sigjmp_buf catch_type;"</span>);
    <span class="keywd">else</span>
      writeln(c_prog, <span class="stri">"#define do_setjmp(jump_buf) setjmp(jump_buf)"</span>);
      writeln(c_prog, <span class="stri">"typedef jmp_buf catch_type;"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(c_prog, <span class="stri">"catch_type *catch_stack;"</span>);
    writeln(c_prog, <span class="stri">"size_t catch_stack_pos;"</span>);
    writeln(c_prog, <span class="stri">"size_t max_catch_stack;"</span>);
    writeln(c_prog, <span class="stri">"const char *error_file = NULL;"</span>);
    writeln(c_prog, <span class="stri">"int error_line = 0;"</span>);
    <span class="keywd">if</span> profile_function <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"intType timMicroSec (void);"</span>);
      writeln(c_prog, <span class="stri">"static unsigned int profile_size;"</span>);
      writeln(c_prog, <span class="stri">"struct profileElement {"</span>);
      writeln(c_prog, <span class="stri">"  intType time;"</span>);
      writeln(c_prog, <span class="stri">"  intType count;"</span>);
      writeln(c_prog, <span class="stri">"  intType depth;"</span>);
      writeln(c_prog, <span class="stri">"  char *file;"</span>);
      writeln(c_prog, <span class="stri">"  intType line;"</span>);
      writeln(c_prog, <span class="stri">"  char *name;"</span>);
      writeln(c_prog, <span class="stri">"};"</span>);
      writeln(c_prog, <span class="stri">"static struct profileElement *profile;"</span>);
      writeln(c_prog, <span class="stri">"static void initProfile (void);"</span>);
      writeln(c_prog, <span class="stri">"static int cmpProfileElement (const void *elem1, const void *elem2)"</span>);
      writeln(c_prog, <span class="stri">"{"</span>);
      writeln(c_prog, <span class="stri">"  int signumValue;"</span>);
      writeln(c_prog, <span class="stri">"  if (((struct profileElement *) elem1)->time &lt;"</span>);
      writeln(c_prog, <span class="stri">"      ((struct profileElement *) elem2)->time) {"</span>);
      writeln(c_prog, <span class="stri">"    signumValue = 1;"</span>);
      writeln(c_prog, <span class="stri">"  } else if (((struct profileElement *) elem1)->time >"</span>);
      writeln(c_prog, <span class="stri">"             ((struct profileElement *) elem2)->time) {"</span>);
      writeln(c_prog, <span class="stri">"    signumValue = -1;"</span>);
      writeln(c_prog, <span class="stri">"  } else if (((struct profileElement *) elem1)->count &lt;"</span>);
      writeln(c_prog, <span class="stri">"             ((struct profileElement *) elem2)->count) {"</span>);
      writeln(c_prog, <span class="stri">"    signumValue = 1;"</span>);
      writeln(c_prog, <span class="stri">"  } else if (((struct profileElement *) elem1)->count >"</span>);
      writeln(c_prog, <span class="stri">"             ((struct profileElement *) elem2)->count) {"</span>);
      writeln(c_prog, <span class="stri">"    signumValue = -1;"</span>);
      writeln(c_prog, <span class="stri">"  } else {"</span>);
      writeln(c_prog, <span class="stri">"    signumValue = strcmp(((struct profileElement *) elem1)->name,"</span>);
      writeln(c_prog, <span class="stri">"                         ((struct profileElement *) elem2)->name);"</span>);
      writeln(c_prog, <span class="stri">"  }"</span>);
      writeln(c_prog, <span class="stri">"  return signumValue;"</span>);
      writeln(c_prog, <span class="stri">"}"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: declareExtern (<span class="op">in</span> <span class="type">string</span>: prototype) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    write(c_prog, <span class="stri">"extern "</span>);
    <span class="keywd">if</span> declare_with_extern_c <span class="keywd">then</span>
      write(c_prog, <span class="stri">"\"C\" "</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(c_prog, prototype);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: write_prototypes <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    act_prototypes(c_prog);
    arr_prototypes(c_prog);
    big_prototypes(c_prog);
    bin_prototypes(c_prog);
    bln_prototypes(c_prog);
    bst_prototypes(c_prog);
    chr_prototypes(c_prog);
    cmd_prototypes(c_prog);
    con_prototypes(c_prog);
    drw_prototypes(c_prog);
    fil_prototypes(c_prog);
    flt_prototypes(c_prog);
    gkb_prototypes(c_prog);
    hsh_prototypes(c_prog);
    int_prototypes(c_prog);
    itf_prototypes(c_prog);
    kbd_prototypes(c_prog);
    pcs_prototypes(c_prog);
    pol_prototypes(c_prog);
    prc_prototypes(c_prog);
    prg_prototypes(c_prog);
    ref_prototypes(c_prog);
    rfl_prototypes(c_prog);
    set_prototypes(c_prog);
    soc_prototypes(c_prog);
    sql_prototypes(c_prog);
    str_prototypes(c_prog);
    tim_prototypes(c_prog);
    typ_prototypes(c_prog);
    ut8_prototypes(c_prog);
    <span class="keywd">if</span> ccConf.USE_WMAIN <span class="keywd">then</span>
      declareExtern(<span class="stri">"arrayType   getArgv (const int, wchar_t *const *const, striType *, striType *, striType *);"</span>);
    <span class="keywd">else</span>
      declareExtern(<span class="stri">"arrayType   getArgv (const int, char *const *const, striType *, striType *, striType *);"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    declareExtern(<span class="stri">"intType     heapsize (void);"</span>);
    declareExtern(<span class="stri">"void        setupStack (memSizeType);"</span>);
    declareExtern(<span class="stri">"void        setupFiles (void);"</span>);
    declareExtern(<span class="stri">"void        setupRand (void);"</span>);
    declareExtern(<span class="stri">"void        setupFloat (void);"</span>);
    declareExtern(<span class="stri">"void        setupBig (void);"</span>);
    declareExtern(<span class="stri">"void        init_primitiv (void);"</span>);
    writeln(c_prog, <span class="stri">"static void        prcNoop (void) {}"</span>);
    writeln(c_prog, <span class="stri">"static void        init_values (void);"</span>);
    writeln(c_prog, <span class="stri">"static void        init_globals (void);"</span>);
    declareExtern(<span class="stri">"void        initPollOperations (const createFuncType, const destrFuncType);"</span>);
    declareExtern(<span class="stri">"void        genericCpy (genericType *const, const genericType);"</span>);
    declareExtern(<span class="stri">"genericType genericCreate (genericType);"</span>);
    declareExtern(<span class="stri">"void        genericDestr (genericType);"</span>);
    declareExtern(<span class="stri">"intType     genericHashCode (genericType);"</span>);
    declareExtern(<span class="stri">"intType     ptrCmp (const void *const, const void *const);"</span>);
    declareExtern(<span class="stri">"intType     ptrCmpGeneric (const genericType, const genericType);"</span>);
    declareExtern(<span class="stri">"void        ptrCpyGeneric (genericType *const, const genericType);"</span>);
    declareExtern(<span class="stri">"genericType ptrCreateGeneric (const genericType);"</span>);
    declareExtern(<span class="stri">"intType     ptrHashCodeGeneric (const genericType);"</span>);
    writeln(c_prog, <span class="stri">"typedef void (*suspendInterprType) (int signalNum);"</span>);
    declareExtern(<span class="stri">"void        setupSignalHandlers (boolType, boolType, boolType, boolType, suspendInterprType);"</span>);
    declareExtern(<span class="stri">"void        triggerSigfpe (void);"</span>);
    declareExtern(<span class="stri">"void        rtlRaiseError (int, const char *, int) NORETURN;"</span>);
    writeln(c_prog, <span class="stri">"#define raiseError(num) rtlRaiseError(num, __FILE__, __LINE__)"</span>);
    writeln(c_prog, <span class="stri">"#define intRaiseError(num) (rtlRaiseError(num, __FILE__, __LINE__), 0)"</span>);
    writeln(c_prog, <span class="stri">"#define bigRaiseError(num) (bigIntType)(rtlRaiseError(num, __FILE__, __LINE__), NULL)"</span>);
    writeln(c_prog, <span class="stri">"#define strRaiseError(num) (striType)(rtlRaiseError(num, __FILE__, __LINE__), NULL)"</span>);
    writeln(c_prog, <span class="stri">"#define refRaiseError(num) (objRefType)(rtlRaiseError(num, __FILE__, __LINE__), NULL)"</span>);
<span class="comment">(*
    declareExtern("intType     enuValue (objRefType a)                         {printf(\"enuValue\\n\");}");
    declareExtern("intType     enuValue (objRefType);");
*)</span>
    <span class="keywd">if</span> trace_signal <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"#define filGetc(inFile) filGetcChkCtrlC(inFile)"</span>);
      writeln(c_prog, <span class="stri">"#define filGets(inFile, length) filGetsChkCtrlC(inFile, length)"</span>);
      writeln(c_prog, <span class="stri">"#define filHasNext(inFile) filHasNextChkCtrlC(inFile)"</span>);
      writeln(c_prog, <span class="stri">"#define filLineRead(inFile, terminationChar) filLineReadChkCtrlC(inFile, terminationChar)"</span>);
      writeln(c_prog, <span class="stri">"#define filWordRead(inFile, terminationChar) filWordReadChkCtrlC(inFile, terminationChar)"</span>);
    <span class="keywd">else</span>
      writeln(c_prog, <span class="stri">"#define filGetc(inFile) (unlikely((inFile)->cFile==NULL)?intRaiseError(FILE_ERROR):fgetc((inFile)->cFile))"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> ccConf.USE_DO_EXIT <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"void doExit (int returnCode);"</span>);
    <span class="keywd">else</span>
      writeln(c_prog, <span class="stri">"#define doExit(returnCode) exit(returnCode)"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: write_resize_catch_stack <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    writeln(c_prog);
    writeln(c_prog);
    writeln(c_prog, <span class="stri">"static void resize_catch_stack (void)"</span>);
    writeln(c_prog);
    writeln(c_prog, <span class="stri">"  {"</span>);
    writeln(c_prog, <span class="stri">"    catch_type *resized_stack;"</span>);
    writeln(c_prog);
    writeln(c_prog, <span class="stri">"    max_catch_stack += 128;"</span>);
    writeln(c_prog, <span class="stri">"    resized_stack = (catch_type *)(realloc(catch_stack, max_catch_stack * sizeof(catch_type)));"</span>);
    writeln(c_prog, <span class="stri">"    if (resized_stack == NULL) {"</span>);
    writeln(c_prog, <span class="stri">"      catch_stack_pos--;"</span>);
    writeln(c_prog, <span class="stri">"      raiseError(MEMORY_ERROR);"</span>);
    writeln(c_prog, <span class="stri">"    } else {"</span>);
    writeln(c_prog, <span class="stri">"      catch_stack = resized_stack;"</span>);
    writeln(c_prog, <span class="stri">"    }"</span>);
    writeln(c_prog, <span class="stri">"  }"</span>);
    writeln(c_prog);
    writeln(c_prog);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: initPollOperations (<span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> fileInterfaceType &lt;> void <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"initPollOperations((createFuncType)(&amp;itfCreate), "</span>;
      process_destr_declaration(fileInterfaceType, global_c_expr);
      c_expr.expr &amp;:= <span class="stri">"(destrFuncType)(&amp;destr_"</span>;
      c_expr.expr &amp;:= str(typeNumber(fileInterfaceType));
      c_expr.expr &amp;:= <span class="stri">"));\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">ref_list</span>: determine_multiple_array_elements (<span class="op">in</span> <span class="type">ref_list</span>: array_list) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: elements_to_walk <span class="keywd">is</span> ref_list.EMPTY;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: element <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">reference</span>: previous_element <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">reference</span>: repeat_block_element <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">integer</span>: repeat_count <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> element <span class="keywd">range</span> array_list <span class="keywd">do</span>
      <span class="keywd">if</span> previous_element &lt;> NIL <span class="keywd">then</span>
        <span class="keywd">if</span> identical_values(previous_element, element) <span class="keywd">then</span>
          <span class="keywd">if</span> repeat_block_element = NIL <span class="keywd">then</span>
            repeat_block_element := previous_element;
            repeat_count := 2;
          <span class="keywd">else</span>
            incr(repeat_count);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          elements_to_walk &amp;:= make_list(element);
          <span class="keywd">if</span> repeat_block_element &lt;> NIL <span class="keywd">then</span>
            element_repeat_count @:= [repeat_block_element] repeat_count;
            repeat_block_element := NIL;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        elements_to_walk &amp;:= make_list(element);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      previous_element := element;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> repeat_block_element &lt;> NIL <span class="keywd">then</span>
      element_repeat_count @:= [repeat_block_element] repeat_count;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: walk_const_list (<span class="op">in</span> <span class="type">ref_list</span>: const_list, <span class="keywd">inout</span> <span class="type">ref_list</span>: sorted_list) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: current_object <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">reference</span>: struct_of_interface <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">category</span>: objectCategory <span class="keywd">is</span> category.value;
    <span class="keywd">var</span> <span class="type">ref_list</span>: elements_to_walk <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">pointList</span>: aPointList <span class="keywd">is</span> pointList.value;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> current_object <span class="keywd">range</span> const_list <span class="keywd">do</span>
      objectCategory := category(current_object);
      <span class="keywd">if</span> objectCategory = BIGINTOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> getValue(current_object, bigInteger) <span class="op">not</span> <span class="op">in</span> bigint_const_table <span class="keywd">then</span>
          bigint_const_table @:= [getValue(current_object, bigInteger)] length(bigint_const_table);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> objectCategory = STRIOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> getValue(current_object, string) <span class="op">not</span> <span class="op">in</span> stri_const_table <span class="keywd">then</span>
          stri_const_table @:= [getValue(current_object, string)] length(stri_const_table);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> objectCategory = BSTRIOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> getValue(current_object, bstring) <span class="op">not</span> <span class="op">in</span> bstri_const_table <span class="keywd">then</span>
          bstri_const_table @:= [getValue(current_object, bstring)] length(bstri_const_table);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> objectCategory = SETOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> getValue(current_object, bitset) <span class="op">not</span> <span class="op">in</span> set_const_table <span class="keywd">then</span>
          set_const_table @:= [getValue(current_object, bitset)] length(set_const_table);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> objectCategory = WINOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> getValue(current_object, PRIMITIVE_WINDOW) <span class="op">not</span> <span class="op">in</span> win_const_table <span class="keywd">then</span>
          win_const_table @:= [getValue(current_object, PRIMITIVE_WINDOW)] length(win_const_table);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> objectCategory = POINTLISTOBJECT <span class="keywd">then</span>
        aPointList := getValue(current_object, pointList);
        <span class="keywd">if</span> aPointList <span class="op">not</span> <span class="op">in</span> plist_const_table <span class="keywd">then</span>
          plist_const_table @:= [aPointList] length(plist_const_table);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> objectCategory = ARRAYOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> current_object <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
          const_table @:= [current_object] length(const_table);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        elements_to_walk := determine_multiple_array_elements(arrayToList(current_object));
        walk_const_list(elements_to_walk, sorted_list);
        sorted_list &amp;:= make_list(current_object);
      <span class="keywd">elsif</span> objectCategory = STRUCTOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> current_object <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
          const_table @:= [current_object] length(const_table);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        walk_const_list(structToList(current_object), sorted_list);
        sorted_list &amp;:= make_list(current_object);
      <span class="keywd">elsif</span> objectCategory = HASHOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> current_object <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
          const_table @:= [current_object] length(const_table);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        walk_const_list(hashKeysToList(current_object), sorted_list);
        walk_const_list(hashDataToList(current_object), sorted_list);
        sorted_list &amp;:= make_list(current_object);
      <span class="keywd">elsif</span> objectCategory = INTERFACEOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> current_object <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
          const_table @:= [current_object] length(const_table);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        struct_of_interface := interfaceToStruct(current_object);
        <span class="keywd">if</span> struct_of_interface <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
          const_table @:= [struct_of_interface] length(const_table);
          walk_const_list(structToList(struct_of_interface), sorted_list);
          sorted_list &amp;:= make_list(struct_of_interface);
        <span class="keywd">elsif</span> const_table[struct_of_interface] >= const_table[current_object] <span class="keywd">then</span>
          sorted_list &amp;:= make_list(struct_of_interface);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        sorted_list &amp;:= make_list(current_object);
      <span class="keywd">elsif</span> objectCategory = MATCHOBJECT <span class="op">or</span> objectCategory = ACTOBJECT <span class="op">or</span>
          objectCategory = BLOCKOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> current_object <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
          const_table @:= [current_object] length(const_table);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        sorted_list &amp;:= make_list(current_object);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: prepare_func_literal (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> expr_type: c_value <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">string</span>: valueName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    create_name(current_object, objNumber(current_object), valueName);
    processFuncValue(valueName, getType(current_object), current_object, c_value);
    global_c_expr.expr &amp;:= c_value.temp_decls;
    global_init.expr &amp;:= diagnosticLine(current_object);
    global_init.expr &amp;:= c_value.temp_assigns;
    function_declared @:= [current_object] TRUE;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_func_literal (<span class="op">in</span> <span class="type">reference</span>: current_object,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: valueName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    create_name(current_object, objNumber(current_object), valueName);
    c_expr.expr &amp;:= <span class="stri">"&amp;funcvalue_"</span>;
    c_expr.expr &amp;:= valueName;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_pollData_literal (<span class="op">in</span> <span class="keywd">var</span> <span class="type">pollData</span>: aPollData,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"polEmpty()"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_const_value (<span class="op">in</span> <span class="type">reference</span>: current_object, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">category</span>: objectCategory <span class="keywd">is</span> category.value;
  <span class="keywd">begin</span>
    objectCategory := category(current_object);
    <span class="keywd">if</span> objectCategory = INTOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.intValue="</span>;
      c_expr.expr &amp;:= integerLiteral(getValue(current_object, integer));
    <span class="keywd">elsif</span> objectCategory = BIGINTOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.bigIntValue="</span>;
      c_expr.expr &amp;:= bigIntegerLiteral(getValue(current_object, bigInteger));
    <span class="keywd">elsif</span> objectCategory = CHAROBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.charValue="</span>;
      c_expr.expr &amp;:= charLiteral(getValue(current_object, char));
    <span class="keywd">elsif</span> objectCategory = STRIOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.striValue="</span>;
      c_expr.expr &amp;:= stringLiteral(getValue(current_object, string));
    <span class="keywd">elsif</span> objectCategory = BSTRIOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.bstriValue="</span>;
      c_expr.expr &amp;:= bstriLiteral(getValue(current_object, bstring));
    <span class="keywd">elsif</span> objectCategory = SETOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.setValue="</span>;
      c_expr.expr &amp;:= bitsetLiteral(getValue(current_object, bitset));
    <span class="keywd">elsif</span> objectCategory = FLOATOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.floatValue="</span>;
      c_expr.expr &amp;:= floatLiteral(getValue(current_object, float));
    <span class="keywd">elsif</span> objectCategory = REFOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.objRefValue="</span>;
      <span class="keywd">if</span> getValue(current_object, reference) = NIL <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"NULL"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"(objRefType)(&amp;("</span>;
        process_expr(getValue(current_object, reference), c_expr);
        c_expr.expr &amp;:= <span class="stri">"))"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> objectCategory = REFLISTOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.listValue=NULL"</span>;
    <span class="keywd">elsif</span> objectCategory = FILEOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.fileValue=&amp;"</span>;
      c_expr.expr &amp;:= lower(literal(getValue(current_object, clib_file)));
      c_expr.expr &amp;:= <span class="stri">"FileRecord"</span>;
    <span class="keywd">elsif</span> objectCategory = SOCKETOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.intValue="</span>;
      c_expr.expr &amp;:= <span class="stri">"-1"</span>;
    <span class="keywd">elsif</span> objectCategory = POLLOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.pollValue="</span>;
      process_pollData_literal(getValue(current_object, pollData), c_expr);
    <span class="keywd">elsif</span> objectCategory = WINOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.winValue=drwCreate("</span>;
      c_expr.expr &amp;:= windowLiteral(getValue(current_object, PRIMITIVE_WINDOW));
      c_expr.expr &amp;:= <span class="stri">")"</span>;
    <span class="keywd">elsif</span> objectCategory = POINTLISTOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.bstriValue="</span>;
      c_expr.expr &amp;:= pointListLiteral(getValue(current_object, pointList));
    <span class="keywd">elsif</span> objectCategory = PROCESSOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.processValue="</span>;
      c_expr.expr &amp;:= <span class="stri">"NULL"</span>;
    <span class="keywd">elsif</span> objectCategory = PROGOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.progValue="</span>;
      c_expr.expr &amp;:= <span class="stri">"NULL"</span>;
    <span class="keywd">elsif</span> objectCategory = TYPEOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.typeValue="</span>;
      c_expr.expr &amp;:= typeLiteral(getValue(current_object, type));
    <span class="keywd">elsif</span> objectCategory = CONSTENUMOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= select_value_from_rtlObjectStruct(
          getType(getValue(current_object, reference)));
      c_expr.expr &amp;:= <span class="stri">"="</span>;
      c_expr.expr &amp;:= enum_value(getValue(current_object, reference));
    <span class="keywd">elsif</span> objectCategory = VARENUMOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= select_value_from_rtlObjectStruct(
          getType(getValue(current_object, reference)));
      c_expr.expr &amp;:= <span class="stri">"="</span>;
      c_expr.expr &amp;:= enum_value(getValue(current_object, reference));
    <span class="keywd">elsif</span> objectCategory = ARRAYOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.arrayValue="</span>;
      c_expr.expr &amp;:= <span class="stri">"arr["</span>;
      c_expr.expr &amp;:= str(const_table[current_object]);
      c_expr.expr &amp;:= <span class="stri">"]"</span>;
    <span class="keywd">elsif</span> objectCategory = STRUCTOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.structValue="</span>;
      c_expr.expr &amp;:= <span class="stri">"sct["</span>;
      c_expr.expr &amp;:= str(const_table[current_object]);
      c_expr.expr &amp;:= <span class="stri">"]"</span>;
    <span class="keywd">elsif</span> objectCategory = HASHOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.hashValue="</span>;
      c_expr.expr &amp;:= <span class="stri">"hsh["</span>;
      c_expr.expr &amp;:= str(const_table[current_object]);
      c_expr.expr &amp;:= <span class="stri">"]"</span>;
    <span class="keywd">elsif</span> objectCategory = INTERFACEOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.interfaceValue=itfCreate(itf["</span>;
      c_expr.expr &amp;:= str(const_table[current_object]);
      c_expr.expr &amp;:= <span class="stri">"])"</span>;
    <span class="keywd">elsif</span> objectCategory = MATCHOBJECT <span class="op">or</span> objectCategory = ACTOBJECT <span class="op">or</span>
        objectCategory = BLOCKOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.genericValue="</span>;
      process_func_literal(current_object, c_expr);
    <span class="keywd">elsif</span> objectCategory = DATABASEOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.databaseValue=NULL"</span>;
    <span class="keywd">elsif</span> objectCategory = SQLSTMTOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">".value.sqlStmtValue=NULL"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"/* "</span>;
      c_expr.expr &amp;:= str(objectCategory);
      c_expr.expr &amp;:= <span class="stri">" */"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: int32AsFourBytes (<span class="op">in</span> <span class="type">integer</span>: number) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> ccConf.LITTLE_ENDIAN_INTTYPE <span class="keywd">then</span>
      stri := bytes(number, UNSIGNED, LE, 4);
    <span class="keywd">else</span>
      stri := bytes(number, UNSIGNED, BE, 4);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: int64AsEightBytes (<span class="op">in</span> <span class="type">integer</span>: number) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> ccConf.LITTLE_ENDIAN_INTTYPE <span class="keywd">then</span>
      stri := bytes(number, UNSIGNED, LE, 8);
    <span class="keywd">else</span>
      stri := bytes(number, UNSIGNED, BE, 8);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: int64AsTwoInt32 (<span class="op">in</span> <span class="type">bigInteger</span>: number) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: literals <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> ccConf.LITTLE_ENDIAN_INTTYPE <span class="keywd">then</span>
      literals := str( number        <span class="op">mod</span> 16#100000000_) &amp;
                  <span class="stri">","</span> &amp;
                  str((number >> 32) <span class="op">mod</span> 16#100000000_) &amp;
                  <span class="stri">","</span>;
    <span class="keywd">else</span>
      literals := str((number >> 32) <span class="op">mod</span> 16#100000000_) &amp;
                  <span class="stri">","</span> &amp;
                  str( number        <span class="op">mod</span> 16#100000000_) &amp;
                  <span class="stri">","</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_bigint_constants <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> bigint_index_hash: bigint_index <span class="keywd">is</span> bigint_index_hash.EMPTY_HASH;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">bstring</span>: bstri <span class="keywd">is</span> bstring.value;
  <span class="keywd">begin</span>
    bigint_index := flip(bigint_const_table);
    <span class="keywd">for</span> number <span class="keywd">range</span> sort(keys(bigint_index)) <span class="keywd">do</span>
      bstri := bStriLe(bigint_index[number][1], TRUE);
      <span class="keywd">if</span> bstri <span class="op">not</span> <span class="op">in</span> bstri_const_table <span class="keywd">then</span>
        bstri_const_table @:= [bstri] length(bstri_const_table);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      bigint_bstri_table @:= [number] bstri_const_table[bstri];
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: assign_bigint_constants (<span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> bigint_index_hash: bigint_index <span class="keywd">is</span> bigint_index_hash.EMPTY_HASH;
    <span class="keywd">var</span> <span class="type">bigInteger</span>: big1 <span class="keywd">is</span> bigInteger.value;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(bigint_const_table) = 0 <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"big = NULL;\n"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"big = (bigIntType *)(malloc("</span>;
      c_expr.expr &amp;:= str(length(bigint_const_table));
      c_expr.expr &amp;:= <span class="stri">" * sizeof(bigIntType)));\n"</span>;
      bigint_index := flip(bigint_const_table);
      <span class="keywd">for</span> number <span class="keywd">range</span> sort(keys(bigint_index)) <span class="keywd">do</span>
        big1 := bigint_index[number][1];
        c_expr.expr &amp;:= <span class="stri">"big["</span>;
        c_expr.expr &amp;:= str(number);
        c_expr.expr &amp;:= <span class="stri">"]=bigFromBStriLe("</span>;
        <span class="keywd">if</span> ccConf.ALLOW_BSTRITYPE_SLICES <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"&amp;"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"bst["</span>;
        c_expr.expr &amp;:= str(bigint_bstri_table[number]);
        c_expr.expr &amp;:= <span class="stri">"], 1);"</span>;
        <span class="keywd">if</span> bitLength(big1) &lt;= MAX_SHOWN_BIGINT_LITERAL_BITLENGTH <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">" /* "</span>;
          c_expr.expr &amp;:= str(big1);
          c_expr.expr &amp;:= <span class="stri">" */"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"\n"</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: pixelEncodingIdentical <span class="keywd">is</span>
  <span class="keywd">return</span> ord(colorPixel(color(65535,     0,     0))) =
             ccConf.PIXEL_RED_MASK   + ccConf.PIXEL_ALPHA_MASK <span class="op">and</span>
         ord(colorPixel(color(    0, 65535,     0))) =
             ccConf.PIXEL_GREEN_MASK + ccConf.PIXEL_ALPHA_MASK <span class="op">and</span>
         ord(colorPixel(color(    0,     0, 65535))) =
             ccConf.PIXEL_BLUE_MASK  + ccConf.PIXEL_ALPHA_MASK;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: pixelEncodingWithoutAlphaChannel <span class="keywd">is</span>
  <span class="keywd">return</span> ccConf.PIXEL_ALPHA_MASK &lt;> 0 <span class="op">and</span>
         ord(colorPixel(color(65535,     0,     0))) = ccConf.PIXEL_RED_MASK   <span class="op">and</span>
         ord(colorPixel(color(    0, 65535,     0))) = ccConf.PIXEL_GREEN_MASK <span class="op">and</span>
         ord(colorPixel(color(    0,     0, 65535))) = ccConf.PIXEL_BLUE_MASK;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: pixelEncodingWithRedAndBlueSwapped <span class="keywd">is</span>
  <span class="keywd">return</span> ord(colorPixel(color(65535,     0,     0))) =
             ccConf.PIXEL_BLUE_MASK  + ccConf.PIXEL_ALPHA_MASK <span class="op">and</span>
         ord(colorPixel(color(    0, 65535,     0))) =
             ccConf.PIXEL_GREEN_MASK + ccConf.PIXEL_ALPHA_MASK <span class="op">and</span>
         ord(colorPixel(color(    0,     0, 65535))) =
             ccConf.PIXEL_RED_MASK   + ccConf.PIXEL_ALPHA_MASK;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: pixelEncodingWithRedAndBlueSwappedWithoutAlphaChannel <span class="keywd">is</span>
  <span class="keywd">return</span> ccConf.PIXEL_ALPHA_MASK &lt;> 0 <span class="op">and</span>
         ord(colorPixel(color(65535,     0,     0))) = ccConf.PIXEL_BLUE_MASK  <span class="op">and</span>
         ord(colorPixel(color(    0, 65535,     0))) = ccConf.PIXEL_GREEN_MASK <span class="op">and</span>
         ord(colorPixel(color(    0,     0, 65535))) = ccConf.PIXEL_RED_MASK;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">bstring</span>: swapRedAndBlue (<span class="op">in</span> <span class="type">bstring</span>: bImage) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">bstring</span>: swappedImage <span class="keywd">is</span> bstring.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: image <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">char</span>: aByte <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    image := string(bImage);
    <span class="keywd">if</span> ccConf.LITTLE_ENDIAN_INTTYPE <span class="keywd">then</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length(image) step 4 <span class="keywd">do</span>
        aByte := image[index];
        image @:= [index] image[index + 2];
        image @:= [index + 2] aByte;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">else</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length(image) step 4 <span class="keywd">do</span>
        aByte := image[index + 1];
        image @:= [index + 1] image[index + 3];
        image @:= [index + 3] aByte;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    swappedImage := bstring(image);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">bstring</span>: fixPixels (<span class="op">in</span> <span class="keywd">var</span> <span class="type">array</span> <span class="type">array</span> <span class="type">pixel</span>: pixelArray) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">bstring</span>: swappedImageData <span class="keywd">is</span> bstring.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: redRightShift <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: greenRightShift <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: blueRightShift <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: redLeftShift <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: greenLeftShift <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: blueLeftShift <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">color</span>: pixelColor <span class="keywd">is</span> color.value;
    <span class="keywd">var</span> <span class="type">integer</span>: pixelData <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    redRightShift := 16 - (bitLength(ccConf.PIXEL_RED_MASK) - lowestSetBit(ccConf.PIXEL_RED_MASK));
    redLeftShift := lowestSetBit(ccConf.PIXEL_RED_MASK);
    greenRightShift := 16 - (bitLength(ccConf.PIXEL_GREEN_MASK) - lowestSetBit(ccConf.PIXEL_GREEN_MASK));
    greenLeftShift := lowestSetBit(ccConf.PIXEL_GREEN_MASK);
    blueRightShift := 16 - (bitLength(ccConf.PIXEL_BLUE_MASK) - lowestSetBit(ccConf.PIXEL_BLUE_MASK));
    blueLeftShift := lowestSetBit(ccConf.PIXEL_BLUE_MASK);
    <span class="keywd">for</span> <span class="keywd">key</span> line <span class="keywd">range</span> pixelArray <span class="keywd">do</span>
      <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> length(pixelArray[line]) <span class="keywd">do</span>
        pixelColor := pixelToColor(pixelArray[line][column]);
        pixelData := (pixelColor.redLight   >> redRightShift   &lt;&lt; redLeftShift) +
                     (pixelColor.greenLight >> greenRightShift &lt;&lt; greenLeftShift) +
                     (pixelColor.blueLight  >> blueRightShift  &lt;&lt; blueLeftShift);
        pixelArray[line][column] := pixel(pixelData);
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    swappedImageData := getPixelData(pixelArray);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_win_constants <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> win_index_hash: win_index <span class="keywd">is</span> win_index_hash.EMPTY_HASH;
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: win1 <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">bstring</span>: bImage <span class="keywd">is</span> bstring.value;
  <span class="keywd">begin</span>
    win_index := flip(win_const_table);
    <span class="keywd">if</span> length(win_index) &lt;> 0 <span class="op">and</span> (length(win_index) > 1 <span class="op">or</span>
        width(win_index[keys(win_index)[1]][1]) &lt;> 0 <span class="op">or</span>
        height(win_index[keys(win_index)[1]][1]) &lt;> 0) <span class="keywd">then</span>
      <span class="comment"># There is at least one non-empty window.</span>
      <span class="keywd">if</span> pixelEncodingIdentical <span class="op">or</span> pixelEncodingWithoutAlphaChannel <span class="op">or</span>
          ccConf.PIXEL_RED_MASK = 0 <span class="op">or</span>
          ccConf.PIXEL_GREEN_MASK = 0 <span class="op">or</span>
          ccConf.PIXEL_BLUE_MASK = 0 <span class="keywd">then</span>
        <span class="comment"># For an identical encoding no changes are necessary.</span>
        <span class="comment"># For zero pixel masks an identical encoding is assumed.</span>
        <span class="keywd">for</span> number <span class="keywd">range</span> sort(keys(win_index)) <span class="keywd">do</span>
          win1 := win_index[number][1];
          <span class="keywd">if</span> width(win1) &lt;> 0 <span class="op">or</span> height(win1) &lt;> 0 <span class="keywd">then</span>
            bImage := getPixelData(win1);
            <span class="keywd">if</span> bImage <span class="op">not</span> <span class="op">in</span> bstri_const_table <span class="keywd">then</span>
              bstri_const_table @:= [bImage] length(bstri_const_table);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            win_bstri_table @:= [number] bstri_const_table[bImage];
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">elsif</span> pixelEncodingWithRedAndBlueSwapped <span class="op">or</span>
          pixelEncodingWithRedAndBlueSwappedWithoutAlphaChannel <span class="keywd">then</span>
        <span class="keywd">for</span> number <span class="keywd">range</span> sort(keys(win_index)) <span class="keywd">do</span>
          win1 := win_index[number][1];
          <span class="keywd">if</span> width(win1) &lt;> 0 <span class="op">or</span> height(win1) &lt;> 0 <span class="keywd">then</span>
            bImage := swapRedAndBlue(getPixelData(win1));
            <span class="keywd">if</span> bImage <span class="op">not</span> <span class="op">in</span> bstri_const_table <span class="keywd">then</span>
              bstri_const_table @:= [bImage] length(bstri_const_table);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            win_bstri_table @:= [number] bstri_const_table[bImage];
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">else</span>
        <span class="keywd">for</span> number <span class="keywd">range</span> sort(keys(win_index)) <span class="keywd">do</span>
          win1 := win_index[number][1];
          <span class="keywd">if</span> width(win1) &lt;> 0 <span class="op">or</span> height(win1) &lt;> 0 <span class="keywd">then</span>
            bImage := fixPixels(getPixelArray(win1));
            <span class="keywd">if</span> bImage <span class="op">not</span> <span class="op">in</span> bstri_const_table <span class="keywd">then</span>
              bstri_const_table @:= [bImage] length(bstri_const_table);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            win_bstri_table @:= [number] bstri_const_table[bImage];
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: assign_win_constants (<span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> win_index_hash: win_index <span class="keywd">is</span> win_index_hash.EMPTY_HASH;
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: win1 <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(win_const_table) = 0 <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"win = NULL;\n"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"win = (winType *)(malloc("</span>;
      c_expr.expr &amp;:= str(length(win_const_table));
      c_expr.expr &amp;:= <span class="stri">" * sizeof(winType)));\n"</span>;
      win_index := flip(win_const_table);
      <span class="keywd">for</span> number <span class="keywd">range</span> sort(keys(win_index)) <span class="keywd">do</span>
        win1 := win_index[number][1];
        c_expr.expr &amp;:= <span class="stri">"win["</span>;
        c_expr.expr &amp;:= str(number);
        c_expr.expr &amp;:= <span class="stri">"]="</span>;
        <span class="keywd">if</span> width(win1) = 0 <span class="op">and</span> height(win1) = 0 <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"drwEmpty();\n"</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"drwImage((int32Type *)(("</span>;
          <span class="keywd">if</span> ccConf.ALLOW_BSTRITYPE_SLICES <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"&amp;"</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">"bst["</span>;
          c_expr.expr &amp;:= str(win_bstri_table[number]);
          c_expr.expr &amp;:= <span class="stri">"])->mem), "</span>;
          c_expr.expr &amp;:= str(width(win1));
          c_expr.expr &amp;:= <span class="stri">", "</span>;
          c_expr.expr &amp;:= str(height(win1));
          c_expr.expr &amp;:= <span class="stri">", 0);\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: pointListEncodingIdentical <span class="keywd">is</span>
  <span class="keywd">return</span> (ccConf.POINT_LIST_INT_SIZE = 16 <span class="op">and</span> <span class="op">not</span> ccConf.POINT_LIST_ABSOLUTE <span class="op">and</span>
          bstring(genPointList([] (597, 362, 219, 205))) =
              bstring(<span class="stri">"U\2;j\1;\134;\254;c\255;"</span>)) <span class="op">or</span>
         (ccConf.POINT_LIST_INT_SIZE = 32 <span class="op">and</span> ccConf.POINT_LIST_ABSOLUTE <span class="op">and</span>
          bstring(genPointList([] (597, 362, 219, 205))) =
              bstring(<span class="stri">"U\2;\0;\0;j\1;\0;\0;\219;\0;\0;\0;\205;\0;\0;\0;"</span>));


<span class="keywd">const</span> <span class="type">func</span> <span class="type">bstring</span>: toPointListAbsolute (<span class="op">in</span> <span class="type">pointList</span>: aPointList) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">bstring</span>: bstri <span class="keywd">is</span> bstring(<span class="stri">""</span>);
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: xyArray <span class="keywd">is</span> 0 <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: xOrY <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: pointListData <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    xyArray := xyArray(aPointList);
    <span class="keywd">if</span> ccConf.POINT_LIST_INT_SIZE = 16 <span class="keywd">then</span>
      <span class="keywd">if</span> ccConf.LITTLE_ENDIAN_INTTYPE <span class="keywd">then</span>
        <span class="keywd">for</span> xOrY <span class="keywd">range</span> xyArray <span class="keywd">do</span>
          pointListData &amp;:= bytes(xOrY, SIGNED, LE, 2);
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">else</span>
        <span class="keywd">for</span> xOrY <span class="keywd">range</span> xyArray <span class="keywd">do</span>
          pointListData &amp;:= bytes(xOrY, SIGNED, BE, 2);
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> ccConf.POINT_LIST_INT_SIZE = 32 <span class="keywd">then</span>
      <span class="keywd">if</span> ccConf.LITTLE_ENDIAN_INTTYPE <span class="keywd">then</span>
        <span class="keywd">for</span> xOrY <span class="keywd">range</span> xyArray <span class="keywd">do</span>
          pointListData &amp;:= bytes(xOrY, SIGNED, LE, 4);
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">else</span>
        <span class="keywd">for</span> xOrY <span class="keywd">range</span> xyArray <span class="keywd">do</span>
          pointListData &amp;:= bytes(xOrY, SIGNED, BE, 4);
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    bstri := bstring(pointListData);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">bstring</span>: toPointListRelative16 (<span class="op">in</span> <span class="type">pointList</span>: aPointList) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">bstring</span>: bstri <span class="keywd">is</span> bstring(<span class="stri">""</span>);
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: xyArray <span class="keywd">is</span> 0 <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: xOrY <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: pointListData <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    xyArray := xyArray(aPointList);
    <span class="keywd">if</span> length(xyArray) &lt;> 0 <span class="keywd">then</span>
      <span class="keywd">if</span> ccConf.LITTLE_ENDIAN_INTTYPE <span class="keywd">then</span>
        pointListData &amp;:= bytes(xyArray[1], SIGNED, LE, 2);
        pointListData &amp;:= bytes(xyArray[2], SIGNED, LE, 2);
        <span class="keywd">for</span> index <span class="keywd">range</span> 3 <span class="keywd">to</span> length(xyArray) step 2 <span class="keywd">do</span>
          pointListData &amp;:= bytes(xyArray[index    ] -
                                  xyArray[index - 2], SIGNED, LE, 2);
          pointListData &amp;:= bytes(xyArray[index + 1] -
                                  xyArray[index - 1], SIGNED, LE, 2);
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">else</span>
        pointListData &amp;:= bytes(xyArray[1], SIGNED, BE, 2);
        pointListData &amp;:= bytes(xyArray[2], SIGNED, BE, 2);
        <span class="keywd">for</span> index <span class="keywd">range</span> 3 <span class="keywd">to</span> length(xyArray) step 2 <span class="keywd">do</span>
          pointListData &amp;:= bytes(xyArray[index    ] -
                                  xyArray[index - 2], SIGNED, BE, 2);
          pointListData &amp;:= bytes(xyArray[index + 1] -
                                  xyArray[index - 1], SIGNED, BE, 2);
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    bstri := bstring(pointListData);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">bstring</span>: toPointListRelative32 (<span class="op">in</span> <span class="type">pointList</span>: aPointList) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">bstring</span>: bstri <span class="keywd">is</span> bstring(<span class="stri">""</span>);
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: xyArray <span class="keywd">is</span> 0 <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: xOrY <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: pointListData <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    xyArray := xyArray(aPointList);
    <span class="keywd">if</span> length(xyArray) &lt;> 0 <span class="keywd">then</span>
      <span class="keywd">if</span> ccConf.LITTLE_ENDIAN_INTTYPE <span class="keywd">then</span>
        pointListData &amp;:= bytes(xyArray[1], SIGNED, LE, 4);
        pointListData &amp;:= bytes(xyArray[2], SIGNED, LE, 4);
        <span class="keywd">for</span> index <span class="keywd">range</span> 3 <span class="keywd">to</span> length(xyArray) step 2 <span class="keywd">do</span>
          pointListData &amp;:= bytes(xyArray[index    ] -
                                  xyArray[index - 2], SIGNED, LE, 4);
          pointListData &amp;:= bytes(xyArray[index + 1] -
                                  xyArray[index - 1], SIGNED, LE, 4);
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">else</span>
        pointListData &amp;:= bytes(xyArray[1], SIGNED, BE, 4);
        pointListData &amp;:= bytes(xyArray[2], SIGNED, BE, 4);
        <span class="keywd">for</span> index <span class="keywd">range</span> 3 <span class="keywd">to</span> length(xyArray) step 2 <span class="keywd">do</span>
          pointListData &amp;:= bytes(xyArray[index    ] -
                                  xyArray[index - 2], SIGNED, BE, 4);
          pointListData &amp;:= bytes(xyArray[index + 1] -
                                  xyArray[index - 1], SIGNED, BE, 4);
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    bstri := bstring(pointListData);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">bstring</span>: toTargetPointListBstring (<span class="op">in</span> <span class="type">pointList</span>: aPointList) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">bstring</span>: bstri <span class="keywd">is</span> bstring(<span class="stri">""</span>);
  <span class="keywd">begin</span>
    <span class="keywd">if</span> pointListEncodingIdentical <span class="keywd">then</span>
      bstri := bstring(aPointList);
    <span class="keywd">elsif</span> ccConf.POINT_LIST_ABSOLUTE <span class="keywd">then</span>
      bstri := toPointListAbsolute(aPointList);
    <span class="keywd">else</span>
      <span class="keywd">if</span> ccConf.POINT_LIST_INT_SIZE = 16 <span class="keywd">then</span>
        bstri := toPointListRelative16(aPointList);
      <span class="keywd">elsif</span> ccConf.POINT_LIST_INT_SIZE = 32 <span class="keywd">then</span>
        bstri := toPointListRelative32(aPointList);
      <span class="keywd">else</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_plist_constants <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> plist_index_hash: plist_index <span class="keywd">is</span> plist_index_hash.EMPTY_HASH;
    <span class="keywd">var</span> <span class="type">pointList</span>: plist <span class="keywd">is</span> pointList.value;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">bstring</span>: bstri <span class="keywd">is</span> bstring.value;
  <span class="keywd">begin</span>
    plist_index := flip(plist_const_table);
    <span class="keywd">for</span> number <span class="keywd">range</span> sort(keys(plist_index)) <span class="keywd">do</span>
      plist := plist_index[number][1];
      bstri := toTargetPointListBstring(plist);
      <span class="keywd">if</span> bstri <span class="op">not</span> <span class="op">in</span> bstri_const_table <span class="keywd">then</span>
        bstri_const_table @:= [bstri] length(bstri_const_table);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      plist_bstri_table @:= [number] bstri_const_table[bstri];
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: assign_plist_constants (<span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> plist_index_hash: plist_index <span class="keywd">is</span> plist_index_hash.EMPTY_HASH;
    <span class="keywd">var</span> <span class="type">pointList</span>: plist <span class="keywd">is</span> pointList.value;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(win_const_table) = 0 <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"plist = NULL;\n"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"plist = (bstriType *)(malloc("</span>;
      c_expr.expr &amp;:= str(length(plist_const_table));
      c_expr.expr &amp;:= <span class="stri">" * sizeof(bstriType)));\n"</span>;
      plist_index := flip(plist_const_table);
      <span class="keywd">for</span> number <span class="keywd">range</span> sort(keys(plist_index)) <span class="keywd">do</span>
        plist := plist_index[number][1];
        c_expr.expr &amp;:= <span class="stri">"plist["</span>;
        c_expr.expr &amp;:= str(number);
        c_expr.expr &amp;:= <span class="stri">"]=pltAlign("</span>;
        <span class="keywd">if</span> ccConf.ALLOW_BSTRITYPE_SLICES <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"&amp;"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"bst["</span>;
        c_expr.expr &amp;:= str(plist_bstri_table[number]);
        c_expr.expr &amp;:= <span class="stri">"]);\n"</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: write_striChars (<span class="op">in</span> <span class="type">string</span>: striChars, <span class="keywd">inout</span> <span class="type">file</span>: c_prog) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: countChars <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(striChars) &lt;> 0 <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"static strElemType striChars["</span> &lt;&amp;
                      str(length(striChars)) &lt;&amp;
                      <span class="stri">"]={"</span>);
      <span class="keywd">for</span> ch <span class="keywd">range</span> striChars <span class="keywd">do</span>
        write(c_prog, c_literal(ch) &lt;&amp; <span class="stri">","</span>);
        incr(countChars);
        <span class="keywd">if</span> countChars = 20 <span class="keywd">then</span>
          writeln(c_prog);
          countChars := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      writeln(c_prog, <span class="stri">"};"</span>);
      writeln(c_prog);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: write_str_table (<span class="op">in</span> stri_index_hash: stri_index,
    <span class="op">in</span> <span class="type">array</span> <span class="type">integer</span>: stringPosition, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"struct striStruct str[]={\n"</span>;
    <span class="keywd">if</span> length(stri_const_table) > 0 <span class="keywd">then</span>
      <span class="keywd">for</span> number <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(length(stri_const_table)) <span class="keywd">do</span>
        stri := stri_index[number][1];
        c_expr.expr &amp;:= <span class="stri">"/* str["</span>;
        c_expr.expr &amp;:= str(number);
        c_expr.expr &amp;:= <span class="stri">"] */ {"</span>;
        c_expr.expr &amp;:= str(length(stri));
        c_expr.expr &amp;:= <span class="stri">","</span>;
        <span class="keywd">if</span> ccConf.WITH_STRI_CAPACITY <span class="keywd">then</span>
          c_expr.expr &amp;:= str(length(stri));
          c_expr.expr &amp;:= <span class="stri">","</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> stri = <span class="stri">""</span> <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"NULL"</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"&amp;striChars["</span>;
          c_expr.expr &amp;:= str(pred(stringPosition[number]));
          c_expr.expr &amp;:= <span class="stri">"]"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"},"</span>;
        c_expr.expr &amp;:= stringInComment(stri);
        c_expr.expr &amp;:= <span class="stri">"\n"</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"/* dummy */ {0,"</span>;
      <span class="keywd">if</span> ccConf.WITH_STRI_CAPACITY <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"0,"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">"NULL}"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">"};\n\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: handleOverlappingStrings (<span class="keywd">inout</span> <span class="type">string</span>: striChars, <span class="op">in</span> <span class="type">string</span>: stri,
    <span class="keywd">inout</span> <span class="type">integer</span>: stringPosition) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">integer</span>: endLength <span class="keywd">is</span> 8;
    <span class="keywd">var</span> <span class="type">string</span>: striCharsEnd <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: striIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: startPosition <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: checkedLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: found <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(striChars) >= endLength <span class="keywd">then</span>
      striCharsEnd :=
          striChars[succ(length(striChars) - endLength) fixLen endLength];
    <span class="keywd">else</span>
      striCharsEnd := striChars;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    striIndex := rpos(stri, striCharsEnd);
    found := FALSE;
    <span class="keywd">while</span> striIndex &lt;> 0 <span class="op">and</span> <span class="op">not</span> found <span class="keywd">do</span>
      startPosition := length(striChars) - striIndex - length(striCharsEnd) + 2;
      checkedLength := pred(striIndex + length(striCharsEnd));
      <span class="keywd">if</span> startPosition >= 1 <span class="op">and</span>
          stri[.. checkedLength] = striChars[startPosition ..] <span class="keywd">then</span>
        stringPosition := startPosition;
        striChars &amp;:= stri[succ(checkedLength) ..];
        found := TRUE;
      <span class="keywd">else</span>
        striIndex := rpos(stri, striCharsEnd, pred(striIndex));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> <span class="op">not</span> found <span class="keywd">then</span>
      <span class="keywd">if</span> length(stri) > 1 <span class="keywd">then</span>
        <span class="keywd">for</span> checkedLength <span class="keywd">range</span> min(length(stri), pred(endLength))
            <span class="keywd">downto</span> 1 <span class="keywd">until</span> found <span class="keywd">do</span>
          <span class="keywd">if</span> checkedLength &lt;= length(stri) <span class="keywd">then</span>
            startPosition := succ(length(striChars) - checkedLength);
            <span class="keywd">if</span> startPosition >= 1 <span class="op">and</span>
                stri[.. checkedLength] = striChars[startPosition ..] <span class="keywd">then</span>
              stringPosition := startPosition;
              striChars &amp;:= stri[succ(checkedLength) ..];
              found := TRUE;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> <span class="op">not</span> found <span class="keywd">then</span>
        stringPosition := succ(length(striChars));
        striChars &amp;:= stri;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_string_constants_with_slices (<span class="op">in</span> stri_index_hash: stri_index,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">integer</span>: endLength <span class="keywd">is</span> 8;
    <span class="keywd">var</span> <span class="type">stringLengthHash</span>: stringLengths <span class="keywd">is</span> stringLengthHash.value;
    <span class="keywd">var</span> <span class="type">lengthToStriNumHash</span>: lengthToStriNum <span class="keywd">is</span> lengthToStriNumHash.value;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: lengthList <span class="keywd">is</span> 0 <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: lengthIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: stringPosition <span class="keywd">is</span> 0 <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: combinedStriLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: striChars <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: striPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: striCharsEnd <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: striIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: startPosition <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: checkedLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: found <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    stringPosition := [0 .. pred(length(stri_const_table))] <span class="op">times</span> 0;
    <span class="keywd">for</span> number <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(length(stri_const_table)) <span class="keywd">do</span>
      stringLengths @:= [number] length(stri_index[number][1]);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    lengthToStriNum := flip(stringLengths);
    lengthList := sort(keys(lengthToStriNum));
    <span class="keywd">for</span> lengthIndex <span class="keywd">range</span> maxIdx(lengthList) <span class="keywd">downto</span> minIdx(lengthList) <span class="keywd">do</span>
      length := lengthList[lengthIndex];
      <span class="keywd">if</span> length <span class="op">in</span> lengthToStriNum <span class="keywd">then</span>
        <span class="keywd">for</span> number <span class="keywd">range</span> lengthToStriNum[length] <span class="keywd">do</span>
          stri := stri_index[number][1];
          combinedStriLength +:= length(stri);
          striPos := pos(striChars, stri);
          <span class="keywd">if</span> striPos = 0 <span class="keywd">then</span>
            handleOverlappingStrings(striChars, stri, stringPosition[number]);
          <span class="keywd">else</span>
            stringPosition[number] := striPos;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    write(c_prog, global_c_expr.expr);
    write(c_prog, c_expr.expr);
    global_c_expr := expr_type.value;
    c_expr := expr_type.value;
    write_striChars(striChars, c_prog);
    write_str_table(stri_index, stringPosition, c_expr);
    <span class="keywd">if</span> SHOW_STATISTIC <span class="keywd">then</span>
      writeln(combinedStriLength &lt;&amp; <span class="stri">" chars in all strings"</span>);
      writeln(length(striChars) &lt;&amp; <span class="stri">" chars in string pool"</span>);
      writeln(combinedStriLength - length(striChars) &lt;&amp; <span class="stri">" chars of string memory saved"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_string_constants_no_slices (<span class="op">in</span> stri_index_hash: stri_index,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> number <span class="keywd">range</span> sort(keys(stri_index)) <span class="keywd">do</span>
      stri := stri_index[number][1];
      c_expr.expr &amp;:= <span class="stri">"/* str["</span>;
      c_expr.expr &amp;:= str(number);
      c_expr.expr &amp;:= <span class="stri">"] */ static strElemType stri_"</span>;
      c_expr.expr &amp;:= str(number);
      c_expr.expr &amp;:= <span class="stri">"[]={"</span>;
      <span class="keywd">if</span> ccConf.POINTER_SIZE = 32 <span class="keywd">then</span>
        c_expr.expr &amp;:= str(length(stri));
        c_expr.expr &amp;:= <span class="stri">","</span>;
        <span class="keywd">if</span> ccConf.WITH_STRI_CAPACITY <span class="keywd">then</span>
          c_expr.expr &amp;:= str(length(stri));
          c_expr.expr &amp;:= <span class="stri">","</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> ccConf.POINTER_SIZE = 64 <span class="keywd">then</span>
        c_expr.expr &amp;:= int64AsTwoInt32(bigInteger(length(stri)));
        <span class="keywd">if</span> ccConf.WITH_STRI_CAPACITY <span class="keywd">then</span>
          c_expr.expr &amp;:= int64AsTwoInt32(bigInteger(length(stri)));
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">for</span> ch <span class="keywd">range</span> stri <span class="keywd">do</span>
        c_expr.expr &amp;:= c_literal(ch);
        c_expr.expr &amp;:= <span class="stri">","</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      c_expr.expr &amp;:= <span class="stri">"};\n"</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    c_expr.expr &amp;:= <span class="stri">"striType str[]={\n"</span>;
    <span class="keywd">if</span> length(stri_const_table) > 0 <span class="keywd">then</span>
      <span class="keywd">for</span> number <span class="keywd">range</span> sort(keys(stri_index)) <span class="keywd">do</span>
        stri := stri_index[number][1];
        c_expr.expr &amp;:= <span class="stri">"(striType) stri_"</span>;
        c_expr.expr &amp;:= str(number);
        c_expr.expr &amp;:= <span class="stri">","</span>;
        c_expr.expr &amp;:= stringInComment(stri);
        c_expr.expr &amp;:= <span class="stri">"\n"</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"(striType) NULL"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">"};\n\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_string_constants (<span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> stri_index_hash: stri_index <span class="keywd">is</span> stri_index_hash.EMPTY_HASH;
  <span class="keywd">begin</span>
    stri_index := flip(stri_const_table);
    <span class="keywd">if</span> ccConf.ALLOW_STRITYPE_SLICES <span class="keywd">then</span>
      init_string_constants_with_slices(stri_index, c_expr);
    <span class="keywd">else</span>
      init_string_constants_no_slices(stri_index, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: write_bstriChars (<span class="op">in</span> <span class="type">string</span>: bstriChars, <span class="keywd">inout</span> <span class="type">file</span>: c_prog) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: countChars <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(bstriChars) &lt;> 0 <span class="keywd">then</span>
      write(c_prog, <span class="stri">"static unsigned char bstriChars[/*"</span> &lt;&amp;
                    str(length(bstriChars)) &lt;&amp;
                    <span class="stri">"*/]"</span>);
      countChars := 0;
      <span class="keywd">if</span> ccConf.LIMITED_CSTRI_LITERAL_LEN <span class="keywd">then</span>
        writeln(c_prog, <span class="stri">"={"</span>);
        <span class="keywd">for</span> ch <span class="keywd">range</span> bstriChars <span class="keywd">do</span>
          write(c_prog, c_literal(ch) &lt;&amp; <span class="stri">","</span>);
          incr(countChars);
          <span class="keywd">if</span> countChars = 20 <span class="keywd">then</span>
            writeln(c_prog);
            countChars := 0;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
        writeln(c_prog, <span class="stri">"};"</span>);
        writeln(c_prog);
      <span class="keywd">else</span>
        <span class="keywd">if</span> length(bstriChars) &lt;> 0 <span class="keywd">then</span>
          write(c_prog, <span class="stri">"="</span>);
          <span class="keywd">for</span> countChars <span class="keywd">range</span> 1 <span class="keywd">to</span> length(bstriChars) step 40 <span class="keywd">do</span>
            writeln(c_prog);
            write(c_prog, c_literal(bstriChars[countChars len 40]));
          <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        writeln(c_prog, <span class="stri">";"</span>);
        writeln(c_prog);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: write_bst_table (<span class="op">in</span> bstri_index_hash: bstri_index,
    <span class="op">in</span> <span class="type">array</span> <span class="type">integer</span>: stringPosition, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"struct bstriStruct bst[]={\n"</span>;
    <span class="keywd">if</span> length(bstri_const_table) > 0 <span class="keywd">then</span>
      <span class="keywd">for</span> number <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(length(bstri_const_table)) <span class="keywd">do</span>
        stri := str(bstri_index[number][1]);
        c_expr.expr &amp;:= <span class="stri">"/* bst["</span>;
        c_expr.expr &amp;:= str(number);
        c_expr.expr &amp;:= <span class="stri">"] */ {"</span>;
        c_expr.expr &amp;:= str(length(stri));
        c_expr.expr &amp;:= <span class="stri">","</span>;
        <span class="keywd">if</span> stri = <span class="stri">""</span> <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"NULL"</span>;
        <span class="keywd">else</span>
          c_expr.expr &amp;:= <span class="stri">"&amp;bstriChars["</span>;
          c_expr.expr &amp;:= str(pred(stringPosition[number]));
          c_expr.expr &amp;:= <span class="stri">"]"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"},"</span>;
        c_expr.expr &amp;:= stringInComment(stri);
        c_expr.expr &amp;:= <span class="stri">"\n"</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"/* dummy */ {0,"</span>;
      c_expr.expr &amp;:= <span class="stri">"NULL}"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">"};\n\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_bstri_constants_with_slices (<span class="op">in</span> bstri_index_hash: bstri_index,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">integer</span>: endLength <span class="keywd">is</span> 8;
    <span class="keywd">var</span> <span class="type">stringLengthHash</span>: stringLengths <span class="keywd">is</span> stringLengthHash.value;
    <span class="keywd">var</span> <span class="type">lengthToStriNumHash</span>: lengthToStriNum <span class="keywd">is</span> lengthToStriNumHash.value;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: lengthList <span class="keywd">is</span> 0 <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: lengthIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: stringPosition <span class="keywd">is</span> 0 <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: combinedBStriLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: bstriChars <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: striPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: bstriCharsEnd <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: striIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: startPosition <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: checkedLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: found <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    stringPosition := [0 .. pred(length(bstri_const_table))] <span class="op">times</span> 0;
    <span class="keywd">for</span> number <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(length(bstri_const_table)) <span class="keywd">do</span>
      stringLengths @:= [number] length(bstri_index[number][1]);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    lengthToStriNum := flip(stringLengths);
    lengthList := sort(keys(lengthToStriNum));
    <span class="keywd">for</span> lengthIndex <span class="keywd">range</span> maxIdx(lengthList) <span class="keywd">downto</span> minIdx(lengthList) <span class="keywd">do</span>
      length := lengthList[lengthIndex];
      <span class="keywd">if</span> length <span class="op">in</span> lengthToStriNum <span class="keywd">then</span>
        <span class="keywd">for</span> number <span class="keywd">range</span> lengthToStriNum[length] <span class="keywd">do</span>
          stri := str(bstri_index[number][1]);
          combinedBStriLength +:= length(stri);
          striPos := pos(bstriChars, stri);
          <span class="keywd">if</span> striPos = 0 <span class="keywd">then</span>
            handleOverlappingStrings(bstriChars, stri, stringPosition[number]);
          <span class="keywd">else</span>
            stringPosition[number] := striPos;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    write(c_prog, global_c_expr.expr);
    write(c_prog, c_expr.expr);
    global_c_expr := expr_type.value;
    c_expr := expr_type.value;
    write_bstriChars(bstriChars, c_prog);
    write_bst_table(bstri_index, stringPosition, c_expr);
    <span class="keywd">if</span> SHOW_STATISTIC <span class="keywd">then</span>
      writeln(combinedBStriLength &lt;&amp; <span class="stri">" chars in all bstrings"</span>);
      writeln(length(bstriChars) &lt;&amp; <span class="stri">" chars in bstring pool"</span>);
      writeln(combinedBStriLength - length(bstriChars) &lt;&amp; <span class="stri">" chars of bstring memory saved"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_bstri_constants_no_slices (<span class="op">in</span> bstri_index_hash: bstri_index,
    <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">bstring</span>: bstri <span class="keywd">is</span> bstring.value;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: lengthAsChars <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: countChars <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> number <span class="keywd">range</span> sort(keys(bstri_index)) <span class="keywd">do</span>
      bstri := bstri_index[number][1];
      c_expr.expr &amp;:= <span class="stri">"/* bst["</span>;
      c_expr.expr &amp;:= str(number);
      c_expr.expr &amp;:= <span class="stri">"] */ static const unsigned char bstri_"</span>;
      c_expr.expr &amp;:= str(number);
      <span class="keywd">if</span> ccConf.POINTER_SIZE = 32 <span class="keywd">then</span>
        lengthAsChars := int32AsFourBytes(length(bstri));
      <span class="keywd">elsif</span> ccConf.POINTER_SIZE = 64 <span class="keywd">then</span>
        lengthAsChars := int64AsEightBytes(length(bstri));
      <span class="keywd">end</span> <span class="keywd">if</span>;
      countChars := 0;
      <span class="keywd">if</span> ccConf.LIMITED_CSTRI_LITERAL_LEN <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"[]={"</span>;
        <span class="keywd">for</span> ch <span class="keywd">range</span> lengthAsChars <span class="keywd">do</span>
          c_expr.expr &amp;:= c_literal(ch);
          c_expr.expr &amp;:= <span class="stri">","</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
        c_expr.expr &amp;:= <span class="stri">"\n"</span>;
        <span class="keywd">for</span> ch <span class="keywd">range</span> bstri <span class="keywd">do</span>
          c_expr.expr &amp;:= c_literal(ch);
          c_expr.expr &amp;:= <span class="stri">","</span>;
          incr(countChars);
          <span class="keywd">if</span> countChars = 20 <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"\n"</span>;
            countChars := 0;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
        c_expr.expr &amp;:= <span class="stri">"};\n"</span>;
      <span class="keywd">else</span>
        c_expr.expr &amp;:= <span class="stri">"[]="</span>;
        c_expr.expr &amp;:= c_literal(lengthAsChars);
        <span class="keywd">if</span> length(bstri) &lt;> 0 <span class="keywd">then</span>
          stri := str(bstri);
          <span class="keywd">for</span> countChars <span class="keywd">range</span> 1 <span class="keywd">to</span> length(stri) step 40 <span class="keywd">do</span>
            c_expr.expr &amp;:= <span class="stri">"\n"</span>;
            c_expr.expr &amp;:= c_literal(stri[countChars len 40]);
          <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    c_expr.expr &amp;:= <span class="stri">"bstriType bst[]={\n"</span>;
    <span class="keywd">if</span> length(bstri_const_table) > 0 <span class="keywd">then</span>
      <span class="keywd">for</span> number <span class="keywd">range</span> sort(keys(bstri_index)) <span class="keywd">do</span>
        c_expr.expr &amp;:= <span class="stri">"(bstriType) bstri_"</span>;
        c_expr.expr &amp;:= str(number);
        c_expr.expr &amp;:= <span class="stri">",\n"</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"(bstriType) NULL"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">"};\n\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_bstri_constants (<span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> bstri_index_hash: bstri_index <span class="keywd">is</span> bstri_index_hash.EMPTY_HASH;
  <span class="keywd">begin</span>
    bstri_index := flip(bstri_const_table);
    <span class="keywd">if</span> ccConf.ALLOW_BSTRITYPE_SLICES <span class="keywd">then</span>
      init_bstri_constants_with_slices(bstri_index, c_expr);
    <span class="keywd">else</span>
      init_bstri_constants_no_slices(bstri_index, c_expr);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_set_constants (<span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> set_index_hash: set_index <span class="keywd">is</span> set_index_hash.EMPTY_HASH;
    <span class="keywd">var</span> <span class="type">bitset</span>: set1 <span class="keywd">is</span> EMPTY_SET;
    <span class="keywd">var</span> <span class="type">integer</span>: min_position <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: max_position <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: elem_num <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: columnsFree <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    set_index := flip(set_const_table);
    <span class="keywd">for</span> number <span class="keywd">range</span> sort(keys(set_index)) <span class="keywd">do</span>
      set1 := set_index[number][1];
      c_expr.expr &amp;:= <span class="stri">"/* set["</span>;
      c_expr.expr &amp;:= str(number);
      c_expr.expr &amp;:= <span class="stri">"] */ static bitSetType set_"</span>;
      c_expr.expr &amp;:= str(number);
      c_expr.expr &amp;:= <span class="stri">"[]={"</span>;
      <span class="keywd">if</span> set1 = EMPTY_SET <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"0,0,0,"</span>;
      <span class="keywd">else</span>
        min_position := min(set1) <span class="op">mdiv</span> ccConf.INTTYPE_SIZE;
        max_position := max(set1) <span class="op">mdiv</span> ccConf.INTTYPE_SIZE;
        <span class="keywd">if</span> min_position &lt; 0 <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"(bitSetType)"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= str(min_position);
        c_expr.expr &amp;:= <span class="stri">","</span>;
        <span class="keywd">if</span> max_position &lt; 0 <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"(bitSetType)"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= str(max_position);
        c_expr.expr &amp;:= <span class="stri">","</span>;
        columnsFree := 4;
        <span class="keywd">for</span> elem_num <span class="keywd">range</span> min_position <span class="keywd">to</span> max_position <span class="keywd">do</span>
          <span class="keywd">if</span> columnsFree = 0 <span class="keywd">then</span>
            c_expr.expr &amp;:= <span class="stri">"\n"</span>;
            columnsFree := 6;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          c_expr.expr &amp;:= <span class="stri">"0x"</span>;
          c_expr.expr &amp;:= getBinary(set1, elem_num * ccConf.INTTYPE_SIZE) radix 16 <span class="op">lpad0</span> 16;
          c_expr.expr &amp;:= <span class="stri">","</span>;
          decr(columnsFree);
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">"};\n"</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    c_expr.expr &amp;:= <span class="stri">"setType set[]={\n"</span>;
    <span class="keywd">if</span> length(set_const_table) > 0 <span class="keywd">then</span>
      <span class="keywd">for</span> number <span class="keywd">range</span> sort(keys(set_index)) <span class="keywd">do</span>
        c_expr.expr &amp;:= <span class="stri">"(setType) set_"</span>;
        c_expr.expr &amp;:= str(number);
        c_expr.expr &amp;:= <span class="stri">",\n"</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"(setType) NULL"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">"};\n\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_type_constants (<span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> type_index_hash: type_index <span class="keywd">is</span> type_index_hash.EMPTY_HASH;
    <span class="keywd">var</span> <span class="type">type</span>: aType <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    type_index := flip(type_const_table);
    <span class="keywd">for</span> number <span class="keywd">range</span> sort(keys(type_index)) <span class="keywd">do</span>
      aType := type_index[number][1];
      c_expr.expr &amp;:= <span class="stri">"/* typ["</span>;
      c_expr.expr &amp;:= str(number);
      c_expr.expr &amp;:= <span class="stri">"] */ static struct typeStruct typ_"</span>;
      c_expr.expr &amp;:= str(number);
      c_expr.expr &amp;:= <span class="stri">"={"</span>;
      c_expr.expr &amp;:= <span class="stri">"NULL, NULL, NULL, NULL, NULL, 0, NULL, NULL"</span>;
      <span class="comment"># c_expr.expr &amp;:= c_literal(aType);</span>
      c_expr.expr &amp;:= <span class="stri">"};\n"</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    c_expr.expr &amp;:= <span class="stri">"typeType typ[]={\n"</span>;
    <span class="keywd">if</span> length(type_const_table) > 0 <span class="keywd">then</span>
      <span class="keywd">for</span> number <span class="keywd">range</span> sort(keys(type_index)) <span class="keywd">do</span>
        aType := type_index[number][1];
        c_expr.expr &amp;:= <span class="stri">"&amp;typ_"</span>;
        c_expr.expr &amp;:= str(number);
        c_expr.expr &amp;:= <span class="stri">", /* "</span>;
        c_expr.expr &amp;:= type_name2(aType);
        c_expr.expr &amp;:= <span class="stri">" */\n"</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"(typeType) NULL"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">"};\n\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_array_constants (<span class="op">in</span> <span class="type">reference</span>: const_object, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: array_list <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: elem_num <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: elem_after_repeat_block <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reference</span>: element <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    number := const_table[const_object];
    array_list := arrayToList(const_object);
    c_expr.expr &amp;:= <span class="stri">"arr["</span>;
    c_expr.expr &amp;:= str(number);
    c_expr.expr &amp;:= <span class="stri">"]=arrMalloc("</span>;
    c_expr.expr &amp;:= str(arrayMinIdx(const_object));
    c_expr.expr &amp;:= <span class="stri">", "</span>;
    c_expr.expr &amp;:= str(pred(arrayMinIdx(const_object) + length(array_list)));
    c_expr.expr &amp;:= <span class="stri">");\n"</span>;
    elem_num := 0;
    elem_after_repeat_block := 0;
    <span class="keywd">for</span> element <span class="keywd">range</span> array_list <span class="keywd">do</span>
      <span class="keywd">if</span> element <span class="op">in</span> element_repeat_count <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"int idx;\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"for (idx="</span>;
        c_expr.expr &amp;:= str(elem_num);
        c_expr.expr &amp;:= <span class="stri">"; idx &lt; "</span>;
        c_expr.expr &amp;:= str(elem_num + element_repeat_count[element]);
        c_expr.expr &amp;:= <span class="stri">"; idx++) {\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"arr["</span>;
        c_expr.expr &amp;:= str(number);
        c_expr.expr &amp;:= <span class="stri">"]->arr[idx]"</span>;
        init_const_value(element, c_expr);
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
        elem_after_repeat_block := elem_num + element_repeat_count[element];
      <span class="keywd">elsif</span> elem_num >= elem_after_repeat_block <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"arr["</span>;
        c_expr.expr &amp;:= str(number);
        c_expr.expr &amp;:= <span class="stri">"]->arr["</span>;
        c_expr.expr &amp;:= str(elem_num);
        c_expr.expr &amp;:= <span class="stri">"]"</span>;
        init_const_value(element, c_expr);
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      incr(elem_num);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: malloc_struct (<span class="op">in</span> <span class="type">reference</span>: const_object, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: struct_list <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    number := const_table[const_object];
    struct_list := structToList(const_object);
    c_expr.expr &amp;:= <span class="stri">"sct["</span>;
    c_expr.expr &amp;:= str(number);
    c_expr.expr &amp;:= <span class="stri">"]=(structType)(malloc(sizeof(struct rtlStructStruct) - sizeof(rtlObjectType)"</span>;
    <span class="keywd">if</span> length(struct_list) &lt;> 0 <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">" +\n  "</span>;
      c_expr.expr &amp;:= str(length(struct_list));
      c_expr.expr &amp;:= <span class="stri">" * sizeof(rtlObjectType)"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">"));\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_struct_constants (<span class="op">in</span> <span class="type">reference</span>: const_object, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: struct_list <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: elem_num <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reference</span>: element <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    number := const_table[const_object];
    struct_list := structToList(const_object);
    c_expr.expr &amp;:= <span class="stri">"sct["</span>;
    c_expr.expr &amp;:= str(number);
    c_expr.expr &amp;:= <span class="stri">"]->usage_count=0;\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"sct["</span>;
    c_expr.expr &amp;:= str(number);
    c_expr.expr &amp;:= <span class="stri">"]->type_num="</span>;
    c_expr.expr &amp;:= str(typeNumber(getType(const_object)));
    c_expr.expr &amp;:= <span class="stri">"/*"</span>;
    c_expr.expr &amp;:= str(getType(const_object));
    c_expr.expr &amp;:= <span class="stri">"*/"</span>;
    c_expr.expr &amp;:= <span class="stri">";\n"</span>;
    elem_num := 1;
    <span class="keywd">for</span> element <span class="keywd">range</span> struct_list <span class="keywd">do</span>
      c_expr.expr &amp;:= <span class="stri">"sct["</span>;
      c_expr.expr &amp;:= str(number);
      c_expr.expr &amp;:= <span class="stri">"]->stru["</span>;
      c_expr.expr &amp;:= str(pred(elem_num));
      c_expr.expr &amp;:= <span class="stri">"]"</span>;
      init_const_value(element, c_expr);
      c_expr.expr &amp;:= <span class="stri">";\n"</span>;
      incr(elem_num);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> const_object <span class="op">in</span> globalInitalisations <span class="keywd">then</span>
      c_expr.expr &amp;:= globalInitalisations[const_object];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_hash_constants (<span class="op">in</span> <span class="type">reference</span>: const_object, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: hash_key_list <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">ref_list</span>: hash_data_list <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: elem_num <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reference</span>: key_element <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> expr_type: hashcode_expr <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    number := const_table[const_object];
    hash_key_list := hashKeysToList(const_object);
    hash_data_list := hashDataToList(const_object);
    c_expr.expr &amp;:= <span class="stri">"hsh["</span>;
    c_expr.expr &amp;:= str(number);
    c_expr.expr &amp;:= <span class="stri">"]=hshEmpty();\n"</span>;
    <span class="keywd">if</span> length(hash_key_list) &lt;> 0 <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"rtlObjectType hash_key;\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"rtlObjectType hash_data;\n"</span>;
      elem_num := 1;
      <span class="keywd">for</span> key_element <span class="keywd">range</span> hash_key_list <span class="keywd">do</span>
        c_expr.expr &amp;:= <span class="stri">"hash_key"</span>;
        init_const_value(key_element, c_expr);
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"hash_data"</span>;
        init_const_value(hash_data_list[elem_num], c_expr);
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        hashcode_expr := expr_type.value;
        setVar(key_element, FALSE);
        process_hashcode(key_element, hashcode_expr);
        <span class="keywd">if</span> hashcode_expr.temp_decls &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
          c_expr.expr &amp;:= hashcode_expr.temp_decls;
          c_expr.expr &amp;:= hashcode_expr.temp_assigns;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"hshIncl(hsh["</span>;
        c_expr.expr &amp;:= str(number);
        c_expr.expr &amp;:= <span class="stri">"], hash_key.value.genericValue, hash_data.value.genericValue, "</span>;
        c_expr.expr &amp;:= hashcode_expr.expr;
        c_expr.expr &amp;:= <span class="stri">", (compareType)("</span>;
        object_address(keyCompareObj(getType(const_object)), c_expr);
        c_expr.expr &amp;:= <span class="stri">"), (createFuncType)("</span>;
        object_address(keyCreateObj(getType(const_object)), c_expr);
        c_expr.expr &amp;:= <span class="stri">"), (createFuncType)("</span>;
        object_address(dataCreateObj(getType(const_object)), c_expr);
        c_expr.expr &amp;:= <span class="stri">"), (copyFuncType)("</span>;
        object_address(dataCopyObj(getType(const_object)), c_expr);
        c_expr.expr &amp;:= <span class="stri">"));\n"</span>;
        <span class="keywd">if</span> hashcode_expr.temp_decls &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          c_expr.expr &amp;:= hashcode_expr.temp_frees;
          c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        incr(elem_num);
      <span class="keywd">end</span> <span class="keywd">for</span>;
      c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_interface_constants (<span class="op">in</span> <span class="type">reference</span>: const_object, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: struct_of_interface <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    number := const_table[const_object];
    struct_of_interface := interfaceToStruct(const_object);
    c_expr.expr &amp;:= <span class="stri">"itf["</span>;
    c_expr.expr &amp;:= str(number);
    c_expr.expr &amp;:= <span class="stri">"]"</span>;
    <span class="keywd">if</span> isVar(struct_of_interface) <span class="op">and</span> struct_of_interface <span class="op">in</span> globalInitalisations <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"=o_"</span>;
      create_name(struct_of_interface, c_expr.expr);
    <span class="keywd">elsif</span> category(struct_of_interface) = STRUCTOBJECT <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"=sct["</span>;
      c_expr.expr &amp;:= str(const_table[struct_of_interface]);
      c_expr.expr &amp;:= <span class="stri">"]"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">" /* = "</span>;
      c_expr.expr &amp;:= str(category(struct_of_interface));
      c_expr.expr &amp;:= <span class="stri">" */"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">";\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_nan_constants (<span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> nan_index_hash: nan_index <span class="keywd">is</span> nan_index_hash.EMPTY_HASH;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">bin64</span>: bits <span class="keywd">is</span> bin64(0);
  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"double2BitsUnion nanValue[] = {\n"</span>;
    <span class="keywd">if</span> length(nan_const_table) > 0 <span class="keywd">then</span>
      nan_index := flip(nan_const_table);
      <span class="keywd">for</span> number <span class="keywd">range</span> sort(keys(nan_index)) <span class="keywd">do</span>
        bits := nan_index[number][1];
        c_expr.expr &amp;:= <span class="stri">"{0x"</span>;
        c_expr.expr &amp;:= bits radix 16 <span class="op">lpad0</span> 16;
        c_expr.expr &amp;:= <span class="stri">"},\n"</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"{0}"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">"};\n\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: initCaseLabelsOfWhen (<span class="op">in</span> <span class="type">integer</span>: numOfCaseStmt, <span class="op">in</span> <span class="type">integer</span>: numOfWhenPart,
    <span class="op">in</span> <span class="type">reference</span>: whenLabels, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">ref_list</span>: hash_key_list <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: key_element <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> expr_type: hashcode_expr <span class="keywd">is</span> expr_type.value;
  <span class="keywd">begin</span>
    hash_key_list := hashKeysToList(whenLabels);
    <span class="keywd">if</span> length(hash_key_list) &lt;> 0 <span class="keywd">then</span>
      <span class="keywd">for</span> key_element <span class="keywd">range</span> hash_key_list <span class="keywd">do</span>
        c_expr.expr &amp;:= <span class="stri">"hash_key"</span>;
        init_const_value(key_element, c_expr);
        c_expr.expr &amp;:= <span class="stri">";\n"</span>;
        hashcode_expr := expr_type.value;
        setVar(key_element, FALSE);
        process_hashcode(key_element, hashcode_expr);
        <span class="keywd">if</span> hashcode_expr.temp_decls &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
          c_expr.expr &amp;:= hashcode_expr.temp_decls;
          c_expr.expr &amp;:= hashcode_expr.temp_assigns;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        c_expr.expr &amp;:= <span class="stri">"hshIncl(caseLabels["</span>;
        c_expr.expr &amp;:= str(numOfCaseStmt);
        c_expr.expr &amp;:= <span class="stri">"], hash_key.value.genericValue, "</span>;
        c_expr.expr &amp;:= str(numOfWhenPart);
        c_expr.expr &amp;:= <span class="stri">", "</span>;
        c_expr.expr &amp;:= hashcode_expr.expr;
        c_expr.expr &amp;:= <span class="stri">", (compareType)("</span>;
        object_address(keyCompareObj(getType(whenLabels)), c_expr);
        c_expr.expr &amp;:= <span class="stri">"), (createFuncType)("</span>;
        object_address(keyCreateObj(getType(whenLabels)), c_expr);
        c_expr.expr &amp;:= <span class="stri">"), (createFuncType)(&amp;genericCreate), (copyFuncType)(&amp;genericCpy));\n"</span>;
        <span class="keywd">if</span> hashcode_expr.temp_decls &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          c_expr.expr &amp;:= hashcode_expr.temp_frees;
          c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: initCaseLabelsOfCase (<span class="op">in</span> <span class="type">integer</span>: numOfCaseStmt,
    <span class="op">in</span> <span class="type">array</span> <span class="type">reference</span>: caseWhens, <span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: numOfWhenPart <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reference</span>: whenLabels <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"caseLabels["</span>;
    c_expr.expr &amp;:= str(numOfCaseStmt);
    c_expr.expr &amp;:= <span class="stri">"]=hshEmpty();\n"</span>;
    <span class="keywd">for</span> whenLabels <span class="keywd">key</span> numOfWhenPart <span class="keywd">range</span> caseWhens <span class="keywd">do</span>
      initCaseLabelsOfWhen(numOfCaseStmt, numOfWhenPart, whenLabels, c_expr);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: initCaseLabels (<span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: numOfCaseStmt <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"void initCaseLabelsOfSwitch () {\n"</span>;
    <span class="keywd">if</span> length(case_table) &lt;> 0 <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"rtlObjectType hash_key;\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"caseLabels = (hashType *)(malloc("</span>;
      c_expr.expr &amp;:= str(length(case_table));
      c_expr.expr &amp;:= <span class="stri">" * sizeof(hashType)));\n"</span>;
      <span class="keywd">for</span> <span class="keywd">key</span> numOfCaseStmt <span class="keywd">range</span> case_table <span class="keywd">do</span>
        initCaseLabelsOfCase(numOfCaseStmt, case_table[numOfCaseStmt], c_expr);
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">"}\n\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_values (<span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> const_index_hash: const_index <span class="keywd">is</span> const_index_hash.EMPTY_HASH;
    <span class="keywd">var</span> <span class="type">ref_list</span>: sorted_list <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: struct_of_interface <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">reference</span>: const_object <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">ref_list</span>: elements_to_walk <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">integer</span>: functionNumber <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: functionBreakupLimit <span class="keywd">is</span> 0;
    <span class="keywd">const</span> <span class="type">integer</span>: intendedFunctionSize <span class="keywd">is</span> 100000;
  <span class="keywd">begin</span>
    const_index := flip(const_table);
    <span class="keywd">for</span> number <span class="keywd">range</span> sort(keys(const_index)) <span class="keywd">do</span>
      const_object := const_index[number][1];
      <span class="keywd">if</span> category(const_object) = ARRAYOBJECT <span class="keywd">then</span>
        elements_to_walk := determine_multiple_array_elements(arrayToList(const_object));
        walk_const_list(elements_to_walk, sorted_list);
        sorted_list &amp;:= make_list(const_object);
      <span class="keywd">elsif</span> category(const_object) = STRUCTOBJECT <span class="keywd">then</span>
        walk_const_list(structToList(const_object), sorted_list);
        sorted_list &amp;:= make_list(const_object);
      <span class="keywd">elsif</span> category(const_object) = HASHOBJECT <span class="keywd">then</span>
        walk_const_list(hashKeysToList(const_object), sorted_list);
        walk_const_list(hashDataToList(const_object), sorted_list);
        sorted_list &amp;:= make_list(const_object);
      <span class="keywd">elsif</span> category(const_object) = INTERFACEOBJECT <span class="keywd">then</span>
        <span class="keywd">if</span> const_object <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
          const_table @:= [const_object] length(const_table);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        struct_of_interface := interfaceToStruct(const_object);
        <span class="keywd">if</span> struct_of_interface <span class="op">not</span> <span class="op">in</span> const_table <span class="keywd">then</span>
          const_table @:= [struct_of_interface] length(const_table);
          walk_const_list(structToList(struct_of_interface), sorted_list);
          sorted_list &amp;:= make_list(struct_of_interface);
        <span class="keywd">elsif</span> const_table[struct_of_interface] >= const_table[const_object] <span class="keywd">then</span>
          sorted_list &amp;:= make_list(struct_of_interface);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        sorted_list &amp;:= make_list(const_object);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    writeln(<span class="stri">"after walk_const_list"</span>);

    <span class="keywd">for</span> const_object <span class="keywd">range</span> sorted_list <span class="keywd">do</span>
      <span class="comment"># writeln(str(category(const_object)) &lt;&amp; ": " &lt;&amp; create_name(const_object));</span>
      <span class="keywd">if</span> category(const_object) = MATCHOBJECT <span class="op">or</span> category(const_object) = ACTOBJECT <span class="op">or</span>
          category(const_object) = BLOCKOBJECT <span class="keywd">then</span>
        prepare_func_literal(const_object, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;

    init_bigint_constants;
    init_win_constants;
    init_plist_constants;
    init_string_constants(c_expr);
    init_bstri_constants(c_expr);
    init_set_constants(c_expr);
    init_type_constants(c_expr);

    functionBreakupLimit := length(c_expr.expr) + intendedFunctionSize;
    c_expr.expr &amp;:= <span class="stri">"static void init_values1 (void)\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
    initPollOperations(c_expr);
    assign_bigint_constants(c_expr);
    assign_win_constants(c_expr);
    assign_plist_constants(c_expr);
    c_expr.expr &amp;:= <span class="stri">"arr = (arrayType *)(malloc("</span>;
    c_expr.expr &amp;:= str(length(const_table));
    c_expr.expr &amp;:= <span class="stri">" * sizeof(arrayType)));\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"sct = (structType *)(arr);\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"hsh = (hashType *)(arr);\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"itf = (interfaceType *)(arr);\n"</span>;
    <span class="keywd">for</span> const_object <span class="keywd">range</span> sorted_list <span class="keywd">do</span>
      <span class="keywd">if</span> category(const_object) = STRUCTOBJECT <span class="keywd">then</span>
        malloc_struct(const_object, c_expr);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> const_object <span class="keywd">range</span> sorted_list <span class="keywd">do</span>
      <span class="keywd">if</span> length(c_expr.expr) >= functionBreakupLimit <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"}\n\n"</span>;
        functionBreakupLimit := length(c_expr.expr) + intendedFunctionSize;
        incr(functionNumber);
        c_expr.expr &amp;:= <span class="stri">"static void init_values"</span>;
        c_expr.expr &amp;:= str(functionNumber);
        c_expr.expr &amp;:= <span class="stri">" (void)\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> category(const_object) = ARRAYOBJECT <span class="keywd">then</span>
        init_array_constants(const_object, c_expr);
      <span class="keywd">elsif</span> category(const_object) = STRUCTOBJECT <span class="keywd">then</span>
        init_struct_constants(const_object, c_expr);
      <span class="keywd">elsif</span> category(const_object) = HASHOBJECT <span class="keywd">then</span>
        init_hash_constants(const_object, c_expr);
      <span class="keywd">elsif</span> category(const_object) = INTERFACEOBJECT <span class="keywd">then</span>
        init_interface_constants(const_object, c_expr);
      <span class="keywd">elsif</span> category(const_object) &lt;> MATCHOBJECT <span class="op">and</span>
            category(const_object) &lt;> ACTOBJECT <span class="keywd">then</span>
        number := const_table[const_object];
        c_expr.expr &amp;:= <span class="stri">"/* const "</span>;
        c_expr.expr &amp;:= str(category(const_object));
        c_expr.expr &amp;:= <span class="stri">" ["</span>;
        c_expr.expr &amp;:= str(number);
        c_expr.expr &amp;:= <span class="stri">"] */\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    c_expr.expr &amp;:= <span class="stri">"}\n\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"static void init_values (void)\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> functionNumber <span class="keywd">do</span>
      c_expr.expr &amp;:= <span class="stri">"  init_values"</span>;
      c_expr.expr &amp;:= str(number);
      c_expr.expr &amp;:= <span class="stri">"();\n"</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    c_expr.expr &amp;:= <span class="stri">"  initCaseLabelsOfSwitch();\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"}\n\n"</span>;
    init_nan_constants(c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: declare_rtlRaiseError (<span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"void rtlRaiseError (int fail_value, const char *file_name, int line_number)\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
    <span class="keywd">if</span> trace_exception <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"  int ch;\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"  if (catch_stack_pos == 0) {\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"    printf(\"\\n*** Uncaught exception \");\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"  } else {\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"    printf(\"\\n*** Exception \");\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"  }\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"  if (fail_value >= 0 &amp;&amp; fail_value &lt; sizeof(exception_name) / sizeof(char *)) {\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"    printf(\"%s\", exception_name[fail_value]);\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"  } else {\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"    printf(\"%d\", fail_value);\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"  }\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"  printf(\" raised at %s(%d)\\n\", file_name, line_number);\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"  printf(\"\\n*** The following commands are possible:\\n\"\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"         \"  RETURN  Continue\\n\"\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"         \"  *       Terminate\\n\"\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"         \"  /       Trigger SIGFPE\\n\");\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"  ch = fgetc(stdin);\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"  if (ch == (int) '*') {\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"    doExit(1);\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"  } else if (ch == (int) '/') {\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"    triggerSigfpe();\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"  }\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">"  error_file = file_name;\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"  error_line = line_number;\n"</span>;
    <span class="keywd">if</span> signal_exception <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"  if (catch_stack_pos == 0) {\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"    printf(\"\\n*** Uncaught exception \");\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"    if (fail_value >= 0 &amp;&amp; fail_value &lt; sizeof(exception_name) / sizeof(char *)) {\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"      printf(\"%s\", exception_name[fail_value]);\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"    } else {\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"      printf(\"%d\", fail_value);\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"    }\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"    printf(\" raised at %s(%d)\\n\", file_name, line_number);\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"    triggerSigfpe();\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"  }\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> ccConf.HAS_SIGSETJMP <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"  siglongjmp(catch_stack[catch_stack_pos], fail_value);\n"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"  longjmp(catch_stack[catch_stack_pos], fail_value);\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: declare_raise_error2 (<span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    <span class="keywd">if</span> compilerLibraryUsed <span class="keywd">then</span>
      writeln(c_prog, <span class="stri">"extern boolType interpreter_exception;"</span>);
      declareExtern(<span class="stri">"void interprRaiseError (int, const char *, int);"</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">"void raise_error2 (int fail_value, const char *file_name, int line_number)\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
    <span class="keywd">if</span> compilerLibraryUsed <span class="keywd">then</span>
      c_expr.expr &amp;:= <span class="stri">"  if (interpreter_exception) {\n"</span>;
      <span class="keywd">if</span> trace_exception <span class="keywd">then</span>
        c_expr.expr &amp;:= <span class="stri">"    int ch;\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"    if (fail_value >= 0 &amp;&amp; fail_value &lt; sizeof(exception_name) / sizeof(char *)) {\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"      printf(\"*** Exception %s\", exception_name[fail_value]);\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"    } else {\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"      printf(\"*** Exception %d\", fail_value);\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"    }\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"    printf(\" raised at %s(%d)\\n\", file_name, line_number);\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"    printf(\"\\n*** The following commands are possible:\\n\"\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"           \"  RETURN  Continue\\n\"\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"           \"  *       Terminate\\n\"\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"           \"  /       Trigger SIGFPE\\n\");\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"    ch = fgetc(stdin);\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"    if (ch == (int) '*') {\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"      doExit(1);\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"    } else if (ch == (int) '/') {\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"      triggerSigfpe();\n"</span>;
        c_expr.expr &amp;:= <span class="stri">"    }\n"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      c_expr.expr &amp;:= <span class="stri">"    interprRaiseError(fail_value, file_name, line_number);\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"  } else {\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"    rtlRaiseError(fail_value, file_name, line_number);\n"</span>;
      c_expr.expr &amp;:= <span class="stri">"  }\n"</span>;
    <span class="keywd">else</span>
      c_expr.expr &amp;:= <span class="stri">"  rtlRaiseError(fail_value, file_name, line_number);\n"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    c_expr.expr &amp;:= <span class="stri">"}\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_globals (<span class="keywd">inout</span> expr_type: c_expr) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    c_expr.expr &amp;:= <span class="stri">"static void init_globals (void)\n"</span>;
    c_expr.expr &amp;:= <span class="stri">"{\n"</span>;
    c_expr.expr &amp;:= global_init.temp_decls;
    c_expr.expr &amp;:= global_init.temp_assigns;
    c_expr.expr &amp;:= global_init.expr;
    c_expr.expr &amp;:= <span class="stri">"}\n\n"</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_global_declarations (<span class="op">in</span> <span class="type">program</span>: prog) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> expr_type: c_expr <span class="keywd">is</span> expr_type.value;
    <span class="keywd">var</span> <span class="type">type</span>: int_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">integer</span>: numObjects <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> <span class="op">not</span> compDataLibraryUsed <span class="keywd">then</span>
      declareExtern(<span class="stri">"intType heapsize (void) {return 0;}"</span>);
      declareExtern(<span class="stri">"typeType refType (objRefType a) {printf(\"refType\\n\"); return NULL;}"</span>);
      declareExtern(<span class="stri">"typeType typValue (objRefType a) {printf(\"typValue\\n\"); return NULL;}"</span>);
      writeln(c_prog);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> compDataLibraryUsed <span class="op">and</span> <span class="op">not</span> compilerLibraryUsed <span class="keywd">then</span>
      declareExtern(<span class="stri">"striType get_file_name (unsigned int a) {return "</span> &lt;&amp; stringLiteral(<span class="stri">""</span>) &lt;&amp; <span class="stri">";}"</span>);
      declareExtern(<span class="stri">"const unsigned char *get_file_name_ustri (unsigned int a) {return (unsigned char *) \"?\";}"</span>);
      declareExtern(<span class="stri">"void *get_param_list (const_listType a, int *b) {printf(\"get_param_list\\n\"); return NULL;}"</span>);
      writeln(c_prog);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    declare_rtlRaiseError(c_expr);
    declare_raise_error2(c_expr);
    process_dynamic_decisions(c_expr);
    declare_literal_function_of_enums(c_expr);
    declare_missing_create_declarations(c_expr);
    declare_missing_destr_declarations(c_expr);
    initCaseLabels(c_expr);
    init_values(c_expr);
    init_globals(c_expr);
    <span class="keywd">if</span> profile_function <span class="keywd">then</span>
      int_type := getValue(sysVar(prog, <span class="stri">"integer"</span>), type);
      numObjects := objNumber(alloc(TRUE, int_type, 0));
      writeln(c_prog, <span class="stri">"static unsigned int profile_size = "</span> &lt;&amp; numObjects &lt;&amp; <span class="stri">";"</span>);
      writeln(c_prog);
      writeln(c_prog, <span class="stri">"static void initProfile (void)"</span>);
      writeln(c_prog, <span class="stri">"{"</span>);
      writeln(c_prog, <span class="stri">"  memSizeType index;"</span>);
      writeln(c_prog, <span class="stri">"  profile = (struct profileElement *) malloc("</span> &lt;&amp;
              numObjects &lt;&amp; <span class="stri">" * sizeof(struct profileElement));"</span>);
      writeln(c_prog, <span class="stri">"  if (profile != NULL) {"</span>);
      writeln(c_prog, <span class="stri">"    memset(profile, 0, "</span> &lt;&amp; numObjects &lt;&amp; <span class="stri">" * sizeof(struct profileElement));"</span>);
      writeln(c_prog, <span class="stri">"    for (index = 0; index &lt; "</span> &lt;&amp; numObjects &lt;&amp; <span class="stri">"; index++) {"</span>);
      writeln(c_prog, <span class="stri">"      profile[index].file = \"\";"</span>);
      writeln(c_prog, <span class="stri">"      profile[index].name = \"\";"</span>);
      writeln(c_prog, <span class="stri">"    }"</span>);
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> pred(numObjects) <span class="keywd">do</span>
        <span class="keywd">if</span> index <span class="op">in</span> profiledFunctions <span class="keywd">then</span>
          write(c_prog, <span class="stri">"    profile["</span> &lt;&amp; index &lt;&amp; <span class="stri">"].file = "</span> &lt;&amp;
                c_literal(toUtf8(file(profiledFunctions[index]))) &lt;&amp; <span class="stri">";"</span>);
          write(c_prog, <span class="stri">"    profile["</span> &lt;&amp; index &lt;&amp; <span class="stri">"].line = "</span> &lt;&amp;
                line(profiledFunctions[index]) &lt;&amp; <span class="stri">";"</span>);
          writeln(c_prog, <span class="stri">"    profile["</span> &lt;&amp; index &lt;&amp; <span class="stri">"].name = "</span> &lt;&amp;
                  c_literal(toUtf8(str(profiledFunctions[index]))) &lt;&amp; <span class="stri">";"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      writeln(c_prog, <span class="stri">"  }"</span>);
      writeln(c_prog, <span class="stri">"}"</span>);
      writeln(c_prog);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    write(c_prog, global_c_expr.expr);
    write(c_prog, c_expr.expr);
    count_declarations(c_expr);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_systypes (<span class="op">in</span> <span class="type">program</span>: prog) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">reference</span>: type_ref <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">reference</span>: ref_to_empty <span class="keywd">is</span> NIL;
    <span class="keywd">var</span> <span class="type">type</span>: type_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: int_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: float_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: bigint_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: char_type <span class="keywd">is</span> void;
    <span class="keywd">var</span> <span class="type">type</span>: stri_type <span class="keywd">is</span> void;
  <span class="keywd">begin</span>
    type_ref := sysVar(prog, <span class="stri">"type"</span>);
    <span class="keywd">if</span> type_ref &lt;> NIL <span class="keywd">then</span>
      type_type := getValue(type_ref, type);
      typeCategory @:= [type_type] TYPEOBJECT;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    type_ref := sysVar(prog, <span class="stri">"proc"</span>);
    <span class="keywd">if</span> type_ref &lt;> NIL <span class="keywd">then</span>
      proctype := getValue(type_ref, type);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    type_ref := sysVar(prog, <span class="stri">"integer"</span>);
    <span class="keywd">if</span> type_ref &lt;> NIL <span class="keywd">then</span>
      int_type := getValue(type_ref, type);
      typeCategory @:= [int_type] INTOBJECT;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    type_ref := sysVar(prog, <span class="stri">"bigInteger"</span>);
    <span class="keywd">if</span> type_ref &lt;> NIL <span class="keywd">then</span>
      bigint_type := getValue(type_ref, type);
      typeCategory @:= [bigint_type] BIGINTOBJECT;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    type_ref := sysVar(prog, <span class="stri">"float"</span>);
    <span class="keywd">if</span> type_ref &lt;> NIL <span class="keywd">then</span>
      float_type := getValue(type_ref, type);
      typeCategory @:= [float_type] FLOATOBJECT;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    type_ref := sysVar(prog, <span class="stri">"char"</span>);
    <span class="keywd">if</span> type_ref &lt;> NIL <span class="keywd">then</span>
      char_type := getValue(type_ref, type);
      typeCategory @:= [char_type] CHAROBJECT;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    type_ref := sysVar(prog, <span class="stri">"string"</span>);
    <span class="keywd">if</span> type_ref &lt;> NIL <span class="keywd">then</span>
      stri_type := getValue(type_ref, type);
      typeCategory @:= [stri_type] STRIOBJECT;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    ref_to_empty := sysVar(prog, <span class="stri">"empty"</span>);
    <span class="keywd">if</span> ref_to_empty &lt;> NIL <span class="keywd">then</span>
      voidtype := getType(ref_to_empty);
      typeCategory @:= [voidtype] VOIDOBJECT;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: temp_name (<span class="op">in</span> <span class="type">string</span>: source) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: tempName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> rpos(source, <span class="stri">"/"</span>) = 0 <span class="keywd">then</span>
      tempName := <span class="stri">"tmp_"</span> &amp; source;
    <span class="keywd">else</span>
      tempName := source[.. rpos(source, <span class="stri">"/"</span>)] &amp;
          <span class="stri">"tmp_"</span> &amp; source[succ(rpos(source, <span class="stri">"/"</span>)) ..];
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: pass_1 (<span class="op">in</span> <span class="type">string</span>: source, <span class="keywd">inout</span> <span class="type">program</span>: prog,
    <span class="op">in</span> <span class="type">optionHash</span>: compilerOptions, <span class="keywd">inout</span> <span class="type">boolean</span>: okay) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: optionChar <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">string</span>: configFileName <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> source = <span class="stri">""</span> <span class="keywd">then</span>
      writeln(<span class="stri">"*** Sourcefile missing"</span>);
      okay := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="stri">"-w"</span> <span class="op">in</span> compilerOptions <span class="keywd">then</span>
      <span class="keywd">if</span> compilerOptions[<span class="stri">"-w"</span>] <span class="op">in</span> {<span class="stri">"0"</span>, <span class="stri">"1"</span>, <span class="stri">"2"</span>} <span class="keywd">then</span>
        warning_level := integer(compilerOptions[<span class="stri">"-w"</span>]);
      <span class="keywd">else</span>
        writeln(<span class="stri">"*** Unsupported option: -w"</span> &lt;&amp; compilerOptions[<span class="stri">"-w"</span>]);
        okay := FALSE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="stri">"-g"</span> <span class="op">in</span> compilerOptions <span class="keywd">then</span>
      <span class="keywd">if</span> compilerOptions[<span class="stri">"-g"</span>] <span class="op">in</span> {<span class="stri">""</span>, <span class="stri">"-debug_c"</span>} <span class="keywd">then</span>
        source_debug_info := compilerOptions[<span class="stri">"-g"</span>] &lt;> <span class="stri">"-debug_c"</span>;
      <span class="keywd">else</span>
        writeln(<span class="stri">"*** Unsupported option: -g"</span> &lt;&amp; compilerOptions[<span class="stri">"-g"</span>]);
        okay := FALSE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="stri">"-t"</span> <span class="op">in</span> compilerOptions <span class="keywd">then</span>
      <span class="keywd">for</span> optionChar <span class="keywd">range</span> compilerOptions[<span class="stri">"-t"</span>] <span class="keywd">do</span>
        <span class="keywd">case</span> optionChar <span class="keywd">of</span>
          <span class="keywd">when</span> {<span class="stri">'d'</span>}: trace_dynamic_calls := TRUE;
          <span class="keywd">when</span> {<span class="stri">'e'</span>}: trace_exception := TRUE;
          <span class="keywd">when</span> {<span class="stri">'f'</span>}: trace_function := TRUE;
          <span class="keywd">when</span> {<span class="stri">'s'</span>}: trace_signal := TRUE;
          <span class="keywd">otherwise</span>:
            writeln(<span class="stri">"*** Unsupported option: -t"</span> &lt;&amp; optionChar);
            okay := FALSE;
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="stri">"-p"</span> <span class="op">in</span> compilerOptions <span class="keywd">then</span>
      profile_function := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="stri">"-e"</span> <span class="op">in</span> compilerOptions <span class="keywd">then</span>
      signal_exception := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="stri">"-o"</span> <span class="op">in</span> compilerOptions <span class="keywd">then</span>
      <span class="keywd">if</span> compilerOptions[<span class="stri">"-o"</span>] <span class="op">in</span> {<span class="stri">"c0"</span>, <span class="stri">"c1"</span>, <span class="stri">"c2"</span>, <span class="stri">"c3"</span>} <span class="keywd">then</span>
        evaluate_const_expr := integer(compilerOptions[<span class="stri">"-o"</span>][2 ..]);
      <span class="keywd">else</span>
        writeln(<span class="stri">"*** Unsupported option: -o"</span> &lt;&amp; compilerOptions[<span class="stri">"-o"</span>]);
        okay := FALSE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    setOptimizationSettings(evaluate_const_expr);
    <span class="keywd">if</span> <span class="stri">"-s"</span> <span class="op">in</span> compilerOptions <span class="keywd">then</span>
      <span class="keywd">for</span> optionChar <span class="keywd">range</span> compilerOptions[<span class="stri">"-s"</span>] <span class="keywd">do</span>
        <span class="keywd">case</span> optionChar <span class="keywd">of</span>
          <span class="keywd">when</span> {<span class="stri">'d'</span>}: integer_division_check := FALSE;
          <span class="keywd">when</span> {<span class="stri">'i'</span>}: string_index_check := FALSE;
                      bstring_index_check := FALSE;
                      array_index_check := FALSE;
                      ref_list_index_check := FALSE;
          <span class="keywd">when</span> {<span class="stri">'o'</span>}: integer_overflow_check := FALSE;
          <span class="keywd">when</span> {<span class="stri">'r'</span>}: function_range_check := FALSE;
                      conversion_range_check := FALSE;
          <span class="keywd">otherwise</span>:
            writeln(<span class="stri">"*** Unsupported option: -s"</span> &lt;&amp; optionChar);
            okay := FALSE;
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    setIntegerDivisionCheck(integer_division_check);
    setIntegerOverflowCheck(integer_overflow_check);
    <span class="keywd">if</span> <span class="stri">"-c"</span> <span class="op">in</span> compilerOptions <span class="keywd">then</span>
      <span class="keywd">if</span> compilerOptions[<span class="stri">"-c"</span>] = <span class="stri">"++"</span> <span class="keywd">then</span>
        generate_c_plus_plus := TRUE;
        declare_with_extern_c := generate_c_plus_plus;
      <span class="keywd">else</span>
        configFileName := ccConf.S7_LIB_DIR &amp; <span class="stri">"/cc_conf_"</span> &amp; compilerOptions[<span class="stri">"-c"</span>] &amp; <span class="stri">".prop"</span>;
        <span class="keywd">if</span> fileType(configFileName) = FILE_REGULAR <span class="keywd">then</span>
          ccConf := readConfig(configFileName);
        <span class="keywd">else</span>
          writeln(<span class="stri">"*** Cannot find config file "</span> &lt;&amp; configFileName);
          okay := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="stri">"-f"</span> <span class="op">in</span> compilerOptions <span class="keywd">then</span>
      <span class="keywd">case</span> compilerOptions[<span class="stri">"-f"</span>] <span class="keywd">of</span>
        <span class="keywd">when</span> {<span class="stri">"lto"</span>}:
          <span class="keywd">if</span> ccConf.CC_OPT_LINK_TIME_OPTIMIZATION &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            enable_link_time_optimization := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">otherwise</span>:
          writeln(<span class="stri">"*** Unsupported option: -f"</span> &lt;&amp; compilerOptions[<span class="stri">"-f"</span>]);
          okay := FALSE;
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="stri">"-S"</span> <span class="op">in</span> compilerOptions <span class="keywd">then</span>
      <span class="keywd">block</span>
        stack_size := integer(compilerOptions[<span class="stri">"-S"</span>]);
      exception
        <span class="keywd">otherwise</span>:
          writeln(<span class="stri">"*** Ignore unsupported option: -S"</span> &lt;&amp; compilerOptions[<span class="stri">"-S"</span>]);
          okay := FALSE;
      <span class="keywd">end</span> <span class="keywd">block</span>;
    <span class="keywd">else</span>
      stack_size := ccConf.DEFAULT_STACK_SIZE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> okay <span class="keywd">then</span>
      writeln(<span class="stri">"Source: "</span> &lt;&amp; source);
      writeln(<span class="stri">"Compiling the program ..."</span>);
      <span class="keywd">block</span>
        prog := parseFile(source, parseOptions.value, libraryDirs);
        <span class="keywd">if</span> prog = program.EMPTY <span class="keywd">then</span>
          writeln(<span class="stri">"*** File "</span> &lt;&amp; literal(source) &lt;&amp; <span class="stri">" not found."</span>);
          okay := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      exception
        <span class="keywd">otherwise</span>:
          writeln(<span class="stri">"*** An error occurred."</span>);
        okay := FALSE;
      <span class="keywd">end</span> <span class="keywd">block</span>;
      <span class="keywd">if</span> okay <span class="op">and</span> errorCount(prog) &lt;> 0 <span class="keywd">then</span>
        write(errorCount(prog) &lt;&amp; <span class="stri">" error"</span>);
        <span class="keywd">if</span> errorCount(prog) > 1 <span class="keywd">then</span>
          write(<span class="stri">"s"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        writeln(<span class="stri">" found"</span>);
        okay := FALSE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: pass_2 (<span class="op">in</span> <span class="type">string</span>: source, <span class="op">in</span> <span class="type">program</span>: prog,
    <span class="keywd">inout</span> <span class="type">boolean</span>: okay) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: temporaryFileName <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">ref_list</span>: globalObjects <span class="keywd">is</span> ref_list.EMPTY;
    <span class="keywd">var</span> <span class="type">reference</span>: obj <span class="keywd">is</span> NIL;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> okay <span class="keywd">then</span>
      main_object := sysVar(prog, <span class="stri">"main"</span>);
      <span class="keywd">if</span> main_object &lt;> NIL <span class="keywd">then</span>
        compileLibrary := category(main_object) = FORWARDOBJECT;
        temporaryFileName := temp_name(source);
        <span class="keywd">if</span> generate_c_plus_plus <span class="keywd">then</span>
          temporaryFileName &amp;:= <span class="stri">".cpp"</span>;
        <span class="keywd">else</span>
          temporaryFileName &amp;:= <span class="stri">".c"</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="comment"># The temporary tmp_*.c file is marked with a temp_marker.</span>
        <span class="comment"># The temp_marker is checked, before the file is overwritten.</span>
        c_prog := open(temporaryFileName, <span class="stri">"r"</span>);
        <span class="keywd">if</span> c_prog &lt;> STD_NULL <span class="keywd">then</span>
          <span class="keywd">if</span> getln(c_prog) &lt;> temp_marker <span class="op">and</span> length(c_prog) &lt;> 0 <span class="keywd">then</span>
            write(<span class="stri">"*** The file "</span>);
            write(literal(temporaryFileName));
            writeln(<span class="stri">" was not created by the compiler."</span>);
            write(<span class="stri">"*** Remove the file "</span>);
            write(literal(temporaryFileName));
            writeln(<span class="stri">" manually and restart the compiler."</span>);
            okay := FALSE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          close(c_prog);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> okay <span class="keywd">then</span>
          c_prog := open(temporaryFileName, <span class="stri">"w"</span>);
          <span class="keywd">if</span> c_prog &lt;> STD_NULL <span class="keywd">then</span>
            writeln(<span class="stri">"Generating code ..."</span>);
            init_systypes(prog);
            write_file_head;
            write_prototypes;
            write_resize_catch_stack;
            globalObjects := globalObjects(prog);
            <span class="keywd">if</span> compileLibrary <span class="keywd">then</span>
              writeln(<span class="stri">"Compile library"</span>);
              <span class="keywd">for</span> obj <span class="keywd">range</span> globalObjects <span class="keywd">do</span>
                <span class="keywd">if</span> endsWith(path(prog), file(obj)) <span class="keywd">then</span>
                  process_object(obj);
                <span class="keywd">else</span>
                  process_library_import_object(obj);
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">for</span>;
            <span class="keywd">else</span>
              <span class="keywd">for</span> obj <span class="keywd">range</span> globalObjects <span class="keywd">do</span>
                process_object(obj);
              <span class="keywd">end</span> <span class="keywd">for</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            process_global_declarations(prog);
            close(c_prog);
            writeln(countDeclarations  &lt;&amp; <span class="stri">" declarations processed"</span>);
            writeln(countOptimizations &lt;&amp; <span class="stri">" optimizations done"</span>);
            <span class="keywd">if</span> countInlinedFunctions &lt;> 0 <span class="keywd">then</span>
              writeln(countInlinedFunctions &lt;&amp; <span class="stri">" functions inlined"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> countEvaluations &lt;> 0 <span class="keywd">then</span>
              writeln(countEvaluations &lt;&amp; <span class="stri">" evaluations done"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> countDivisionChecks &lt;> 0 <span class="keywd">then</span>
              writeln(countDivisionChecks &lt;&amp; <span class="stri">" division checks inserted"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> countOptimizedDivisionChecks &lt;> 0 <span class="keywd">then</span>
              writeln(countOptimizedDivisionChecks &lt;&amp; <span class="stri">" division checks optimized away"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> countRangeChecks &lt;> 0 <span class="keywd">then</span>
              writeln(countRangeChecks &lt;&amp; <span class="stri">" range checks inserted"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> countOptimizedRangeChecks &lt;> 0 <span class="keywd">then</span>
              writeln(countOptimizedRangeChecks &lt;&amp; <span class="stri">" range checks optimized away"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> countNoRangeChecks &lt;> 0 <span class="keywd">then</span>
              writeln(countNoRangeChecks &lt;&amp; <span class="stri">" range checks suppressed"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> countIndexChecks &lt;> 0 <span class="keywd">then</span>
              writeln(countIndexChecks &lt;&amp; <span class="stri">" index checks inserted"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> countOptimizedIndexChecks &lt;> 0 <span class="keywd">then</span>
              writeln(countOptimizedIndexChecks &lt;&amp; <span class="stri">" index checks optimized away"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> countSuppressedIndexChecks &lt;> 0 <span class="keywd">then</span>
              writeln(countSuppressedIndexChecks &lt;&amp; <span class="stri">" index checks suppressed"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> countOverflowChecks &lt;> 0 <span class="keywd">then</span>
              writeln(countOverflowChecks &lt;&amp; <span class="stri">" overflow checks inserted"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> countOptimizedOverflowChecks &lt;> 0 <span class="keywd">then</span>
              writeln(countOptimizedOverflowChecks &lt;&amp; <span class="stri">" overflow checks optimized away"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> countSuppressedOverflowChecks &lt;> 0 <span class="keywd">then</span>
              writeln(countSuppressedOverflowChecks &lt;&amp; <span class="stri">" overflow checks suppressed"</span>);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            write(<span class="stri">"*** Cannot open temp file "</span>);
            write(literal(temporaryFileName));
            writeln(<span class="stri">"."</span>);
            okay := FALSE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        writeln(<span class="stri">"*** main not found."</span>);
        okay := FALSE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: importEnvironment (<span class="op">in</span> <span class="type">string</span>: fileName) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> iniDataType: iniData <span class="keywd">is</span> iniDataType.value;
    <span class="keywd">var</span> <span class="type">string</span>: aKey <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: aValue <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    iniData := readIniFile(fileName);
    <span class="keywd">if</span> <span class="stri">""</span> <span class="op">in</span> iniData <span class="keywd">then</span>
      <span class="keywd">for</span> aValue <span class="keywd">key</span> aKey <span class="keywd">range</span> iniData[<span class="stri">""</span>] <span class="keywd">do</span>
        <span class="comment"># writeln(aKey &lt;&amp; "=" &lt;&amp; aValue);</span>
        setenv(aKey, aValue);
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">else</span>
      writeln(<span class="stri">"*** C compiler environment file "</span> &lt;&amp; literal(fileName) &lt;&amp; <span class="stri">" not found."</span>);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: appendLibrary (<span class="keywd">inout</span> <span class="type">array</span> <span class="type">string</span>: options, <span class="op">in</span> <span class="type">string</span>: libraryToAppend) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: existingOption <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: found <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> libraryToAppend &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      <span class="keywd">for</span> existingOption <span class="keywd">range</span> options <span class="keywd">until</span> found <span class="keywd">do</span>
        found := existingOption = libraryToAppend;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">if</span> <span class="op">not</span> found <span class="keywd">then</span>
        options &amp;:= libraryToAppend;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: appendLibrary (<span class="keywd">inout</span> <span class="type">array</span> <span class="type">string</span>: options, <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: librariesToAppend) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: libraryToAppend <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> libraryToAppend <span class="keywd">range</span> librariesToAppend <span class="keywd">do</span>
      appendLibrary(options, libraryToAppend);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: logProgram (<span class="op">in</span> <span class="type">string</span>: command, <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: parameters,
    <span class="op">in</span> <span class="type">string</span>: errorFile) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">begin</span>
    write(toShellPath(command) &lt;&amp; <span class="stri">" "</span> &lt;&amp; shellParameters(parameters));
    <span class="keywd">case</span> ccConf.CC_ERROR_FILEDES <span class="keywd">of</span>
      <span class="keywd">when</span> {1}:
        write(<span class="stri">" "</span> &lt;&amp; ccConf.REDIRECT_FILEDES_1 &lt;&amp; toShellPath(errorFile));
        write(<span class="stri">" "</span> &lt;&amp; ccConf.REDIRECT_FILEDES_2 &lt;&amp; ccConf.NULL_DEVICE);
      <span class="keywd">when</span> {2}:
        write(<span class="stri">" "</span> &lt;&amp; ccConf.REDIRECT_FILEDES_2 &lt;&amp; toShellPath(errorFile));
        write(<span class="stri">" "</span> &lt;&amp; ccConf.REDIRECT_FILEDES_1 &lt;&amp; ccConf.NULL_DEVICE);
    <span class="keywd">end</span> <span class="keywd">case</span>;
    writeln;
    flush(OUT);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: execProgramScript (<span class="op">in</span> <span class="type">string</span>: command, <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: parameters,
    <span class="op">in</span> <span class="type">string</span>: errorFile) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: redirection <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: shellResult <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    logProgram(command, parameters, errorFile);
    <span class="keywd">case</span> ccConf.CC_ERROR_FILEDES <span class="keywd">of</span>
      <span class="keywd">when</span> {1}:
        redirection &amp;:= ccConf.REDIRECT_FILEDES_1 &amp; toShellPath(errorFile);
        redirection &amp;:= ccConf.REDIRECT_FILEDES_2 &amp; ccConf.NULL_DEVICE;
      <span class="keywd">when</span> {2}:
        redirection &amp;:= ccConf.REDIRECT_FILEDES_2 &amp; toShellPath(errorFile);
        redirection &amp;:= ccConf.REDIRECT_FILEDES_1 &amp; ccConf.NULL_DEVICE;
    <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">if</span> length(redirection) = 0 <span class="keywd">then</span>
      <span class="comment"># An CC_ERROR_FILEDES of zero means: Do not redirect.</span>
      shellResult := shell(command, shellParameters(parameters));
    <span class="keywd">else</span>
      shellResult := shell(command, shellParameters(parameters) &lt;&amp; <span class="stri">" "</span> &lt;&amp;
                           join(redirection, <span class="stri">" "</span>));
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> shellResult &lt;> 0 <span class="keywd">then</span>
      writeln(<span class="stri">"*** The shell command returned "</span> &lt;&amp; shellResult);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: execProgram (<span class="op">in</span> <span class="type">string</span>: command, <span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: parameters,
    <span class="op">in</span> <span class="type">string</span>: errorFile) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">file</span>: childStdout <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">file</span>: childStderr <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">process</span>: aProcess <span class="keywd">is</span> process.value;
  <span class="keywd">begin</span>
    logProgram(command, parameters, errorFile);
    <span class="keywd">case</span> ccConf.CC_ERROR_FILEDES <span class="keywd">of</span>
      <span class="keywd">when</span> {1}:
        childStdout := open(errorFile, <span class="stri">"w"</span>);
        <span class="keywd">if</span> childStdout = STD_NULL <span class="keywd">then</span>
          writeln(<span class="stri">"*** Could not open "</span> &lt;&amp; errorFile);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">when</span> {2}:
        childStderr := open(errorFile, <span class="stri">"w"</span>);
        <span class="keywd">if</span> childStderr = STD_NULL <span class="keywd">then</span>
          writeln(<span class="stri">"*** Could not open "</span> &lt;&amp; errorFile);
        <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
    aProcess := startProcess(commandPath(command), parameters, STD_IN, childStdout, childStderr);
    waitFor(aProcess);
    <span class="keywd">case</span> ccConf.CC_ERROR_FILEDES <span class="keywd">of</span>
      <span class="keywd">when</span> {1}: close(childStdout);
      <span class="keywd">when</span> {2}: close(childStderr);
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: pass_3 (<span class="op">in</span> <span class="type">string</span>: sourcePath, <span class="op">in</span> <span class="type">string</span>: sourceExtension, <span class="op">in</span> <span class="type">program</span>: prog,
    <span class="op">in</span> <span class="type">optionHash</span>: compilerOptions, <span class="keywd">inout</span> <span class="type">boolean</span>: okay) <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: s7_lib_dir     <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: seed7_lib      <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: draw_lib       <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: console_lib    <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: database_lib   <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: comp_data_lib  <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: compiler_lib   <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: special_lib    <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: cwd            <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: workDir        <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: sourceFile     <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: cSourceFile    <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: cErrorFile     <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: objectFile     <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: linkErrFile    <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: tempExeFile    <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: linkedProgram  <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: compile_cmd    <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: compileParams <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: link_cmd       <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: linkParams <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> okay <span class="keywd">then</span>
      writeln(<span class="stri">"Calling the C compiler ..."</span>);
      <span class="keywd">if</span> ccConf.CC_ENVIRONMENT_INI &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        importEnvironment(ccConf.CC_ENVIRONMENT_INI);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> <span class="stri">"-b"</span> <span class="op">in</span> compilerOptions <span class="keywd">then</span>
        s7_lib_dir := convDosPath(compilerOptions[<span class="stri">"-b"</span>]);
      <span class="keywd">else</span>
        s7_lib_dir := ccConf.S7_LIB_DIR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      seed7_lib     := s7_lib_dir &amp; <span class="stri">"/"</span> &amp; ccConf.SEED7_LIB;
      draw_lib      := s7_lib_dir &amp; <span class="stri">"/"</span> &amp; ccConf.DRAW_LIB;
      console_lib   := s7_lib_dir &amp; <span class="stri">"/"</span> &amp; ccConf.CONSOLE_LIB;
      database_lib  := s7_lib_dir &amp; <span class="stri">"/"</span> &amp; ccConf.DATABASE_LIB;
      comp_data_lib := s7_lib_dir &amp; <span class="stri">"/"</span> &amp; ccConf.COMP_DATA_LIB;
      compiler_lib  := s7_lib_dir &amp; <span class="stri">"/"</span> &amp; ccConf.COMPILER_LIB;
      special_lib   := s7_lib_dir &amp; <span class="stri">"/"</span> &amp; ccConf.SPECIAL_LIB;
      cwd := getcwd();
      <span class="keywd">if</span> rpos(sourcePath, <span class="stri">"/"</span>) = 0 <span class="keywd">then</span>
        sourceFile := sourcePath;
      <span class="keywd">else</span>
        <span class="keywd">if</span> rpos(sourcePath, <span class="stri">"/"</span>) = 1 <span class="keywd">then</span>
          chdir(<span class="stri">"/"</span>);
        <span class="keywd">else</span>
          chdir(sourcePath[.. pred(rpos(sourcePath, <span class="stri">"/"</span>))]);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        workDir := sourcePath[.. rpos(sourcePath, <span class="stri">"/"</span>)];
        sourceFile := sourcePath[succ(rpos(sourcePath, <span class="stri">"/"</span>)) ..];
      <span class="keywd">end</span> <span class="keywd">if</span>;
      cSourceFile  := <span class="stri">"tmp_"</span> &amp; sourceFile;
      <span class="keywd">if</span> generate_c_plus_plus <span class="keywd">then</span>
        cSourceFile  &amp;:= <span class="stri">".cpp"</span>;
      <span class="keywd">else</span>
        cSourceFile  &amp;:= <span class="stri">".c"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      cErrorFile     := <span class="stri">"tmp_"</span> &amp; sourceFile &amp; <span class="stri">".cerrs"</span>;
      objectFile     := <span class="stri">"tmp_"</span> &amp; sourceFile &amp; ccConf.OBJECT_FILE_EXTENSION;
      linkErrFile    := <span class="stri">"tmp_"</span> &amp; sourceFile &amp; <span class="stri">".lerrs"</span>;
      tempExeFile    := <span class="stri">"tmp_"</span> &amp; sourceFile &amp; ccConf.LINKED_PROGRAM_EXTENSION;
      <span class="keywd">if</span> sourceExtension = <span class="stri">""</span> <span class="op">and</span> ccConf.LINKED_PROGRAM_EXTENSION = <span class="stri">""</span> <span class="keywd">then</span>
        linkedProgram :=         sourceFile &amp; <span class="stri">"_exe"</span>;
      <span class="keywd">else</span>
        linkedProgram :=         sourceFile &amp; ccConf.LINKED_PROGRAM_EXTENSION;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> fileType(objectFile) = FILE_REGULAR <span class="keywd">then</span>
        removeFile(objectFile);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> generate_c_plus_plus <span class="keywd">then</span>
        compile_cmd := ccConf.CPLUSPLUS_COMPILER;
      <span class="keywd">else</span>
        compile_cmd := ccConf.C_COMPILER;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      compileParams &amp;:= ccConf.CC_OPT_NO_WARNINGS;
      <span class="keywd">if</span> enable_link_time_optimization <span class="keywd">then</span>
        compileParams &amp;:= ccConf.CC_OPT_LINK_TIME_OPTIMIZATION;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> <span class="stri">"-O"</span> <span class="op">in</span> compilerOptions <span class="keywd">then</span>
        <span class="keywd">case</span> compilerOptions[<span class="stri">"-O"</span>] <span class="keywd">of</span>
          <span class="keywd">when</span> {<span class="stri">""</span>, <span class="stri">"1"</span>}:
            compileParams &amp;:= ccConf.CC_OPT_OPTIMIZE_1;
          <span class="keywd">when</span> {<span class="stri">"2"</span>}:
            compileParams &amp;:= ccConf.CC_OPT_OPTIMIZE_2;
          <span class="keywd">when</span> {<span class="stri">"3"</span>}:
            compileParams &amp;:= ccConf.CC_OPT_OPTIMIZE_3;
          <span class="keywd">otherwise</span>:
            writeln(<span class="stri">"*** Ignore unsupported option: -O"</span> &lt;&amp; compilerOptions[<span class="stri">"-O"</span>]);
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> integer_overflow_check <span class="op">and</span> ccConf.CC_OPT_TRAP_OVERFLOW &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        compileParams &amp;:= ccConf.CC_OPT_TRAP_OVERFLOW;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> <span class="stri">"-g"</span> <span class="op">in</span> compilerOptions <span class="keywd">then</span>
        compileParams &amp;:= ccConf.CC_OPT_DEBUG_INFO;
        <span class="keywd">if</span> compilerOptions[<span class="stri">"-g"</span>] &lt;> <span class="stri">""</span> <span class="op">and</span> compilerOptions[<span class="stri">"-g"</span>] &lt;> <span class="stri">"-debug_c"</span> <span class="keywd">then</span>
          compileParams &amp;:= compilerOptions[<span class="stri">"-g"</span>];
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> length(ccConf.CC_FLAGS) &lt;> 0 <span class="keywd">then</span>
        compileParams &amp;:= ccConf.CC_FLAGS;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      compileParams &amp;:= <span class="stri">"-c"</span>;
      compileParams &amp;:= toOsPath(cSourceFile);
      <span class="keywd">if</span> ccConf.CALL_C_COMPILER_FROM_SHELL <span class="keywd">then</span>
        execProgramScript(compile_cmd, compileParams, cErrorFile);
      <span class="keywd">else</span>
        execProgram(compile_cmd, compileParams, cErrorFile);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> fileType(cErrorFile) = FILE_REGULAR <span class="op">and</span>
          fileSize(cErrorFile) = 0 <span class="keywd">then</span>
        removeFile(cErrorFile);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> fileType(objectFile) &lt;> FILE_REGULAR <span class="keywd">then</span>
        <span class="keywd">if</span> fileType(cErrorFile) = FILE_REGULAR <span class="keywd">then</span>
          writeln(<span class="stri">"*** Errors in "</span> &lt;&amp; literal(workDir &amp; cSourceFile) &lt;&amp;
              <span class="stri">" - see "</span> &lt;&amp; literal(workDir &amp; cErrorFile));
        <span class="keywd">elsif</span> ccConf.CC_ERROR_FILEDES <span class="op">not</span> <span class="op">in</span> {1, 2} <span class="keywd">then</span>
          writeln(<span class="stri">"*** Compilation terminated"</span>);
        <span class="keywd">else</span>
          writeln(<span class="stri">"*** Compilation terminated without error messages"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        okay := FALSE;
      <span class="keywd">elsif</span> fileType(cErrorFile) = FILE_REGULAR <span class="keywd">then</span>
        removeFile(cErrorFile);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> okay <span class="keywd">then</span>
        <span class="keywd">if</span> <span class="stri">"-g"</span> <span class="op">not</span> <span class="op">in</span> compilerOptions <span class="keywd">then</span>
          removeFile(cSourceFile);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> compilerLibraryUsed <span class="keywd">then</span>
          drawLibraryUsed := TRUE;
          mathLibraryUsed := TRUE;
          consoleLibraryUsed := TRUE;
          databaseLibraryUsed := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> fileType(seed7_lib) &lt;> FILE_REGULAR <span class="keywd">then</span>
          writeln(<span class="stri">"*** Seed7 library "</span> &lt;&amp; literal(seed7_lib) &lt;&amp; <span class="stri">" missing"</span>);
          okay := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> drawLibraryUsed <span class="op">and</span> fileType(draw_lib) &lt;> FILE_REGULAR <span class="keywd">then</span>
          writeln(<span class="stri">"*** Draw library "</span> &lt;&amp; literal(draw_lib) &lt;&amp; <span class="stri">" missing"</span>);
          okay := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> consoleLibraryUsed <span class="op">and</span> fileType(console_lib) &lt;> FILE_REGULAR <span class="keywd">then</span>
          writeln(<span class="stri">"*** Console library "</span> &lt;&amp; literal(console_lib) &lt;&amp; <span class="stri">" missing"</span>);
          okay := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> databaseLibraryUsed <span class="op">and</span> fileType(database_lib) &lt;> FILE_REGULAR <span class="keywd">then</span>
          writeln(<span class="stri">"*** Database library "</span> &lt;&amp; literal(database_lib) &lt;&amp; <span class="stri">" missing"</span>);
          okay := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> compilerLibraryUsed <span class="op">and</span> fileType(compiler_lib) &lt;> FILE_REGULAR <span class="keywd">then</span>
          writeln(<span class="stri">"*** Compiler library "</span> &lt;&amp; literal(compiler_lib) &lt;&amp; <span class="stri">" missing"</span>);
          okay := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> compDataLibraryUsed <span class="op">and</span> fileType(comp_data_lib) &lt;> FILE_REGULAR <span class="keywd">then</span>
          writeln(<span class="stri">"*** Compiler data library "</span> &lt;&amp; literal(comp_data_lib) &lt;&amp; <span class="stri">" missing"</span>);
          okay := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> ccConf.LINKER_OPT_SPECIAL_LIB &lt;> <span class="stri">""</span> <span class="op">and</span> fileType(special_lib) &lt;> FILE_REGULAR <span class="keywd">then</span>
          writeln(<span class="stri">"*** Special library "</span> &lt;&amp; literal(compiler_lib) &lt;&amp; <span class="stri">" missing"</span>);
          okay := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> okay <span class="op">and</span> <span class="op">not</span> compileLibrary <span class="keywd">then</span>
          <span class="keywd">if</span> fileType(linkedProgram) = FILE_REGULAR <span class="keywd">then</span>
            <span class="keywd">block</span>
              removeFile(linkedProgram);
            exception
              catch FILE_ERROR:
                writeln(<span class="stri">"*** Cannot remove old executable: "</span> &lt;&amp;
                    literal(linkedProgram));
            <span class="keywd">end</span> <span class="keywd">block</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> fileType(linkedProgram) = FILE_ABSENT <span class="keywd">then</span>
            writeln(<span class="stri">"Calling the linker ..."</span>);
            <span class="keywd">if</span> generate_c_plus_plus <span class="keywd">then</span>
              link_cmd := ccConf.CPLUSPLUS_COMPILER;
            <span class="keywd">else</span>
              link_cmd := ccConf.C_COMPILER;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> enable_link_time_optimization <span class="op">or</span> ccConf.LINKER_OPT_LTO_MANDATORY <span class="keywd">then</span>
              linkParams &amp;:= ccConf.CC_OPT_LINK_TIME_OPTIMIZATION;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> <span class="stri">"-g"</span> <span class="op">in</span> compilerOptions <span class="keywd">then</span>
              <span class="keywd">if</span> ccConf.LINKER_OPT_DEBUG_INFO &lt;> <span class="stri">""</span> <span class="keywd">then</span>
                linkParams &amp;:= ccConf.LINKER_OPT_DEBUG_INFO;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">else</span>
              <span class="keywd">if</span> ccConf.LINKER_OPT_NO_DEBUG_INFO &lt;> <span class="stri">""</span> <span class="keywd">then</span>
                linkParams &amp;:= ccConf.LINKER_OPT_NO_DEBUG_INFO;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> ccConf.LINKER_OPT_STACK_SIZE &lt;> <span class="stri">""</span> <span class="keywd">then</span>
              linkParams &amp;:= ccConf.LINKER_OPT_STACK_SIZE &lt;&amp; stack_size;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            linkParams &amp;:= ccConf.LINKER_FLAGS;
            <span class="keywd">if</span> ccConf.LINKER_OPT_OUTPUT_FILE &lt;> <span class="stri">""</span> <span class="keywd">then</span>
              <span class="keywd">if</span> endsWith(ccConf.LINKER_OPT_OUTPUT_FILE, <span class="stri">" "</span>) <span class="keywd">then</span>
                linkParams &amp;:= rtrim(ccConf.LINKER_OPT_OUTPUT_FILE);
                linkParams &amp;:= toOsPath(linkedProgram);
              <span class="keywd">else</span>
                linkParams &amp;:= ccConf.LINKER_OPT_OUTPUT_FILE &amp;
                               toOsPath(linkedProgram);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
            linkParams &amp;:= toOsPath(objectFile);
            <span class="keywd">if</span> compilerLibraryUsed <span class="keywd">then</span>
              appendLibrary(linkParams, toOsPath(compiler_lib));
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> compDataLibraryUsed <span class="keywd">then</span>
              appendLibrary(linkParams, toOsPath(comp_data_lib));
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> drawLibraryUsed <span class="keywd">then</span>
              appendLibrary(linkParams, toOsPath(draw_lib));
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> consoleLibraryUsed <span class="keywd">then</span>
              appendLibrary(linkParams, toOsPath(console_lib));
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> databaseLibraryUsed <span class="keywd">then</span>
              appendLibrary(linkParams, toOsPath(database_lib));
            <span class="keywd">end</span> <span class="keywd">if</span>;
            appendLibrary(linkParams, toOsPath(seed7_lib));
            <span class="keywd">if</span> ccConf.LINKER_OPT_SPECIAL_LIB &lt;> <span class="stri">""</span> <span class="keywd">then</span>
              appendLibrary(linkParams, ccConf.LINKER_OPT_SPECIAL_LIB);
              appendLibrary(linkParams, toOsPath(special_lib));
            <span class="keywd">end</span> <span class="keywd">if</span>;
            appendLibrary(linkParams, ccConf.SYSTEM_LIBS);
            <span class="keywd">if</span> bigintLibraryUsed <span class="keywd">then</span>
              appendLibrary(linkParams, ccConf.SYSTEM_BIGINT_LIBS);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> consoleLibraryUsed <span class="keywd">then</span>
              appendLibrary(linkParams, ccConf.SYSTEM_CONSOLE_LIBS);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> databaseLibraryUsed <span class="keywd">then</span>
              appendLibrary(linkParams, ccConf.SYSTEM_DATABASE_LIBS);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> drawLibraryUsed <span class="keywd">then</span>
              appendLibrary(linkParams, ccConf.SYSTEM_DRAW_LIBS);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> mathLibraryUsed <span class="keywd">then</span>
              appendLibrary(linkParams, ccConf.SYSTEM_MATH_LIBS);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> ccConf.CALL_C_COMPILER_FROM_SHELL <span class="keywd">then</span>
              execProgramScript(link_cmd, linkParams, linkErrFile);
            <span class="keywd">else</span>
              execProgram(link_cmd, linkParams, linkErrFile);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> ccConf.LINKER_OPT_OUTPUT_FILE = <span class="stri">""</span> <span class="op">and</span>
                fileType(tempExeFile) = FILE_REGULAR <span class="keywd">then</span>
              moveFile(tempExeFile, linkedProgram);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> fileType(linkedProgram) &lt;> FILE_REGULAR <span class="keywd">then</span>
              <span class="keywd">if</span> fileType(linkErrFile) = FILE_REGULAR <span class="op">and</span>
                  fileSize(linkErrFile) = 0 <span class="keywd">then</span>
                removeFile(linkErrFile);
              <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">if</span> fileType(linkErrFile) = FILE_REGULAR <span class="keywd">then</span>
                writeln(<span class="stri">"*** Linker errors with "</span> &lt;&amp; literal(workDir &amp; objectFile) &lt;&amp;
                    <span class="stri">" - see "</span> &lt;&amp; literal(workDir &amp; linkErrFile));
              <span class="keywd">elsif</span> ccConf.CC_ERROR_FILEDES <span class="op">not</span> <span class="op">in</span> {1, 2} <span class="keywd">then</span>
                writeln(<span class="stri">"*** Linking terminated"</span>);
              <span class="keywd">else</span>
                writeln(<span class="stri">"*** Linking terminated without error messages"</span>);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">elsif</span> fileType(linkErrFile) = FILE_REGULAR <span class="keywd">then</span>
              removeFile(linkErrFile);
            <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">if</span> <span class="stri">"-g"</span> <span class="op">not</span> <span class="op">in</span> compilerOptions <span class="keywd">then</span>
              removeFile(objectFile);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      chdir(cwd);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: writeHelp <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"usage: s7c [options] source"</span>);
    writeln;
    writeln(<span class="stri">"Options:"</span>);
    writeln(<span class="stri">"  -?   Write Seed7 compiler usage."</span>);
    writeln(<span class="stri">"  -On  Tell the C compiler to optimize with level n (n is between 1 and 3)."</span>);
    writeln(<span class="stri">"  -O   Equivalent to -O1"</span>);
    writeln(<span class="stri">"  -S   Specify the stack size of the executable (e.g.: -S 16777216)."</span>);
    writeln(<span class="stri">"  -b   Specify the directory of the Seed7 runtime libraries (e.g.: -b ../bin)."</span>);
    writeln(<span class="stri">"  -c   Specify configuration (C compiler, etc.) to be used (e.g.: -c emcc)."</span>);
    writeln(<span class="stri">"  -e   Generate code which sends a signal, if an uncaught exception occurs."</span>);
    writeln(<span class="stri">"       This option allows debuggers to handle uncaught Seed7 exceptions."</span>);
    writeln(<span class="stri">"  -flto Enable link time optimization."</span>);
    writeln(<span class="stri">"  -g   Tell the C compiler to generate an executable with debug information."</span>);
    writeln(<span class="stri">"       This way the debugger will refer to Seed7 source files and line numbers."</span>);
    writeln(<span class="stri">"       To generate debug information which refers to the temporary C program"</span>);
    writeln(<span class="stri">"       the option -g-debug_c can be used."</span>);
    writeln(<span class="stri">"  -l   Add a directory to the include library search path (e.g.: -l ../lib)."</span>);
    writeln(<span class="stri">"  -ocn Optimize generated C code with level n. E.g.: -oc3"</span>);
    writeln(<span class="stri">"       The level n is a digit between 0 and 3:"</span>);
    writeln(<span class="stri">"         0 Do no optimizations with constants."</span>);
    writeln(<span class="stri">"         1 Use literals and named constants to simplify expressions (default)."</span>);
    writeln(<span class="stri">"         2 Evaluate constant parameter expressions to simplify expressions."</span>);
    writeln(<span class="stri">"         3 Like -oc2 and additionally evaluate all constant expressions."</span>);
    writeln(<span class="stri">"  -p   Activate simple function profiling."</span>);
    writeln(<span class="stri">"  -sx  Suppress checks specified with x. E.g.: -sr or -sro"</span>);
    writeln(<span class="stri">"       The checks x are specified with letters from the following list:"</span>);
    writeln(<span class="stri">"         d Suppress the generation of checks for integer division by zero."</span>);
    writeln(<span class="stri">"         i Suppress the generation of index checks (e.g. string, array)."</span>);
    writeln(<span class="stri">"         o Suppress the generation of integer overflow checks."</span>);
    writeln(<span class="stri">"         r Suppress the generation of range checks."</span>);
    writeln(<span class="stri">"  -tx  Set runtime trace level to x. Where x is a string consisting of:"</span>);
    writeln(<span class="stri">"         d Trace dynamic calls"</span>);
    writeln(<span class="stri">"         e Trace exceptions and handlers"</span>);
    writeln(<span class="stri">"         f Trace functions"</span>);
    writeln(<span class="stri">"         s Trace signals"</span>);
    writeln(<span class="stri">"  -wn  Specify warning level n. E.g.: -w2"</span>);
    writeln(<span class="stri">"       The level n is a digit between 0 and 2:"</span>);
    writeln(<span class="stri">"         0 Omit warnings."</span>);
    writeln(<span class="stri">"         1 Write normal warnings (default)."</span>);
    writeln(<span class="stri">"         2 Write warnings for raised exceptions."</span>);
    writeln;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is</span> <span class="keywd">func</span>

  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: currArg <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">optionHash</span>: compilerOptions <span class="keywd">is</span> optionHash.value;
    <span class="keywd">var</span> <span class="type">string</span>: source <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: sourcePath <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">string</span>: sourceExtension <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> TRUE;

  <span class="keywd">begin</span>
    OUT := STD_UTF8_OUT;
    writeln(<span class="stri">"SEED7 COMPILER Version 3.2."</span> &lt;&amp; ccConf.VERSION_REVISION_LEVEL &lt;&amp;
            <span class="stri">" Copyright (c) 1990-2024 Thomas Mertes"</span>);
    <span class="keywd">if</span> length(argv(PROGRAM)) = 0 <span class="keywd">then</span>
      writeln(<span class="stri">"This is free software; see the source for copying conditions.  There is NO"</span>);
      writeln(<span class="stri">"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."</span>);
      writeln(<span class="stri">"S7c is written in the Seed7 programming language"</span>);
      writeln(<span class="stri">"Homepage: http://seed7.sourceforge.net"</span>);
      writeln;
      writeln(<span class="stri">"usage: s7c [options] source"</span>);
      writeln;
      writeln(<span class="stri">"Use  s7c -?  to get more information about s7c."</span>);
      writeln;
    <span class="keywd">else</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length(argv(PROGRAM)) <span class="keywd">do</span>
        currArg := argv(PROGRAM)[index];
        <span class="keywd">if</span> length(currArg) >= 2 <span class="op">and</span> currArg[1] = <span class="stri">'-'</span> <span class="keywd">then</span>
          <span class="keywd">if</span> currArg <span class="op">in</span> {<span class="stri">"-b"</span>, <span class="stri">"-c"</span>, <span class="stri">"-S"</span>} <span class="op">and</span> index &lt; length(argv(PROGRAM)) <span class="keywd">then</span>
            incr(index);
            compilerOptions @:= [currArg] argv(PROGRAM)[index];
          <span class="keywd">elsif</span> currArg <span class="op">in</span> {<span class="stri">"-l"</span>} <span class="op">and</span> index &lt; length(argv(PROGRAM)) <span class="keywd">then</span>
            incr(index);
            libraryDirs &amp;:= convDosPath(argv(PROGRAM)[index]);
          <span class="keywd">elsif</span> currArg[.. 2] <span class="op">in</span> {<span class="stri">"-?"</span>, <span class="stri">"-b"</span>, <span class="stri">"-c"</span>, <span class="stri">"-e"</span>, <span class="stri">"-f"</span>, <span class="stri">"-g"</span>, <span class="stri">"-o"</span>, <span class="stri">"-p"</span>, <span class="stri">"-s"</span>, <span class="stri">"-t"</span>, <span class="stri">"-w"</span>, <span class="stri">"-O"</span>, <span class="stri">"-S"</span>} <span class="keywd">then</span>
            <span class="keywd">if</span> currArg[.. 2] <span class="op">in</span> compilerOptions <span class="keywd">then</span>
              <span class="keywd">if</span> currArg[3 ..] = compilerOptions[currArg[.. 2]] <span class="keywd">then</span>
                writeln(<span class="stri">"*** Option "</span> &lt;&amp; currArg &lt;&amp; <span class="stri">" specified twice."</span>);
              <span class="keywd">else</span>
                writeln(<span class="stri">"*** Option "</span> &lt;&amp; currArg[.. 2] &lt;&amp; <span class="stri">" specified twice."</span>);
              <span class="keywd">end</span> <span class="keywd">if</span>;
              okay := FALSE;
            <span class="keywd">elsif</span> currArg[.. 2] <span class="op">in</span> {<span class="stri">"-?"</span>, <span class="stri">"-e"</span>, <span class="stri">"-p"</span>} <span class="op">and</span> currArg[3 ..] &lt;> <span class="stri">""</span> <span class="keywd">then</span>
              writeln(<span class="stri">"*** Unsupported option: "</span> &lt;&amp; currArg);
              okay := FALSE;
            <span class="keywd">else</span>
              compilerOptions @:= [currArg[.. 2]] currArg[3 ..];
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            writeln(<span class="stri">"*** Unsupported option: "</span> &lt;&amp; currArg);
            okay := FALSE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> source = <span class="stri">""</span> <span class="keywd">then</span>
          source := convDosPath(currArg);
        <span class="keywd">else</span>
          writeln(<span class="stri">"*** Superfluous parameter: "</span> &lt;&amp; currArg);
          okay := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">if</span> <span class="stri">"-?"</span> <span class="op">in</span> compilerOptions <span class="keywd">then</span>
        writeHelp;
      <span class="keywd">else</span>
        pass_1(source, prog, compilerOptions, okay);
        <span class="keywd">if</span> okay <span class="keywd">then</span>
          sourcePath := path(prog);
          <span class="keywd">if</span>  endsWith(sourcePath, <span class="stri">".sd7"</span>) <span class="op">or</span>
              endsWith(sourcePath, <span class="stri">".s7i"</span>) <span class="keywd">then</span>
            sourceExtension := sourcePath[length(sourcePath) - 3 ..];
            sourcePath := sourcePath[.. length(sourcePath) - 4];
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        pass_2(sourcePath, prog, okay);
        pass_3(sourcePath, sourceExtension, prog, compilerOptions, okay);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
