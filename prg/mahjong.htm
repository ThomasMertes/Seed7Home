<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  mahjong.sd7   Mahjong solitaire game                            *)</span>
<span class="comment">(*  Copyright (C) 2007  Thomas Mertes                               *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/seed7_05.htm">seed7_05.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/float.htm">float.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/draw.htm">draw.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/keybd.htm">keybd.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/dialog.htm">dialog.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/time.htm">time.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/mahjng32.htm">mahjng32.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/duration.htm">duration.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/text.htm">text.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/vecfont10.htm">vecfont10.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/pixmap_file.htm">pixmap_file.s7i</a>"</span>;


<span class="keywd">var</span> <span class="type">text</span>: screen <span class="keywd">is</span> STD_NULL;

<span class="keywd">const</span> <span class="type">integer</span>: WINDOW_WIDTH <span class="keywd">is</span> 1016;
<span class="keywd">const</span> <span class="type">integer</span>: WINDOW_HEIGHT <span class="keywd">is</span> 704;
<span class="keywd">const</span> <span class="type">integer</span>: UPPER_BORDER <span class="keywd">is</span> 46;
<span class="keywd">const</span> <span class="type">integer</span>: LEFT_BORDER <span class="keywd">is</span> 24;
<span class="keywd">const</span> <span class="type">integer</span>: MENUE_BAR_HEIGHT <span class="keywd">is</span> 18;
<span class="keywd">const</span> <span class="type">integer</span>: PIXMAP_WIDTH <span class="keywd">is</span> 48;
<span class="keywd">const</span> <span class="type">integer</span>: PIXMAP_HEIGHT <span class="keywd">is</span> 64;
<span class="keywd">const</span> <span class="type">integer</span>: TILE_BORDER <span class="keywd">is</span> 8;
<span class="keywd">const</span> <span class="type">integer</span>: TILE_WIDTH <span class="keywd">is</span> PIXMAP_WIDTH + 2 * TILE_BORDER;
<span class="keywd">const</span> <span class="type">integer</span>: TILE_HEIGHT <span class="keywd">is</span> PIXMAP_HEIGHT + 2 * TILE_BORDER;
<span class="keywd">const</span> <span class="type">integer</span>: FIELD_X_STEP <span class="keywd">is</span> TILE_WIDTH <span class="op">div</span> 2;
<span class="keywd">const</span> <span class="type">integer</span>: FIELD_Y_STEP <span class="keywd">is</span> TILE_HEIGHT <span class="op">div</span> 2;
<span class="keywd">const</span> <span class="type">integer</span>: HALF_FIELD <span class="keywd">is</span> FIELD_Y_STEP <span class="op">div</span> 2;
<span class="keywd">const</span> <span class="type">integer</span>: FRAME_THICKNESS <span class="keywd">is</span> 5;
<span class="keywd">const</span> <span class="type">integer</span>: MARK_THICKNESS <span class="keywd">is</span> 7;
<span class="keywd">const</span> <span class="type">integer</span>: FIELD_LINES <span class="keywd">is</span> 15;
<span class="keywd">const</span> <span class="type">integer</span>: FIELD_COLUMNS <span class="keywd">is</span> 29;
<span class="keywd">const</span> <span class="type">integer</span>: COMPUTER_HIT_XPOS <span class="keywd">is</span> 8;
<span class="keywd">const</span> <span class="type">integer</span>: PLAYER_HIT_XPOS <span class="keywd">is</span> UPPER_BORDER + FIELD_LINES * FIELD_X_STEP + FIELD_X_STEP + 8;
<span class="keywd">const</span> <span class="type">integer</span>: SHIFT_X <span class="keywd">is</span> 10;
<span class="keywd">const</span> <span class="type">integer</span>: SHIFT_Y <span class="keywd">is</span> 10;
<span class="keywd">const</span> <span class="type">color</span>: BACKGROUND <span class="keywd">is</span> light_blue;
<span class="keywd">const</span> <span class="type">color</span>: leftSideColor <span class="keywd">is</span> gray(49152); <span class="comment"># was: 57344</span>
<span class="keywd">const</span> <span class="type">color</span>: nearSideColor <span class="keywd">is</span> gray(40960); <span class="comment"># was: 49152</span>
<span class="keywd">const</span> <span class="type">color</span>: leftEdgeColor <span class="keywd">is</span> gray(32768); <span class="comment"># was: 40960</span>
<span class="keywd">const</span> <span class="type">color</span>: nearEdgeColor <span class="keywd">is</span> gray(24576); <span class="comment"># was: 32768</span>


<span class="comment">(**
 *  Return an array of colors between 'first' and 'second'.
 *  The returned array has the specified 'length'. The colors 'first'
 *  and 'second' are not part of the array.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">color</span>: colorScale (<span class="op">in</span> <span class="type">color</span>: first, <span class="op">in</span> <span class="type">color</span>: second,
    <span class="op">in</span> <span class="type">integer</span>: length) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">color</span>: colorScale <span class="keywd">is</span> 0 <span class="op">times</span> color.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: red_delta <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: green_delta <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: blue_delta <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    colorScale := length <span class="op">times</span> color.value;
    red_delta   := (second.redLight   - first.redLight)   <span class="op">div</span> succ(length);
    green_delta := (second.greenLight - first.greenLight) <span class="op">div</span> succ(length);
    blue_delta  := (second.blueLight  - first.blueLight)  <span class="op">div</span> succ(length);
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> length <span class="keywd">do</span>
      colorScale[number].redLight   := first.redLight   + number * red_delta;
      colorScale[number].greenLight := first.greenLight + number * green_delta;
      colorScale[number].blueLight  := first.blueLight  + number * blue_delta;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">array</span> <span class="type">color</span>: leftFrameColor  <span class="keywd">is</span> colorScale(leftSideColor, white, FRAME_THICKNESS);
<span class="keywd">const</span> <span class="type">array</span> <span class="type">color</span>: rightFrameColor <span class="keywd">is</span> colorScale(leftEdgeColor, white, FRAME_THICKNESS);
<span class="keywd">const</span> <span class="type">array</span> <span class="type">color</span>: nearFrameColor  <span class="keywd">is</span> colorScale(nearSideColor, white, FRAME_THICKNESS);
<span class="keywd">const</span> <span class="type">array</span> <span class="type">color</span>: farFrameColor   <span class="keywd">is</span> colorScale(nearEdgeColor, white, FRAME_THICKNESS);

<span class="keywd">const</span> <span class="type">array</span> <span class="type">color</span>: nearLeftEdgeColor <span class="keywd">is</span> colorScale(nearSideColor, leftSideColor, 3);

<span class="keywd">const</span> <span class="type">color</span>: nearRightEdgeColor <span class="keywd">is</span> colorScale(leftEdgeColor, nearSideColor, 1)[1];
<span class="keywd">const</span> <span class="type">color</span>: farLeftEdgeColor   <span class="keywd">is</span> colorScale(nearEdgeColor, leftSideColor, 1)[1];

<span class="keywd">var</span> <span class="type">array</span> <span class="type">PRIMITIVE_WINDOW</span>: digit_pixmap <span class="keywd">is</span> 0 <span class="op">times</span> PRIMITIVE_WINDOW.value;

<span class="keywd">const</span> <span class="type">type</span>: tileType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">string</span>: pattern <span class="keywd">is</span> 0 <span class="op">times</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: pixmap <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
    <span class="keywd">var</span> <span class="type">integer</span>: value <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: quantity <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: fieldType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: used <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: present <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: selected <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: backup <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
    <span class="keywd">var</span> <span class="type">integer</span>: tileNumber <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: positionType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: level <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: moveType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">positionType</span>: pos1 <span class="keywd">is</span> positionType.value;
    <span class="keywd">var</span> <span class="type">positionType</span>: pos2 <span class="keywd">is</span> positionType.value;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: layoutType <span class="keywd">is</span> <span class="type">array</span> <span class="type">array</span> string;

<span class="keywd">var</span> <span class="type">array</span> <span class="type">array</span> <span class="type">array</span> <span class="type">fieldType</span>: field <span class="keywd">is</span> 0 <span class="op">times</span> 0 <span class="op">times</span> 0 <span class="op">times</span> fieldType.value;
<span class="keywd">var</span> <span class="type">array</span> <span class="type">moveType</span>: demoMoves <span class="keywd">is</span> 0 <span class="op">times</span> moveType.value;
<span class="keywd">var</span> <span class="type">array</span> <span class="type">moveType</span>: playerMoves <span class="keywd">is</span> 0 <span class="op">times</span> moveType.value;
<span class="keywd">var</span> <span class="type">integer</span>: moveNumber <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">boolean</span>: doQuit <span class="keywd">is</span> FALSE;


<span class="keywd">var</span> <span class="type">layoutType</span>: welcomeLayout <span class="keywd">is</span> [](

 [](<span class="stri">"   X     X     X     X   X   "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"   X X X X   X   X   X   X   "</span>,
    <span class="stri">"                       X     "</span>,
    <span class="stri">"               X             "</span>,
    <span class="stri">"   X     X   X   X   X   X   "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"    X    X X    X   X    X   "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"    X   X   X   X       X    "</span>,
    <span class="stri">"X                 X X        "</span>,
    <span class="stri">"        X   X           X   X"</span>,
    <span class="stri">" X X      X     X   X     X  "</span>),

 [](<span class="stri">"                             "</span>,
    <span class="stri">"    X   X     X X    X   X   "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"      X                X     "</span>,
    <span class="stri">"   X     X   X   X   X   X   "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"   X      X               X  "</span>,
    <span class="stri">"        X   X           X    "</span>,
    <span class="stri">"    X            X  X        "</span>,
    <span class="stri">"        X   X           X   X"</span>,
    <span class="stri">"X   X           X  X         "</span>,
    <span class="stri">"  X      X X             X X "</span>));


<span class="keywd">var</span> <span class="type">layoutType</span>: turtleLayout <span class="keywd">is</span> [](

 [](<span class="stri">"  X X X X X X X X X X X X    "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"      X X X X X X X X        "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"    X X X X X X X X X X      "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"  X X X X X X X X X X X X    "</span>,
    <span class="stri">"X                         X X"</span>,
    <span class="stri">"  X X X X X X X X X X X X    "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"    X X X X X X X X X X      "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"      X X X X X X X X        "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"  X X X X X X X X X X X X    "</span>),

 [](<span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"        X X X X X X          "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"        X X X X X X          "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"        X X X X X X          "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"        X X X X X X          "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"        X X X X X X          "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"        X X X X X X          "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>),

 [](<span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"          X X X X            "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"          X X X X            "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"          X X X X            "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"          X X X X            "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>),

 [](<span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"            X X              "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"            X X              "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>),

 [](<span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"             X               "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>,
    <span class="stri">"                             "</span>));


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: zero <span class="keywd">is</span> [](
  <span class="stri">"                "</span>,
  <span class="stri">"                "</span>,
  <span class="stri">"   xBBBBBBBBBc  "</span>,
  <span class="stri">"  xBBc     xBBc "</span>,
  <span class="stri">"  xBc       xBc "</span>,
  <span class="stri">"  xBc       xBc "</span>,
  <span class="stri">"  xBc       xBc "</span>,
  <span class="stri">"  xBc       xBc "</span>,
  <span class="stri">"  xBc     xBBBc "</span>,
  <span class="stri">"  xBc    xBBBBc "</span>,
  <span class="stri">"  xBc    xBBBBc "</span>,
  <span class="stri">"  xBc    xBBBBc "</span>,
  <span class="stri">"  xBc    xBBBBc "</span>,
  <span class="stri">"  xBBc   xBBBBc "</span>,
  <span class="stri">"   xBBBBBBBBBc  "</span>,
  <span class="stri">"                "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: one <span class="keywd">is</span> [](
  <span class="stri">"                "</span>,
  <span class="stri">"                "</span>,
  <span class="stri">"     xBBBBc     "</span>,
  <span class="stri">"        xBc     "</span>,
  <span class="stri">"        xBc     "</span>,
  <span class="stri">"        xBc     "</span>,
  <span class="stri">"        xBc     "</span>,
  <span class="stri">"        xBc     "</span>,
  <span class="stri">"      xBBBc     "</span>,
  <span class="stri">"     xBBBBc     "</span>,
  <span class="stri">"     xBBBBc     "</span>,
  <span class="stri">"     xBBBBc     "</span>,
  <span class="stri">"     xBBBBc     "</span>,
  <span class="stri">"     xBBBBc     "</span>,
  <span class="stri">"  xBBBBBBBBBBc  "</span>,
  <span class="stri">"                "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: two <span class="keywd">is</span> [](
  <span class="stri">"                "</span>,
  <span class="stri">"                "</span>,
  <span class="stri">"   xBBBBBBBBBc  "</span>,
  <span class="stri">"  xBBc     xBBc "</span>,
  <span class="stri">"  xBc       xBc "</span>,
  <span class="stri">"            xBc "</span>,
  <span class="stri">"            xBc "</span>,
  <span class="stri">"            xBc "</span>,
  <span class="stri">"   xBBBBBBBBBc  "</span>,
  <span class="stri">"  xBBBBc        "</span>,
  <span class="stri">"  xBBBBc        "</span>,
  <span class="stri">"  xBBBBc        "</span>,
  <span class="stri">"  xBBBBc        "</span>,
  <span class="stri">"  xBBBBc        "</span>,
  <span class="stri">"  xBBBBBBBBBBBc "</span>,
  <span class="stri">"                "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: three <span class="keywd">is</span> [](
  <span class="stri">"                "</span>,
  <span class="stri">"                "</span>,
  <span class="stri">"   xBBBBBBBBBc  "</span>,
  <span class="stri">"  xBBc     xBBc "</span>,
  <span class="stri">"  xBc       xBc "</span>,
  <span class="stri">"            xBc "</span>,
  <span class="stri">"            xBc "</span>,
  <span class="stri">"            xBc "</span>,
  <span class="stri">"   xBBBBBBBBBc  "</span>,
  <span class="stri">"         xBBBBc "</span>,
  <span class="stri">"         xBBBBc "</span>,
  <span class="stri">"         xBBBBc "</span>,
  <span class="stri">"  xBc    xBBBBc "</span>,
  <span class="stri">"  xBBc   xBBBBc "</span>,
  <span class="stri">"   xBBBBBBBBBc  "</span>,
  <span class="stri">"                "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: four <span class="keywd">is</span> [](
  <span class="stri">"                "</span>,
  <span class="stri">"                "</span>,
  <span class="stri">"  xBc           "</span>,
  <span class="stri">"  xBc           "</span>,
  <span class="stri">"  xBc           "</span>,
  <span class="stri">"  xBc           "</span>,
  <span class="stri">"  xBc    xBc    "</span>,
  <span class="stri">"  xBc    xBc    "</span>,
  <span class="stri">"  xBBBBBBBBBBBc "</span>,
  <span class="stri">"      xBBBBc    "</span>,
  <span class="stri">"      xBBBBc    "</span>,
  <span class="stri">"      xBBBBc    "</span>,
  <span class="stri">"      xBBBBc    "</span>,
  <span class="stri">"      xBBBBc    "</span>,
  <span class="stri">"      xBBBBc    "</span>,
  <span class="stri">"                "</span>);

<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: five <span class="keywd">is</span> [](
  <span class="stri">"                "</span>,
  <span class="stri">"                "</span>,
  <span class="stri">"  xBBBBBBBBBBBc "</span>,
  <span class="stri">"  xBc           "</span>,
  <span class="stri">"  xBc           "</span>,
  <span class="stri">"  xBc           "</span>,
  <span class="stri">"  xBc           "</span>,
  <span class="stri">"  xBc           "</span>,
  <span class="stri">"  xBBBBBBBBBBc  "</span>,
  <span class="stri">"         xBBBBc "</span>,
  <span class="stri">"         xBBBBc "</span>,
  <span class="stri">"         xBBBBc "</span>,
  <span class="stri">"  xBc    xBBBBc "</span>,
  <span class="stri">"  xBBc   xBBBBc "</span>,
  <span class="stri">"   xBBBBBBBBBc  "</span>,
  <span class="stri">"                "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: six <span class="keywd">is</span> [](
  <span class="stri">"                "</span>,
  <span class="stri">"                "</span>,
  <span class="stri">"   xBBBBBBBBBc  "</span>,
  <span class="stri">"  xBBc     xBBc "</span>,
  <span class="stri">"  xBc       xBc "</span>,
  <span class="stri">"  xBc           "</span>,
  <span class="stri">"  xBc           "</span>,
  <span class="stri">"  xBc           "</span>,
  <span class="stri">"  xBBBBBBBBBBc  "</span>,
  <span class="stri">"  xBc    xBBBBc "</span>,
  <span class="stri">"  xBc    xBBBBc "</span>,
  <span class="stri">"  xBc    xBBBBc "</span>,
  <span class="stri">"  xBc    xBBBBc "</span>,
  <span class="stri">"  xBBc   xBBBBc "</span>,
  <span class="stri">"   xBBBBBBBBBc  "</span>,
  <span class="stri">"                "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: seven <span class="keywd">is</span> [](
  <span class="stri">"                "</span>,
  <span class="stri">"                "</span>,
  <span class="stri">"  xBBBBBBBBBBBc "</span>,
  <span class="stri">"            xBc "</span>,
  <span class="stri">"            xBc "</span>,
  <span class="stri">"            xBc "</span>,
  <span class="stri">"            xBc "</span>,
  <span class="stri">"           xBBc "</span>,
  <span class="stri">"      xBBBBBBc  "</span>,
  <span class="stri">"     xBBBBc     "</span>,
  <span class="stri">"     xBBBBc     "</span>,
  <span class="stri">"     xBBBBc     "</span>,
  <span class="stri">"     xBBBBc     "</span>,
  <span class="stri">"     xBBBBc     "</span>,
  <span class="stri">"     xBBBBc     "</span>,
  <span class="stri">"                "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: eight <span class="keywd">is</span> [](
  <span class="stri">"                "</span>,
  <span class="stri">"                "</span>,
  <span class="stri">"   xBBBBBBBBBc  "</span>,
  <span class="stri">"  xBBc     xBBc "</span>,
  <span class="stri">"  xBc       xBc "</span>,
  <span class="stri">"  xBc       xBc "</span>,
  <span class="stri">"  xBc       xBc "</span>,
  <span class="stri">"  xBc       xBc "</span>,
  <span class="stri">"   xBBBBBBBBBc  "</span>,
  <span class="stri">"  xBc    xBBBBc "</span>,
  <span class="stri">"  xBc    xBBBBc "</span>,
  <span class="stri">"  xBc    xBBBBc "</span>,
  <span class="stri">"  xBc    xBBBBc "</span>,
  <span class="stri">"  xBBc   xBBBBc "</span>,
  <span class="stri">"   xBBBBBBBBBc  "</span>,
  <span class="stri">"                "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: nine <span class="keywd">is</span> [](
  <span class="stri">"                "</span>,
  <span class="stri">"                "</span>,
  <span class="stri">"   xBBBBBBBBBc  "</span>,
  <span class="stri">"  xBBc     xBBc "</span>,
  <span class="stri">"  xBc       xBc "</span>,
  <span class="stri">"  xBc       xBc "</span>,
  <span class="stri">"  xBc       xBc "</span>,
  <span class="stri">"  xBc       xBc "</span>,
  <span class="stri">"   xBBBBBBBBBBc "</span>,
  <span class="stri">"         xBBBBc "</span>,
  <span class="stri">"         xBBBBc "</span>,
  <span class="stri">"         xBBBBc "</span>,
  <span class="stri">"  xBc    xBBBBc "</span>,
  <span class="stri">"  xBBc   xBBBBc "</span>,
  <span class="stri">"   xBBBBBBBBBc  "</span>,
  <span class="stri">"                "</span>);


<span class="keywd">const</span> <span class="type">proc</span>: writeButtons <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    yPos := (MENUE_BAR_HEIGHT - 10) <span class="op">div</span> 2 + 10;
    rect(0, 0, WINDOW_WIDTH, MENUE_BAR_HEIGHT, light_gray);
    color(screen, black, light_gray);
    setPosXY(screen, 5, yPos);
    write(screen, <span class="stri">"New"</span>);
    setPosXY(screen, 55, yPos);
    write(screen, <span class="stri">"Quit"</span>);
    setPosXY(screen, 105, yPos);
    write(screen, <span class="stri">"Demo"</span>);
    setPosXY(screen, 155, yPos);
    write(screen, <span class="stri">"Undo"</span>);
    setPosXY(screen, 205, yPos);
    write(screen, <span class="stri">"Redo"</span>);
    setPosXY(screen, 255, yPos);
    write(screen, <span class="stri">"Help"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">char</span>: getCommand <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">char</span>: command <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    command := upper(getc(KEYBOARD));
    <span class="keywd">if</span> command = KEY_MOUSE1 <span class="keywd">then</span>
      xPos := clickedXPos(KEYBOARD);
      yPos := clickedYPos(KEYBOARD);
      <span class="keywd">if</span> yPos &lt;= 20 <span class="keywd">then</span>
        <span class="keywd">case</span> xPos <span class="op">div</span> 50 <span class="keywd">of</span>
          <span class="keywd">when</span> {0}: command := <span class="stri">'N'</span>;
          <span class="keywd">when</span> {1}: command := <span class="stri">'Q'</span>;
          <span class="keywd">when</span> {2}: command := <span class="stri">'D'</span>;
          <span class="keywd">when</span> {3}: command := <span class="stri">'U'</span>;
          <span class="keywd">when</span> {4}: command := <span class="stri">'R'</span>;
          <span class="keywd">when</span> {5}: command := <span class="stri">'H'</span>;
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> command = KEY_ESC <span class="keywd">then</span>
      bossMode(doQuit);
      <span class="keywd">if</span> doQuit <span class="keywd">then</span>
        command := <span class="stri">'Q'</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> command = KEY_CLOSE <span class="keywd">then</span>
      command := <span class="stri">'Q'</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">tileType</span>: genTile (<span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: pattern) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">tileType</span>: aTile <span class="keywd">is</span> tileType.value;
  <span class="keywd">begin</span>
    aTile.pattern := pattern;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">var</span> <span class="type">array</span> <span class="type">tileType</span>: tiles <span class="keywd">is</span> [](
    genTile(dot1_pic),
    genTile(dot2_pic),
    genTile(dot3_pic),
    genTile(dot4_pic),
    genTile(dot5_pic),
    genTile(dot6_pic),
    genTile(dot7_pic),
    genTile(dot8_pic),
    genTile(dot9_pic),
    genTile(bamboo1_pic),
    genTile(bamboo2_pic),
    genTile(bamboo3_pic),
    genTile(bamboo4_pic),
    genTile(bamboo5_pic),
    genTile(bamboo6_pic),
    genTile(bamboo7_pic),
    genTile(bamboo8_pic),
    genTile(bamboo9_pic),
    genTile(character1_pic),
    genTile(character2_pic),
    genTile(character3_pic),
    genTile(character4_pic),
    genTile(character5_pic),
    genTile(character6_pic),
    genTile(character7_pic),
    genTile(character8_pic),
    genTile(character9_pic),
    genTile(north_pic),
    genTile(south_pic),
    genTile(east_pic),
    genTile(west_pic),
    genTile(middle_pic),
    genTile(green_pic),
    genTile(white_pic),
    genTile(plum_pic),
    genTile(orchid_pic),
    genTile(chrysanthemum_pic),
    genTile(bamboo_pic),
    genTile(spring_pic),
    genTile(summer_pic),
    genTile(autumn_pic),
    genTile(winter_pic)
  );


<span class="comment">(**
 *  Draws the symbols of a tile.
 *  The symbols of a tile are stored in a pixmap. If the pixmap
 *  does not already exist it is generated from the pattern.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: draw (<span class="keywd">inout</span> <span class="type">PRIMITIVE_WINDOW</span>: win, <span class="op">in</span> <span class="type">integer</span>: xPos, <span class="op">in</span> <span class="type">integer</span>: yPos,
    <span class="keywd">inout</span> <span class="type">tileType</span>: aTile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> aTile.pixmap = PRIMITIVE_WINDOW.value <span class="keywd">then</span>
      rect(win, xPos, yPos, PIXMAP_WIDTH, PIXMAP_HEIGHT, BACKGROUND);
      drawPattern(win, xPos, yPos, aTile.pattern, PIXMAP_HEIGHT <span class="op">div</span> length(aTile.pattern), white);
      aTile.pixmap := getPixmap(win, xPos, yPos, PIXMAP_WIDTH, PIXMAP_HEIGHT);
    <span class="keywd">else</span>
      put(win, xPos, yPos, aTile.pixmap);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Draws the top borders of a tile.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: putFrame (<span class="keywd">inout</span> <span class="type">PRIMITIVE_WINDOW</span>: win, <span class="op">in</span> <span class="type">integer</span>: xPos, <span class="op">in</span> <span class="type">integer</span>: yPos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: shift <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> shift <span class="keywd">range</span> 1 <span class="keywd">to</span> FRAME_THICKNESS <span class="keywd">do</span>
      line(win, xPos - TILE_BORDER + shift,
          yPos - TILE_BORDER + shift - 1,
          TILE_WIDTH -  2 * shift - 1, 0, farFrameColor[shift]);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> shift <span class="keywd">range</span> 1 <span class="keywd">to</span> FRAME_THICKNESS <span class="keywd">do</span>
      line(win, xPos - TILE_BORDER + shift - 1,
          yPos - TILE_BORDER + shift,
          0, TILE_HEIGHT -  2 * shift - 1, leftFrameColor[shift]);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> shift <span class="keywd">range</span> 1 <span class="keywd">to</span> FRAME_THICKNESS <span class="keywd">do</span>
      line(win, xPos - TILE_BORDER + TILE_WIDTH - shift,
          yPos - TILE_BORDER + shift,
          0, TILE_HEIGHT -  2 * shift - 1, rightFrameColor[shift]);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> shift <span class="keywd">range</span> 1 <span class="keywd">to</span> FRAME_THICKNESS <span class="keywd">do</span>
      line(win, xPos - TILE_BORDER + shift,
          yPos - TILE_BORDER + TILE_HEIGHT - shift,
          TILE_WIDTH -  2 * shift - 1, 0, nearFrameColor[shift]);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Draws the left (western) vertical side of a tile.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: drawLeftSide (<span class="keywd">inout</span> <span class="type">PRIMITIVE_WINDOW</span>: win, <span class="op">in</span> <span class="type">integer</span>: xPos, <span class="op">in</span> <span class="type">integer</span>: yPos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: shift <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> shift <span class="keywd">range</span> 1 <span class="keywd">to</span> pred(SHIFT_X) <span class="keywd">do</span>
      lineTo(win, xPos - TILE_BORDER - shift,
          yPos - TILE_BORDER + shift + 2,
          xPos - TILE_BORDER - shift,
          yPos + PIXMAP_HEIGHT + TILE_BORDER + shift - 3, leftSideColor);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    lineTo(win, xPos - TILE_BORDER - SHIFT_X,
        yPos - TILE_BORDER + SHIFT_X + 1,
        xPos - TILE_BORDER - SHIFT_X,
        yPos + PIXMAP_HEIGHT + TILE_BORDER + SHIFT_X - 2, leftEdgeColor);
    line(win, xPos - TILE_BORDER, yPos - TILE_BORDER + 1,
        -pred(SHIFT_X), pred(SHIFT_Y), farLeftEdgeColor);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Draws the near (southern) vertical side of a tile.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: drawNearSide (<span class="keywd">inout</span> <span class="type">PRIMITIVE_WINDOW</span>: win, <span class="op">in</span> <span class="type">integer</span>: xPos, <span class="op">in</span> <span class="type">integer</span>: yPos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: shift <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> shift <span class="keywd">range</span> 1 <span class="keywd">to</span> pred(SHIFT_X) <span class="keywd">do</span>
      lineTo(win, xPos - TILE_BORDER - shift + 2,
          yPos + PIXMAP_HEIGHT + TILE_BORDER + shift - 1,
          xPos + PIXMAP_WIDTH + TILE_BORDER - shift - 3,
          yPos + PIXMAP_HEIGHT + TILE_BORDER + shift - 1, nearSideColor);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    lineTo(win, xPos - TILE_BORDER - SHIFT_X + 1,
        yPos + PIXMAP_HEIGHT + TILE_BORDER + SHIFT_X - 1,
        xPos + PIXMAP_WIDTH + TILE_BORDER - SHIFT_X - 2,
        yPos + PIXMAP_HEIGHT + TILE_BORDER + SHIFT_X - 1, nearEdgeColor);
    line(win, xPos + PIXMAP_WIDTH + TILE_BORDER - 2,
        yPos + PIXMAP_HEIGHT + TILE_BORDER - 1,
        -pred(SHIFT_X), pred(SHIFT_Y), nearRightEdgeColor);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Draws a tile at the position (level, line, column).
 *  The 'field' is not checked for the existence of a tile at
 *  (level, line, column). The complete tile is drawn inclusive
 *  borders. Although the tile is drawn with isometric graphic the
 *  visibility is not checked.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: drawTile (<span class="keywd">inout</span> <span class="type">PRIMITIVE_WINDOW</span>: win, <span class="op">in</span> <span class="type">integer</span>: level,
    <span class="op">in</span> <span class="type">integer</span>: line, <span class="op">in</span> <span class="type">integer</span>: column) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    xPos := LEFT_BORDER + TILE_BORDER + FIELD_X_STEP * pred(column) + SHIFT_X * level;
    yPos := UPPER_BORDER + TILE_BORDER + FIELD_Y_STEP * pred(line) - SHIFT_Y * level;
    drawLeftSide(win, xPos, yPos);
    drawNearSide(win, xPos, yPos);
    line(win, xPos - TILE_BORDER + 1, yPos + PIXMAP_HEIGHT + TILE_BORDER - 1,
        -pred(SHIFT_X), pred(SHIFT_Y), nearLeftEdgeColor[1]);
    line(win, xPos - TILE_BORDER, yPos + PIXMAP_HEIGHT + TILE_BORDER - 1,
        -pred(SHIFT_X), pred(SHIFT_Y), nearLeftEdgeColor[2]);
    line(win, xPos - TILE_BORDER, yPos + PIXMAP_HEIGHT + TILE_BORDER - 2,
        -pred(SHIFT_X), pred(SHIFT_Y), nearLeftEdgeColor[3]);
    rect(win, xPos - TILE_BORDER + 1, yPos - TILE_BORDER + 1,
        TILE_WIDTH - 2, TILE_HEIGHT - 2, white);
    putFrame(win, xPos, yPos);
    draw(win, xPos, yPos, tiles[field[level][line][column].tileNumber]);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Draw a complete board of tiles and flush after each tile.
 *  This function us just used on the welcome screen.
 *  The order in which the tiles are drawn makes sure that
 *  the visibility is okay.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: drawBoardWithFlush <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: level <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: diagonalStartColumn <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> level <span class="keywd">range</span> 1 <span class="keywd">to</span> length(field) <span class="keywd">do</span>
      <span class="keywd">for</span> diagonalStartColumn <span class="keywd">range</span> FIELD_COLUMNS <span class="keywd">downto</span> 2 - FIELD_LINES <span class="keywd">do</span>
        <span class="keywd">for</span> line <span class="keywd">range</span> 1 <span class="keywd">to</span> FIELD_LINES <span class="keywd">do</span>
          column := diagonalStartColumn + line - 1;
          <span class="keywd">if</span> column >= 1 <span class="op">and</span> column &lt;= FIELD_COLUMNS <span class="op">and</span>
              field[level][line][column].present <span class="keywd">then</span>
            drawTile(curr_win, level, line, column);
            flushGraphic;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Draw a complete board of tiles.
 *  The order in which the tiles are drawn makes sure that
 *  the visibility is okay.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: drawBoard <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: win <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
    <span class="keywd">var</span> <span class="type">integer</span>: level <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: diagonalStartColumn <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    win := newPixmap(WINDOW_WIDTH, WINDOW_HEIGHT);
    clear(win, BACKGROUND);
    <span class="keywd">for</span> level <span class="keywd">range</span> 1 <span class="keywd">to</span> length(field) <span class="keywd">do</span>
      <span class="keywd">for</span> diagonalStartColumn <span class="keywd">range</span> FIELD_COLUMNS <span class="keywd">downto</span> 2 - FIELD_LINES <span class="keywd">do</span>
        <span class="keywd">for</span> line <span class="keywd">range</span> 1 <span class="keywd">to</span> FIELD_LINES <span class="keywd">do</span>
          column := diagonalStartColumn + line - 1;
          <span class="keywd">if</span> column >= 1 <span class="op">and</span> column &lt;= FIELD_COLUMNS <span class="op">and</span>
              field[level][line][column].present <span class="keywd">then</span>
            drawTile(win, level, line, column);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    put(0, 0, win);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getMaximumLevelLeftward (<span class="op">in</span> <span class="type">integer</span>: line, <span class="op">in</span> <span class="type">integer</span>: column) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: maximumLevelLeftward <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: level <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: lin <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> column > 2 <span class="keywd">then</span>
      <span class="keywd">for</span> level <span class="keywd">range</span> 1 <span class="keywd">to</span> length(field) <span class="keywd">do</span>
        <span class="keywd">for</span> lin <span class="keywd">range</span> pred(line) <span class="keywd">to</span> succ(line) <span class="keywd">do</span>
          <span class="keywd">if</span> lin >= 1 <span class="op">and</span> lin &lt;= FIELD_LINES <span class="keywd">then</span>
            <span class="keywd">if</span> field[level][lin][column - 2].present <span class="keywd">then</span>
              maximumLevelLeftward := level;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getMaximumLevelDownward (<span class="op">in</span> <span class="type">integer</span>: line, <span class="op">in</span> <span class="type">integer</span>: column) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: maximumLevelDownward <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: level <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: col <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> line &lt; pred(FIELD_LINES) <span class="keywd">then</span>
      <span class="keywd">for</span> level <span class="keywd">range</span> 1 <span class="keywd">to</span> length(field) <span class="keywd">do</span>
        <span class="keywd">for</span> col <span class="keywd">range</span> pred(column) <span class="keywd">to</span> succ(column) <span class="keywd">do</span>
          <span class="keywd">if</span> col >= 1 <span class="op">and</span> col &lt;= FIELD_COLUMNS <span class="keywd">then</span>
            <span class="keywd">if</span> field[level][line + 2][col].present <span class="keywd">then</span>
              maximumLevelDownward := level;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: markFrame (<span class="op">in</span> <span class="type">positionType</span>: pos, <span class="op">in</span> <span class="type">color</span>: frameColor) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: maximumLevelLeftward <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: maximumLevelDownward <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: shorten_x1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: shorten_y1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: shorten_x2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: shorten_y2 <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    xPos := LEFT_BORDER + TILE_BORDER + FIELD_X_STEP * pred(pos.column) + SHIFT_X * pos.level;
    yPos := UPPER_BORDER + TILE_BORDER + FIELD_Y_STEP * pred(pos.line) - SHIFT_Y * pos.level;
    field[pos.level][pos.line][pos.column].backup := getPixmap(
        xPos - TILE_BORDER, yPos - TILE_BORDER, TILE_WIDTH, TILE_HEIGHT);
    maximumLevelLeftward := getMaximumLevelLeftward(pos.line, pos.column);
    maximumLevelDownward := getMaximumLevelDownward(pos.line, pos.column);
    <span class="keywd">if</span> maximumLevelLeftward > pos.level <span class="keywd">then</span>
      shorten_x1 := SHIFT_X * (maximumLevelLeftward - pos.level)
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> maximumLevelDownward > pos.level <span class="keywd">then</span>
      shorten_y2 := SHIFT_Y * (maximumLevelDownward - pos.level)
    <span class="keywd">end</span> <span class="keywd">if</span>;
    maximumLevelLeftward := getMaximumLevelLeftward(pos.line + 2, pos.column);
    maximumLevelDownward := getMaximumLevelDownward(pos.line, pos.column - 2);
    <span class="keywd">if</span> maximumLevelLeftward > pos.level <span class="keywd">then</span>
      shorten_x2 := SHIFT_X * (maximumLevelLeftward - pos.level)
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> maximumLevelDownward > pos.level <span class="keywd">then</span>
      shorten_y1 := SHIFT_Y * (maximumLevelDownward - pos.level)
    <span class="keywd">end</span> <span class="keywd">if</span>;
    rect(xPos - TILE_BORDER + shorten_x1, yPos - TILE_BORDER,
        TILE_WIDTH - shorten_x1, MARK_THICKNESS, frameColor);
    <span class="keywd">if</span> shorten_x1 = 0 <span class="keywd">then</span>
      rect(xPos - TILE_BORDER, yPos - TILE_BORDER,
          MARK_THICKNESS, TILE_HEIGHT - shorten_y1, frameColor);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    rect(xPos - TILE_BORDER + TILE_WIDTH - MARK_THICKNESS,
        yPos - TILE_BORDER,
        MARK_THICKNESS, TILE_HEIGHT - shorten_y2, frameColor);
    <span class="keywd">if</span> shorten_y2 = 0 <span class="keywd">then</span>
      rect(xPos - TILE_BORDER + shorten_x2,
          yPos - TILE_BORDER + TILE_HEIGHT - MARK_THICKNESS,
          TILE_WIDTH - shorten_x2, MARK_THICKNESS, frameColor);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: unmarkFrame (<span class="op">in</span> <span class="type">positionType</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    xPos := LEFT_BORDER + TILE_BORDER + FIELD_X_STEP * pred(pos.column) + SHIFT_X * pos.level;
    yPos := UPPER_BORDER + TILE_BORDER + FIELD_Y_STEP * pred(pos.line) - SHIFT_Y * pos.level;
    put(xPos - TILE_BORDER, yPos - TILE_BORDER,
        field[pos.level][pos.line][pos.column].backup);
    field[pos.level][pos.line][pos.column].backup := PRIMITIVE_WINDOW.value;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: mark (<span class="op">in</span> <span class="type">positionType</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> field[pos.level][pos.line][pos.column].present <span class="op">and</span>
        <span class="op">not</span> field[pos.level][pos.line][pos.column].selected <span class="keywd">then</span>
      field[pos.level][pos.line][pos.column].selected := TRUE;
      markFrame(pos, light_red);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: unmark (<span class="op">in</span> <span class="type">positionType</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> field[pos.level][pos.line][pos.column].present <span class="op">and</span>
        field[pos.level][pos.line][pos.column].selected <span class="keywd">then</span>
      field[pos.level][pos.line][pos.column].selected := FALSE;
      unmarkFrame(pos);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: unmarkAll <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">positionType</span>: pos <span class="keywd">is</span> positionType.value;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> pos.level <span class="keywd">range</span> 1 <span class="keywd">to</span> length(field) <span class="keywd">do</span>
      <span class="keywd">for</span> pos.line <span class="keywd">range</span> 1 <span class="keywd">to</span> FIELD_LINES <span class="keywd">do</span>
        <span class="keywd">for</span> pos.column <span class="keywd">range</span> 1 <span class="keywd">to</span> FIELD_COLUMNS <span class="keywd">do</span>
          unmark(pos);
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Refreshes the tile at the position 'pos' (level, line, column).
 *  This function takes the visibility into account.
 *  The tiles around the specified position are drawn to an offscreen
 *  pixmap. Finally the area of the tile is copied to the screen.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: refresh (<span class="op">in</span> <span class="type">positionType</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: win <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
    <span class="keywd">var</span> <span class="type">integer</span>: level <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: diagonalStartColumn <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    win := newPixmap(WINDOW_WIDTH, WINDOW_HEIGHT);
    clear(win, BACKGROUND);
    <span class="keywd">for</span> level <span class="keywd">range</span> 1 <span class="keywd">to</span> length(field) <span class="keywd">do</span>
      <span class="keywd">for</span> diagonalStartColumn <span class="keywd">range</span> pos.column + 2 <span class="keywd">downto</span> pos.column - 6 <span class="keywd">do</span>
        <span class="keywd">for</span> line <span class="keywd">range</span> pos.line - 2 <span class="keywd">to</span> pos.line + 2 <span class="keywd">do</span>
          column := diagonalStartColumn + line - pos.line + 2 ;
          <span class="keywd">if</span> line >= 1 <span class="op">and</span> line &lt;= FIELD_LINES <span class="op">and</span>
                column >= 1 <span class="op">and</span> column &lt;= FIELD_COLUMNS <span class="op">and</span>
                field[level][line][column].present <span class="keywd">then</span>
            drawTile(win, level, line, column);
            <span class="comment"># writeln("refresh " &lt;&amp; level &lt;&amp; " " &lt;&amp; line &lt;&amp; " " &lt;&amp; column);</span>
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    xPos := LEFT_BORDER + TILE_BORDER + FIELD_X_STEP * pred(pos.column) + SHIFT_X * pos.level;
    yPos := UPPER_BORDER + TILE_BORDER + FIELD_Y_STEP * pred(pos.line) - SHIFT_Y * pos.level;
    win := getPixmap(win, xPos - TILE_BORDER - SHIFT_X, yPos - TILE_BORDER,
        TILE_WIDTH + SHIFT_X, TILE_HEIGHT + SHIFT_Y);
    put(xPos - TILE_BORDER - SHIFT_X, yPos - TILE_BORDER, win);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Removes the tile at the position 'pos' (level, line, column).
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: remove (<span class="op">in</span> <span class="type">positionType</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> field[pos.level][pos.line][pos.column].present <span class="keywd">then</span>
      field[pos.level][pos.line][pos.column].present := FALSE;
      refresh(pos);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Inserts the tile at the position 'pos' (level, line, column).
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: insert (<span class="op">in</span> <span class="type">positionType</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> <span class="op">not</span> field[pos.level][pos.line][pos.column].present <span class="keywd">then</span>
      field[pos.level][pos.line][pos.column].present := TRUE;
      refresh(pos);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: draw_number (<span class="op">in</span> <span class="type">integer</span>: xPos, <span class="op">in</span> <span class="type">integer</span>: yPos, <span class="op">in</span> <span class="type">string</span>: num_stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length(num_stri) <span class="keywd">do</span>
      ch := num_stri[index];
      <span class="keywd">if</span> ch = <span class="stri">' '</span> <span class="keywd">then</span>
        rect(xPos + pred(index) * 32,
            yPos,
            32,
            32,
            BACKGROUND);
      <span class="keywd">else</span>
        put(xPos + pred(index) * 32,
            yPos,
            digit_pixmap[ord(ch) - ord(<span class="stri">'0'</span>)]);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: covered (<span class="op">in</span> <span class="type">integer</span>: level, <span class="op">in</span> <span class="type">integer</span>: line,
    <span class="op">in</span> <span class="type">integer</span>: column) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: isCovered <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: lin <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: col <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> level &lt; length(field) <span class="keywd">then</span>
      <span class="keywd">for</span> lin <span class="keywd">range</span> pred(line) <span class="keywd">to</span> succ(line) <span class="keywd">do</span>
        <span class="keywd">if</span> lin >= 1 <span class="op">and</span> lin &lt;= FIELD_LINES <span class="keywd">then</span>
          <span class="keywd">for</span> col <span class="keywd">range</span> pred(column) <span class="keywd">to</span> succ(column) <span class="keywd">do</span>
            <span class="keywd">if</span> col >= 1 <span class="op">and</span> col &lt;= FIELD_COLUMNS <span class="keywd">then</span>
              <span class="keywd">if</span> field[succ(level)][lin][col].present <span class="keywd">then</span>
                isCovered := TRUE;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getFirstAccessibleTileColumn (<span class="op">in</span> <span class="type">integer</span>: level, <span class="op">in</span> <span class="type">integer</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: accessibleColumn <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> FIELD_COLUMNS <span class="keywd">do</span>
      <span class="keywd">if</span> accessibleColumn = 0 <span class="op">and</span>
          field[level][line][column].present <span class="keywd">then</span>
        accessibleColumn := column;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> accessibleColumn &lt;> 0 <span class="keywd">then</span>
      <span class="keywd">if</span> covered(level, line, accessibleColumn) <span class="keywd">then</span>
        accessibleColumn := 0;
      <span class="keywd">else</span>
        <span class="keywd">for</span> column <span class="keywd">range</span> accessibleColumn <span class="keywd">downto</span> 1 <span class="keywd">do</span>
          <span class="keywd">if</span>  (line > 1 <span class="op">and</span>
              field[level][pred(line)][column].present) <span class="op">or</span>
              (line &lt; FIELD_LINES <span class="op">and</span>
              field[level][succ(line)][column].present) <span class="keywd">then</span>
            accessibleColumn := 0;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getLastAccessibleTileColumn (<span class="op">in</span> <span class="type">integer</span>: level, <span class="op">in</span> <span class="type">integer</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: accessibleColumn <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> column <span class="keywd">range</span> FIELD_COLUMNS <span class="keywd">downto</span> 1 <span class="keywd">do</span>
      <span class="keywd">if</span> accessibleColumn = 0 <span class="op">and</span>
          field[level][line][column].present <span class="keywd">then</span>
        accessibleColumn := column;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> accessibleColumn &lt;> 0 <span class="keywd">then</span>
      <span class="keywd">if</span> covered(level, line, accessibleColumn) <span class="keywd">then</span>
        accessibleColumn := 0;
      <span class="keywd">else</span>
        <span class="keywd">for</span> column <span class="keywd">range</span> accessibleColumn <span class="keywd">to</span> FIELD_COLUMNS <span class="keywd">do</span>
          <span class="keywd">if</span>  (line > 1 <span class="op">and</span>
              field[level][pred(line)][column].present) <span class="op">or</span>
              (line &lt; FIELD_LINES <span class="op">and</span>
              field[level][succ(line)][column].present) <span class="keywd">then</span>
            accessibleColumn := 0;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">positionType</span>: getAccessibleTilePositions <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">positionType</span>: accessibleTilePositions <span class="keywd">is</span> 0 <span class="op">times</span> positionType.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">positionType</span>: pos <span class="keywd">is</span> positionType.value;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> pos.level <span class="keywd">range</span> 1 <span class="keywd">to</span> length(field) <span class="keywd">do</span>
      <span class="keywd">for</span> pos.line <span class="keywd">range</span> 1 <span class="keywd">to</span> FIELD_LINES <span class="keywd">do</span>
        pos.column := getFirstAccessibleTileColumn(pos.level, pos.line);
        <span class="keywd">if</span> pos.column &lt;> 0 <span class="keywd">then</span>
          accessibleTilePositions &amp;:= [] (pos);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        column := getLastAccessibleTileColumn(pos.level, pos.line);
        <span class="keywd">if</span> column &lt;> 0 <span class="op">and</span> column &lt;> pos.column <span class="keywd">then</span>
          pos.column := column;
          accessibleTilePositions &amp;:= [] (pos);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: countPossibleMoves <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: count <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">positionType</span>: accessibleTilePositions <span class="keywd">is</span> 0 <span class="op">times</span> positionType.value;
    <span class="keywd">var</span> <span class="type">integer</span>: first <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: second <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">positionType</span>: pos1 <span class="keywd">is</span> positionType.value;
    <span class="keywd">var</span> <span class="type">positionType</span>: pos2 <span class="keywd">is</span> positionType.value;
  <span class="keywd">begin</span>
    accessibleTilePositions := getAccessibleTilePositions;
    <span class="keywd">for</span> first <span class="keywd">range</span> 1 <span class="keywd">to</span> length(accessibleTilePositions) <span class="keywd">do</span>
      <span class="keywd">for</span> second <span class="keywd">range</span> succ(first) <span class="keywd">to</span> length(accessibleTilePositions) <span class="keywd">do</span>
        pos1 := accessibleTilePositions[first];
        pos2 := accessibleTilePositions[second];
        <span class="keywd">if</span> tiles[field[pos1.level][pos1.line][pos1.column].tileNumber].value =
            tiles[field[pos2.level][pos2.line][pos2.column].tileNumber].value <span class="keywd">then</span>
          incr(count);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showPossibleMoves (<span class="op">in</span> <span class="type">color</span>: frameColor, <span class="keywd">inout</span> <span class="type">char</span>: command,
    <span class="keywd">inout</span> <span class="type">boolean</span>: readCommand); <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">positionType</span>: accessibleTilePositions <span class="keywd">is</span> 0 <span class="op">times</span> positionType.value;
    <span class="keywd">var</span> <span class="type">integer</span>: first <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: second <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">positionType</span>: pos1 <span class="keywd">is</span> positionType.value;
    <span class="keywd">var</span> <span class="type">positionType</span>: pos2 <span class="keywd">is</span> positionType.value;
  <span class="keywd">begin</span>
    accessibleTilePositions := getAccessibleTilePositions;
    <span class="keywd">for</span> first <span class="keywd">range</span> 1 <span class="keywd">to</span> length(accessibleTilePositions) <span class="keywd">do</span>
      <span class="keywd">for</span> second <span class="keywd">range</span> succ(first) <span class="keywd">to</span> length(accessibleTilePositions) <span class="keywd">do</span>
        pos1 := accessibleTilePositions[first];
        pos2 := accessibleTilePositions[second];
        <span class="keywd">if</span> command = <span class="stri">'H'</span> <span class="op">and</span>
            tiles[field[pos1.level][pos1.line][pos1.column].tileNumber].value =
            tiles[field[pos2.level][pos2.line][pos2.column].tileNumber].value <span class="keywd">then</span>
          markFrame(pos1, frameColor);
          markFrame(pos2, frameColor);
          command := getCommand;
          readCommand := FALSE;
          unmarkFrame(pos2);
          unmarkFrame(pos1);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showPossibleMatches (<span class="op">in</span> <span class="type">positionType</span>: pos1, <span class="op">in</span> <span class="type">boolean</span>: marked) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">positionType</span>: accessibleTilePositions <span class="keywd">is</span> 0 <span class="op">times</span> positionType.value;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">positionType</span>: pos2 <span class="keywd">is</span> positionType.value;
  <span class="keywd">begin</span>
    accessibleTilePositions := getAccessibleTilePositions;
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> length(accessibleTilePositions) <span class="keywd">do</span>
      pos2 := accessibleTilePositions[number];
      <span class="keywd">if</span> pos1.level &lt;> pos2.level <span class="op">or</span> pos1.line &lt;> pos2.line <span class="op">or</span> pos1.column &lt;> pos2.column <span class="keywd">then</span>
        <span class="keywd">if</span> tiles[field[pos1.level][pos1.line][pos1.column].tileNumber].value =
            tiles[field[pos2.level][pos2.line][pos2.column].tileNumber].value <span class="keywd">then</span>
          <span class="keywd">if</span> marked <span class="keywd">then</span>
            markFrame(pos2, light_green);
          <span class="keywd">else</span>
            unmarkFrame(pos2);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: updateNumbers <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    draw_number(WINDOW_WIDTH - 104, 30, 2 * (72 - moveNumber) <span class="op">lpad</span> 3);
    draw_number(WINDOW_WIDTH - 104, 70, countPossibleMoves <span class="op">lpad</span> 3);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showDemo <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">array</span> <span class="type">array</span> <span class="type">fieldType</span>: backupField <span class="keywd">is</span> 0 <span class="op">times</span> 0 <span class="op">times</span> 0 <span class="op">times</span> fieldType.value;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: level <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">moveType</span>: move <span class="keywd">is</span> moveType.value;
    <span class="keywd">var</span> <span class="type">char</span>: command <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: continueDemo <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    backupField := field;
    <span class="keywd">for</span> level <span class="keywd">range</span> 1 <span class="keywd">to</span> length(field) <span class="keywd">do</span>
      <span class="keywd">for</span> line <span class="keywd">range</span> 1 <span class="keywd">to</span> FIELD_LINES <span class="keywd">do</span>
        <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> FIELD_COLUMNS <span class="keywd">do</span>
          <span class="keywd">if</span> field[level][line][column].used <span class="keywd">then</span>
            field[level][line][column].present := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    drawBoard;
    number := 1;
    <span class="keywd">while</span> continueDemo <span class="op">and</span> number &lt;= length(demoMoves) <span class="keywd">do</span>
      <span class="keywd">if</span> inputReady(KEYBOARD) <span class="keywd">then</span>
        command := getc(KEYBOARD);
        <span class="keywd">if</span> command = KEY_ESC <span class="keywd">then</span>
          bossMode(doQuit);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        continueDemo := FALSE;
      <span class="keywd">else</span>
        wait(200000 . MICRO_SECONDS);
        remove(demoMoves[number].pos1);
        remove(demoMoves[number].pos2);
        flushGraphic;
        incr(number);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    field := backupField;
    drawBoard;
    writeButtons;
    updateNumbers;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: locateTile (<span class="op">in</span> <span class="type">integer</span>: xPos, <span class="op">in</span> <span class="type">integer</span>: yPos,
    <span class="keywd">inout</span> <span class="type">integer</span>: level, <span class="keywd">inout</span> <span class="type">integer</span>: line, <span class="keywd">inout</span> <span class="type">integer</span>: column,
    <span class="keywd">inout</span> <span class="type">boolean</span>: found) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: line2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: lev <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: lin <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: col <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    found := FALSE;
    <span class="keywd">for</span> lev <span class="keywd">range</span> length(field) <span class="keywd">downto</span> 1 <span class="keywd">do</span>
      line2 := (yPos - UPPER_BORDER + SHIFT_Y * lev) <span class="op">div</span> FIELD_Y_STEP + 1;
      column2 := (xPos - LEFT_BORDER - SHIFT_X * lev) <span class="op">div</span> FIELD_X_STEP + 1;
      <span class="keywd">for</span> lin <span class="keywd">range</span> pred(line2) <span class="keywd">to</span> line2 <span class="keywd">do</span>
        <span class="keywd">for</span> col <span class="keywd">range</span> pred(column2) <span class="keywd">to</span> column2 <span class="keywd">do</span>
          <span class="keywd">if</span> <span class="op">not</span> found <span class="op">and</span>
              lin >= 1 <span class="op">and</span> lin &lt;= length(field[lev]) <span class="op">and</span>
              col >= 1 <span class="op">and</span> col &lt;= length(field[lev][lin]) <span class="op">and</span>
              field[lev][lin][col].present <span class="keywd">then</span>
            found := TRUE;
            level := lev;
            line := lin;
            column := col;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Returns TRUE if 'pos' is a legal move, FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: legalMove (<span class="op">in</span> <span class="type">positionType</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: isLegal <span class="keywd">is</span> TRUE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: col <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> col <span class="keywd">range</span> 1 <span class="keywd">to</span> pred(pos.column) <span class="keywd">do</span>
      <span class="keywd">if</span> field[pos.level][pos.line][col].present <span class="op">or</span>
          pos.line > 1 <span class="op">and</span>
          field[pos.level][pred(pos.line)][col].present <span class="op">or</span>
          pos.line &lt; FIELD_LINES <span class="op">and</span>
          field[pos.level][succ(pos.line)][col].present <span class="keywd">then</span>
        isLegal := FALSE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> <span class="op">not</span> isLegal <span class="keywd">then</span>
      isLegal := TRUE;
      <span class="keywd">for</span> col <span class="keywd">range</span> succ(pos.column) <span class="keywd">to</span> FIELD_COLUMNS <span class="keywd">do</span>
        <span class="keywd">if</span> field[pos.level][pos.line][col].present <span class="op">or</span>
            pos.line > 1 <span class="op">and</span>
            field[pos.level][pred(pos.line)][col].present <span class="op">or</span>
            pos.line &lt; FIELD_LINES <span class="op">and</span>
            field[pos.level][succ(pos.line)][col].present <span class="keywd">then</span>
          isLegal := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    isLegal := isLegal <span class="op">and</span> <span class="op">not</span> covered(pos.level, pos.line, pos.column);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: playerMove (<span class="keywd">inout</span> <span class="type">moveType</span>: move, <span class="keywd">inout</span> <span class="type">char</span>: command) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: readCommand <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">integer</span>: selectedTiles <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">positionType</span>: pos <span class="keywd">is</span> positionType.value;
    <span class="keywd">var</span> <span class="type">boolean</span>: found <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: moveFinished <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      <span class="keywd">if</span> readCommand <span class="keywd">then</span>
        command := getCommand;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      readCommand := TRUE;
      <span class="keywd">if</span> command &lt;> KEY_MOUSE1 <span class="keywd">then</span>
        <span class="keywd">if</span> command = <span class="stri">'H'</span> <span class="keywd">then</span>
          <span class="keywd">if</span> selectedTiles = 0 <span class="keywd">then</span>
            showPossibleMoves(light_green, command, readCommand);
          <span class="keywd">else</span>
            showPossibleMatches(move.pos1, TRUE);
            command := getCommand;
            readCommand := FALSE;
            showPossibleMatches(move.pos1, FALSE);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          moveFinished := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        xPos := clickedXPos(KEYBOARD);
        yPos := clickedYPos(KEYBOARD);
        <span class="keywd">if</span> xPos >= LEFT_BORDER <span class="op">and</span> yPos >= UPPER_BORDER <span class="keywd">then</span>
          locateTile(xPos, yPos, pos.level, pos.line, pos.column, found);
          <span class="keywd">if</span> found <span class="op">and</span> legalMove(pos) <span class="keywd">then</span>
            <span class="keywd">if</span> field[pos.level][pos.line][pos.column].present <span class="keywd">then</span>
              <span class="keywd">if</span> field[pos.level][pos.line][pos.column].selected <span class="keywd">then</span>
                unmark(move.pos1);
                decr(selectedTiles);
              <span class="keywd">else</span>
                <span class="keywd">if</span> selectedTiles = 0 <span class="keywd">then</span>
                  move.pos1 := pos;
                  mark(move.pos1);
                  incr(selectedTiles);
                <span class="keywd">elsif</span> selectedTiles = 1 <span class="keywd">then</span>
                  <span class="keywd">if</span>  tiles[field[move.pos1.level][move.pos1.line][move.pos1.column].tileNumber].value =
                      tiles[field[pos.level][pos.line][pos.column].tileNumber].value <span class="keywd">then</span>
                    move.pos2 := pos;
                    mark(move.pos2);
                    moveFinished := TRUE;
                  <span class="keywd">else</span>
                    unmark(move.pos1);
                    move.pos1 := pos;
                    mark(move.pos1);
                  <span class="keywd">end</span> <span class="keywd">if</span>;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> moveFinished;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: playerTurn (<span class="keywd">inout</span> <span class="type">char</span>: command) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">moveType</span>: move <span class="keywd">is</span> moveType.value;
    <span class="keywd">var</span> <span class="type">boolean</span>: onTurn <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> onTurn <span class="keywd">do</span>
      playerMove(move, command);
      <span class="keywd">if</span> upper(command) = <span class="stri">'U'</span> <span class="keywd">then</span>
        unmarkAll;
        <span class="keywd">if</span> moveNumber >= 1 <span class="keywd">then</span>
          move := playerMoves[moveNumber];
          insert(move.pos1);
          insert(move.pos2);
          decr(moveNumber);
          updateNumbers;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> upper(command) = <span class="stri">'R'</span> <span class="keywd">then</span>
        unmarkAll;
        <span class="keywd">if</span> moveNumber &lt; length(playerMoves) <span class="keywd">then</span>
          incr(moveNumber);
          move := playerMoves[moveNumber];
          remove(move.pos1);
          remove(move.pos2);
          updateNumbers;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> upper(command) = <span class="stri">'D'</span> <span class="keywd">then</span>
        unmarkAll;
        showDemo;
        <span class="keywd">if</span> doQuit <span class="keywd">then</span>
          onTurn := FALSE;
          command := <span class="stri">'Q'</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> command &lt;> KEY_MOUSE1 <span class="keywd">then</span>
        unmarkAll;
        onTurn := FALSE;
      <span class="keywd">elsif</span> tiles[field[move.pos1.level][move.pos1.line][move.pos1.column].tileNumber].value =
          tiles[field[move.pos2.level][move.pos2.line][move.pos2.column].tileNumber].value <span class="keywd">then</span>
        flushGraphic;
        number := 0;
        <span class="keywd">while</span> <span class="op">not</span> inputReady(KEYBOARD) <span class="op">and</span> number &lt;= 5 <span class="keywd">do</span>
          wait(100000 . MICRO_SECONDS);
          incr(number);
        <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">if</span> inputReady(KEYBOARD) <span class="keywd">then</span>
          ignore(getc(KEYBOARD));
        <span class="keywd">end</span> <span class="keywd">if</span>;
        unmark(move.pos1);
        unmark(move.pos2);
        remove(move.pos1);
        remove(move.pos2);
        <span class="keywd">if</span> length(playerMoves) > moveNumber <span class="keywd">then</span>
          playerMoves := playerMoves[.. moveNumber];
        <span class="keywd">end</span> <span class="keywd">if</span>;
        playerMoves &amp;:= [] (move);
        incr(moveNumber);
        updateNumbers;
      <span class="keywd">else</span>
        unmark(move.pos1);
        unmark(move.pos2);
        onTurn := FALSE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: initLayout (<span class="op">in</span> <span class="type">layoutType</span>: layout) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: level <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    field := length(layout) <span class="op">times</span> FIELD_LINES <span class="op">times</span> FIELD_COLUMNS <span class="op">times</span> fieldType.value;
    <span class="keywd">for</span> level <span class="keywd">range</span> 1 <span class="keywd">to</span> length(field) <span class="keywd">do</span>
      <span class="keywd">for</span> line <span class="keywd">range</span> 1 <span class="keywd">to</span> FIELD_LINES <span class="keywd">do</span>
        <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> FIELD_COLUMNS <span class="keywd">do</span>
          field[level][line][column].used := layout[level][line][column] = <span class="stri">'X'</span>;
          field[level][line][column].present := FALSE;
          field[level][line][column].selected := FALSE;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getFirstFreeColumn (<span class="op">in</span> <span class="type">integer</span>: level, <span class="op">in</span> <span class="type">integer</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: freeColumn <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> FIELD_COLUMNS <span class="keywd">do</span>
      <span class="keywd">if</span> freeColumn = 0 <span class="keywd">then</span>
        <span class="keywd">if</span> field[level][line][column].present <span class="op">or</span>
            (line > 1 <span class="op">and</span>
            field[level][pred(line)][column].present) <span class="op">or</span>
            (line &lt; FIELD_LINES <span class="op">and</span>
            field[level][succ(line)][column].present) <span class="keywd">then</span>
          freeColumn := column;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> freeColumn > 2 <span class="op">and</span>
        (field[level][line][freeColumn].present <span class="op">or</span>
        ((line = 1 <span class="op">or</span>
        <span class="op">not</span> field[level][pred(line)][freeColumn].used <span class="op">or</span>
        field[level][pred(line)][freeColumn].present) <span class="op">and</span>
        (line = FIELD_LINES <span class="op">or</span>
        <span class="op">not</span> field[level][succ(line)][freeColumn].used <span class="op">or</span>
        field[level][succ(line)][freeColumn].present))) <span class="keywd">then</span>
      freeColumn -:= 2;
      <span class="keywd">if</span> <span class="op">not</span> field[level][line][freeColumn].used <span class="op">or</span>
          field[level][line][freeColumn].present <span class="keywd">then</span>
        freeColumn := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      freeColumn := 0;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getLastFreeColumn (<span class="op">in</span> <span class="type">integer</span>: level, <span class="op">in</span> <span class="type">integer</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: freeColumn <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> column <span class="keywd">range</span> FIELD_COLUMNS <span class="keywd">downto</span> 1 <span class="keywd">do</span>
      <span class="keywd">if</span> freeColumn = 0 <span class="keywd">then</span>
        <span class="keywd">if</span> field[level][line][column].present <span class="op">or</span>
            (line > 1 <span class="op">and</span>
            field[level][pred(line)][column].present) <span class="op">or</span>
            (line &lt; FIELD_LINES <span class="op">and</span>
            field[level][succ(line)][column].present) <span class="keywd">then</span>
          freeColumn := column;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> freeColumn &lt;> 0 <span class="keywd">then</span>
      <span class="keywd">if</span> freeColumn &lt; pred(FIELD_COLUMNS) <span class="op">and</span>
          (field[level][line][freeColumn].present <span class="op">or</span>
          ((line = 1 <span class="op">or</span>
          <span class="op">not</span> field[level][pred(line)][freeColumn].used <span class="op">or</span>
          field[level][pred(line)][freeColumn].present) <span class="op">and</span>
          (line = FIELD_LINES <span class="op">or</span>
          <span class="op">not</span> field[level][succ(line)][freeColumn].used <span class="op">or</span>
          field[level][succ(line)][freeColumn].present))) <span class="keywd">then</span>
        freeColumn +:= 2;
        <span class="keywd">if</span> <span class="op">not</span> field[level][line][freeColumn].used <span class="op">or</span>
            field[level][line][freeColumn].present <span class="keywd">then</span>
          freeColumn := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        freeColumn := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: lineIsFree (<span class="op">in</span> <span class="type">integer</span>: level, <span class="op">in</span> <span class="type">integer</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: isFree <span class="keywd">is</span> TRUE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> FIELD_COLUMNS <span class="keywd">do</span>
      <span class="keywd">if</span> isFree <span class="keywd">then</span>
        <span class="keywd">if</span> field[level][line][column].present <span class="op">or</span>
            (line > 1 <span class="op">and</span>
            field[level][pred(line)][column].present) <span class="op">or</span>
            (line &lt; FIELD_LINES <span class="op">and</span>
            field[level][succ(line)][column].present) <span class="keywd">then</span>
          isFree := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getAnyFreeColumn (<span class="op">in</span> <span class="type">integer</span>: level, <span class="op">in</span> <span class="type">integer</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: freeColumn <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: first <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: count <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> FIELD_COLUMNS <span class="keywd">do</span>
      <span class="keywd">if</span> field[level][line][column].used <span class="op">and</span>
          <span class="op">not</span> field[level][line][column].present <span class="keywd">then</span>
        incr(count);
        <span class="keywd">if</span> first = 0 <span class="keywd">then</span>
          first := column;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> count &lt;> 0 <span class="keywd">then</span>
      number := rand(1, count);
      <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> FIELD_COLUMNS <span class="keywd">do</span>
        <span class="keywd">if</span> field[level][line][column].used <span class="op">and</span>
            <span class="op">not</span> field[level][line][column].present <span class="keywd">then</span>
          decr(number);
          <span class="keywd">if</span> number = 0 <span class="keywd">then</span>
            freeColumn := column;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getFreeColumn (<span class="op">in</span> <span class="type">integer</span>: level, <span class="op">in</span> <span class="type">integer</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: freeColumn <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: firstPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: lastPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    firstPos := getFirstFreeColumn(level, line);
    lastPos := getLastFreeColumn(level, line);
    <span class="keywd">if</span> firstPos &lt;> 0 <span class="keywd">then</span>
      <span class="keywd">if</span> lastPos &lt;> 0 <span class="keywd">then</span>
        <span class="keywd">if</span> rand(FALSE, TRUE) <span class="keywd">then</span>
          freeColumn := firstPos;
        <span class="keywd">else</span>
          freeColumn := lastPos;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        freeColumn := firstPos;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      <span class="keywd">if</span> lastPos &lt;> 0 <span class="keywd">then</span>
        freeColumn := lastPos;
      <span class="keywd">elsif</span> lineIsFree(level, line) <span class="keywd">then</span>
        freeColumn := getAnyFreeColumn(level, line);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getFreePlaceColumn (<span class="op">in</span> <span class="type">integer</span>: level, <span class="op">in</span> <span class="type">integer</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: freePlaceColumn <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    column := getFreeColumn(level, line);
    <span class="keywd">if</span> column &lt;> 0 <span class="keywd">then</span>
      <span class="keywd">if</span>
          <span class="comment"># Piece at ground level</span>
          level = 1 <span class="op">or</span>

          <span class="comment"># Supported by one piece</span>
          field[pred(level)][line][column].present <span class="op">or</span>

          <span class="comment"># Supported by two pieces</span>
          (line > 1 <span class="op">and</span> line &lt; FIELD_LINES <span class="op">and</span>
          field[pred(level)][pred(line)][column].present <span class="op">and</span>
          field[pred(level)][succ(line)][column].present) <span class="op">or</span>
          (column > 1 <span class="op">and</span> column &lt; FIELD_COLUMNS <span class="op">and</span>
          field[pred(level)][line][pred(column)].present <span class="op">and</span>
          field[pred(level)][line][succ(column)].present) <span class="op">or</span>

          <span class="comment"># Supported by four pieces</span>
          (line > 1 <span class="op">and</span> line &lt; FIELD_LINES <span class="op">and</span>
          column > 1 <span class="op">and</span> column &lt; FIELD_COLUMNS <span class="op">and</span>
          field[pred(level)][pred(line)][pred(column)].present <span class="op">and</span>
          field[pred(level)][pred(line)][succ(column)].present <span class="op">and</span>
          field[pred(level)][succ(line)][pred(column)].present <span class="op">and</span>
          field[pred(level)][succ(line)][succ(column)].present) <span class="keywd">then</span>

        freePlaceColumn := column;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Find a free position to place a tile in the inverse game.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: getFreePlace (<span class="keywd">inout</span> <span class="type">positionType</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      pos.level := rand(1, length(field));
      pos.line := rand(1, FIELD_LINES);
      pos.column := getFreePlaceColumn(pos.level, pos.line);
    <span class="keywd">until</span> pos.column &lt;> 0;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Deals the tile 'tileNumber' to 'pos' (level, line, column).
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: dealOneTile (<span class="op">in</span> <span class="type">integer</span>: tileNumber, <span class="op">in</span> <span class="type">positionType</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    field[pos.level][pos.line][pos.column].tileNumber := tileNumber;
    field[pos.level][pos.line][pos.column].present := TRUE;
    decr(tiles[tileNumber].quantity);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Removes the tile from 'pos' (level, line, column).
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: removeOneTile (<span class="op">in</span> <span class="type">positionType</span>: pos) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: tileNumber <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    tileNumber := field[pos.level][pos.line][pos.column].tileNumber;
    field[pos.level][pos.line][pos.column].tileNumber := 0;
    field[pos.level][pos.line][pos.column].present := FALSE;
    incr(tiles[tileNumber].quantity);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Deals a pair of tiles in the inverse game.
 *  Both tiles have the same 'value'. That means they have the same
 *  symbols on them or they are both flower tiles or season tiles.
 *  The tile 'value' is randomly chosen. The places for the tiles are
 *  chosen with the getFreePlace function. It can happen that the
 *  tiles block each other. In that case the tiles are removed and
 *  the process of dealing is retried. If five attempts to deal a
 *  pair of tiles fail the inverse game fails also and the inverse
 *  game must be retried from scratch. In this case 'okay' is set to
 *  FALSE.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: dealTilePair (<span class="keywd">inout</span> <span class="type">boolean</span>: okay) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: retryCount <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">moveType</span>: move <span class="keywd">is</span> moveType.value;
    <span class="keywd">var</span> <span class="type">integer</span>: tileNumber1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: tileNumber2 <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      okay := TRUE;
      <span class="keywd">repeat</span>
        tileNumber1 := rand(1, length(tiles));
      <span class="keywd">until</span> tiles[tileNumber1].quantity > 0;
      getFreePlace(move.pos1);
      dealOneTile(tileNumber1, move.pos1);
      <span class="keywd">if</span> tiles[tileNumber1].quantity > 0 <span class="keywd">then</span>
        tileNumber2 := tileNumber1;
      <span class="keywd">else</span>
        <span class="keywd">repeat</span>
          tileNumber2 := rand(35, 42);
        <span class="keywd">until</span> tiles[tileNumber1].value = tiles[tileNumber2].value <span class="op">and</span>
            tiles[tileNumber2].quantity > 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      getFreePlace(move.pos2);
      dealOneTile(tileNumber2, move.pos2);
      <span class="keywd">if</span> <span class="op">not</span> legalMove(move.pos1) <span class="op">or</span>
          <span class="op">not</span> legalMove(move.pos2) <span class="keywd">then</span>
        removeOneTile(move.pos1);
        removeOneTile(move.pos2);
        okay := FALSE;
        incr(retryCount);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> okay <span class="op">or</span> retryCount > 5;
    demoMoves := [] (move) &amp; demoMoves;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Assigns the value and the quantity to the tiles.
 *  Two tiles are compared using the 'value'. E.g.: Two seasons and
 *  two flowers have different symbols but have the same 'value'.
 *  The 'quantity' is used when dealing the tiles to maintain how many
 *  tiles with the same symbols on them can be dealt. E.g.: The dot,
 *  bamboo, character, wind and dragon tiles have a 'quantity' of 4
 *  because in each case there are 4 tiles with the same symbols.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: initTiles <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> 34 <span class="keywd">do</span>
      tiles[number].value := number;
      tiles[number].quantity := 4;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> number <span class="keywd">range</span> 35 <span class="keywd">to</span> 38 <span class="keywd">do</span>
      tiles[number].value := 35;
      tiles[number].quantity := 1;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> number <span class="keywd">range</span> 39 <span class="keywd">to</span> 42 <span class="keywd">do</span>
      tiles[number].value := 36;
      tiles[number].quantity := 1;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Deals all tiles of a solvable game using the turtle layout.
 *  To create a solvable game an inverse game is played. The inverse
 *  game starts with an empty field and the tiles are added according
 *  to the inverse rules. If the inverse game fails it is retried
 *  from scratch until it succeeds.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: dealTiles (<span class="keywd">inout</span> <span class="type">char</span>: command) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: okay <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      okay := TRUE;
      initTiles;
      initLayout(turtleLayout);
      number := 1;
      demoMoves := 0 <span class="op">times</span> moveType.value;
      <span class="keywd">while</span> okay <span class="op">and</span> number &lt;= 72 <span class="keywd">do</span>
        dealTilePair(okay);
        <span class="keywd">if</span> inputReady(KEYBOARD) <span class="keywd">then</span>
          command := upper(getc(KEYBOARD));
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> command = KEY_ESC <span class="keywd">then</span>
          bossMode(doQuit);
          <span class="keywd">if</span> doQuit <span class="keywd">then</span>
            command := <span class="stri">'Q'</span>;
            number := 72;
          <span class="keywd">else</span>
            command := <span class="stri">' '</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        incr(number);
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">until</span> okay;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Deals tiles using the welcome layout.
 *  The tiles are dealt in a random fashion until the layout is
 *  filled. It would be pure coincidence if the resulting game is
 *  solvable.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: dealTiles2 <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">positionType</span>: pos <span class="keywd">is</span> positionType.value;
    <span class="keywd">var</span> <span class="type">integer</span>: tileNumber <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    initTiles;
    initLayout(welcomeLayout);
    <span class="keywd">for</span> pos.level <span class="keywd">range</span> 1 <span class="keywd">to</span> length(field) <span class="keywd">do</span>
      <span class="keywd">for</span> pos.line <span class="keywd">range</span> 1 <span class="keywd">to</span> FIELD_LINES <span class="keywd">do</span>
        <span class="keywd">for</span> pos.column <span class="keywd">range</span> 1 <span class="keywd">to</span> FIELD_COLUMNS <span class="keywd">do</span>
          <span class="keywd">if</span> field[pos.level][pos.line][pos.column].used <span class="keywd">then</span>
            <span class="keywd">repeat</span>
              tileNumber := rand(1, length(tiles));
            <span class="keywd">until</span> tiles[tileNumber].quantity > 0;
            dealOneTile(tileNumber, pos);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: writeCentered (<span class="keywd">inout</span> <span class="type">text</span>: screen, <span class="op">in</span> <span class="type">integer</span>: yPos, <span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    setPosXY(screen, (WINDOW_WIDTH - width(vecFont10, stri)) <span class="op">div</span> 2, yPos);
    writeln(screen, stri);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: command <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    screen(WINDOW_WIDTH, WINDOW_HEIGHT);
    selectInput(curr_win, KEY_CLOSE, TRUE);
    clear(curr_win, BACKGROUND);
    KEYBOARD := GRAPH_KEYBOARD;
    screen := openPixmapFontFile(curr_win);
    setFont(screen, vecFont10);
    color(screen, white, BACKGROUND);
    writeCentered(screen, 14, <span class="stri">"M A H J O N G"</span>);
    writeCentered(screen, 29, <span class="stri">"Copyright (C) 2007  Thomas Mertes"</span>);
    writeCentered(screen, 344, <span class="stri">"This program is free software under the terms of the GNU General Public License"</span>);
    writeCentered(screen, 359, <span class="stri">"Mahjong is written in the Seed7 programming language"</span>);
    writeCentered(screen, 374, <span class="stri">"Homepage:   http://seed7.sourceforge.net"</span>);
    flushGraphic;
    digit_pixmap := [0](
      createPixmap(zero,  2, white),
      createPixmap(one,   2, white),
      createPixmap(two,   2, white),
      createPixmap(three, 2, white),
      createPixmap(four,  2, white),
      createPixmap(five,  2, white),
      createPixmap(six,   2, white),
      createPixmap(seven, 2, white),
      createPixmap(eight, 2, white),
      createPixmap(nine,  2, white));
    dealTiles2;
    drawBoardWithFlush;
    writeCentered(screen, 700, <span class="stri">"Press any key to start game"</span>);
    dealTiles(command);
    <span class="keywd">if</span> command &lt;> <span class="stri">'Q'</span> <span class="op">and</span> <span class="op">not</span> doQuit <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        command := getCommand;
      <span class="keywd">until</span> command &lt;> KEY_ESC;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> command &lt;> <span class="stri">'Q'</span> <span class="op">and</span> <span class="op">not</span> doQuit <span class="keywd">then</span>
      clear(curr_win, BACKGROUND);
      <span class="comment"># rect(0, height(curr_win) - 80, width(curr_win), 80, BACKGROUND);</span>
      drawBoard;
      writeButtons;
      updateNumbers;
      <span class="keywd">while</span> command &lt;> <span class="stri">'Q'</span> <span class="keywd">do</span>
        <span class="keywd">repeat</span>
          playerTurn(command);
        <span class="keywd">until</span> command = <span class="stri">'N'</span> <span class="op">or</span> command = <span class="stri">'Q'</span>;
        <span class="keywd">if</span> command &lt;> <span class="stri">'N'</span> <span class="op">and</span> command &lt;> <span class="stri">'Q'</span> <span class="keywd">then</span>
          command := getCommand;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> command = <span class="stri">'N'</span> <span class="op">and</span> isOkay([] (<span class="stri">"Discard old board?"</span>)) <span class="keywd">then</span>
          dealTiles2;
          clear(curr_win, BACKGROUND);
          drawBoard;
          flushGraphic;
          dealTiles(command);
          <span class="keywd">if</span> <span class="op">not</span> doQuit <span class="keywd">then</span>
            clear(curr_win, BACKGROUND);
            drawBoard;
            writeButtons;
            moveNumber := 0;
            playerMoves := 0 <span class="op">times</span> moveType.value;
            updateNumbers;
            <span class="keywd">while</span> command &lt;> <span class="stri">'Q'</span> <span class="op">and</span> inputReady(KEYBOARD) <span class="keywd">do</span>
              command := getCommand;
            <span class="keywd">end</span> <span class="keywd">while</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> command = <span class="stri">'Q'</span> <span class="op">and</span> <span class="op">not</span> doQuit <span class="op">and</span> <span class="op">not</span> isOkay([] (<span class="stri">"Quit mahjong?"</span>)) <span class="keywd">then</span>
          command := <span class="stri">' '</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
