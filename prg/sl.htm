<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  sl.sd7        Game of Life                                      *)</span>
<span class="comment">(*  Copyright (C) 1993, 1994, 2004  Thomas Mertes                   *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/seed7_05.htm">seed7_05.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/stdio.htm">stdio.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/console.htm">console.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/window.htm">window.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/keybd.htm">keybd.s7i</a>"</span>;

<span class="keywd">const</span> <span class="type">string</span>: MARKEDFIELD <span class="keywd">is</span> <span class="stri">"#"</span>;
<span class="keywd">const</span> <span class="type">string</span>: EMPTYFIELD  <span class="keywd">is</span> <span class="stri">" "</span>;
<span class="keywd">const</span> <span class="type">integer</span>: MAXDIGITS  <span class="keywd">is</span>    7;

<span class="comment">(*
const integer: MINLINE    is  -50;
const integer: MAXLINE    is   76;
const integer: MINCOLUMN  is  -23;
const integer: MAXCOLUMN  is  104;
*)</span>
<span class="keywd">const</span> <span class="type">integer</span>: MINLINE    <span class="keywd">is</span> -114;
<span class="keywd">const</span> <span class="type">integer</span>: MAXLINE    <span class="keywd">is</span>  140;
<span class="keywd">const</span> <span class="type">integer</span>: MINCOLUMN  <span class="keywd">is</span>  -87;
<span class="keywd">const</span> <span class="type">integer</span>: MAXCOLUMN  <span class="keywd">is</span>  168;


<span class="keywd">var</span> <span class="type">text</span>: scr <span class="keywd">is</span> STD_NULL;
<span class="keywd">var</span> <span class="type">text</span>: win <span class="keywd">is</span> STD_NULL;
<span class="keywd">var</span> <span class="type">text</span>: gen_win <span class="keywd">is</span> STD_NULL;
<span class="keywd">var</span> <span class="type">text</span>: field_win <span class="keywd">is</span> STD_NULL;
<span class="keywd">var</span> <span class="type">text</span>: cmd_win <span class="keywd">is</span> STD_NULL;
<span class="keywd">var</span> <span class="type">text</span>: map_win <span class="keywd">is</span> STD_NULL;
<span class="keywd">var</span> <span class="type">text</span>: header <span class="keywd">is</span> STD_NULL;
<span class="keywd">var</span> <span class="type">text</span>: prot <span class="keywd">is</span> STD_NULL;

<span class="keywd">const</span> <span class="type">type</span>: coord <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: lin <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: col <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">coord</span>: COORD_REC <span class="keywd">is</span> coord.value;

<span class="keywd">const</span> <span class="type">type</span>: fieldlinetype <span class="keywd">is</span> <span class="type">array</span> <span class="type">boolean</span>;
<span class="keywd">const</span> <span class="type">type</span>: fieldtype <span class="keywd">is</span> <span class="type">array</span> <span class="type">fieldlinetype</span>;
<span class="keywd">const</span> <span class="type">type</span>: listtype <span class="keywd">is</span> <span class="type">array</span> <span class="type">coord</span>;

<span class="keywd">const</span> <span class="type">type</span>: workplace <span class="keywd">is</span> <span class="keywd">new</span> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">fieldtype</span>: field <span class="keywd">is</span> 0 <span class="op">times</span> 0 <span class="op">times</span> FALSE;
    <span class="keywd">var</span> <span class="type">listtype</span>: bact_list <span class="keywd">is</span> 8001 <span class="op">times</span> COORD_REC;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">workplace</span>: WORKPLACE_REC <span class="keywd">is</span> workplace.value;

<span class="keywd">var</span> <span class="type">array</span> <span class="type">workplace</span>: workspace <span class="keywd">is</span> 2 <span class="op">times</span> WORKPLACE_REC;
<span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: listlength <span class="keywd">is</span> 2 <span class="op">times</span> 0;
<span class="keywd">var</span> <span class="type">integer</span>: current <span class="keywd">is</span> 1;
<span class="keywd">var</span> <span class="type">integer</span>: next <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">integer</span>: listindex <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
<span class="keywd">var</span> <span class="type">boolean</span>: singlestep <span class="keywd">is</span> FALSE;
<span class="keywd">var</span> <span class="type">boolean</span>: quit <span class="keywd">is</span> FALSE;
<span class="keywd">var</span> <span class="type">integer</span>: generation <span class="keywd">is</span> 0;


<span class="keywd">const</span> <span class="type">proc</span>: textcolour (<span class="op">in</span> <span class="type">integer</span>: colour) <span class="keywd">is</span> noop;

<span class="keywd">const</span> <span class="type">proc</span>: setbackground (<span class="op">in</span> <span class="type">integer</span>: colour) <span class="keywd">is</span> noop;


<span class="keywd">const</span> <span class="type">proc</span>: info1 <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    clear(scr);
    setPos(win, 1, 1);
    writeln(win, <span class="stri">"                               L  I  F  E"</span>);
    writeln(win);
    writeln(win, <span class="stri">"  The original game of life was invented by mathematician John Conway. The idea"</span>);
    writeln(win, <span class="stri">"is  to  initialize  the screen with a pattern of bacteria in EDIT mode. The RUN"</span>);
    writeln(win, <span class="stri">"mode or singlestep commands then bring  life  to  the  colony.  The  population"</span>);
    writeln(win, <span class="stri">"increases  and  decreases  according  to fixed rules which affect the birth and"</span>);
    writeln(win, <span class="stri">"death of individual bacterium. A rectangular grid  (2-dimensional matrix)  will"</span>);
    writeln(win, <span class="stri">"be  shown  on  the  screen. Each cell in the grid can contain a bacterium or be"</span>);
    writeln(win, <span class="stri">"empty. Each cell has 8 neighbors. The existence of cells from one generation to"</span>);
    writeln(win, <span class="stri">"the next is determined by the following rules:"</span>);
    writeln(win);
    writeln(win, <span class="stri">"  1.  A bacteria with 2 or 3 neighbors survives from one generation to"</span>);
    writeln(win, <span class="stri">"      the next.  A bacterium with fewer neighbors dies of isolation."</span>);
    writeln(win, <span class="stri">"      One with more neighbors dies of overcrowding."</span>);
    writeln(win);
    writeln(win, <span class="stri">"  2.  An empty cell spawns a bacteria if it has exactly three"</span>);
    writeln(win, <span class="stri">"      neighboring cells which contain bacteria."</span>);
    writeln(win);
    writeln(win);
    write  (win, <span class="stri">"   Press the any key to continue "</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: info2 <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    clear(scr);
    setPos(win, 1, 1);
    writeln(win, <span class="stri">"In EDIT mode the following commands are available:"</span>);
    writeln(win);
    writeln(win, <span class="stri">"  Cursor keys  Move the cursor                  I            Show info pages"</span>);
    writeln(win, <span class="stri">"  HJKL         Move the cursor                  Q            Quit the program"</span>);
    writeln(win, <span class="stri">"  M or *       Mark a cell                      +            Scroll down"</span>);
    writeln(win, <span class="stri">"  space        Erase a cell                     -            Scroll up"</span>);
    writeln(win, <span class="stri">"  enter        Calculate next generation        &lt;            Scroll left"</span>);
    writeln(win, <span class="stri">"  B            Back to previous generation      >            Scroll right"</span>);
    writeln(win, <span class="stri">"  R            Enter the RUN mode               backspace    Erase cell left"</span>);
    writeln(win, <span class="stri">"  C            Clear the grid                   tab          Forward 8 columns"</span>);
    writeln(win, <span class="stri">"  D            Redraw the screen                shift-tab    Backward 8 columns"</span>);
    writeln(win, <span class="stri">"  G            Load (get) state from file       home         First column"</span>);
    writeln(win, <span class="stri">"  P            Save (put) state to file         end          Last column"</span>);
    writeln(win);
    writeln(win);
    writeln(win, <span class="stri">"In RUN mode the following commands are available:"</span>);
    writeln(win);
    writeln(win, <span class="stri">"  any key      to enter the EDIT mode to create or change the pattern"</span>);
    writeln(win, <span class="stri">"  Q            to Quit the game of LIFE"</span>);
    writeln(win);
    writeln(win);
    writeln(win, <span class="stri">"The EDIT and Quit commands take effect only at the end of a cycle."</span>);
    writeln(win);
    write  (win, <span class="stri">"   Press the any key to continue "</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: nextDecimal <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> generation = 999999 <span class="keywd">then</span>
      generation := 0;
    <span class="keywd">else</span>
      incr(generation);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    setPos(gen_win, 1, 1);
    write(gen_win, generation <span class="op">lpad</span> MAXDIGITS);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: writeHeader <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    clear(header);
    box(header);
    setPos(header, 2, 10);
    write(header, <span class="stri">"SCIENTIFIC LIFE  2.0"</span>);
    setPos(header, 5, 13);
    write(header, <span class="stri">"Copyright 1994"</span>);
    setPos(header, 7, 19);
    write(header, <span class="stri">"by"</span>);
    setPos(header, 9, 13);
    write(header, <span class="stri">"Thomas  Mertes"</span>);
    flush(header);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: editInfo <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    textcolour(0);
    setbackground(7);
    setPos(cmd_win, 1, 1);
    write(cmd_win, <span class="stri">" EDIT "</span>);
    textcolour(7);
    setbackground(0);
    setPos(cmd_win, 1, 7);
    write(cmd_win, <span class="stri">" I=Info, HJKL=Move, M=Mark, space=Erase, C=Clear, R=Run, Q=Quit "</span>);
    textcolour(15);
    setPos(cmd_win, 1, 8);
    write(cmd_win, <span class="stri">"I"</span>);
    setPos(cmd_win, 1, 16);
    write(cmd_win, <span class="stri">"HJKL"</span>);
    setPos(cmd_win, 1, 27);
    write(cmd_win, <span class="stri">"M"</span>);
    setPos(cmd_win, 1, 35);
    write(cmd_win, <span class="stri">"space"</span>);
    setPos(cmd_win, 1, 48);
    write(cmd_win, <span class="stri">"C"</span>);
    setPos(cmd_win, 1, 57);
    write(cmd_win, <span class="stri">"R"</span>);
    setPos(cmd_win, 1, 64);
    write(cmd_win, <span class="stri">"Q"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: clearScreen <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> listlength[current] <span class="keywd">do</span>
      setPos(field_win,
          workspace[current].bact_list[index].lin + MINLINE,
          workspace[current].bact_list[index].col + MINCOLUMN);
      write(field_win, EMPTYFIELD);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: writeScreen <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> listlength[current] <span class="keywd">do</span>
      setPos(field_win,
          workspace[current].bact_list[index].lin + MINLINE,
          workspace[current].bact_list[index].col + MINCOLUMN);
      write(field_win, MARKEDFIELD);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: writeMap (<span class="keywd">inout</span> <span class="type">text</span>: map_win) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: line_div <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column_div <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">array</span> <span class="type">integer</span>: mapfield <span class="keywd">is</span> 0 <span class="op">times</span> 0 <span class="op">times</span> 0;
  <span class="keywd">begin</span>
    mapfield := height(map_win) <span class="op">times</span> width(map_win) <span class="op">times</span> 0;
    line_div := pred(length(workspace[current].field)) <span class="op">div</span> pred(height(map_win)) ;
    column_div :=  pred(length(workspace[current].field[1])) <span class="op">div</span> pred(width(map_win));
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> listlength[current] <span class="keywd">do</span>
<span class="comment">(*    writeln(prot, "CELL(" &lt;&amp; index &lt;&amp; ", " &lt;&amp;
          workspace[current].bact_list[index].lin &lt;&amp; ", " &lt;&amp;
          workspace[current].bact_list[index].col &lt;&amp; ");"); *)</span>
      line := succ((workspace[current].bact_list[index].lin - 2) <span class="op">div</span> line_div);
      column := succ((workspace[current].bact_list[index].col - 2) <span class="op">div</span> column_div);
      <span class="keywd">if</span> line >= 1 <span class="op">and</span> line &lt;= length(mapfield) <span class="op">and</span>
          column >= 1 <span class="op">and</span> column &lt;= length(mapfield[1]) <span class="keywd">then</span>
        incr(mapfield[line][column]);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    box(map_win);
    clear(map_win);
    <span class="keywd">for</span> line <span class="keywd">range</span> 1 <span class="keywd">to</span> height(map_win) <span class="keywd">do</span>
      <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> width(map_win) <span class="keywd">do</span>
        <span class="keywd">case</span> mapfield[line][column] <span class="keywd">of</span>
          <span class="keywd">when</span> {0}:
            noop;
          <span class="keywd">when</span> {1, 2, 3, 4}:
            setPos(map_win, line, column);
            write(map_win, <span class="stri">"1"</span>);
          <span class="keywd">when</span> {5, 6, 7, 8}:
            setPos(map_win, line, column);
            write(map_win, <span class="stri">"2"</span>);
          <span class="keywd">when</span> {9, 10, 11, 12, 13}:
            setPos(map_win, line, column);
            write(map_win, <span class="stri">"3"</span>);
          <span class="keywd">when</span> {14, 15, 16, 17}:
            setPos(map_win, line, column);
            write(map_win, <span class="stri">"4"</span>);
          <span class="keywd">when</span> {18, 19, 20, 21, 22}:
            setPos(map_win, line, column);
            write(map_win, <span class="stri">"5"</span>);
          <span class="keywd">when</span> {23, 24, 25, 26}:
            setPos(map_win, line, column);
            write(map_win, <span class="stri">"6"</span>);
          <span class="keywd">when</span> {27, 28, 29, 30}:
            setPos(map_win, line, column);
            write(map_win, <span class="stri">"7"</span>);
          <span class="keywd">when</span> {31, 32, 33, 34, 35}:
            setPos(map_win, line, column);
            write(map_win, <span class="stri">"8"</span>);
          <span class="keywd">when</span> {36, 37, 38, 39}:
            setPos(map_win, line, column);
            write(map_win, <span class="stri">"9"</span>);
          <span class="keywd">when</span> {40, 41, 42, 43, 44}:
            setPos(map_win, line, column);
            write(map_win, <span class="stri">"0"</span>);
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    setPos(win,  3, 67);
    write(win, <span class="stri">"Living: "</span>);
    setPos(win,  3, 75);
    write(win, str(listlength[current]));
    setPos(win, 23, 67);
    write(win, <span class="stri">"Press a key"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: redraw <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    box(field_win);
    clear(field_win);
    editInfo();
    setPos(gen_win, 1, 1);
    write(gen_win, <span class="stri">"        "</span>);
    setPos(gen_win, 1, 1);
    write(gen_win, generation <span class="op">lpad</span> MAXDIGITS);
    writeScreen();
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: shiftField (<span class="keywd">inout</span> <span class="type">fieldtype</span>: curr_field, <span class="keywd">inout</span> <span class="type">listtype</span>: curr_list,
    <span class="op">in</span> <span class="type">integer</span>: lindiff, <span class="op">in</span> <span class="type">integer</span>: coldiff) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> listlength[current] <span class="keywd">do</span>
      line := curr_list[index].lin;
      column := curr_list[index].col;
      curr_field[line][column] := FALSE;
      setPos(field_win, line + MINLINE, column + MINCOLUMN);
      write(field_win, EMPTYFIELD);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> listlength[current] <span class="keywd">do</span>
      line := curr_list[index].lin;
      column := curr_list[index].col;
      <span class="keywd">if</span> line + lindiff >= 1 <span class="op">and</span> line + lindiff &lt;=
          length(curr_field) <span class="keywd">then</span>
        line +:= lindiff;
        curr_list[index].lin := line;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> column + coldiff >= 1 <span class="op">and</span> column + coldiff &lt;=
          length(curr_field[1]) <span class="keywd">then</span>
        column +:= coldiff;
        curr_list[index].col := column;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      curr_field[line][column] := TRUE;
      setPos(field_win, line + MINLINE, column + MINCOLUMN);
      write(field_win, MARKEDFIELD);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: mark (<span class="op">in</span> <span class="type">integer</span>: win_line, <span class="op">in</span> <span class="type">integer</span>: win_column) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> <span class="op">not</span> workspace[current].field[win_line - MINLINE][win_column - MINCOLUMN] <span class="keywd">then</span>
      workspace[current].field[win_line - MINLINE][win_column - MINCOLUMN] := TRUE;
      incr(listlength[current]);
      workspace[current].bact_list[listlength[current]].lin := win_line - MINLINE;
      workspace[current].bact_list[listlength[current]].col := win_column - MINCOLUMN;
      setPos(field_win, win_line, win_column);
      write(field_win, MARKEDFIELD);
      setPos(field_win, win_line, win_column);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: erase (<span class="op">in</span> <span class="type">integer</span>: win_line, <span class="op">in</span> <span class="type">integer</span>: win_column) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: found <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> workspace[current].field[win_line - MINLINE][win_column - MINCOLUMN] <span class="keywd">then</span>
      <span class="keywd">if</span> listlength[current] >= 1 <span class="keywd">then</span>
        found := FALSE;
        index := listlength[current];
        <span class="keywd">repeat</span>
          <span class="keywd">if</span> workspace[current].bact_list[index].lin = win_line - MINLINE <span class="op">and</span>
              workspace[current].bact_list[index].col = win_column - MINCOLUMN <span class="keywd">then</span>
            found := TRUE;
          <span class="keywd">else</span>
            decr(index);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">until</span> found <span class="op">or</span> index &lt; 1;
        <span class="keywd">if</span> found <span class="keywd">then</span>
          <span class="keywd">for</span> number <span class="keywd">range</span> index <span class="keywd">to</span> pred(listlength[current]) <span class="keywd">do</span>
            workspace[current].bact_list[number].lin := workspace[current].bact_list[succ(number)].lin;
            workspace[current].bact_list[number].col := workspace[current].bact_list[succ(number)].col;
          <span class="keywd">end</span> <span class="keywd">for</span>;
          decr(listlength[current]);
          workspace[current].field[win_line - MINLINE][win_column - MINCOLUMN] := FALSE;
          setPos(field_win, win_line, win_column);
          write(field_win, EMPTYFIELD);
          setPos(field_win, win_line, win_column);
        <span class="keywd">else</span>
          redraw();
          setPos(field_win, win_line, win_column);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: clearField <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> listlength[current] &lt;> 0 <span class="keywd">then</span>
      clearScreen();
      next := current;
      current := 3 - current;
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> listlength[current] <span class="keywd">do</span>
        workspace[current].field
            [workspace[current].bact_list[index].lin]
            [workspace[current].bact_list[index].col] := FALSE;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      listlength[current] := 0;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    generation := 0;
    setPos(gen_win, 1, 1);
    write(gen_win, generation <span class="op">lpad</span> MAXDIGITS);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readFilename (<span class="op">in</span> <span class="type">string</span>: prompt, <span class="keywd">inout</span> <span class="type">string</span>: filename) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: startPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    clear(cmd_win);
    textcolour(0);
    setbackground(7);
    setPos(cmd_win, 1, 1);
    write(cmd_win, prompt);
    textcolour(7);
    setbackground(0);
    startPos := 3 + length(prompt);
    setPos(cmd_win, 1, startPos);
    filename := <span class="stri">""</span>;
    pos := 0;
    <span class="keywd">repeat</span>
      flush(cmd_win);
      ch := getc(KEYBOARD);
      <span class="keywd">if</span> ch >= <span class="stri">' '</span> <span class="op">and</span> ch &lt;= <span class="stri">'~'</span> <span class="keywd">then</span>
        <span class="keywd">if</span> pos &lt;= 50 <span class="keywd">then</span>
          incr(pos);
          filename := filename &amp; str(ch);
          setPos(cmd_win, 1, startPos + pos - 1);
          write(cmd_win, filename[pos]);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> ch = <span class="stri">'\b'</span> <span class="keywd">then</span>  <span class="comment"># Backspace</span>
        <span class="keywd">if</span> pos >= 1 <span class="keywd">then</span>
          decr(pos);
          filename := filename[ .. pos];
          setPos(cmd_win, 1, startPos + pos);
          write(cmd_win, <span class="stri">" "</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      setPos(cmd_win, 1, startPos + pos);
    <span class="keywd">until</span> ch = <span class="stri">'\n'</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: load (<span class="op">in</span> <span class="type">string</span>: filename) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">file</span>: loadfile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: startcolumn <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    loadfile := open(filename, <span class="stri">"r"</span>);
    <span class="keywd">if</span> loadfile &lt;> STD_NULL <span class="keywd">then</span>
      clear(field_win);
      ch := getc(loadfile);
      <span class="keywd">if</span> ch = <span class="stri">'+'</span> <span class="keywd">then</span>
        read(loadfile, generation);
        read(loadfile, line);
        read(loadfile, startcolumn);
        line -:= pred(MINLINE);
        startcolumn -:= MINCOLUMN;
        <span class="keywd">if</span> line &lt; 1 <span class="keywd">then</span>
          line := 1;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> startcolumn &lt; 1 <span class="keywd">then</span>
          startcolumn := 1;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        ch := getc(loadfile);
      <span class="keywd">else</span>
        line := 1 - MINLINE;
        startcolumn := 1 - MINCOLUMN;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      index := 0;
      <span class="keywd">while</span> <span class="op">not</span> eof(loadfile) <span class="op">and</span> line &lt;= MAXLINE - MINLINE - 1 <span class="keywd">do</span>
        column := startcolumn;
        <span class="keywd">while</span> ch &lt;> <span class="stri">'\n'</span> <span class="keywd">do</span>
          <span class="keywd">if</span> ch &lt;> <span class="stri">' '</span> <span class="op">and</span> ch &lt;> <span class="stri">'\r'</span> <span class="op">and</span>
              column &lt;= MAXCOLUMN - MINCOLUMN - 1 <span class="keywd">then</span>
            workspace[current].field[line][column] := TRUE;
            incr(index);
            workspace[current].bact_list[index].lin := line;
            workspace[current].bact_list[index].col := column;
            setPos(field_win, line + MINLINE, column + MINCOLUMN);
            write(field_win, MARKEDFIELD);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          incr(column);
          ch := getc(loadfile);
        <span class="keywd">end</span> <span class="keywd">while</span>;
        incr(line);
        ch := getc(loadfile);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      listlength[current] := index;
      setPos(gen_win, 1, 1);
      write(gen_win, generation <span class="op">lpad</span> MAXDIGITS);
      close(loadfile);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: save (<span class="op">in</span> <span class="type">string</span>: filename) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">file</span>: savefile <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: startline <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: startcolumn <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: stopline <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: stopcolumn <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: end_of_current_line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">coord</span>: current_element <span class="keywd">is</span> COORD_REC;
  <span class="keywd">begin</span>
    savefile := open(filename, <span class="stri">"w"</span>);
    <span class="keywd">if</span> savefile &lt;> STD_NULL <span class="keywd">then</span>
      startline := MAXLINE;
      startcolumn := MAXCOLUMN;
      stopline := MINLINE;
      stopcolumn := MINCOLUMN;
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> listlength[current] <span class="keywd">do</span>
        current_element := workspace[current].bact_list[index];
        <span class="keywd">if</span> current_element.lin &lt; startline <span class="keywd">then</span>
          startline := current_element.lin;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> current_element.col &lt; startcolumn <span class="keywd">then</span>
          startcolumn := current_element.col;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> current_element.lin > stopline <span class="keywd">then</span>
          stopline := current_element.lin;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> current_element.col > stopcolumn <span class="keywd">then</span>
          stopcolumn := current_element.col;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      writeln(savefile, <span class="stri">"+ "</span> &lt;&amp; generation &lt;&amp; <span class="stri">" "</span> &lt;&amp;
          startline + MINLINE - 1 &lt;&amp; <span class="stri">" "</span> &lt;&amp; startcolumn + MINCOLUMN);
      <span class="keywd">for</span> line <span class="keywd">range</span> startline <span class="keywd">to</span> stopline <span class="keywd">do</span>
        end_of_current_line := stopcolumn;
        <span class="keywd">while</span> end_of_current_line >= startcolumn <span class="op">and</span>
            <span class="op">not</span> workspace[current].field[line][end_of_current_line] <span class="keywd">do</span>
          decr(end_of_current_line);
        <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">for</span> column <span class="keywd">range</span> startcolumn <span class="keywd">to</span> end_of_current_line <span class="keywd">do</span>
          <span class="keywd">if</span> workspace[current].field[line][column] <span class="keywd">then</span>
            write(savefile, <span class="stri">"#"</span>);
          <span class="keywd">else</span>
            write(savefile, <span class="stri">" "</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
        writeln(savefile);
      <span class="keywd">end</span> <span class="keywd">for</span>;
      close(savefile);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: pressakey <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := gets(KEYBOARD, 1);
    <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      <span class="keywd">if</span> stri[1] = <span class="stri">'Q'</span> <span class="op">or</span> stri[1] = <span class="stri">'q'</span> <span class="keywd">then</span>
        quit := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(** Function to get and display a pattern.
 *  Instructions are written in line 25.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: editmode (<span class="keywd">inout</span> <span class="type">boolean</span>: quit) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: endEdit <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: backstep <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: win_line <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: win_column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: oldgeneration <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: help <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: filename <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    editInfo();
    singlestep := FALSE;
    win_line := 12;
    win_column := 39;
    setPos(field_win, win_line, win_column);
    oldgeneration := 0;
    backstep := FALSE;
    endEdit := FALSE;
    <span class="keywd">repeat</span>
      flush(field_win);
      ch := getc(KEYBOARD);
      <span class="keywd">case</span> ch <span class="keywd">of</span>
        <span class="keywd">when</span> {<span class="stri">'H'</span>, <span class="stri">'h'</span>, KEY_LEFT}:   <span class="comment"># Left</span>
          <span class="keywd">if</span> win_column > 1 <span class="keywd">then</span>
            decr(win_column);
            setPos(field_win, win_line, win_column);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'J'</span>, <span class="stri">'j'</span>, KEY_DOWN}:   <span class="comment"># Down</span>
          <span class="keywd">if</span> win_line &lt; height(field_win) <span class="keywd">then</span>
            incr(win_line);
            setPos(field_win, win_line, win_column);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'K'</span>, <span class="stri">'k'</span>, KEY_UP}:     <span class="comment"># Up</span>
          <span class="keywd">if</span> win_line > 1 <span class="keywd">then</span>
            decr(win_line);
            setPos(field_win, win_line, win_column);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'L'</span>, <span class="stri">'l'</span>, KEY_RIGHT}:  <span class="comment"># Right</span>
          <span class="keywd">if</span> win_column &lt; width(field_win) <span class="keywd">then</span>
            incr(win_column);
            setPos(field_win, win_line, win_column);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">' '</span>}:    <span class="comment"># Space</span>
          erase(win_line, win_column);
          <span class="keywd">if</span> win_column &lt; width(field_win) <span class="keywd">then</span>
            incr(win_column);
            setPos(field_win, win_line, win_column);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'\b'</span>}:   <span class="comment"># Backspace</span>
          <span class="keywd">if</span> win_column > 1 <span class="keywd">then</span>
            decr(win_column);
            setPos(field_win, win_line, win_column);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          erase(win_line, win_column);
        <span class="keywd">when</span> {KEY_DEL}:  <span class="comment"># Del</span>
          erase(win_line, win_column);
        <span class="keywd">when</span> {<span class="stri">'\t'</span>}:     <span class="comment"># Tab</span>
          <span class="keywd">if</span> win_column + 8 &lt; width(field_win) <span class="keywd">then</span>
            win_column +:= 8;
          <span class="keywd">else</span>
            win_column := width(field_win);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          setPos(field_win, win_line, win_column);
        <span class="keywd">when</span> {KEY_BACKTAB}:  <span class="comment"># Backtab</span>
          <span class="keywd">if</span> win_column - 8 > 1 <span class="keywd">then</span>
            win_column := win_column - 8;
          <span class="keywd">else</span>
            win_column := 1;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          setPos(field_win, win_line, win_column);
        <span class="keywd">when</span> {KEY_HOME}:  <span class="comment"># Home</span>
          win_column := 1;
          setPos(field_win, win_line, win_column);
        <span class="keywd">when</span> {KEY_END}:   <span class="comment"># End</span>
          win_column := width(field_win);
          setPos(field_win, win_line, win_column);
        <span class="keywd">when</span> {<span class="stri">'+'</span>, KEY_SFT_F1}:  <span class="comment"># Shift-F1</span>
          shiftField(workspace[current].field,
              workspace[current].bact_list, 1, 0);
          setPos(field_win, win_line, win_column);
        <span class="keywd">when</span> {<span class="stri">'-'</span>, KEY_SFT_F2}:  <span class="comment"># Shift-F2</span>
          shiftField(workspace[current].field,
              workspace[current].bact_list, -1, 0);
          setPos(field_win, win_line, win_column);
        <span class="keywd">when</span> {<span class="stri">'>'</span>, KEY_SFT_F3}:  <span class="comment"># Shift-F3</span>
          shiftField(workspace[current].field,
              workspace[current].bact_list, 0, 1);
          setPos(field_win, win_line, win_column);
        <span class="keywd">when</span> {<span class="stri">'&lt;'</span>, KEY_SFT_F4}:  <span class="comment"># Shift-F4</span>
          shiftField(workspace[current].field,
              workspace[current].bact_list, 0, -1);
          setPos(field_win, win_line, win_column);
        <span class="keywd">when</span> {KEY_NL}:  <span class="comment"># Enter</span>
          endEdit := TRUE;
          singlestep := TRUE;
        <span class="keywd">when</span> {<span class="stri">'M'</span>, <span class="stri">'m'</span>, <span class="stri">'*'</span>}:
          mark(win_line, win_column);
          <span class="keywd">if</span> win_column &lt; width(field_win) <span class="keywd">then</span>
            incr(win_column);
            setPos(field_win, win_line, win_column);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'R'</span>, <span class="stri">'r'</span>}:
          endEdit := TRUE;
        <span class="keywd">when</span> {<span class="stri">'D'</span>, <span class="stri">'d'</span>}:
          redraw();
          setPos(field_win, win_line, win_column);
        <span class="keywd">when</span> {<span class="stri">'C'</span>, <span class="stri">'c'</span>}:
          <span class="keywd">if</span> listlength[current] &lt;> 0 <span class="keywd">then</span>
            oldgeneration := generation;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          clearField;
          win_line := 12;
          win_column := 39;
          setPos(field_win, win_line, win_column);
        <span class="keywd">when</span> {<span class="stri">'B'</span>, <span class="stri">'b'</span>}:
          clearScreen();
          next := current;
          current := 3 - current;
          <span class="keywd">if</span> <span class="op">not</span> backstep <span class="keywd">then</span>
            backstep := TRUE;
            <span class="keywd">if</span> generation = 0 <span class="keywd">then</span>
              help := generation;
              generation := oldgeneration;
              oldgeneration := help;
            <span class="keywd">else</span>
              oldgeneration := generation;
              decr(generation);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            help := generation;
            generation := oldgeneration;
            oldgeneration := help;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          writeScreen();
          setPos(gen_win, 1, 1);
          write(gen_win, generation <span class="op">lpad</span> MAXDIGITS);
          setPos(field_win, win_line, win_column);
        <span class="keywd">when</span> {<span class="stri">'O'</span>, <span class="stri">'o'</span>}:
          writeMap(map_win);
          pressakey();
          <span class="keywd">if</span> <span class="op">not</span> quit <span class="keywd">then</span>
            redraw();
            setPos(field_win, win_line, win_column);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'I'</span>, <span class="stri">'i'</span>}:
          info1();
          setPos(win, 1, 1);
          pressakey();
          <span class="keywd">if</span> <span class="op">not</span> quit <span class="keywd">then</span>
            info2();
            setPos(win, 1, 1);
            pressakey();
            <span class="keywd">if</span> <span class="op">not</span> quit <span class="keywd">then</span>
              redraw();
              setPos(field_win, win_line, win_column);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">when</span> {<span class="stri">'P'</span>, <span class="stri">'p'</span>}:
          readFilename(<span class="stri">"SAVE?"</span>, filename);
          <span class="keywd">if</span> filename &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            save(filename);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          editInfo();
          setPos(field_win, win_line, win_column);
        <span class="keywd">when</span> {<span class="stri">'G'</span>, <span class="stri">'g'</span>}:
          readFilename(<span class="stri">"LOAD?"</span>, filename);
          <span class="keywd">if</span> filename &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            load(filename);
          <span class="keywd">end</span> <span class="keywd">if</span>;
          editInfo();
          setPos(field_win, win_line, win_column);
        <span class="keywd">when</span> {<span class="stri">'Q'</span>, <span class="stri">'q'</span>}:
          quit := TRUE;
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">until</span> endEdit <span class="op">or</span> quit;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: runinfo <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    textcolour(0);
    setbackground(7);
    setPos(cmd_win, 1, 1);
    write(cmd_win, <span class="stri">" RUN "</span>);
    textcolour(7);
    setbackground(0);
    setPos(cmd_win, 1, 6);
    write(cmd_win, <span class="stri">" Q=Quit, any key=Edit -------------------------------------------"</span>);
    textcolour(15);
    setPos(cmd_win, 1, 7);
    write(cmd_win, <span class="stri">"Q"</span>);
    setPos(cmd_win, 1, 15);
    write(cmd_win, <span class="stri">"any key"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    workspace[1].field :=
        1 <span class="op">times</span>
        MAXCOLUMN - MINCOLUMN + 1 <span class="op">times</span> TRUE &amp;
        (MAXLINE - MINLINE - 1) <span class="op">times</span>
        (1 <span class="op">times</span> TRUE &amp; MAXCOLUMN - MINCOLUMN - 1 <span class="op">times</span> FALSE &amp; 1 <span class="op">times</span> TRUE) &amp;
        1 <span class="op">times</span>
        MAXCOLUMN - MINCOLUMN + 1 <span class="op">times</span> TRUE;
    workspace[2].field := workspace[1].field;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: markcell (<span class="op">in</span> <span class="type">integer</span>: line, <span class="op">in</span> <span class="type">integer</span>: column, <span class="keywd">inout</span> <span class="type">fieldtype</span>: nextfield, <span class="keywd">inout</span> <span class="type">listtype</span>: nextlist) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
<span class="comment">(*  writeln(prot, "mark(" &lt;&amp; line &lt;&amp; ", " &lt;&amp; column &lt;&amp; ");"); *)</span>
    incr(listindex);
    nextlist[listindex].lin := line;
    nextlist[listindex].col := column;
    nextfield[line][column] := TRUE;
    setPos(field_win, line + MINLINE, column + MINCOLUMN);
    write(field_win, MARKEDFIELD);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: nextgeneration (<span class="op">in</span> <span class="type">fieldtype</span>: currfield, <span class="keywd">inout</span> <span class="type">fieldtype</span>: nextfield,
    <span class="op">in</span> <span class="type">listtype</span>: currlist, <span class="keywd">inout</span> <span class="type">listtype</span>: nextlist) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: neighbors <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: cell1 <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: cell2 <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: cell3 <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: cell4 <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: cell5 <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: cell6 <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: cell7 <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: cell33 <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: cell55 <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="comment"># Zero out last generation</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> listlength[next] <span class="keywd">do</span>
      nextfield[nextlist[index].lin][nextlist[index].col] := FALSE;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    listindex := 0;

    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> listlength[current] <span class="keywd">do</span>
      line := currlist[index].lin;
      column := currlist[index].col;

<span class="comment">(*    writeln(prot, "DO(" &lt;&amp; index &lt;&amp; ", " &lt;&amp; line &lt;&amp; ", " &lt;&amp; column &lt;&amp; ");"); *)</span>

      cell2 := currfield[pred(line)][succ(column)];
      cell3 := currfield[line][succ(column)];
      cell4 := currfield[succ(line)][succ(column)];
      cell5 := currfield[succ(line)][column];
      cell6 := currfield[succ(line)][pred(column)];
      cell7 := currfield[line][pred(column)];
      cell33 := currfield[line][column + 2];
      cell55 := currfield[line + 2][column];

      <span class="comment"># Consider each of the cells neighbors:</span>

      <span class="comment"># neighbor 1 at pred(line), column</span>
      <span class="keywd">if</span> currfield[pred(line)][column] <span class="keywd">then</span>
        cell1 := TRUE;
        neighbors := 1;
      <span class="keywd">else</span>
        cell1 := FALSE;
        neighbors := 0;
        <span class="keywd">if</span> (ord(cell2) + ord(cell3) + ord(cell7) +
            ord(currfield[pred(line)][pred(column)]) +
            ord(currfield[line - 2][pred(column)]) +
            ord(currfield[line - 2][column]) +
            ord(currfield[line - 2][succ(column)])) = 2 <span class="keywd">then</span>
          markcell(pred(line), column, nextfield, nextlist);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;

      <span class="comment"># neighbor 2 at pred(line), succ(column)</span>
      <span class="keywd">if</span> cell2 <span class="keywd">then</span>
        incr(neighbors);
      <span class="keywd">else</span>
        <span class="keywd">if</span> <span class="op">not</span> cell3 <span class="keywd">then</span>
          <span class="keywd">if</span> (ord(cell1) + ord(cell33) +
              ord(currfield[line - 2][column]) +
              ord(currfield[line - 2][succ(column)]) +
              ord(currfield[line - 2][column + 2]) +
              ord(currfield[pred(line)][column + 2])) = 2 <span class="keywd">then</span>
            markcell(pred(line), succ(column), nextfield, nextlist);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;

      <span class="comment"># neighbor 3 at line, succ(column)</span>
      <span class="keywd">if</span> cell3 <span class="keywd">then</span>
        incr(neighbors);
      <span class="keywd">else</span>
        <span class="keywd">if</span> <span class="op">not</span> (cell4 <span class="op">or</span> cell5) <span class="keywd">then</span>
          <span class="keywd">if</span> (ord(cell1) + ord(cell2) + ord(cell33) +
              ord(currfield[succ(line)][column + 2]) +
              ord(currfield[pred(line)][column + 2])) = 2 <span class="keywd">then</span>
            markcell(line, succ(column), nextfield, nextlist);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;

      <span class="comment"># neighbor 4 at succ(line), succ(column)</span>
      <span class="keywd">if</span> cell4 <span class="keywd">then</span>
        incr(neighbors);
      <span class="keywd">else</span>
        <span class="keywd">if</span> <span class="op">not</span> (cell5 <span class="op">or</span> cell55 <span class="op">or</span>
            currfield[line + 2][succ(column)]) <span class="keywd">then</span>
          <span class="keywd">if</span> (ord(currfield[line + 2][column + 2]) +
              ord(cell3) + ord(cell33) +
              ord(currfield[succ(line)][column + 2])) = 2 <span class="keywd">then</span>
            markcell(succ(line), succ(column), nextfield, nextlist);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;

      <span class="comment"># neighbor 5 at succ(line), column</span>
      <span class="keywd">if</span> cell5 <span class="keywd">then</span>
        incr(neighbors);
      <span class="keywd">else</span>
        <span class="keywd">if</span> <span class="op">not</span> (cell6 <span class="op">or</span> cell7 <span class="op">or</span> cell55 <span class="op">or</span>
            currfield[line + 2][pred(column)]) <span class="keywd">then</span>
          <span class="keywd">if</span> (ord(cell3) + ord(cell4) +
              ord(currfield[line + 2][succ(column)])) = 2 <span class="keywd">then</span>
            markcell(succ(line), column, nextfield, nextlist);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;

      <span class="comment"># neighbor 6 at succ(line), pred(column)</span>
      <span class="keywd">if</span> cell6 <span class="keywd">then</span>
        incr(neighbors);
      <span class="keywd">else</span>
        <span class="keywd">if</span> cell5 <span class="op">and</span> cell55 <span class="keywd">then</span>
          <span class="keywd">if</span> <span class="op">not</span> (cell7 <span class="op">or</span> currfield[line + 2][pred(column)] <span class="op">or</span>
              currfield[line + 2][column - 2] <span class="op">or</span>
              currfield[succ(line)][column - 2] <span class="op">or</span>
              currfield[line][column - 2]) <span class="keywd">then</span>
            markcell(succ(line), pred(column), nextfield, nextlist);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;

      <span class="comment"># neighbor 7 at line, pred(column) and</span>
      <span class="comment"># neighbor 8 at pred(line), pred(column) need no check</span>

      neighbors := neighbors + ord(cell7) +
          ord(currfield[pred(line)][pred(column)]);
      <span class="keywd">if</span> neighbors &lt;> 2 <span class="op">and</span> neighbors &lt;> 3 <span class="keywd">then</span>
        <span class="comment"># Cell dies</span>
<span class="comment">(*      writeln(prot, "DIE(" &lt;&amp; line &lt;&amp; ", " &lt;&amp; column &lt;&amp; ");"); *)</span>
        setPos(field_win, line + MINLINE, column + MINCOLUMN);
        write(field_win, EMPTYFIELD);
      <span class="keywd">else</span>
        <span class="comment"># Cell lives</span>
<span class="comment">(*      writeln(prot, "LIVE(" &lt;&amp; line &lt;&amp; ", " &lt;&amp; column &lt;&amp; ");"); *)</span>
        incr(listindex);
        nextlist[listindex].lin := line;
        nextlist[listindex].col := column;
        nextfield[line][column] := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    listlength[next] := listindex;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    scr := open(CONSOLE);
    cursor(scr, TRUE);
    win := openWindow(scr, 1, 1, 25, 80);
    field_win := openWindow(scr, 2, 2, 23, 78);
    gen_win := openWindow(scr, 1, 3, 1, 8);
    cmd_win := openWindow(scr, 25, 2, 1, 78);
    map_win := openWindow(scr, 2, 2, 23, 63);
    header := openWindow(scr, 6, 21, 10, 38);
    prot := openWindow(scr, 2, 2, 22, 20);
    writeHeader();
    quit := FALSE;
    current := 1;
    next := 2;
    listlength[1] := 0;
    listlength[2] := 0;
    init();
    box(field_win);
    clear(field_win);
    generation := 0;
    clear(gen_win);
    setPos(gen_win, 1, 1);
    write(gen_win, generation <span class="op">lpad</span> MAXDIGITS &lt;&amp; <span class="stri">" "</span>);
    editmode(quit);
    <span class="keywd">if</span> <span class="op">not</span> quit <span class="keywd">then</span>
      runinfo();
      <span class="keywd">repeat</span>
        <span class="keywd">if</span> singlestep <span class="keywd">then</span>
          nextDecimal();
          nextgeneration(workspace[current].field, workspace[next].field,
              workspace[current].bact_list, workspace[next].bact_list);
          next := current;
          current := 3 - current;
          ch := KEY_NONE;
        <span class="keywd">else</span>
          cursor(scr, FALSE);
          <span class="keywd">repeat</span>
            nextDecimal();
            nextgeneration(workspace[current].field, workspace[next].field,
                workspace[current].bact_list, workspace[next].bact_list);
            next := current;
            current := 3 - current;
            ch := getc(KEYBOARD, NO_WAIT);
          <span class="keywd">until</span> ch &lt;> KEY_NONE;
          cursor(scr, TRUE);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> ch = KEY_NONE <span class="keywd">then</span>
          ch := <span class="stri">'E'</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> singlestep <span class="keywd">then</span>
          <span class="keywd">if</span> ch &lt;> <span class="stri">'\r'</span> <span class="keywd">then</span>
            editmode(quit);
            runinfo();
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          <span class="keywd">if</span> ch &lt;> <span class="stri">'Q'</span> <span class="op">and</span> ch &lt;> <span class="stri">'q'</span> <span class="keywd">then</span>
            editmode(quit);
            runinfo();
          <span class="keywd">else</span>
            quit := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> quit;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    clear(scr);
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
