<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  zstd.s7i      Zstandard compression support library             *)</span>
<span class="comment">(*  Copyright (C) 2020  Thomas Mertes                               *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/bytedata.htm">bytedata.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/bitdata.htm">bitdata.s7i</a>"</span>;


<span class="keywd">const</span> <span class="type">string</span>: ZSTD_MAGIC <span class="keywd">is</span> <span class="stri">"(\16#B5;/\16#FD;"</span>;


<span class="keywd">const</span> <span class="type">type</span>: zstdFrameHeader <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: frameContentSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: windowSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: dictionaryId <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: contentChecksumFlag <span class="keywd">is</span> FALSE;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: zstdWindowSize (<span class="op">in</span> <span class="type">integer</span>: exponent, <span class="op">in</span> <span class="type">integer</span>: mantissa) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: windowSize <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: windowBase <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: windowAdd <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    windowBase := 1 &lt;&lt; (10 + exponent);
    windowAdd := (windowBase <span class="op">mdiv</span> 8) * mantissa;
    windowSize := windowBase + windowAdd;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readFrameHeader (<span class="keywd">inout</span> <span class="type">file</span>: compressed, <span class="keywd">inout</span> <span class="type">zstdFrameHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: descriptor <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: fcsFieldSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: singleSegmentFlag <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: dictionaryIdFlag <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: dictionaryIdFieldSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: windowDescriptor <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    descriptor := ord(getc(compressed));
    <span class="comment"># writeln("descriptor: " &lt;&amp; descriptor);</span>
    <span class="keywd">case</span> (descriptor >> 6) <span class="op">mod</span> 4 <span class="keywd">of</span>
      <span class="keywd">when</span> {0}: fcsFieldSize := (descriptor >> 5) <span class="op">mod</span> 2;
      <span class="keywd">when</span> {1}: fcsFieldSize := 2;
      <span class="keywd">when</span> {2}: fcsFieldSize := 4;
      <span class="keywd">when</span> {3}: fcsFieldSize := 8;
    <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="comment"># writeln("fcsFieldSize: " &lt;&amp; fcsFieldSize);</span>
    singleSegmentFlag := odd(descriptor >> 5);
    header.contentChecksumFlag := odd(descriptor >> 2);
    <span class="comment"># writeln("contentChecksumFlag: " &lt;&amp; header.contentChecksumFlag);</span>
    dictionaryIdFlag := descriptor <span class="op">mod</span> 4;
    <span class="keywd">if</span> dictionaryIdFlag = 3 <span class="keywd">then</span>
      dictionaryIdFieldSize := 4;
    <span class="keywd">else</span>
      dictionaryIdFieldSize := dictionaryIdFlag;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> <span class="op">not</span> singleSegmentFlag <span class="keywd">then</span>
      windowDescriptor := ord(getc(compressed));
      <span class="comment"># writeln("windowDescriptor: " &lt;&amp; windowDescriptor);</span>
      header.windowSize := zstdWindowSize(windowDescriptor >> 3, windowDescriptor <span class="op">mod</span> 8);
      <span class="comment"># writeln("windowSize: " &lt;&amp; header.windowSize);</span>
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> dictionaryIdFieldSize &lt;> 0 <span class="keywd">then</span>
      header.dictionaryId := bytes2Int(gets(compressed, dictionaryIdFieldSize), UNSIGNED, LE);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="comment"># writeln("dictionaryId: " &lt;&amp; header.dictionaryId);</span>
    <span class="keywd">case</span> fcsFieldSize <span class="keywd">of</span>
      <span class="keywd">when</span> {0}: header.frameContentSize := -1;
      <span class="keywd">when</span> {1}: header.frameContentSize := ord(getc(compressed));
      <span class="keywd">when</span> {2}: header.frameContentSize := 256 + bytes2Int(gets(compressed, 2), UNSIGNED, LE);
      <span class="keywd">when</span> {4}: header.frameContentSize := bytes2Int(gets(compressed, 4), UNSIGNED, LE);
      <span class="keywd">when</span> {8}: header.frameContentSize := bytes2Int(gets(compressed, 8), UNSIGNED, LE);
    <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="comment"># writeln("frameContentSize: " &lt;&amp; header.frameContentSize);</span>
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment"># FSE means Finite State Entropy. It refers to an entropy codec.</span>
<span class="comment"># FSE encoding/decoding involves a state that is carried over between symbols.</span>
<span class="comment"># Decoding must be done in the opposite direction as encoding.</span>
<span class="comment"># Therefore, all FSE bitstreams are read from end to beginning.</span>

<span class="keywd">const</span> <span class="type">type</span>: fseValueMap <span class="keywd">is</span> <span class="type">hash</span> <span class="type">[</span><span class="type">integer</span><span class="type">]</span> <span class="type">integer</span>;

<span class="keywd">const</span> <span class="type">type</span>: fseWeightsType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: accuracyLog <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">fseValueMap</span>: fseValues <span class="keywd">is</span> fseValueMap.value;  <span class="comment"># probability = value - 1</span>
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: fseTableEntry <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: baseline <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: numberOfAdditionalBits <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: numberOfBits <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: symbol <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: fseDecodingType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: accuracyLog <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">fseTableEntry</span>: decodingTable <span class="keywd">is</span> 0 <span class="op">times</span> fseTableEntry.value;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">fseWeightsType</span>: getFseCompressedHuffmanWeights (<span class="keywd">inout</span> <span class="type">file</span>: compressed) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fseWeightsType</span>: fseWeights <span class="keywd">is</span> fseWeightsType.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: bitPos <span class="keywd">is</span> 8;
    <span class="keywd">var</span> <span class="type">integer</span>: remainingProbabilities <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: currentSymbol <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bitsNeeded <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: value <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: thresh <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: probability <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: skip <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    fseWeights.accuracyLog := getBitsLsb(compressed, bitPos, 4) + 5;
    remainingProbabilities := 1 &lt;&lt; fseWeights.accuracyLog;

    <span class="keywd">while</span> remainingProbabilities > 0 <span class="keywd">do</span>
      bitsNeeded := log2(succ(remainingProbabilities));
      value := getBitsLsb(compressed, bitPos, bitsNeeded);
      thresh := (1 &lt;&lt; succ(bitsNeeded)) - 1 - (remainingProbabilities + 1);
      <span class="keywd">if</span> value >= thresh <span class="keywd">then</span>
        value +:= getBitLsb(compressed, bitPos) &lt;&lt; bitsNeeded;
        <span class="keywd">if</span> value >= 1 &lt;&lt; bitsNeeded <span class="keywd">then</span>
          value -:= thresh;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;

      fseWeights.fseValues @:= [currentSymbol] value;
      incr(currentSymbol);

      probability := value - 1;
      <span class="keywd">if</span> probability = -1 <span class="keywd">then</span>
         <span class="comment"># Counts as 1 because it will get one cell in the decoding table.</span>
        decr(remainingProbabilities);
      <span class="keywd">else</span>
        remainingProbabilities -:= probability;
      <span class="keywd">end</span> <span class="keywd">if</span>;

      <span class="keywd">if</span> probability = 0 <span class="keywd">then</span>
        <span class="comment"># The next two bits specify how many symbols following have probability 0 too.</span>
        <span class="keywd">repeat</span>
          skip := getBitsLsb(compressed, bitPos, 2);
          <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> skip <span class="keywd">do</span>
            <span class="comment"># Does not count into remainingProbabilities because probability = 0</span>
            fseWeights.fseValues @:= [currentSymbol] 1;  <span class="comment"># value = probability + 1</span>
            incr(currentSymbol);
          <span class="keywd">end</span> <span class="keywd">for</span>;
        <span class="keywd">until</span> skip &lt;> 3;  <span class="comment"># As long as skip = 3 the next two bits specify how many symbols to skip.</span>
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;

    <span class="keywd">if</span> remainingProbabilities &lt;> 0 <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">fseDecodingType</span>: buildDecodingTable (<span class="op">in</span> <span class="type">fseWeightsType</span>: fseWeights) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fseDecodingType</span>: fseDecoding <span class="keywd">is</span> fseDecodingType.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: nextStateOfSymbol <span class="keywd">is</span> 0 <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: tableSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: highPosition <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: symbol <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: probability <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: position <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: nextState <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    nextStateOfSymbol := [0 .. length(fseWeights.fseValues)] <span class="op">times</span> 0;

    tableSize := 1 &lt;&lt; fseWeights.accuracyLog;
    fseDecoding.accuracyLog := fseWeights.accuracyLog;
    fseDecoding.decodingTable := [0 .. pred(tableSize)] <span class="op">times</span> fseTableEntry.value;
    highPosition := pred(tableSize);
    <span class="comment"># Find all symbols with a probability of -1.</span>
    <span class="comment"># This is a special probability that means: Less than 1.</span>
    <span class="keywd">for</span> symbol <span class="keywd">range</span> sort(keys(fseWeights.fseValues)) <span class="keywd">do</span>
      probability := fseWeights.fseValues[symbol] - 1;
      <span class="keywd">if</span> probability = -1 <span class="keywd">then</span>
        <span class="comment"># Symbols with this probability get a single cell at the end of the table.</span>
        fseDecoding.decodingTable[highPosition].symbol := symbol;
        decr(highPosition);
        <span class="comment"># These symbols define a full state reset, reading accuracyLog bits.</span>
        nextStateOfSymbol[symbol] := 1;
      <span class="keywd">else</span>
        nextStateOfSymbol[symbol] := probability;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;

    <span class="comment"># All remaining symbols are allocated in their natural order.</span>
    <span class="keywd">for</span> symbol <span class="keywd">range</span> sort(keys(fseWeights.fseValues)) <span class="keywd">do</span>
      probability := fseWeights.fseValues[symbol] - 1;
      <span class="keywd">if</span> probability > 0 <span class="keywd">then</span>
        <span class="comment"># Each symbol gets allocated as many cells as its probability.</span>
        <span class="keywd">for</span> probability <span class="keywd">do</span>
          fseDecoding.decodingTable[position].symbol := symbol;
          <span class="keywd">repeat</span>
            <span class="comment"># The cell allocation is spread following this rule:</span>
            position +:= (tableSize >> 1) + (tableSize >> 3) + 3;
            position := position <span class="op">mod</span> tableSize;
            <span class="comment"># Skip positions occupied by a "less than 1" probability symbol.</span>
          <span class="keywd">until</span> position &lt;= highPosition;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;

    <span class="keywd">if</span> position &lt;> 0 <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">for</span> <span class="keywd">key</span> index <span class="keywd">range</span> fseDecoding.decodingTable <span class="keywd">do</span>
        symbol := fseDecoding.decodingTable[index].symbol;
        nextState := nextStateOfSymbol[symbol];
        incr(nextStateOfSymbol[symbol]);
        fseDecoding.decodingTable[index].numberOfBits := fseWeights.accuracyLog - log2(nextState);
        fseDecoding.decodingTable[index].baseline :=
            (nextState &lt;&lt; fseDecoding.decodingTable[index].numberOfBits) - tableSize;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">fseDecodingType</span>: repeatingFseDecodingTable (<span class="op">in</span> <span class="type">integer</span>: symbol,
    <span class="op">in</span> <span class="type">integer</span>: numberOfAdditionalBits) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fseDecodingType</span>: fseDecoding <span class="keywd">is</span> fseDecodingType.value;
  <span class="keywd">begin</span>
    fseDecoding.decodingTable := [0 .. 0] <span class="op">times</span> fseTableEntry.value;
    fseDecoding.decodingTable[0].numberOfAdditionalBits := numberOfAdditionalBits;
    fseDecoding.decodingTable[0].symbol := symbol;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: symbolTranslation (<span class="keywd">inout</span> <span class="type">array</span> <span class="type">fseTableEntry</span>: decodingTable,
    <span class="op">in</span> <span class="type">array</span> <span class="type">integer</span>: symbolTranslation, <span class="op">in</span> <span class="type">array</span> <span class="type">integer</span>: extraBits) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: symbol <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> <span class="keywd">key</span> index <span class="keywd">range</span> decodingTable <span class="keywd">do</span>
      symbol := decodingTable[index].symbol;
      <span class="comment"># Translate symbols to the real ones:</span>
      decodingTable[index].symbol := symbolTranslation[symbol];
      <span class="comment"># Extra bits needed for decoding the sequences:</span>
      decodingTable[index].numberOfAdditionalBits := extraBits[symbol];
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: peekSymbol (<span class="op">in</span> <span class="type">fseDecodingType</span>: fseDecoding, <span class="op">in</span> <span class="type">integer</span>: fseState) <span class="keywd">is</span>
    <span class="keywd">return</span> fseDecoding.decodingTable[fseState].symbol;


<span class="keywd">const</span> <span class="type">proc</span>: nextState (<span class="op">in</span> <span class="type">fseDecodingType</span>: fseDecoding, <span class="keywd">inout</span> <span class="type">integer</span>: fseState,
    <span class="keywd">inout</span> <span class="type">reverseBitStream</span>: compressedStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: bitsNeeded <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: baseLine <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    bitsNeeded := fseDecoding.decodingTable[fseState].numberOfBits;
    baseLine := fseDecoding.decodingTable[fseState].baseline;
    fseState := baseLine + getBits(compressedStream, bitsNeeded);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: getAdditionalBits (<span class="op">in</span> <span class="type">fseDecodingType</span>: fseDecoding, <span class="op">in</span> <span class="type">integer</span>: fseState) <span class="keywd">is</span>
    <span class="keywd">return</span> fseDecoding.decodingTable[fseState].numberOfAdditionalBits;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">integer</span>: decodeInterleavedFseStreams (<span class="op">in</span> <span class="type">fseDecodingType</span>: fseDecoding,
    <span class="keywd">inout</span> <span class="type">reverseBitStream</span>: compressedStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: weights <span class="keywd">is</span> [0 .. -1] <span class="op">times</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: aBit <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: fseState <span class="keywd">is</span> 2 <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: otherIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: endOfStreamReached <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: symbol <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      aBit := getBits(compressedStream, 1);
    <span class="keywd">until</span> aBit = 1;
    <span class="keywd">if</span> bitsRead(compressedStream) > 8 <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      fseState[1] := getBits(compressedStream, fseDecoding.accuracyLog);
      fseState[2] := getBits(compressedStream, fseDecoding.accuracyLog);
      <span class="keywd">repeat</span>
        <span class="keywd">for</span> <span class="keywd">key</span> index <span class="keywd">range</span> fseState <span class="keywd">until</span> endOfStreamReached <span class="keywd">do</span>
          symbol := peekSymbol(fseDecoding, fseState[index]);
          nextState(fseDecoding, fseState[index], compressedStream);
          weights &amp;:= symbol;

          <span class="keywd">if</span> bitsStillInStream(compressedStream) &lt; 0 <span class="keywd">then</span>
            otherIndex := succ(index <span class="op">mod</span> length(fseState));
            symbol := peekSymbol(fseDecoding, fseState[otherIndex]);
            weights &amp;:= symbol;
            endOfStreamReached := TRUE;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">until</span> endOfStreamReached;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: zstdHuffmanDecodingTable <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: maxBits <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: numberOfBits <span class="keywd">is</span> 0 <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: symbols <span class="keywd">is</span> 0 <span class="op">times</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">zstdHuffmanDecodingTable</span>: buildZstdHuffmanDecodingTable (<span class="op">in</span> <span class="type">integer</span>: maxBits,
    <span class="op">in</span> <span class="type">array</span> <span class="type">integer</span>: numBits, <span class="op">in</span> <span class="type">array</span> <span class="type">integer</span>: rankCount) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">zstdHuffmanDecodingTable</span>: table <span class="keywd">is</span> zstdHuffmanDecodingTable.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: base <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: code <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: rankIdx <span class="keywd">is</span> 0 <span class="op">times</span> 0;
  <span class="keywd">begin</span>
    table.maxBits := maxBits;
    table.symbols := [0 .. pred(1 &lt;&lt; maxBits)] <span class="op">times</span> 0;
    table.numberOfBits := [0 .. pred(1 &lt;&lt; maxBits)] <span class="op">times</span> 0;

    rankIdx := [0 .. maxBits] <span class="op">times</span> 0;
    <span class="keywd">for</span> index <span class="keywd">range</span> maxBits <span class="keywd">downto</span> 1 <span class="keywd">do</span>
      rankIdx[index - 1] := rankIdx[index] + rankCount[index] * (1 &lt;&lt; (maxBits - index));
      base := rankIdx[index];
      <span class="keywd">for</span> index2 <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(rankIdx[pred(index)] - rankIdx[index]) <span class="keywd">do</span>
        table.numberOfBits[base + index2] := index;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;

    <span class="keywd">if</span> rankIdx[0] &lt;> length(table.numberOfBits) <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(length(numBits)) <span class="keywd">do</span>
        <span class="keywd">if</span> numBits[index] &lt;> 0 <span class="keywd">then</span>
          code := rankIdx[numBits[index]];
          length := 1 &lt;&lt; (maxBits - numBits[index]);
          <span class="keywd">for</span> index2 <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(length) <span class="keywd">do</span>
            table.symbols[code + index2] := index;
          <span class="keywd">end</span> <span class="keywd">for</span>;
          rankIdx[numBits[index]] +:= length;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">zstdHuffmanDecodingTable</span>: buildZstdHuffmanDecodingTable (<span class="op">in</span> <span class="type">array</span> <span class="type">integer</span>: weights) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">zstdHuffmanDecodingTable</span>: table <span class="keywd">is</span> zstdHuffmanDecodingTable.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: sum <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: weight <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: maxBits <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: leftOver <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: lastWeight <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: numberOfBits <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: numBits <span class="keywd">is</span> 0 <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: rankCount <span class="keywd">is</span> 0 <span class="op">times</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> weight <span class="keywd">range</span> weights <span class="keywd">do</span>
      <span class="keywd">if</span> weight > 0 <span class="keywd">then</span>
        sum +:= 1 &lt;&lt; pred(weight);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;

    maxBits := log2(sum) + 1;
    <span class="comment"># Deduce the weight of the last symbol.</span>
    leftOver := (1 &lt;&lt; maxBits) - sum;
    <span class="keywd">if</span> leftOver > 0 <span class="op">and</span> 1 &lt;&lt; log2(leftOver) &lt;> leftOver <span class="keywd">then</span>
      <span class="comment"># leftOver is not a power of two.</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      lastWeight := log2(leftOver) + 1;

      numBits := [0 .. length(weights)] <span class="op">times</span> 0;
      rankCount := [0 .. maxBits] <span class="op">times</span> 0;
      <span class="keywd">for</span> weight <span class="keywd">key</span> index <span class="keywd">range</span> weights <span class="keywd">do</span>
        <span class="keywd">if</span> weight > 0 <span class="keywd">then</span>
          numberOfBits := maxBits + 1 - weight;
        <span class="keywd">else</span>
          numberOfBits := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        numBits[index] := numberOfBits;
        incr(rankCount[numberOfBits]);
      <span class="keywd">end</span> <span class="keywd">for</span>;

      <span class="keywd">if</span> lastWeight > 0 <span class="keywd">then</span>
        numberOfBits := maxBits + 1 - lastWeight;
      <span class="keywd">else</span>
        numberOfBits := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      numBits[maxIdx(numBits)] := numberOfBits;
      incr(rankCount[numberOfBits]);

      table := buildZstdHuffmanDecodingTable(maxBits, numBits, rankCount);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">array</span> <span class="type">integer</span>: readZstdHuffmanTreeWeights (<span class="keywd">inout</span> <span class="type">file</span>: compressed) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: weights <span class="keywd">is</span> [0 .. -1] <span class="op">times</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: huffmanTreeHeaderByte <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">fseWeightsType</span>: fseWeights <span class="keywd">is</span> fseWeightsType.value;
    <span class="keywd">var</span> <span class="type">fseDecodingType</span>: fseDecoding <span class="keywd">is</span> fseDecodingType.value;
    <span class="keywd">var</span> <span class="type">integer</span>: posBefore <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bitStreamLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reverseBitStream</span>: compressedStream <span class="keywd">is</span> reverseBitStream.value;
    <span class="keywd">var</span> <span class="type">integer</span>: numberOfWeights <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: aByte <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    huffmanTreeHeaderByte := ord(getc(compressed));
    <span class="keywd">if</span> huffmanTreeHeaderByte &lt; 128 <span class="keywd">then</span>
      posBefore := tell(compressed);
      fseWeights := getFseCompressedHuffmanWeights(compressed);
      fseDecoding := buildDecodingTable(fseWeights);
      bitStreamLength := huffmanTreeHeaderByte - (tell(compressed) - posBefore);
      compressedStream := reverseBitStream(compressed, bitStreamLength);
      weights := decodeInterleavedFseStreams(fseDecoding, compressedStream);
    <span class="keywd">else</span>
      <span class="comment"># Direct representation of huffman weights.</span>
      numberOfWeights := huffmanTreeHeaderByte - 127;
      weights := [0 .. pred(numberOfWeights)] <span class="op">times</span> 0;
      <span class="keywd">for</span> index <span class="keywd">range</span> 0 <span class="keywd">to</span> pred(numberOfWeights) <span class="keywd">do</span>
        <span class="keywd">if</span> index <span class="op">mod</span> 2 = 0 <span class="keywd">then</span>
          aByte := ord(getc(compressed));
          weights[index] := aByte >> 4;
        <span class="keywd">else</span>
          weights[index] := aByte <span class="op">mod</span> 16;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">char</span>: decodeSymbol (<span class="op">in</span> <span class="type">zstdHuffmanDecodingTable</span>: huffmanDecoding,
    <span class="keywd">inout</span> <span class="type">integer</span>: state, <span class="keywd">inout</span> <span class="type">reverseBitStream</span>: compressedStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">char</span>: symbol <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: bitsNeeded <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: rest <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    symbol := char(huffmanDecoding.symbols[state]);
    bitsNeeded := huffmanDecoding.numberOfBits[state];
    rest := getBits(compressedStream, bitsNeeded);
    state := ((state &lt;&lt; bitsNeeded) + rest) <span class="op">mod</span> (1 &lt;&lt; huffmanDecoding.maxBits);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: decodeStream (<span class="op">in</span> <span class="type">zstdHuffmanDecodingTable</span>: huffmanDecoding,
    <span class="keywd">inout</span> <span class="type">reverseBitStream</span>: compressedStream) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: uncompressed <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: aBit <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: state <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      aBit := getBits(compressedStream, 1);
    <span class="keywd">until</span> aBit = 1;
    <span class="keywd">if</span> bitsRead(compressedStream) > 8 <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      state := getBits(compressedStream, huffmanDecoding.maxBits);
      <span class="keywd">while</span> bitsStillInStream(compressedStream) > -huffmanDecoding.maxBits <span class="keywd">do</span>
        uncompressed &amp;:= decodeSymbol(huffmanDecoding, state, compressedStream);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">if</span> bitsStillInStream(compressedStream) &lt;> -huffmanDecoding.maxBits <span class="keywd">then</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">integer</span>: ZSTD_RAW_LITERALS_BLOCK        <span class="keywd">is</span> 0;
<span class="keywd">const</span> <span class="type">integer</span>: ZSTD_RLE_LITERALS_BLOCK        <span class="keywd">is</span> 1;
<span class="keywd">const</span> <span class="type">integer</span>: ZSTD_COMPRESSED_LITERALS_BLOCK <span class="keywd">is</span> 2;
<span class="keywd">const</span> <span class="type">integer</span>: ZSTD_TREELESS_LITERALS_BLOCK   <span class="keywd">is</span> 3;

<span class="keywd">const</span> <span class="type">type</span>: zstdLiteralSectionHeader <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: literalsBlockType <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: numStreams <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: regeneratedSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: compressedSize <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">zstdLiteralSectionHeader</span>: readZstdLiteralsSectionHeader (<span class="keywd">inout</span> <span class="type">file</span>: compressed) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">zstdLiteralSectionHeader</span>: header <span class="keywd">is</span> zstdLiteralSectionHeader.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: aByte <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: sizeFormat <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    aByte := ord(getc(compressed));
    header.literalsBlockType := aByte <span class="op">mod</span> 4;
    sizeFormat := (aByte >> 2) <span class="op">mod</span> 4;
    <span class="keywd">if</span> header.literalsBlockType <span class="op">in</span> {ZSTD_RAW_LITERALS_BLOCK, ZSTD_RLE_LITERALS_BLOCK} <span class="keywd">then</span>
      <span class="comment"># Only regeneratedSize is decoded.</span>
      <span class="keywd">case</span> sizeFormat <span class="keywd">of</span>
        <span class="keywd">when</span> {0, 2}:
          <span class="comment"># Only one bit of sizeFormat is used.</span>
          header.regeneratedSize := aByte >> 3;
        <span class="keywd">when</span> {1}:
          header.regeneratedSize := (aByte >> 4) + (ord(getc(compressed)) &lt;&lt; 4);
        <span class="keywd">when</span> {3}:
          header.regeneratedSize := (aByte >> 4) + (bytes2Int(gets(compressed, 2), UNSIGNED, LE) &lt;&lt; 4);
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">else</span>
      <span class="comment"># Decode compressedSize and regeneratedSize.</span>
      <span class="keywd">case</span> sizeFormat <span class="keywd">of</span>
        <span class="keywd">when</span> {0}:
           header.numStreams := 1;
           number := (aByte >> 4) + (bytes2Int(gets(compressed, 2), UNSIGNED, LE) &lt;&lt; 4);
           header.regeneratedSize := number <span class="op">mod</span> 1024;
           header.compressedSize := number >> 10;
        <span class="keywd">when</span> {1}:
           header.numStreams := 4;
           number := (aByte >> 4) + (bytes2Int(gets(compressed, 2), UNSIGNED, LE) &lt;&lt; 4);
           header.regeneratedSize := number <span class="op">mod</span> 1024;
           header.compressedSize := number >> 10;
        <span class="keywd">when</span> {2}:
           header.numStreams := 4;
           number := (aByte >> 4) + (bytes2Int(gets(compressed, 3), UNSIGNED, LE) &lt;&lt; 4);
           header.regeneratedSize := number <span class="op">mod</span> 16384;
           header.compressedSize := number >> 14;
        <span class="keywd">when</span> {3}:
           header.numStreams := 4;
           number := (aByte >> 4) + (bytes2Int(gets(compressed, 4), UNSIGNED, LE) &lt;&lt; 4);
           header.regeneratedSize := number <span class="op">mod</span> 262144;
           header.compressedSize := number >> 18;
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: zstdSequencesSectionType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: numberOfSequences <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">fseDecodingType</span>: literalLengthsFseDecoding <span class="keywd">is</span> fseDecodingType.value;
    <span class="keywd">var</span> <span class="type">fseDecodingType</span>: offsetsFseDecoding <span class="keywd">is</span> fseDecodingType.value;
    <span class="keywd">var</span> <span class="type">fseDecodingType</span>: matchLengthsFseDecoding <span class="keywd">is</span> fseDecodingType.value;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: zstdBlockStateType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: offsetHistory <span class="keywd">is</span> [] (1, 4, 8);
    <span class="keywd">var</span> <span class="type">zstdHuffmanDecodingTable</span>: table <span class="keywd">is</span> zstdHuffmanDecodingTable.value;
    <span class="keywd">var</span> <span class="type">zstdSequencesSectionType</span>: sequencesSection <span class="keywd">is</span> zstdSequencesSectionType.value;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: readCompressedLiteralsBlock (<span class="keywd">inout</span> <span class="type">file</span>: compressed,
    <span class="keywd">inout</span> <span class="type">zstdBlockStateType</span>: blockState, <span class="op">in</span> <span class="type">zstdLiteralSectionHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: literals <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: compressedSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: posBefore <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: weights <span class="keywd">is</span> [0 .. -1] <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">integer</span>: streamSize <span class="keywd">is</span> 4 <span class="op">times</span> 0;
    <span class="keywd">var</span> <span class="type">array</span> <span class="type">reverseBitStream</span>: compressedStream <span class="keywd">is</span> 4 <span class="op">times</span> reverseBitStream.value;
  <span class="keywd">begin</span>
    compressedSize := header.compressedSize;
    <span class="keywd">if</span> header.literalsBlockType = ZSTD_COMPRESSED_LITERALS_BLOCK <span class="keywd">then</span>
      posBefore := tell(compressed);
      weights := readZstdHuffmanTreeWeights(compressed);
      compressedSize -:= tell(compressed) - posBefore;
      blockState.table := buildZstdHuffmanDecodingTable(weights);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> header.numStreams = 1 <span class="keywd">then</span>
      compressedStream[1] := reverseBitStream(compressed, compressedSize);
      literals := decodeStream(blockState.table, compressedStream[1]);
    <span class="keywd">elsif</span> header.numStreams = 4 <span class="keywd">then</span>
      streamSize[1] := bytes2Int(gets(compressed, 2), UNSIGNED, LE);
      streamSize[2] := bytes2Int(gets(compressed, 2), UNSIGNED, LE);
      streamSize[3] := bytes2Int(gets(compressed, 2), UNSIGNED, LE);
      compressedSize -:= 6;
      streamSize[4] := compressedSize - streamSize[1] - streamSize[2] - streamSize[3];
      compressedStream[1] := reverseBitStream(compressed, streamSize[1]);
      compressedStream[2] := reverseBitStream(compressed, streamSize[2]);
      compressedStream[3] := reverseBitStream(compressed, streamSize[3]);
      compressedStream[4] := reverseBitStream(compressed, streamSize[4]);
      literals := decodeStream(blockState.table, compressedStream[1]) &amp;
                  decodeStream(blockState.table, compressedStream[2]) &amp;
                  decodeStream(blockState.table, compressedStream[3]) &amp;
                  decodeStream(blockState.table, compressedStream[4]);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: readLiteralsSection (<span class="keywd">inout</span> <span class="type">file</span>: compressed,
    <span class="keywd">inout</span> <span class="type">zstdBlockStateType</span>: blockState) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: literals <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">zstdLiteralSectionHeader</span>: header <span class="keywd">is</span> zstdLiteralSectionHeader.value;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    header := readZstdLiteralsSectionHeader(compressed);
    <span class="keywd">case</span> header.literalsBlockType <span class="keywd">of</span>
      <span class="keywd">when</span> {ZSTD_RAW_LITERALS_BLOCK}: literals := gets(compressed, header.regeneratedSize);
      <span class="keywd">when</span> {ZSTD_RLE_LITERALS_BLOCK}: literals := str(getc(compressed)) <span class="op">mult</span> header.regeneratedSize;
      <span class="keywd">when</span> {ZSTD_COMPRESSED_LITERALS_BLOCK, ZSTD_TREELESS_LITERALS_BLOCK}:
          literals := readCompressedLiteralsBlock(compressed, blockState, header);
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">integer</span>: ZSTD_PREDEFINED_MODE     <span class="keywd">is</span> 0;
<span class="keywd">const</span> <span class="type">integer</span>: ZSTD_RLE_MODE            <span class="keywd">is</span> 1;
<span class="keywd">const</span> <span class="type">integer</span>: ZSTD_FSE_COMPRESSED_MODE <span class="keywd">is</span> 2;
<span class="keywd">const</span> <span class="type">integer</span>: ZSTD_REPEAT_MODE         <span class="keywd">is</span> 3;

<span class="keywd">const</span> <span class="type">type</span>: zstdSequencesSectionHeader <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: numberOfSequences <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: literalLengthsMode <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: offsetsMode <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: matchLengthsMode <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">zstdSequencesSectionHeader</span>: readZstdSequencesSectionHeader (<span class="keywd">inout</span> <span class="type">file</span>: compressed) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">zstdSequencesSectionHeader</span>: header <span class="keywd">is</span> zstdSequencesSectionHeader.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: byte0 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: symbolCompressionModes <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    byte0 := ord(getc(compressed));
    <span class="keywd">if</span> byte0 = 0 <span class="keywd">then</span>
      header.numberOfSequences := 0;
    <span class="keywd">elsif</span> byte0 &lt; 128 <span class="keywd">then</span>
      header.numberOfSequences := byte0;
    <span class="keywd">elsif</span> byte0 &lt; 255 <span class="keywd">then</span>
      header.numberOfSequences := ((byte0 - 128) &lt;&lt; 8) + ord(getc(compressed));
    <span class="keywd">elsif</span> byte0 = 255 <span class="keywd">then</span>
      header.numberOfSequences := bytes2Int(gets(compressed, 2), UNSIGNED, LE) + 16#7f00;
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> header.numberOfSequences &lt;> 0 <span class="keywd">then</span>
      symbolCompressionModes := ord(getc(compressed));
      header.literalLengthsMode := symbolCompressionModes >> 6;
      header.offsetsMode := (symbolCompressionModes >> 4) <span class="op">mod</span> 4;
      header.matchLengthsMode := (symbolCompressionModes >> 2) <span class="op">mod</span> 4;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">type</span>: zstdSequenceState <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: literalLengthsState <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: offsetsState <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: matchLengthsState <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: zstdSequenceType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: matchLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: literalLength <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: offset <span class="keywd">is</span> 0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">array</span> <span class="type">integer</span>: zstdLiteralLengthBaseValueTranslation <span class="keywd">is</span> [0] (
    0, 1, 2, 3, 4, 5, 6, 7,
    8, 9, 10, 11, 12, 13, 14, 15,
    16, 18, 20, 22, 24, 28, 32, 40,
    48, 64, 16#80, 16#100, 16#200, 16#400, 16#800,
    16#1000, 16#2000, 16#4000, 16#8000, 16#10000);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">integer</span>: zstdLiteralLengthExtraBits <span class="keywd">is</span> [0] (
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
    1, 1, 2, 2, 3, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">integer</span>: zstdMatchLengthBaseValueTranslation <span class="keywd">is</span> [0] (
    3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
    17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
    31, 32, 33, 34, 35, 37, 39, 41, 43, 47, 51, 59, 67, 83,
    99, 131, 259, 515, 1027, 2051, 4099, 8195, 16387, 32771, 65539);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">integer</span>: zstdMatchLengthsExtraBits <span class="keywd">is</span> [0] (
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
    2, 2, 3, 3, 4, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">fseDecodingType</span>: buildZstdLiteralLengthsTable <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fseDecodingType</span>: fseDecoding <span class="keywd">is</span> fseDecodingType.value;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">integer</span>: literalLengthDefaultAccuracyLog <span class="keywd">is</span> 6;
    <span class="keywd">const</span> <span class="type">array</span> <span class="type">integer</span>: literalLengthDefaultDistributions <span class="keywd">is</span> [0] (
        4, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 1, 1, 1, 1, 1,
        -1, -1, -1, -1);
    <span class="keywd">var</span> <span class="type">fseWeightsType</span>: fseData <span class="keywd">is</span> fseWeightsType.value;
    <span class="keywd">var</span> <span class="type">integer</span>: probability <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    fseData.accuracyLog := literalLengthDefaultAccuracyLog;
    <span class="keywd">for</span> probability <span class="keywd">key</span> index <span class="keywd">range</span> literalLengthDefaultDistributions <span class="keywd">do</span>
      fseData.fseValues @:= [index] succ(probability);  <span class="comment"># value = probability + 1</span>
    <span class="keywd">end</span> <span class="keywd">for</span>;
    fseDecoding := buildDecodingTable(fseData);
    symbolTranslation(fseDecoding.decodingTable,
        zstdLiteralLengthBaseValueTranslation, zstdLiteralLengthExtraBits);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">fseDecodingType</span>: buildZstdOffsetTable <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fseDecodingType</span>: fseDecoding <span class="keywd">is</span> fseDecodingType.value;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">integer</span>: offsetDefaultAccuracyLog <span class="keywd">is</span> 5;
    <span class="keywd">const</span> <span class="type">array</span> <span class="type">integer</span>: offsetDefaultDistribution <span class="keywd">is</span> [0] (
        1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1);
    <span class="keywd">var</span> <span class="type">fseWeightsType</span>: fseData <span class="keywd">is</span> fseWeightsType.value;
    <span class="keywd">var</span> <span class="type">integer</span>: probability <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    fseData.accuracyLog := offsetDefaultAccuracyLog;
    <span class="keywd">for</span> probability <span class="keywd">key</span> index <span class="keywd">range</span> offsetDefaultDistribution <span class="keywd">do</span>
      fseData.fseValues @:= [index] succ(probability);  <span class="comment"># value = probability + 1</span>
    <span class="keywd">end</span> <span class="keywd">for</span>;
    fseDecoding := buildDecodingTable(fseData);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">fseDecodingType</span>: buildZstdMatchLengthsTable <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">fseDecodingType</span>: fseDecoding <span class="keywd">is</span> fseDecodingType.value;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">integer</span>: matchLengthDefaultAccuracyLog <span class="keywd">is</span> 6;
    <span class="keywd">const</span> <span class="type">array</span> <span class="type">integer</span>: matchLengthDefaultDistribution <span class="keywd">is</span> [0] (
        1, 4, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1);
    <span class="keywd">var</span> <span class="type">fseWeightsType</span>: fseData <span class="keywd">is</span> fseWeightsType.value;
    <span class="keywd">var</span> <span class="type">integer</span>: probability <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    fseData.accuracyLog := matchLengthDefaultAccuracyLog;
    <span class="keywd">for</span> probability <span class="keywd">key</span> index <span class="keywd">range</span> matchLengthDefaultDistribution <span class="keywd">do</span>
      fseData.fseValues @:= [index] succ(probability);  <span class="comment"># value = probability + 1</span>
    <span class="keywd">end</span> <span class="keywd">for</span>;
    fseDecoding := buildDecodingTable(fseData);
    symbolTranslation(fseDecoding.decodingTable,
        zstdMatchLengthBaseValueTranslation, zstdMatchLengthsExtraBits);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: initDecodeTables (<span class="keywd">inout</span> <span class="type">file</span>: compressed,
    <span class="keywd">inout</span> <span class="type">zstdBlockStateType</span>: blockState, <span class="op">in</span> <span class="type">zstdSequencesSectionHeader</span>: header) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: byteToRepeat <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">fseWeightsType</span>: fseData <span class="keywd">is</span> fseWeightsType.value;
  <span class="keywd">begin</span>
    blockState.sequencesSection.numberOfSequences := header.numberOfSequences;
    <span class="keywd">case</span> header.literalLengthsMode <span class="keywd">of</span>
      <span class="keywd">when</span> {ZSTD_PREDEFINED_MODE}:
        blockState.sequencesSection.literalLengthsFseDecoding := buildZstdLiteralLengthsTable;
      <span class="keywd">when</span> {ZSTD_RLE_MODE}:
        byteToRepeat := ord(getc(compressed));
        blockState.sequencesSection.literalLengthsFseDecoding :=
            repeatingFseDecodingTable(zstdLiteralLengthBaseValueTranslation[byteToRepeat],
                                      zstdLiteralLengthExtraBits[byteToRepeat]);
      <span class="keywd">when</span> {ZSTD_FSE_COMPRESSED_MODE}:
        fseData := getFseCompressedHuffmanWeights(compressed);
        blockState.sequencesSection.literalLengthsFseDecoding := buildDecodingTable(fseData);
        symbolTranslation(blockState.sequencesSection.literalLengthsFseDecoding.decodingTable,
            zstdLiteralLengthBaseValueTranslation, zstdLiteralLengthExtraBits);
      <span class="keywd">when</span> {ZSTD_REPEAT_MODE}:
        <span class="keywd">if</span> length(blockState.sequencesSection.literalLengthsFseDecoding.decodingTable) = 0 <span class="keywd">then</span>
          raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;

    <span class="keywd">case</span> header.offsetsMode <span class="keywd">of</span>
      <span class="keywd">when</span> {ZSTD_PREDEFINED_MODE}:
        blockState.sequencesSection.offsetsFseDecoding := buildZstdOffsetTable;
      <span class="keywd">when</span> {ZSTD_RLE_MODE}:
        byteToRepeat := ord(getc(compressed));
        blockState.sequencesSection.offsetsFseDecoding :=
            repeatingFseDecodingTable(byteToRepeat, 0);
      <span class="keywd">when</span> {ZSTD_FSE_COMPRESSED_MODE}:
        fseData := getFseCompressedHuffmanWeights(compressed);
        blockState.sequencesSection.offsetsFseDecoding := buildDecodingTable(fseData);
      <span class="keywd">when</span> {ZSTD_REPEAT_MODE}:
        <span class="keywd">if</span> length(blockState.sequencesSection.offsetsFseDecoding.decodingTable) = 0 <span class="keywd">then</span>
          raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;

    <span class="keywd">case</span> header.matchLengthsMode <span class="keywd">of</span>
      <span class="keywd">when</span> {ZSTD_PREDEFINED_MODE}:
        blockState.sequencesSection.matchLengthsFseDecoding := buildZstdMatchLengthsTable;
      <span class="keywd">when</span> {ZSTD_RLE_MODE}:
        byteToRepeat := ord(getc(compressed));
        blockState.sequencesSection.matchLengthsFseDecoding :=
            repeatingFseDecodingTable(zstdMatchLengthBaseValueTranslation[byteToRepeat],
                                      zstdMatchLengthsExtraBits[byteToRepeat]);
      <span class="keywd">when</span> {ZSTD_FSE_COMPRESSED_MODE}:
        fseData := getFseCompressedHuffmanWeights(compressed);
        blockState.sequencesSection.matchLengthsFseDecoding := buildDecodingTable(fseData);
        symbolTranslation(blockState.sequencesSection.matchLengthsFseDecoding.decodingTable,
            zstdMatchLengthBaseValueTranslation, zstdMatchLengthsExtraBits);
      <span class="keywd">when</span> {ZSTD_REPEAT_MODE}:
        <span class="keywd">if</span> length(blockState.sequencesSection.matchLengthsFseDecoding.decodingTable) = 0 <span class="keywd">then</span>
          raise RANGE_ERROR;
        <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">zstdSequenceType</span>: decodeSequence (<span class="op">in</span> <span class="type">zstdSequencesSectionType</span>: sequencesSection,
    <span class="keywd">inout</span> <span class="type">reverseBitStream</span>: compressedStream, <span class="keywd">inout</span> <span class="type">zstdSequenceState</span>: state) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">zstdSequenceType</span>: sequence <span class="keywd">is</span> zstdSequenceType.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: offsetCode <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: matchLengthAdditionalBits <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: literalLengthAdditionalBits <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    offsetCode := peekSymbol(sequencesSection.offsetsFseDecoding, state.offsetsState);
    sequence.offset := getBits(compressedStream, offsetCode) + (1 &lt;&lt; offsetCode);

    sequence.matchLength := peekSymbol(sequencesSection.matchLengthsFseDecoding,
                                       state.matchLengthsState);
    matchLengthAdditionalBits := getAdditionalBits(sequencesSection.matchLengthsFseDecoding,
                                                   state.matchLengthsState);
    <span class="keywd">if</span> matchLengthAdditionalBits &lt;> 0 <span class="keywd">then</span>
      sequence.matchLength +:= getBits(compressedStream, matchLengthAdditionalBits);
    <span class="keywd">end</span> <span class="keywd">if</span>;

    sequence.literalLength := peekSymbol(sequencesSection.literalLengthsFseDecoding,
                                         state.literalLengthsState);
    literalLengthAdditionalBits := getAdditionalBits(sequencesSection.literalLengthsFseDecoding,
                                                     state.literalLengthsState);
    <span class="keywd">if</span> literalLengthAdditionalBits &lt;> 0 <span class="keywd">then</span>
      sequence.literalLength +:= getBits(compressedStream, literalLengthAdditionalBits);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: decodeSequences (<span class="op">in</span> <span class="type">zstdSequencesSectionType</span>: sequencesSection,
    <span class="keywd">inout</span> <span class="type">reverseBitStream</span>: compressedStream, <span class="op">in</span> <span class="type">string</span>: literals,
    <span class="keywd">inout</span> <span class="type">zstdBlockStateType</span>: blockState, <span class="keywd">inout</span> <span class="type">string</span>: uncompressed) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: aBit <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">zstdSequenceState</span>: state <span class="keywd">is</span> zstdSequenceState.value;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">zstdSequenceType</span>: sequence <span class="keywd">is</span> zstdSequenceType.value;
    <span class="keywd">var</span> <span class="type">integer</span>: literalPos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: offset <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: nextPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      aBit := getBits(compressedStream, 1);
    <span class="keywd">until</span> aBit = 1;
    <span class="keywd">if</span> bitsRead(compressedStream) > 8 <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">else</span>
      state.literalLengthsState := getBits(compressedStream, sequencesSection.literalLengthsFseDecoding.accuracyLog);
      state.offsetsState        := getBits(compressedStream, sequencesSection.offsetsFseDecoding.accuracyLog);
      state.matchLengthsState   := getBits(compressedStream, sequencesSection.matchLengthsFseDecoding.accuracyLog);

      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> sequencesSection.numberOfSequences <span class="keywd">do</span>
        sequence := decodeSequence(sequencesSection, compressedStream, state);
        <span class="keywd">if</span> sequence.literalLength > 0 <span class="keywd">then</span>
          uncompressed &amp;:= literals[literalPos len sequence.literalLength];
          literalPos +:= sequence.literalLength;
        <span class="keywd">end</span> <span class="keywd">if</span>;

        <span class="keywd">if</span> sequence.matchLength > 0 <span class="keywd">then</span>
          <span class="keywd">if</span> sequence.offset &lt;= 3 <span class="keywd">then</span>
            <span class="keywd">if</span> sequence.literalLength = 0 <span class="keywd">then</span>
              <span class="keywd">case</span> sequence.offset <span class="keywd">of</span>
                <span class="keywd">when</span> {0}: raise RANGE_ERROR;
                <span class="keywd">when</span> {1}: offset := blockState.offsetHistory[2];
                          blockState.offsetHistory[2] := blockState.offsetHistory[1];
                <span class="keywd">when</span> {2}: offset := blockState.offsetHistory[3];
                          blockState.offsetHistory[3] := blockState.offsetHistory[2];
                          blockState.offsetHistory[2] := blockState.offsetHistory[1];
                <span class="keywd">when</span> {3}: offset := pred(blockState.offsetHistory[1]);
                          blockState.offsetHistory[3] := blockState.offsetHistory[2];
                          blockState.offsetHistory[2] := blockState.offsetHistory[1];
              <span class="keywd">end</span> <span class="keywd">case</span>;
              blockState.offsetHistory[1] := offset;
            <span class="keywd">else</span>
              offset := blockState.offsetHistory[sequence.offset];
              <span class="keywd">case</span> sequence.offset <span class="keywd">of</span>
                <span class="keywd">when</span> {0}: raise RANGE_ERROR;
                <span class="keywd">when</span> {1}: noop;
                <span class="keywd">when</span> {2}: blockState.offsetHistory[2] := blockState.offsetHistory[1];
                          blockState.offsetHistory[1] := offset;
                <span class="keywd">when</span> {3}: blockState.offsetHistory[3] := blockState.offsetHistory[2];
                          blockState.offsetHistory[2] := blockState.offsetHistory[1];
                          blockState.offsetHistory[1] := offset;
              <span class="keywd">end</span> <span class="keywd">case</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            offset := sequence.offset - 3;
            blockState.offsetHistory[3] := blockState.offsetHistory[2];
            blockState.offsetHistory[2] := blockState.offsetHistory[1];
            blockState.offsetHistory[1] := offset;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> sequence.matchLength > offset <span class="keywd">then</span>
            nextPos := succ(length(uncompressed));
            uncompressed &amp;:= <span class="stri">"\0;"</span> <span class="op">mult</span> sequence.matchLength;
            <span class="keywd">for</span> number <span class="keywd">range</span> nextPos <span class="keywd">to</span> nextPos + sequence.matchLength - 1 <span class="keywd">do</span>
              uncompressed @:= [number] uncompressed[number - offset];
            <span class="keywd">end</span> <span class="keywd">for</span>;
          <span class="keywd">else</span> <span class="comment"># hopefully length(uncompressed) >= offset holds</span>
            uncompressed &amp;:= uncompressed[succ(length(uncompressed)) - offset len sequence.matchLength];
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;

        <span class="comment"># Don't update on the last index.</span>
        <span class="keywd">if</span> index &lt; sequencesSection.numberOfSequences <span class="keywd">then</span>
          nextState(sequencesSection.literalLengthsFseDecoding, state.literalLengthsState,
                    compressedStream);
          nextState(sequencesSection.matchLengthsFseDecoding, state.matchLengthsState,
                    compressedStream);
          nextState(sequencesSection.offsetsFseDecoding, state.offsetsState,
                    compressedStream);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;

      uncompressed &amp;:= literals[literalPos ..];

      <span class="keywd">if</span> bitsStillInStream(compressedStream) &lt;> 0 <span class="keywd">then</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: readCompressedBlock (<span class="keywd">inout</span> <span class="type">file</span>: compressed, <span class="op">in</span> <span class="type">integer</span>: blockSize,
    <span class="keywd">inout</span> <span class="type">zstdBlockStateType</span>: blockState, <span class="keywd">inout</span> <span class="type">string</span>: uncompressed) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: blockStartPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: literals <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">zstdSequencesSectionHeader</span>: header <span class="keywd">is</span> zstdSequencesSectionHeader.value;
    <span class="keywd">var</span> <span class="type">integer</span>: lengthOfSequencesData <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">reverseBitStream</span>: compressedStream <span class="keywd">is</span> reverseBitStream.value;
  <span class="keywd">begin</span>
    blockStartPos := tell(compressed);
    literals := readLiteralsSection(compressed, blockState);
    header := readZstdSequencesSectionHeader(compressed);
    <span class="keywd">if</span> header.numberOfSequences = 0 <span class="keywd">then</span>
      uncompressed &amp;:= literals;
    <span class="keywd">else</span>
      initDecodeTables(compressed, blockState, header);
      lengthOfSequencesData := blockSize - (tell(compressed) - blockStartPos);
      compressedStream := reverseBitStream(compressed, lengthOfSequencesData);
      decodeSequences(blockState.sequencesSection, compressedStream, literals, blockState, uncompressed);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: zstdBlock (<span class="keywd">inout</span> <span class="type">file</span>: compressed, <span class="keywd">inout</span> <span class="type">zstdBlockStateType</span>: blockState,
    <span class="keywd">inout</span> <span class="type">string</span>: uncompressed) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: lastBlock <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: blockSize <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: blockType <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    blockSize := bytes2Int(gets(compressed, 3), UNSIGNED, LE);
    lastBlock := odd(blockSize);
    <span class="comment"># writeln("lastBlock: " &lt;&amp; lastBlock);</span>
    blockSize >>:= 1;
    blockType := blockSize <span class="op">mod</span> 4;
    <span class="comment"># writeln("blockType: " &lt;&amp; blockType);</span>
    blockSize >>:= 2;
    <span class="comment"># writeln("blockSize: " &lt;&amp; blockSize);</span>
    <span class="keywd">case</span> blockType <span class="keywd">of</span>
      <span class="keywd">when</span> {0}: uncompressed &amp;:= gets(compressed, blockSize);
      <span class="keywd">when</span> {1}: uncompressed &amp;:= str(getc(compressed)) <span class="op">mult</span> blockSize;
      <span class="keywd">when</span> {2}: readCompressedBlock(compressed, blockSize, blockState, uncompressed);
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  [[file|File]] implementation type to decompress a Zstandard file.
 *  Zstandard is a file format used for compression.
 *)</span>
<span class="keywd">const</span> <span class="type">type</span>: zstdFile <span class="keywd">is</span> sub null_file <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">file</span>: compressed <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">boolean</span>: finished <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">zstdBlockStateType</span>: blockState <span class="keywd">is</span> zstdBlockStateType.value;
    <span class="keywd">var</span> <span class="type">string</span>: uncompressed <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">integer</span>: position <span class="keywd">is</span> 1;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

type_implements_interface(zstdFile, file);


<span class="comment">(**
 *  Open a Zstandard file for reading (decompression).
 *  Zstandard is a file format used for compression. Reading from
 *  the file delivers decompressed data. Writing is not supported.
 *  @return the file opened, or [[null_file#STD_NULL|STD_NULL]]
 *          if the file is not in Zstandard format.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">file</span>: openZstdFile (<span class="keywd">inout</span> <span class="type">file</span>: compressed) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">file</span>: newFile <span class="keywd">is</span> STD_NULL;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: magic <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">zstdFrameHeader</span>: frameHeader <span class="keywd">is</span> zstdFrameHeader.value;
    <span class="keywd">var</span> <span class="type">zstdFile</span>: new_zstdFile <span class="keywd">is</span> zstdFile.value;
  <span class="keywd">begin</span>
    magic := gets(compressed, length(ZSTD_MAGIC));
    <span class="comment"># writeln("openZstdFile: " &lt;&amp; literal(magic));</span>
    <span class="keywd">if</span> magic = ZSTD_MAGIC <span class="keywd">then</span>
      readFrameHeader(compressed, frameHeader);
      new_zstdFile.compressed := compressed;
      newFile := toInterface(new_zstdFile);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Close a ''zstdFile''.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: close (<span class="op">in</span> <span class="type">zstdFile</span>: aFile) <span class="keywd">is</span> noop;


<span class="comment">(**
 *  Read a character from a ''zstdFile''.
 *  @return the character read.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">char</span>: getc (<span class="keywd">inout</span> <span class="type">zstdFile</span>: inFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">char</span>: charRead <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> inFile.position > length(inFile.uncompressed) <span class="op">and</span>
        <span class="op">not</span> inFile.finished <span class="keywd">do</span>
      inFile.finished:= zstdBlock(inFile.compressed, inFile.blockState, inFile.uncompressed);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> inFile.position &lt;= length(inFile.uncompressed) <span class="keywd">then</span>
      charRead := inFile.uncompressed[inFile.position];
      incr(inFile.position);
    <span class="keywd">else</span>
      charRead := EOF;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Read a string with maximum length from a ''zstdFile''.
 *  @return the string read.
 *  @exception RANGE_ERROR The parameter ''maxLength'' is negative.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: gets (<span class="keywd">inout</span> <span class="type">zstdFile</span>: inFile, <span class="op">in</span> <span class="type">integer</span>: maxLength) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: striRead <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> maxLength &lt;= 0 <span class="keywd">then</span>
      <span class="keywd">if</span> maxLength &lt;> 0 <span class="keywd">then</span>
        raise RANGE_ERROR;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      <span class="keywd">while</span> maxLength > succ(length(inFile.uncompressed) - inFile.position) <span class="op">and</span>
          <span class="op">not</span> inFile.finished <span class="keywd">do</span>
        inFile.finished:= zstdBlock(inFile.compressed, inFile.blockState, inFile.uncompressed);
      <span class="keywd">end</span> <span class="keywd">while</span>;
      <span class="keywd">if</span> maxLength &lt;= succ(length(inFile.uncompressed) - inFile.position) <span class="keywd">then</span>
        striRead := inFile.uncompressed[inFile.position len maxLength];
        inFile.position +:= maxLength;
      <span class="keywd">else</span>
        striRead := inFile.uncompressed[inFile.position ..];
        inFile.position := succ(length(inFile.uncompressed));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the end-of-file indicator.
 *  The end-of-file indicator is set if at least one request to read
 *  from the file failed.
 *  @return TRUE if the end-of-file indicator is set, FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: eof (<span class="op">in</span> <span class="type">zstdFile</span>: inFile) <span class="keywd">is</span>
  <span class="keywd">return</span> inFile.position > length(inFile.uncompressed) <span class="op">and</span> inFile.finished;


<span class="comment">(**
 *  Determine if at least one character can be read successfully.
 *  This function allows a file to be handled like an iterator.
 *  @return FALSE if ''getc'' would return EOF, TRUE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: hasNext (<span class="keywd">inout</span> <span class="type">zstdFile</span>: inFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: hasNext <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> inFile.position > length(inFile.uncompressed) <span class="op">and</span>
        <span class="op">not</span> inFile.finished <span class="keywd">do</span>
      inFile.finished:= zstdBlock(inFile.compressed, inFile.blockState, inFile.uncompressed);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    hasNext := inFile.position &lt;= length(inFile.uncompressed);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Obtain the length of a file.
 *  The file length is measured in bytes.
 *  @return the length of a file, or 0 if it cannot be obtained.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: length (<span class="keywd">inout</span> <span class="type">zstdFile</span>: aFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> <span class="op">not</span> aFile.finished <span class="keywd">do</span>
      aFile.finished:= zstdBlock(aFile.compressed, aFile.blockState, aFile.uncompressed);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    length := length(aFile.uncompressed);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine if the file ''aFile'' is seekable.
 *  If a file is seekable the functions ''seek'' and ''tell''
 *  can be used to set and and obtain the current file position.
 *  @return TRUE, since a ''zstdFile'' is seekable.
 *)</span>
<span class="keywd">const</span> <span class="type">boolean</span>: seekable (<span class="op">in</span> <span class="type">zstdFile</span>: aFile) <span class="keywd">is</span> TRUE;


<span class="comment">(**
 *  Set the current file position.
 *  The file position is measured in bytes from the start of the file.
 *  The first byte in the file has the position 1.
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: seek (<span class="keywd">inout</span> <span class="type">zstdFile</span>: aFile, <span class="op">in</span> <span class="type">integer</span>: position) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    aFile.position := position;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Obtain the current file position.
 *  The file position is measured in bytes from the start of the file.
 *  The first byte in the file has the position 1.
 *  @return the current file position.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: tell (<span class="op">in</span> <span class="type">zstdFile</span>: aFile) <span class="keywd">is</span>
  <span class="keywd">return</span> aFile.position;
</pre>
</body>
</html>
