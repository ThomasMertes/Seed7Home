<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style1.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  panic.sd7     Catch aliens in traps game                        *)</span>
<span class="comment">(*  Copyright (C) 2004, 2005  Thomas Mertes                         *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/seed7_05.htm">seed7_05.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/time.htm">time.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/duration.htm">duration.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/float.htm">float.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/keybd.htm">keybd.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/draw.htm">draw.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/pic_util.htm">pic_util.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/dialog.htm">dialog.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/stdfont9.htm">stdfont9.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/pixmap_file.htm">pixmap_file.s7i</a>"</span>;


<span class="keywd">const</span> <span class="type">integer</span>: NUM_LEVELS <span class="keywd">is</span> 6;
<span class="keywd">const</span> <span class="type">integer</span>: SPEED <span class="keywd">is</span> 1;
<span class="keywd">const</span> <span class="type">integer</span>: FALL_SPEED <span class="keywd">is</span> 2 * SPEED;
<span class="keywd">const</span> <span class="type">integer</span>: FIELD_ELEM_STEP <span class="keywd">is</span> 2;
<span class="keywd">const</span> <span class="type">integer</span>: PICTURE_SCALE <span class="keywd">is</span> 2;
<span class="keywd">const</span> <span class="type">integer</span>: AREA_LINES <span class="keywd">is</span> 161;
<span class="keywd">const</span> <span class="type">integer</span>: AREA_COLUMNS <span class="keywd">is</span> 267;
<span class="keywd">const</span> <span class="type">integer</span>: WIN_HEIGHT <span class="keywd">is</span> (AREA_LINES + 34) * FIELD_ELEM_STEP;
<span class="keywd">const</span> <span class="type">integer</span>: WIN_WIDTH <span class="keywd">is</span> (AREA_COLUMNS + 16) * FIELD_ELEM_STEP;
<span class="keywd">const</span> <span class="type">integer</span>: FIELD_BORDER <span class="keywd">is</span> SPEED;
<span class="keywd">const</span> <span class="type">integer</span>: FIELD_LINES <span class="keywd">is</span> AREA_LINES + 2 * FIELD_BORDER;
<span class="keywd">const</span> <span class="type">integer</span>: FIELD_COLUMNS <span class="keywd">is</span> AREA_COLUMNS + 2 * FIELD_BORDER;
<span class="keywd">const</span> <span class="type">integer</span>: FIELD_X_START <span class="keywd">is</span> (1 - FIELD_BORDER) * FIELD_ELEM_STEP;
<span class="keywd">const</span> <span class="type">integer</span>: FIELD_Y_START <span class="keywd">is</span> (17 - FIELD_BORDER) * FIELD_ELEM_STEP;
<span class="keywd">const</span> <span class="type">integer</span>: FULL_MOTION <span class="keywd">is</span> 0;
<span class="keywd">const</span> <span class="type">integer</span>: CATCH_MOTION <span class="keywd">is</span> 1;
<span class="keywd">const</span> <span class="type">integer</span>: LEAVE_MOTION <span class="keywd">is</span> 2;
<span class="keywd">const</span> <span class="type">integer</span>: TRAP_DEPTH <span class="keywd">is</span> 9;
<span class="keywd">const</span> <span class="type">duration</span>: TIME_IN_HOLE <span class="keywd">is</span> 17 . SECONDS;

<span class="keywd">const</span> <span class="type">type</span>: holeType <span class="keywd">is</span> new <span class="keywd">enum</span>
    no_hole, hole_depth1, hole_depth2, hole_depth3, hole_depth4, hole_finished,
    hole_part, hole_unfinished, hole_bottom, hole_entering, hole_leaving,
    hole_filled, hole_pound1, hole_pound2, hole_pound3, hole_pound4, hole_pounded
  <span class="keywd">end</span> <span class="keywd">enum</span>;

<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">holeType</span>: aHole) <span class="keywd">is</span>
  <span class="keywd">return</span> literal(aHole);

enable_output(holeType);

<span class="keywd">const</span> <span class="type">array</span> <span class="type">array</span> <span class="type">integer</span>: round_description <span class="keywd">is</span> [](
  [](3, 0, 0, 2000, 0),
  [](5, 0, 0, 2000, 0),
  [](8, 0, 0, 2000, 0),
  [](2, 1, 0, 3000, 1),
  [](4, 1, 0, 3000, 0),
  [](7, 1, 0, 3000, 0),
  [](1, 1, 1, 3000, 0),
  [](3, 1, 1, 4000, 0),
  [](6, 1, 1, 4000, 0),
  [](0, 2, 1, 4000, 0),
  [](2, 2, 1, 4000, 0),
  [](5, 2, 1, 5000, 0),
  [](0, 2, 1, 5000, 0),
  [](1, 3, 1, 5000, 0),
  [](4, 3, 1, 5000, 0),
  [](0, 2, 1, 6000, 0), <span class="comment">(* ? *)</span>
  [](0, 4, 1, 6000, 0), <span class="comment">(* ? *)</span>
  [](3, 4, 1, 6000, 0), <span class="comment">(* ? *)</span>
  [](0, 2, 1, 6000, 0), <span class="comment">(* ? *)</span>
  [](0, 4, 1, 7000, 0), <span class="comment">(* ? *)</span>
  [](2, 5, 1, 7000, 0), <span class="comment">(* ? *)</span>
  [](0, 2, 1, 7000, 0), <span class="comment">(* ? *)</span>
  [](0, 4, 1, 7000, 0), <span class="comment">(* ? *)</span>
  [](1, 6, 1, 8000, 0), <span class="comment">(* ? *)</span>
  [](0, 2, 1, 8000, 0), <span class="comment">(* ? *)</span>
  [](0, 4, 1, 8000, 0), <span class="comment">(* ? *)</span>
  [](0, 7, 1, 8000, 0), <span class="comment">(* ? *)</span>
  [](0, 1, 2, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 3, 2, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 6, 2, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 0, 3, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 2, 3, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 5, 3, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 0, 3, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 1, 4, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 4, 4, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 0, 3, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 0, 5, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 3, 5, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 0, 3, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 0, 5, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 2, 6, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 0, 3, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 0, 5, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 1, 7, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 0, 3, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 0, 5, 9000, 0), <span class="comment">(* ? *)</span>
  [](0, 0, 8, 9000, 0));<span class="comment">(* ? *)</span>

<span class="keywd">const</span> <span class="type">type</span>: ladderLayout <span class="keywd">is</span> <span class="type">array</span> <span class="type">array</span> integer;

<span class="keywd">const</span> <span class="type">array</span> <span class="type">ladderLayout</span>: layout_description <span class="keywd">is</span> [](
  []([](1, 6,   8), [](1, 2,  48), [](1, 3,  96), [](1, 6, 256), [](2, 3, 160),
     [](2, 4, 200), [](3, 5,  80), [](5, 6,  64), [](5, 6, 160)),
  []([](1, 4,   8), [](1, 2,  72), [](1, 6, 128), [](1, 2, 192), [](2, 5, 176),
     [](3, 4,  40), [](3, 5,  80), [](3, 6, 260), [](5, 6,   8)),
  []([](1, 2,   8), [](1, 2, 192), [](2, 4,  96), [](2, 6, 176), [](2, 4, 236),
     [](3, 4,   8), [](4, 5,  44), [](5, 6,   8), [](5, 6, 104), [](5, 6, 260)),
  []([](1, 6,   8), [](1, 3,  64), [](1, 2, 128), [](1, 6, 236), [](3, 6, 164),
     [](4, 5,  64), [](5, 6, 106))
  );

<span class="keywd">var</span> <span class="type">array</span> <span class="type">array</span> <span class="type">PRIMITIVE_WINDOW</span>: monster_pixmap <span class="keywd">is</span> 3 <span class="op">times</span> 0 <span class="op">times</span> PRIMITIVE_WINDOW.value;
<span class="keywd">var</span> <span class="type">array</span> <span class="type">PRIMITIVE_WINDOW</span>: player_left_pixmap <span class="keywd">is</span> 0 <span class="op">times</span> PRIMITIVE_WINDOW.value;
<span class="keywd">var</span> <span class="type">array</span> <span class="type">PRIMITIVE_WINDOW</span>: player_right_pixmap <span class="keywd">is</span> 0 <span class="op">times</span> PRIMITIVE_WINDOW.value;
<span class="keywd">var</span> <span class="type">array</span> <span class="type">PRIMITIVE_WINDOW</span>: player_up_pixmap <span class="keywd">is</span> 0 <span class="op">times</span> PRIMITIVE_WINDOW.value;
<span class="keywd">var</span> <span class="type">array</span> <span class="type">PRIMITIVE_WINDOW</span>: player_down_pixmap <span class="keywd">is</span> 0 <span class="op">times</span> PRIMITIVE_WINDOW.value;
<span class="keywd">var</span> <span class="type">array</span> <span class="type">PRIMITIVE_WINDOW</span>: player_falling_pixmap <span class="keywd">is</span> 0 <span class="op">times</span> PRIMITIVE_WINDOW.value;
<span class="keywd">var</span> <span class="type">array</span> <span class="type">PRIMITIVE_WINDOW</span>: player_dig_left_pixmap <span class="keywd">is</span> 0 <span class="op">times</span> PRIMITIVE_WINDOW.value;
<span class="keywd">var</span> <span class="type">array</span> <span class="type">PRIMITIVE_WINDOW</span>: player_dig_right_pixmap <span class="keywd">is</span> 0 <span class="op">times</span> PRIMITIVE_WINDOW.value;
<span class="keywd">var</span> <span class="type">array</span> <span class="type">PRIMITIVE_WINDOW</span>: digit_pixmap <span class="keywd">is</span> 0 <span class="op">times</span> PRIMITIVE_WINDOW.value;
<span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: player_reserve_pixmap <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
<span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: score_text_pixmap <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
<span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: bonus_text_pixmap <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
<span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: hiscore_text_pixmap <span class="keywd">is</span> PRIMITIVE_WINDOW.value;

<span class="keywd">const</span> <span class="type">type</span>: pixmap_array <span class="keywd">is</span> <span class="type">array</span> <span class="type">PRIMITIVE_WINDOW</span>;

<span class="keywd">const</span> <span class="type">type</span>: screenObj <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: line <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: column <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: height <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: width <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: line_direction <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: column_direction <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: moving <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">boolean</span>: falling <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: motionIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: motionSpeed <span class="keywd">is</span> FULL_MOTION;
    <span class="keywd">var</span> <span class="type">integer</span>: actual_pixmap_index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">pixmap_array</span>: pixmap <span class="keywd">is</span> 0 <span class="op">times</span> PRIMITIVE_WINDOW.value;
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: saved_pixmap <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: playerObj <span class="keywd">is</span> sub screenObj <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">char</span>:    command <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">boolean</span>: living <span class="keywd">is</span> TRUE;
    <span class="keywd">var</span> <span class="type">boolean</span>: digging <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: dig_direction <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: face_direction <span class="keywd">is</span> 1;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: monsterObj <span class="keywd">is</span> sub screenObj <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: category <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: saved_column_direction <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">time</span>:    action_time <span class="keywd">is</span> time.value;
    <span class="keywd">var</span> <span class="type">integer</span>: holes_passed <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: basePoints <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: points <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: catching <span class="keywd">is</span> FALSE;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: gameObj <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: num_players <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: round_number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: round_bonus <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: num_monsters <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: score <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: hiScore <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">time</span>: turn_time <span class="keywd">is</span> time.value;
    <span class="keywd">var</span> <span class="type">boolean</span>: round_finished <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: restart <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">boolean</span>: quit <span class="keywd">is</span> FALSE;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">var</span> <span class="type">array</span> <span class="type">monsterObj</span>: monster <span class="keywd">is</span> 0 <span class="op">times</span> monsterObj.value;
<span class="keywd">var</span> <span class="type">playerObj</span>: player <span class="keywd">is</span> playerObj.value;
<span class="keywd">var</span> <span class="type">gameObj</span>: game <span class="keywd">is</span> gameObj.value;

<span class="keywd">const</span> <span class="type">array</span> <span class="type">integer</span>: level_line <span class="keywd">is</span> [](
    1, 33, 65, 97, 129, 161
  );

<span class="keywd">var</span> <span class="type">array</span> <span class="type">array</span> <span class="type">boolean</span>: field <span class="keywd">is</span> FIELD_LINES <span class="op">times</span> FIELD_COLUMNS <span class="op">times</span> FALSE;
<span class="keywd">var</span> <span class="type">array</span> <span class="type">array</span> <span class="type">holeType</span>: hole_status <span class="keywd">is</span> FIELD_LINES <span class="op">times</span> FIELD_COLUMNS <span class="op">times</span> no_hole;

<span class="keywd">var</span> <span class="type">text</span>: scr <span class="keywd">is</span> STD_NULL;


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: player_right_1 <span class="keywd">is</span> [](
  <span class="stri">"    WWWWW     "</span>,
  <span class="stri">"    WW WWW    "</span>,
  <span class="stri">"    WWWWW   WW"</span>,
  <span class="stri">"     WWW    WW"</span>,
  <span class="stri">"      W    WW "</span>,
  <span class="stri">"  WWWWWWWWWW  "</span>,
  <span class="stri">" WW  WWW      "</span>,
  <span class="stri">"WW   WWW      "</span>,
  <span class="stri">"WW   WWW      "</span>,
  <span class="stri">"    WWWWWWWW  "</span>,
  <span class="stri">"    WW    WW  "</span>,
  <span class="stri">"    WW    WW  "</span>,
  <span class="stri">"    WW    WW  "</span>,
  <span class="stri">"    WW    WWW "</span>,
  <span class="stri">"    WW        "</span>,
  <span class="stri">"    WWW       "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: player_right_2 <span class="keywd">is</span> [](
  <span class="stri">"    WWWWW     "</span>,
  <span class="stri">"    WW WWW    "</span>,
  <span class="stri">"    WWWWW     "</span>,
  <span class="stri">"     WWW      "</span>,
  <span class="stri">"      W       "</span>,
  <span class="stri">"   WWWWWWW  WW"</span>,
  <span class="stri">"  WW WWW WW WW"</span>,
  <span class="stri">" WW  WWW  WWW "</span>,
  <span class="stri">"  WW WWW      "</span>,
  <span class="stri">"    WWWWWW    "</span>,
  <span class="stri">"    WW  WW    "</span>,
  <span class="stri">"    WW  WW    "</span>,
  <span class="stri">"WWWWWW  WW    "</span>,
  <span class="stri">"W       WW    "</span>,
  <span class="stri">"        WW    "</span>,
  <span class="stri">"        WWW   "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: player_left_1 <span class="keywd">is</span> [](
  <span class="stri">"     WWWWW    "</span>,
  <span class="stri">"    WWW WW    "</span>,
  <span class="stri">"WW   WWWWW    "</span>,
  <span class="stri">"WW    WWW     "</span>,
  <span class="stri">" WW    W      "</span>,
  <span class="stri">"  WWWWWWWWWW  "</span>,
  <span class="stri">"      WWW  WW "</span>,
  <span class="stri">"      WWW   WW"</span>,
  <span class="stri">"      WWW   WW"</span>,
  <span class="stri">"  WWWWWWWW    "</span>,
  <span class="stri">"  WW    WW    "</span>,
  <span class="stri">"  WW    WW    "</span>,
  <span class="stri">"  WW    WW    "</span>,
  <span class="stri">" WWW    WW    "</span>,
  <span class="stri">"        WW    "</span>,
  <span class="stri">"       WWW    "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: player_left_2 <span class="keywd">is</span> [](
  <span class="stri">"     WWWWW    "</span>,
  <span class="stri">"    WWW WW    "</span>,
  <span class="stri">"     WWWWW    "</span>,
  <span class="stri">"      WWW     "</span>,
  <span class="stri">"       W      "</span>,
  <span class="stri">"WW  WWWWWWW   "</span>,
  <span class="stri">"WW WW WWW WW  "</span>,
  <span class="stri">" WWW  WWW  WW "</span>,
  <span class="stri">"      WWW WW  "</span>,
  <span class="stri">"    WWWWWW    "</span>,
  <span class="stri">"    WW  WW    "</span>,
  <span class="stri">"    WW  WW    "</span>,
  <span class="stri">"    WW  WWWWWW"</span>,
  <span class="stri">"    WW       W"</span>,
  <span class="stri">"    WW        "</span>,
  <span class="stri">"   WWW        "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: player_falling <span class="keywd">is</span> [](
  <span class="stri">" WW  WWW    "</span>,
  <span class="stri">" WW WWWWW   "</span>,
  <span class="stri">" WW WWWWW   "</span>,
  <span class="stri">" WW  WWW    "</span>,
  <span class="stri">"  WW  W     "</span>,
  <span class="stri">"   WWWWWWWW "</span>,
  <span class="stri">"     WWW  WW"</span>,
  <span class="stri">"     WWW  WW"</span>,
  <span class="stri">"     WWW  WW"</span>,
  <span class="stri">" WWWWWWWW WW"</span>,
  <span class="stri">" WW    WW   "</span>,
  <span class="stri">" WW    WW   "</span>,
  <span class="stri">" WW    WW   "</span>,
  <span class="stri">"       WW   "</span>,
  <span class="stri">"       WW   "</span>,
  <span class="stri">"       WW   "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: player_dig_right_1 <span class="keywd">is</span> [](
  <span class="stri">" WWWWW       "</span>,
  <span class="stri">" WW WWW      "</span>,
  <span class="stri">" WWWWW       "</span>,
  <span class="stri">"  WWW        "</span>,
  <span class="stri">"   W         "</span>,
  <span class="stri">" WWWWWW      "</span>,
  <span class="stri">" WWWW WW     "</span>,
  <span class="stri">"  WWWW WW    "</span>,
  <span class="stri">"  WWWWWWW    "</span>,
  <span class="stri">"  WWW  WW    "</span>,
  <span class="stri">" WW WW  WW   "</span>,
  <span class="stri">" WW WW   WW  "</span>,
  <span class="stri">" WW WW    WWW"</span>,
  <span class="stri">" WW WW    WWW"</span>,
  <span class="stri">" WW WW     WW"</span>,
  <span class="stri">"WWW WWW     W"</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: player_dig_right_2 <span class="keywd">is</span> [](
  <span class="stri">" WWWWW     WW"</span>,
  <span class="stri">" WW WWW   WWW"</span>,
  <span class="stri">" WWWWW   WWWW"</span>,
  <span class="stri">"  WWW   WW   "</span>,
  <span class="stri">"   W   WW    "</span>,
  <span class="stri">"  WWWWWWW    "</span>,
  <span class="stri">"  WWW  WW    "</span>,
  <span class="stri">"  WWWWWW     "</span>,
  <span class="stri">"  WWW        "</span>,
  <span class="stri">"  WWW        "</span>,
  <span class="stri">" WW WW       "</span>,
  <span class="stri">" WW WW       "</span>,
  <span class="stri">" WW WW       "</span>,
  <span class="stri">" WW WW       "</span>,
  <span class="stri">" WW WW       "</span>,
  <span class="stri">"WWW WWW      "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: player_dig_left_1 <span class="keywd">is</span> [](
  <span class="stri">"       WWWWW "</span>,
  <span class="stri">"      WWW WW "</span>,
  <span class="stri">"       WWWWW "</span>,
  <span class="stri">"        WWW  "</span>,
  <span class="stri">"         W   "</span>,
  <span class="stri">"      WWWWWW "</span>,
  <span class="stri">"     WW WWWW "</span>,
  <span class="stri">"    WW WWWW  "</span>,
  <span class="stri">"    WWWWWWW  "</span>,
  <span class="stri">"    WW  WWW  "</span>,
  <span class="stri">"   WW  WW WW "</span>,
  <span class="stri">"  WW   WW WW "</span>,
  <span class="stri">"WWW    WW WW "</span>,
  <span class="stri">"WWW    WW WW "</span>,
  <span class="stri">"WW     WW WW "</span>,
  <span class="stri">"W     WWW WWW"</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: player_dig_left_2 <span class="keywd">is</span> [](
  <span class="stri">"WW     WWWWW "</span>,
  <span class="stri">"WWW   WWW WW "</span>,
  <span class="stri">"WWWW   WWWWW "</span>,
  <span class="stri">"   WW   WWW  "</span>,
  <span class="stri">"    WW   W   "</span>,
  <span class="stri">"    WWWWWWW  "</span>,
  <span class="stri">"    WW  WWW  "</span>,
  <span class="stri">"     WWWWWW  "</span>,
  <span class="stri">"        WWW  "</span>,
  <span class="stri">"        WWW  "</span>,
  <span class="stri">"       WW WW "</span>,
  <span class="stri">"       WW WW "</span>,
  <span class="stri">"       WW WW "</span>,
  <span class="stri">"       WW WW "</span>,
  <span class="stri">"       WW WW "</span>,
  <span class="stri">"      WWW WWW"</span>);

<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: player_up_down_1 <span class="keywd">is</span> [](
  <span class="stri">"    WWWWW WWW"</span>,
  <span class="stri">"    WWWWW WWW"</span>,
  <span class="stri">"    WWWWW WWW"</span>,
  <span class="stri">"     WWW  WWW"</span>,
  <span class="stri">"      W WWW  "</span>,
  <span class="stri">"  WWWWWWWWW  "</span>,
  <span class="stri">"WWW  WWW     "</span>,
  <span class="stri">"WWW  WWW     "</span>,
  <span class="stri">"WWW WWWWW    "</span>,
  <span class="stri">"WWW WWWWWWWWW"</span>,
  <span class="stri">"    WW    WWW"</span>,
  <span class="stri">"    WW    WWW"</span>,
  <span class="stri">"    WWW   WWW"</span>,
  <span class="stri">"    WWW      "</span>,
  <span class="stri">"    WW       "</span>,
  <span class="stri">"    WW       "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: player_up_down_2 <span class="keywd">is</span> [](
  <span class="stri">"WWW  WWW     "</span>,
  <span class="stri">"WWW WWWWW    "</span>,
  <span class="stri">"WWW WWWWW    "</span>,
  <span class="stri">"WWW WWWWW    "</span>,
  <span class="stri">"  WW  W      "</span>,
  <span class="stri">"   WWWWWWWW  "</span>,
  <span class="stri">"    WWWWW WWW"</span>,
  <span class="stri">"    WWWWW WWW"</span>,
  <span class="stri">"     WWW  WWW"</span>,
  <span class="stri">"WWWWWWWWW WWW"</span>,
  <span class="stri">"WWW   WWW    "</span>,
  <span class="stri">"WWW   WWW    "</span>,
  <span class="stri">"WWW    WW    "</span>,
  <span class="stri">"       WW    "</span>,
  <span class="stri">"      WWW    "</span>,
  <span class="stri">"      WWW    "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: monster1_1 <span class="keywd">is</span> [](
  <span class="stri">"B           B"</span>,
  <span class="stri">"B           B"</span>,
  <span class="stri">"BBBBB   BBBBB"</span>,
  <span class="stri">"     OOO     "</span>,
  <span class="stri">"   OOOOOOO   "</span>,
  <span class="stri">" O      B  O "</span>,
  <span class="stri">" O      B  O "</span>,
  <span class="stri">" O         O "</span>,
  <span class="stri">" OOOOOOOOOOO "</span>,
  <span class="stri">"   O     O   "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: monster1_2 <span class="keywd">is</span> [](
  <span class="stri">"B           B"</span>,
  <span class="stri">"BB         BB"</span>,
  <span class="stri">"B BBB   BBB B"</span>,
  <span class="stri">"     OOO     "</span>,
  <span class="stri">"   OOOOOOO   "</span>,
  <span class="stri">" O     B   O "</span>,
  <span class="stri">" O     B   O "</span>,
  <span class="stri">" O         O "</span>,
  <span class="stri">" OOOOOOOOOOO "</span>,
  <span class="stri">"   OO   OO   "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: monster1_3 <span class="keywd">is</span> [](
  <span class="stri">"B           B"</span>,
  <span class="stri">"BBBB     BBBB"</span>,
  <span class="stri">"B   B   B   B"</span>,
  <span class="stri">"     OOO     "</span>,
  <span class="stri">"   OOOOOOO   "</span>,
  <span class="stri">" O    B    O "</span>,
  <span class="stri">" O    B    O "</span>,
  <span class="stri">" O         O "</span>,
  <span class="stri">" OOOOOOOOOOO "</span>,
  <span class="stri">"  O O   O O  "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: monster1_4 <span class="keywd">is</span> [](
  <span class="stri">"BBB       BBB"</span>,
  <span class="stri">"B  B     B  B"</span>,
  <span class="stri">"    B   B    "</span>,
  <span class="stri">"     OOO     "</span>,
  <span class="stri">"   OOOOOOO   "</span>,
  <span class="stri">" O   B     O "</span>,
  <span class="stri">" O   B     O "</span>,
  <span class="stri">" O         O "</span>,
  <span class="stri">" OOOOOOOOOOO "</span>,
  <span class="stri">"  O  O O  O  "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: monster1_5 <span class="keywd">is</span> [](
  <span class="stri">"BBB       BBB"</span>,
  <span class="stri">"B   B   B   B"</span>,
  <span class="stri">"    B   B    "</span>,
  <span class="stri">"     OOO     "</span>,
  <span class="stri">"   OOOOOOO   "</span>,
  <span class="stri">" O  B      O "</span>,
  <span class="stri">" O  B      O "</span>,
  <span class="stri">" O         O "</span>,
  <span class="stri">" OOOOOOOOOOO "</span>,
  <span class="stri">" O   OOO   O "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: monster2_1 <span class="keywd">is</span> [](
  <span class="stri">"  G       G  "</span>,
  <span class="stri">"  G       G  "</span>,
  <span class="stri">"GGGGG   GGGGG"</span>,
  <span class="stri">"GGGGG   GGGGG"</span>,
  <span class="stri">"G  M  G  M  G"</span>,
  <span class="stri">"G     G     G"</span>,
  <span class="stri">"GGGGGGGGGGGGG"</span>,
  <span class="stri">"  GGGGGGGGG  "</span>,
  <span class="stri">"  OOO   OOO  "</span>,
  <span class="stri">"OOO       OOO"</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: monster2_2 <span class="keywd">is</span> [](
  <span class="stri">"G           G"</span>,
  <span class="stri">"GGG       GGG"</span>,
  <span class="stri">"GGG       GGG"</span>,
  <span class="stri">"GGGGG   GGGGG"</span>,
  <span class="stri">"G     G     G"</span>,
  <span class="stri">"G  M  G  M  G"</span>,
  <span class="stri">"GGGGGGGGGGGGG"</span>,
  <span class="stri">"  GGGGGGGGG  "</span>,
  <span class="stri">"  OOO   OOO  "</span>,
  <span class="stri">"    O   O    "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: monster3_1 <span class="keywd">is</span> [](
  <span class="stri">"  B       B  "</span>,
  <span class="stri">"  BBB   BBB  "</span>,
  <span class="stri">"BBBBB   BBBBB"</span>,
  <span class="stri">"BBBBB   BBBBB"</span>,
  <span class="stri">"  B  OOO  B  "</span>,
  <span class="stri">"  B  OOO  B  "</span>,
  <span class="stri">"  BBB   BBB  "</span>,
  <span class="stri">"  B   B   B  "</span>,
  <span class="stri">"    BBBBB    "</span>,
  <span class="stri">"    B   B    "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: monster3_2 <span class="keywd">is</span> [](
  <span class="stri">"B           B"</span>,
  <span class="stri">"BBB       BBB"</span>,
  <span class="stri">"BBB       BBB"</span>,
  <span class="stri">"BBB  OOO  BBB"</span>,
  <span class="stri">"  B  OOO  B  "</span>,
  <span class="stri">"  B       B  "</span>,
  <span class="stri">"  BBB   BBB  "</span>,
  <span class="stri">"  B   B   B  "</span>,
  <span class="stri">"B     B     B"</span>,
  <span class="stri">"B           B"</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: player_reserve <span class="keywd">is</span> [](
  <span class="stri">"  WWW  "</span>,
  <span class="stri">"  WWW  "</span>,
  <span class="stri">"W  W  W"</span>,
  <span class="stri">" WWWWW "</span>,
  <span class="stri">"   W   "</span>,
  <span class="stri">"  WWW  "</span>,
  <span class="stri">" W   W "</span>,
  <span class="stri">"W     W"</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: score_text <span class="keywd">is</span> [](
  <span class="stri">" WWW    WWW        "</span>,
  <span class="stri">"G   G  M   M       "</span>,
  <span class="stri">"G      M           "</span>,
  <span class="stri">" WWW   M      WWWWW"</span>,
  <span class="stri">"    G  M           "</span>,
  <span class="stri">"G   G  M   M       "</span>,
  <span class="stri">" WWW    WWW        "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: bonus_text <span class="keywd">is</span> [](
  <span class="stri">"WWWW    WWW   M   M  G   G   WWW        "</span>,
  <span class="stri">"M   M  G   G  M   M  G   G  M   M       "</span>,
  <span class="stri">"M   M  G   G  WW  M  G   G  M           "</span>,
  <span class="stri">"WWWW   G   G  MMMMM  G   G   WWW   WWWWW"</span>,
  <span class="stri">"M   M  G   G  M  WW  G   G      M       "</span>,
  <span class="stri">"M   M  G   G  M   M  G   G  M   M       "</span>,
  <span class="stri">"WWWW    WWW   M   M   WWW    WWW        "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: hiscore_text <span class="keywd">is</span> [](
  <span class="stri">"M   M   WWW        "</span>,
  <span class="stri">"M   M    G         "</span>,
  <span class="stri">"M   M    G         "</span>,
  <span class="stri">"WWWWW    G    WWWWW"</span>,
  <span class="stri">"M   M    G         "</span>,
  <span class="stri">"M   M    G         "</span>,
  <span class="stri">"M   M   WWW        "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: zero <span class="keywd">is</span> [](
  <span class="stri">"     "</span>,
  <span class="stri">" WWW "</span>,
  <span class="stri">"M   M"</span>,
  <span class="stri">"M   M"</span>,
  <span class="stri">"M   M"</span>,
  <span class="stri">"M   M"</span>,
  <span class="stri">" WWW "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: one <span class="keywd">is</span> [](
  <span class="stri">"  WW "</span>,
  <span class="stri">" MMM "</span>,
  <span class="stri">"   M "</span>,
  <span class="stri">"   M "</span>,
  <span class="stri">"   M "</span>,
  <span class="stri">"   M "</span>,
  <span class="stri">"  WWW"</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: two <span class="keywd">is</span> [](
  <span class="stri">" WWW "</span>,
  <span class="stri">"G   G"</span>,
  <span class="stri">"    G"</span>,
  <span class="stri">"   M "</span>,
  <span class="stri">" WW  "</span>,
  <span class="stri">"G    "</span>,
  <span class="stri">"WWWWW"</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: three <span class="keywd">is</span> [](
  <span class="stri">" WWW "</span>,
  <span class="stri">"M   M"</span>,
  <span class="stri">"    M"</span>,
  <span class="stri">"  WW "</span>,
  <span class="stri">"    M"</span>,
  <span class="stri">"M   M"</span>,
  <span class="stri">" WWW "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: four <span class="keywd">is</span> [](
  <span class="stri">"G    "</span>,
  <span class="stri">"G    "</span>,
  <span class="stri">"G  M "</span>,
  <span class="stri">"WWWWW"</span>,
  <span class="stri">"   M "</span>,
  <span class="stri">"   M "</span>,
  <span class="stri">"   M "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: five <span class="keywd">is</span> [](
  <span class="stri">"WWWW "</span>,
  <span class="stri">"M    "</span>,
  <span class="stri">"M    "</span>,
  <span class="stri">"WWWW "</span>,
  <span class="stri">"    M"</span>,
  <span class="stri">"    M"</span>,
  <span class="stri">"WWWW "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: six <span class="keywd">is</span> [](
  <span class="stri">" WWW "</span>,
  <span class="stri">"G   G"</span>,
  <span class="stri">"G    "</span>,
  <span class="stri">"WWWW "</span>,
  <span class="stri">"G   G"</span>,
  <span class="stri">"G   G"</span>,
  <span class="stri">" WWW "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: seven <span class="keywd">is</span> [](
  <span class="stri">"WWWWW"</span>,
  <span class="stri">"M   M"</span>,
  <span class="stri">"    M"</span>,
  <span class="stri">"   G "</span>,
  <span class="stri">"   G "</span>,
  <span class="stri">"  M  "</span>,
  <span class="stri">"  M  "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: eight <span class="keywd">is</span> [](
  <span class="stri">" WWW "</span>,
  <span class="stri">"G   G"</span>,
  <span class="stri">"G   G"</span>,
  <span class="stri">" WWW "</span>,
  <span class="stri">"G   G"</span>,
  <span class="stri">"G   G"</span>,
  <span class="stri">" WWW "</span>);


<span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: nine <span class="keywd">is</span> [](
  <span class="stri">" WWW "</span>,
  <span class="stri">"M   M"</span>,
  <span class="stri">"M   M"</span>,
  <span class="stri">" WWWW"</span>,
  <span class="stri">"    M"</span>,
  <span class="stri">"M   M"</span>,
  <span class="stri">" WWW "</span>);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">PRIMITIVE_WINDOW</span>: createPixmap (<span class="op">in</span> <span class="type">array</span> <span class="type">string</span>: pattern) <span class="keywd">is</span>
  <span class="keywd">return</span> createPixmap(pattern, PICTURE_SCALE, black);


<span class="keywd">const</span> <span class="type">proc</span>: init_pictures <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    monster_pixmap[1] := 8 <span class="op">times</span> PRIMITIVE_WINDOW.value;
    monster_pixmap[1][1] := createPixmap(monster1_1);
    monster_pixmap[1][2] := monster_pixmap[1][1];
    monster_pixmap[1][3] := monster_pixmap[1][1];
    monster_pixmap[1][4] := monster_pixmap[1][1];
    monster_pixmap[1][5] := createPixmap(monster1_5);
    monster_pixmap[1][6] := monster_pixmap[1][5];
    monster_pixmap[1][7] := monster_pixmap[1][5];
    monster_pixmap[1][8] := monster_pixmap[1][5];
    monster_pixmap[2] := 8 <span class="op">times</span> PRIMITIVE_WINDOW.value;
    monster_pixmap[2][1] := createPixmap(monster2_1);
    monster_pixmap[2][2] := monster_pixmap[2][1];
    monster_pixmap[2][3] := monster_pixmap[2][1];
    monster_pixmap[2][4] := monster_pixmap[2][1];
    monster_pixmap[2][5] := createPixmap(monster2_2);
    monster_pixmap[2][6] := monster_pixmap[2][5];
    monster_pixmap[2][7] := monster_pixmap[2][5];
    monster_pixmap[2][8] := monster_pixmap[2][5];
    monster_pixmap[3] := 8 <span class="op">times</span> PRIMITIVE_WINDOW.value;
    monster_pixmap[3][1] := createPixmap(monster3_1);
    monster_pixmap[3][2] := monster_pixmap[3][1];
    monster_pixmap[3][3] := monster_pixmap[3][1];
    monster_pixmap[3][4] := monster_pixmap[3][1];
    monster_pixmap[3][5] := createPixmap(monster3_2);
    monster_pixmap[3][6] := monster_pixmap[3][5];
    monster_pixmap[3][7] := monster_pixmap[3][5];
    monster_pixmap[3][8] := monster_pixmap[3][5];
    player_right_pixmap := 6 <span class="op">times</span> PRIMITIVE_WINDOW.value;
    player_right_pixmap[1] := createPixmap(player_right_1);
    player_right_pixmap[2] := player_right_pixmap[1];
    player_right_pixmap[3] := player_right_pixmap[1];
    player_right_pixmap[4] := createPixmap(player_right_2);
    player_right_pixmap[5] := player_right_pixmap[4];
    player_right_pixmap[6] := player_right_pixmap[4];
    player_left_pixmap := 6 <span class="op">times</span> PRIMITIVE_WINDOW.value;
    player_left_pixmap[1] := createPixmap(player_left_1);
    player_left_pixmap[2] := player_left_pixmap[1];
    player_left_pixmap[3] := player_left_pixmap[1];
    player_left_pixmap[4] := createPixmap(player_left_2);
    player_left_pixmap[5] := player_left_pixmap[4];
    player_left_pixmap[6] := player_left_pixmap[4];
    player_up_pixmap := 6 <span class="op">times</span> PRIMITIVE_WINDOW.value;
    player_up_pixmap[1] := createPixmap(player_up_down_1);
    player_up_pixmap[2] := player_up_pixmap[1];
    player_up_pixmap[3] := player_up_pixmap[1];
    player_up_pixmap[4] := createPixmap(player_up_down_2);
    player_up_pixmap[5] := player_up_pixmap[4];
    player_up_pixmap[6] := player_up_pixmap[4];
    player_down_pixmap := 6 <span class="op">times</span> PRIMITIVE_WINDOW.value;
    player_down_pixmap[1] := createPixmap(player_up_down_1);
    player_down_pixmap[2] := player_down_pixmap[1];
    player_down_pixmap[3] := player_down_pixmap[1];
    player_down_pixmap[4] := createPixmap(player_up_down_2);
    player_down_pixmap[5] := player_down_pixmap[4];
    player_down_pixmap[6] := player_down_pixmap[4];
    player_falling_pixmap := 1 <span class="op">times</span> PRIMITIVE_WINDOW.value;
    player_falling_pixmap[1] := createPixmap(player_falling);
    player_dig_right_pixmap := 22 <span class="op">times</span> PRIMITIVE_WINDOW.value;
    player_dig_right_pixmap[1] := createPixmap(player_dig_right_1);
    player_dig_right_pixmap[2] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[3] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[4] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[5] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[6] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[7] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[8] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[9] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[10] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[11] := player_dig_right_pixmap[1];
    player_dig_right_pixmap[12] := createPixmap(player_dig_right_2);
    player_dig_right_pixmap[13] := player_dig_right_pixmap[12];
    player_dig_right_pixmap[14] := player_dig_right_pixmap[12];
    player_dig_right_pixmap[15] := player_dig_right_pixmap[12];
    player_dig_right_pixmap[16] := player_dig_right_pixmap[12];
    player_dig_right_pixmap[17] := player_dig_right_pixmap[12];
    player_dig_right_pixmap[18] := player_dig_right_pixmap[12];
    player_dig_right_pixmap[19] := player_dig_right_pixmap[12];
    player_dig_right_pixmap[20] := player_dig_right_pixmap[12];
    player_dig_right_pixmap[21] := player_dig_right_pixmap[12];
    player_dig_right_pixmap[22] := player_dig_right_pixmap[12];
    player_dig_left_pixmap := 22 <span class="op">times</span> PRIMITIVE_WINDOW.value;
    player_dig_left_pixmap[1] := createPixmap(player_dig_left_1);
    player_dig_left_pixmap[2] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[3] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[4] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[5] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[6] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[7] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[8] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[9] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[10] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[11] := player_dig_left_pixmap[1];
    player_dig_left_pixmap[12] := createPixmap(player_dig_left_2);
    player_dig_left_pixmap[13] := player_dig_left_pixmap[12];
    player_dig_left_pixmap[14] := player_dig_left_pixmap[12];
    player_dig_left_pixmap[15] := player_dig_left_pixmap[12];
    player_dig_left_pixmap[16] := player_dig_left_pixmap[12];
    player_dig_left_pixmap[17] := player_dig_left_pixmap[12];
    player_dig_left_pixmap[18] := player_dig_left_pixmap[12];
    player_dig_left_pixmap[19] := player_dig_left_pixmap[12];
    player_dig_left_pixmap[20] := player_dig_left_pixmap[12];
    player_dig_left_pixmap[21] := player_dig_left_pixmap[12];
    player_dig_left_pixmap[22] := player_dig_left_pixmap[12];
    digit_pixmap := [0](
      createPixmap(zero),
      createPixmap(one),
      createPixmap(two),
      createPixmap(three),
      createPixmap(four),
      createPixmap(five),
      createPixmap(six),
      createPixmap(seven),
      createPixmap(eight),
      createPixmap(nine));
    player_reserve_pixmap := createPixmap(player_reserve);
    score_text_pixmap := createPixmap(score_text);
    bonus_text_pixmap := createPixmap(bonus_text);
    hiscore_text_pixmap := createPixmap(hiscore_text);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: pause_game (<span class="op">in</span> <span class="type">boolean</span>: blankWindow, <span class="op">in</span> <span class="type">boolean</span>: exitWithAnyKey) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: exitPause <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">time</span>: pause_time <span class="keywd">is</span> time.value;
    <span class="keywd">var</span> <span class="type">duration</span>: pause_duration <span class="keywd">is</span> duration.value;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">char</span>: cmd <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    pause_time := time(NOW);
    <span class="keywd">if</span> blankWindow <span class="keywd">then</span>
      bossMode(game.quit);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">while</span> <span class="op">not</span> (exitPause <span class="op">or</span> game.quit) <span class="keywd">do</span>
      cmd := getc(KEYBOARD);
      <span class="keywd">if</span> cmd <span class="op">in</span> {<span class="stri">'Q'</span>, <span class="stri">'q'</span>, KEY_CLOSE} <span class="keywd">then</span>
        game.quit := TRUE;
      <span class="keywd">elsif</span> cmd = KEY_ESC <span class="keywd">then</span>
        bossMode(game.quit);
      <span class="keywd">else</span>
        exitPause := exitWithAnyKey <span class="op">or</span> cmd <span class="op">in</span> {<span class="stri">'P'</span>, <span class="stri">'p'</span>};
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    pause_duration := time(NOW) - pause_time;
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> length(monster) <span class="keywd">do</span>
      <span class="keywd">if</span> monster[number].action_time &lt;> time.value <span class="keywd">then</span>
        monster[number].action_time +:= pause_duration;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> game.turn_time &lt;> time.value <span class="keywd">then</span>
      game.turn_time +:= pause_duration;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: game_command (<span class="op">in</span> <span class="type">char</span>: cmd) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">case</span> cmd <span class="keywd">of</span>
      <span class="keywd">when</span> {KEY_CTL_R}:
        game.round_finished := TRUE;
        game.restart := TRUE;
      <span class="keywd">when</span> {<span class="stri">'Q'</span>, <span class="stri">'q'</span>, KEY_CLOSE}:
        game.quit := TRUE;
      <span class="keywd">when</span> {<span class="stri">'Y'</span>, <span class="stri">'y'</span>}:
        writeln(heapsize(PROGRAM));
      <span class="keywd">when</span> {KEY_ESC}:
        pause_game(TRUE, FALSE);
      <span class="keywd">when</span> {<span class="stri">'P'</span>, <span class="stri">'p'</span>}:
        pause_game(FALSE, FALSE);
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: draw_number (<span class="op">in</span> <span class="type">integer</span>: line, <span class="op">in</span> <span class="type">integer</span>: column, <span class="op">in</span> <span class="type">string</span>: num_stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length(num_stri) <span class="keywd">do</span>
      ch := num_stri[index];
      <span class="keywd">if</span> ch = <span class="stri">' '</span> <span class="keywd">then</span>
        rect(succ((column + index - 2) * 7) * FIELD_ELEM_STEP,
            succ((pred(line) * 8 + 2)       * FIELD_ELEM_STEP),
            5                               * FIELD_ELEM_STEP,
            7                               * FIELD_ELEM_STEP,
            black);
      <span class="keywd">else</span>
        put(succ((column + index - 2) * 7) * FIELD_ELEM_STEP,
            succ((pred(line) * 8 + 2)      * FIELD_ELEM_STEP),
            digit_pixmap[ord(ch) - ord(<span class="stri">'0'</span>)]);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">PRIMITIVE_WINDOW</span>: number_pixmap (<span class="op">in</span> <span class="type">string</span>: num_stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">PRIMITIVE_WINDOW</span>: pixmap <span class="keywd">is</span> PRIMITIVE_WINDOW.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    pixmap := newPixmap(
        (7 * length(num_stri) + 2) * PICTURE_SCALE,
        11                         * PICTURE_SCALE);
    clear(pixmap, black);
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length(num_stri) <span class="keywd">do</span>
      ch := num_stri[index];
      <span class="keywd">if</span> ch &lt;> <span class="stri">' '</span> <span class="keywd">then</span>
        put(pixmap,
            (2 + pred(index) * 7) * PICTURE_SCALE,
            2                     * PICTURE_SCALE,
            digit_pixmap[ord(ch) - ord(<span class="stri">'0'</span>)]);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: draw_level (<span class="op">in</span> <span class="type">integer</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    rect(2            * FIELD_ELEM_STEP,
         (17 + line)  * FIELD_ELEM_STEP,
         5            * FIELD_ELEM_STEP,
         2            * FIELD_ELEM_STEP,
         light_green);
    number := 10;
    <span class="keywd">while</span> number &lt; AREA_COLUMNS <span class="keywd">do</span>
      rect(number       * FIELD_ELEM_STEP,
           (17 + line)  * FIELD_ELEM_STEP,
           11           * FIELD_ELEM_STEP,
           2            * FIELD_ELEM_STEP,
           light_green);
      number +:= 14;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    rect(number                   * FIELD_ELEM_STEP,
         (17 + line)              * FIELD_ELEM_STEP,
         WIN_WIDTH - (number + 2) * FIELD_ELEM_STEP,
         2                        * FIELD_ELEM_STEP,
         light_green);
    number := 2;
    <span class="keywd">while</span> number &lt; AREA_COLUMNS <span class="keywd">do</span>
      rect(number        * FIELD_ELEM_STEP,
           (20 + line)   * FIELD_ELEM_STEP,
           11            * FIELD_ELEM_STEP,
           3             * FIELD_ELEM_STEP,
           light_green);
      number +:= 14;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    rect(number                   * FIELD_ELEM_STEP,
         (20 + line)              * FIELD_ELEM_STEP,
         WIN_WIDTH - (number + 2) * FIELD_ELEM_STEP,
         3                        * FIELD_ELEM_STEP,
         light_green);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: draw_base_level (<span class="op">in</span> <span class="type">integer</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    rect(2             * FIELD_ELEM_STEP,
         (17 + line)   * FIELD_ELEM_STEP,
         WIN_WIDTH - 4 * FIELD_ELEM_STEP,
         2             * FIELD_ELEM_STEP,
         orange);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: mark_level (<span class="op">in</span> <span class="type">integer</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> number <span class="keywd">range</span> succ(FIELD_BORDER) <span class="keywd">to</span> FIELD_COLUMNS - FIELD_BORDER <span class="keywd">do</span>
      field[FIELD_BORDER + line][number] := TRUE;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: draw_level_piece (<span class="op">in</span> <span class="type">integer</span>: line, <span class="op">in</span> <span class="type">integer</span>: column) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: col1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: col2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: len2 <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    col1 := 6 + (column + 3) <span class="op">div</span> 14 * 14;
    <span class="keywd">if</span> col1 >= column <span class="keywd">then</span>
      rect(column              * FIELD_ELEM_STEP,
           (16 + line)         * FIELD_ELEM_STEP,
           (col1 - column + 1) * FIELD_ELEM_STEP,
           2                   * FIELD_ELEM_STEP,
           light_green);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    col2 := 10 + (column + 3) <span class="op">div</span> 14 * 14;
    len2 := column + 13 - col2;
    <span class="keywd">if</span> len2 > 11 <span class="keywd">then</span>
      len2 := 11;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> col2 >= column <span class="comment">(* and col2 + 13 &lt;= column *)</span> <span class="keywd">then</span>
      rect(col2                 * FIELD_ELEM_STEP,
           (16 + line)          * FIELD_ELEM_STEP,
           len2                 * FIELD_ELEM_STEP,
           2                    * FIELD_ELEM_STEP,
           light_green);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    col1 := -2 + (column + 11) <span class="op">div</span> 14 * 14;
    <span class="keywd">if</span> col1 >= column <span class="keywd">then</span>
      rect(column              * FIELD_ELEM_STEP,
           (19 + line)         * FIELD_ELEM_STEP,
           (col1 - column + 1) * FIELD_ELEM_STEP,
           3                   * FIELD_ELEM_STEP,
           light_green);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    col2 := 2 + (column + 11) <span class="op">div</span> 14 * 14;
    len2 := column + 13 - col2;
    <span class="keywd">if</span> len2 > 11 <span class="keywd">then</span>
      len2 := 11;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> col2 >= column <span class="comment">(* and col2 + 13 &lt;= column *)</span> <span class="keywd">then</span>
      rect(col2                 * FIELD_ELEM_STEP,
           (19 + line)          * FIELD_ELEM_STEP,
           len2                 * FIELD_ELEM_STEP,
           3                    * FIELD_ELEM_STEP,
           light_green);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: draw_hole (<span class="op">in</span> <span class="type">integer</span>: line, <span class="op">in</span> <span class="type">integer</span>: column,
    <span class="op">in</span> <span class="type">holeType</span>: curr_hole_status) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    draw_level_piece(line, column);
    <span class="keywd">case</span> curr_hole_status <span class="keywd">of</span>
      <span class="keywd">when</span> {hole_depth1}:
        rect((2 + column) * FIELD_ELEM_STEP,
             (16 + line)  * FIELD_ELEM_STEP,
             9            * FIELD_ELEM_STEP,
             1            * FIELD_ELEM_STEP,
             black);
        rect((4 + column) * FIELD_ELEM_STEP,
             (17 + line)  * FIELD_ELEM_STEP,
             5            * FIELD_ELEM_STEP,
             1            * FIELD_ELEM_STEP,
             black);
      <span class="keywd">when</span> {hole_depth2}:
        rect(column       * FIELD_ELEM_STEP,
             (16 + line)  * FIELD_ELEM_STEP,
             13           * FIELD_ELEM_STEP,
             1            * FIELD_ELEM_STEP,
             black);
        rect((2 + column) * FIELD_ELEM_STEP,
             (17 + line)  * FIELD_ELEM_STEP,
             9            * FIELD_ELEM_STEP,
             1            * FIELD_ELEM_STEP,
             black);
        rect((4 + column) * FIELD_ELEM_STEP,
             (18 + line)  * FIELD_ELEM_STEP,
             5            * FIELD_ELEM_STEP,
             1            * FIELD_ELEM_STEP,
             black);
      <span class="keywd">when</span> {hole_depth3}:
        rect(column       * FIELD_ELEM_STEP,
             (16 + line)  * FIELD_ELEM_STEP,
             13           * FIELD_ELEM_STEP,
             2            * FIELD_ELEM_STEP,
             black);
        rect((2 + column) * FIELD_ELEM_STEP,
             (18 + line)  * FIELD_ELEM_STEP,
             9            * FIELD_ELEM_STEP,
             1            * FIELD_ELEM_STEP,
             black);
        rect((4 + column) * FIELD_ELEM_STEP,
             (19 + line)  * FIELD_ELEM_STEP,
             5            * FIELD_ELEM_STEP,
             1            * FIELD_ELEM_STEP,
             black);
      <span class="keywd">when</span> {hole_depth4}:
        rect(column       * FIELD_ELEM_STEP,
             (16 + line)  * FIELD_ELEM_STEP,
             13           * FIELD_ELEM_STEP,
             3            * FIELD_ELEM_STEP,
             black);
        rect((2 + column) * FIELD_ELEM_STEP,
             (19 + line)  * FIELD_ELEM_STEP,
             9            * FIELD_ELEM_STEP,
             1            * FIELD_ELEM_STEP,
             black);
        rect((4 + column) * FIELD_ELEM_STEP,
             (20 + line)  * FIELD_ELEM_STEP,
             5            * FIELD_ELEM_STEP,
             1            * FIELD_ELEM_STEP,
             black);
      <span class="keywd">when</span> {hole_finished}:
        rect(column       * FIELD_ELEM_STEP,
             (16 + line)  * FIELD_ELEM_STEP,
             13           * FIELD_ELEM_STEP,
             6            * FIELD_ELEM_STEP,
             black);
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: draw_ladder (<span class="op">in</span> <span class="type">integer</span>: line1, <span class="op">in</span> <span class="type">integer</span>: line2, <span class="op">in</span> <span class="type">integer</span>: column) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    rect((1 + column)        * FIELD_ELEM_STEP,
         (7 + line1)         * FIELD_ELEM_STEP,
         13                  * FIELD_ELEM_STEP,
         (line2- line1 + 10) * FIELD_ELEM_STEP,
         black);
    rect((1 + column)        * FIELD_ELEM_STEP,
         (7 + line1)         * FIELD_ELEM_STEP,
         1                   * FIELD_ELEM_STEP,
         (line2- line1 + 10) * FIELD_ELEM_STEP,
         light_magenta);
    rect((13 + column)       * FIELD_ELEM_STEP,
         (7 + line1)         * FIELD_ELEM_STEP,
         1                   * FIELD_ELEM_STEP,
         (line2- line1 + 10) * FIELD_ELEM_STEP,
         light_magenta);
    <span class="keywd">for</span> number <span class="keywd">range</span> line1 - 8 <span class="keywd">to</span> line2 - 4 step 4 <span class="keywd">do</span>
      rect((2 + column)  * FIELD_ELEM_STEP,
           (17 + number) * FIELD_ELEM_STEP,
           11            * FIELD_ELEM_STEP,
           2             * FIELD_ELEM_STEP,
           light_magenta);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: mark_ladder (<span class="op">in</span> <span class="type">integer</span>: line1, <span class="op">in</span> <span class="type">integer</span>: line2,
    <span class="op">in</span> <span class="type">integer</span>: column) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> number <span class="keywd">range</span> line1 <span class="keywd">to</span> line2 <span class="keywd">do</span>
      field[FIELD_BORDER + number][FIELD_BORDER + column] := TRUE;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: set_ladder (<span class="op">in</span> <span class="type">integer</span>: line1, <span class="op">in</span> <span class="type">integer</span>: line2,
    <span class="op">in</span> <span class="type">integer</span>: column) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    mark_ladder(line1, line2, column);
    draw_ladder(line1, line2, column);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_ladders (<span class="op">in</span> <span class="type">ladderLayout</span>: layout_descr) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> length(layout_descr) <span class="keywd">do</span>
      set_ladder(level_line[layout_descr[number][1]],
                 level_line[layout_descr[number][2]],
                 layout_descr[number][3]);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: change_direction (<span class="keywd">inout</span> <span class="type">screenObj</span>: monster) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: num_directions <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: random_direction <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    num_directions := 0;
    <span class="keywd">if</span> field[pred(monster.line)][monster.column] <span class="keywd">then</span>
      incr(num_directions);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> field[succ(monster.line)][monster.column] <span class="keywd">then</span>
      incr(num_directions);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> field[monster.line][pred(monster.column)] <span class="keywd">then</span>
      incr(num_directions);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> field[monster.line][succ(monster.column)] <span class="keywd">then</span>
      incr(num_directions);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> num_directions >= 1 <span class="keywd">then</span>
      random_direction := rand(1, num_directions);
      <span class="keywd">if</span> field[pred(monster.line)][monster.column] <span class="keywd">then</span>
        decr(random_direction);
        <span class="keywd">if</span> random_direction = 0 <span class="keywd">then</span>
          monster.line_direction := -SPEED;
          monster.column_direction := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> field[succ(monster.line)][monster.column] <span class="keywd">then</span>
        decr(random_direction);
        <span class="keywd">if</span> random_direction = 0 <span class="keywd">then</span>
          monster.line_direction := SPEED;
          monster.column_direction := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> field[monster.line][pred(monster.column)] <span class="keywd">then</span>
        decr(random_direction);
        <span class="keywd">if</span> random_direction = 0 <span class="keywd">then</span>
          monster.line_direction := 0;
          monster.column_direction := -SPEED;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> field[monster.line][succ(monster.column)] <span class="keywd">then</span>
        decr(random_direction);
        <span class="keywd">if</span> random_direction = 0 <span class="keywd">then</span>
          monster.line_direction := 0;
          monster.column_direction := SPEED;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: collision (<span class="op">in</span> <span class="type">screenObj</span>: obj1, <span class="op">in</span> <span class="type">screenObj</span>: obj2) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: collision <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> obj1.line + obj1.line_direction >= obj2.line - obj2.height <span class="op">and</span>
        obj1.line - obj1.height + obj1.line_direction &lt;= obj2.line <span class="op">and</span>
        obj1.column + obj1.width + obj1.column_direction >= obj2.column <span class="op">and</span>
        obj1.column + obj1.column_direction &lt;= obj2.column + obj2.width <span class="keywd">then</span>
      collision := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: collision2 (<span class="op">in</span> <span class="type">screenObj</span>: obj1, <span class="op">in</span> <span class="type">screenObj</span>: obj2) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: collision <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> obj1.line + obj1.line_direction > obj2.line - obj2.height + obj2.line_direction <span class="op">and</span>
        obj1.line - obj1.height + obj1.line_direction &lt; obj2.line + obj2.line_direction <span class="op">and</span>
        obj1.column + obj1.width + obj1.column_direction > obj2.column + obj2.column_direction <span class="op">and</span>
        obj1.column + obj1.column_direction &lt; obj2.column + obj2.width + obj2.column_direction <span class="op">or</span>
        obj1.line + obj1.line_direction > obj2.line - obj2.height <span class="op">and</span>
        obj1.line - obj1.height + obj1.line_direction &lt; obj2.line <span class="op">and</span>
        obj1.column + obj1.width + obj1.column_direction > obj2.column <span class="op">and</span>
        obj1.column + obj1.column_direction &lt; obj2.column + obj2.width <span class="keywd">then</span>
      collision := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: avoid_monster_collision (<span class="keywd">inout</span> <span class="type">screenObj</span>: screenObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: collision_found <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> length(monster) <span class="keywd">do</span>
      <span class="keywd">if</span> (screenObject.line &lt;> monster[number].line <span class="op">or</span>
          screenObject.column &lt;> monster[number].column) <span class="op">and</span>
          collision(screenObject, monster[number]) <span class="keywd">then</span>
        <span class="keywd">if</span> collision_found <span class="keywd">then</span>
          <span class="keywd">if</span> screenObject.column >= monster[number].column <span class="keywd">then</span>
            <span class="keywd">if</span> screenObject.column_direction &lt; 0 <span class="keywd">then</span>
              screenObject.column_direction := 0;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            <span class="keywd">if</span> screenObject.column_direction > 0 <span class="keywd">then</span>
              screenObject.column_direction := 0;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">if</span> screenObject.line >= monster[number].line <span class="keywd">then</span>
            <span class="keywd">if</span> screenObject.line_direction &lt; 0 <span class="keywd">then</span>
              screenObject.line_direction := 0;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">else</span>
            <span class="keywd">if</span> screenObject.line_direction > 0 <span class="keywd">then</span>
              screenObject.line_direction := 0;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          collision_found := TRUE;
          <span class="keywd">if</span> screenObject.column_direction &lt;> 0 <span class="keywd">then</span>
            <span class="keywd">if</span> screenObject.column >= monster[number].column <span class="keywd">then</span>
              screenObject.column_direction := SPEED;
            <span class="keywd">else</span>
              screenObject.column_direction := -SPEED;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">elsif</span> screenObject.line_direction &lt;> 0 <span class="keywd">then</span>
            <span class="keywd">if</span> screenObject.line >= monster[number].line <span class="keywd">then</span>
              screenObject.line_direction := SPEED;
            <span class="keywd">else</span>
              screenObject.line_direction := -SPEED;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: move (<span class="keywd">inout</span> <span class="type">screenObj</span>: screenObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> screenObject.moving <span class="op">and</span> screenObject.motionIndex = 0 <span class="keywd">then</span>
      incr(screenObject.actual_pixmap_index);
      <span class="keywd">if</span> screenObject.actual_pixmap_index > length(screenObject.pixmap) <span class="keywd">then</span>
        screenObject.actual_pixmap_index := 1;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> screenObject.line_direction &lt;> 0 <span class="op">or</span> screenObject.column_direction &lt;> 0 <span class="op">or</span>
          width(screenObject.saved_pixmap) &lt;> screenObject.width * PICTURE_SCALE <span class="keywd">then</span>
        put(FIELD_X_START + screenObject.column * FIELD_ELEM_STEP,
            FIELD_Y_START + screenObject.line * FIELD_ELEM_STEP - screenObject.height * PICTURE_SCALE,
            screenObject.saved_pixmap);
        screenObject.line +:= screenObject.line_direction;
        screenObject.column +:= screenObject.column_direction;
        screenObject.saved_pixmap := getPixmap(
            FIELD_X_START + screenObject.column * FIELD_ELEM_STEP,
            FIELD_Y_START + screenObject.line * FIELD_ELEM_STEP - screenObject.height * PICTURE_SCALE,
            screenObject.width * PICTURE_SCALE,
            screenObject.height * PICTURE_SCALE);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      put(FIELD_X_START + screenObject.column * FIELD_ELEM_STEP,
          FIELD_Y_START + screenObject.line * FIELD_ELEM_STEP - screenObject.height * PICTURE_SCALE,
          screenObject.pixmap[screenObject.actual_pixmap_index]);
      screenObject.motionIndex := screenObject.motionSpeed;
    <span class="keywd">elsif</span> screenObject.motionIndex > 0 <span class="keywd">then</span>
      decr(screenObject.motionIndex);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: visible (<span class="keywd">inout</span> <span class="type">screenObj</span>: screenObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    screenObject.saved_pixmap := getPixmap(
        FIELD_X_START + screenObject.column * FIELD_ELEM_STEP,
        FIELD_Y_START + screenObject.line * FIELD_ELEM_STEP - screenObject.height * PICTURE_SCALE,
        screenObject.width * PICTURE_SCALE,
        screenObject.height * PICTURE_SCALE);
    put(FIELD_X_START + screenObject.column * FIELD_ELEM_STEP,
        FIELD_Y_START + screenObject.line * FIELD_ELEM_STEP - screenObject.height * PICTURE_SCALE,
        screenObject.pixmap[screenObject.actual_pixmap_index]);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: invisible (<span class="keywd">inout</span> <span class="type">screenObj</span>: screenObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    put(FIELD_X_START + screenObject.column * FIELD_ELEM_STEP,
        FIELD_Y_START + screenObject.line * FIELD_ELEM_STEP - screenObject.height * PICTURE_SCALE,
        screenObject.saved_pixmap);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: place (<span class="keywd">inout</span> <span class="type">screenObj</span>: screenObject,
    <span class="op">in</span> <span class="type">integer</span>: line, <span class="op">in</span> <span class="type">integer</span>: column) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    screenObject.line := line;
    screenObject.column := column;
    visible(screenObject);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: jump (<span class="keywd">inout</span> <span class="type">screenObj</span>: screenObject,
    <span class="op">in</span> <span class="type">integer</span>: line, <span class="op">in</span> <span class="type">integer</span>: column) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    invisible(screenObject);
    screenObject.line := line;
    screenObject.column := column;
    visible(screenObject);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: die (<span class="keywd">inout</span> <span class="type">screenObj</span>: screenObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    screenObject.moving := FALSE;
    screenObject.line := -100;
    screenObject.column := -100;
    decr(game.num_monsters);
    <span class="keywd">if</span> game.num_monsters = 0 <span class="keywd">then</span>
      game.round_finished := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: save_overlapping (<span class="keywd">inout</span> <span class="type">screenObj</span>: screenObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> length(monster) <span class="keywd">do</span>
      <span class="keywd">if</span> (screenObject.line &lt;> monster[number].line <span class="op">or</span>
          screenObject.column &lt;> monster[number].column) <span class="op">and</span>
          collision(screenObject, monster[number]) <span class="keywd">then</span>
        invisible(monster[number]);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> collision(screenObject, player) <span class="keywd">then</span>
      invisible(player);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: restore_overlapping (<span class="keywd">inout</span> <span class="type">screenObj</span>: screenObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> length(monster) <span class="keywd">do</span>
      <span class="keywd">if</span> (screenObject.line &lt;> monster[number].line <span class="op">or</span>
          screenObject.column &lt;> monster[number].column) <span class="op">and</span>
          collision(screenObject, monster[number]) <span class="keywd">then</span>
        visible(monster[number]);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">if</span> collision(screenObject, player) <span class="keywd">then</span>
      visible(player);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: redraw_hole (<span class="op">in</span> <span class="type">integer</span>: line, <span class="op">in</span> <span class="type">integer</span>: column, <span class="keywd">inout</span> <span class="type">monsterObj</span>: currObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    invisible(currObject);
    draw_hole(line, column, no_hole);
    visible(currObject);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: mark_hole (<span class="op">in</span> <span class="type">integer</span>: line, <span class="op">in</span> <span class="type">integer</span>: column,
    <span class="op">in</span> <span class="type">holeType</span>: curr_hole_status) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: depth <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    hole_status[line][column] := curr_hole_status;
    <span class="keywd">case</span> curr_hole_status <span class="keywd">of</span>
      <span class="keywd">when</span> {no_hole}:
        <span class="keywd">for</span> depth <span class="keywd">range</span> 1 <span class="keywd">to</span> TRAP_DEPTH <span class="keywd">do</span>
          hole_status[line + depth][column] := no_hole;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">when</span> {hole_depth1}:
        hole_status[line + 1][column] := hole_part;
        hole_status[line + 2][column] := hole_unfinished;
      <span class="keywd">when</span> {hole_depth2}:
        hole_status[line + 1][column] := hole_part;
        hole_status[line + 2][column] := hole_part;
        hole_status[line + 3][column] := hole_unfinished;
      <span class="keywd">when</span> {hole_depth3}:
        hole_status[line + 1][column] := hole_part;
        hole_status[line + 2][column] := hole_part;
        hole_status[line + 3][column] := hole_part;
        hole_status[line + 4][column] := hole_unfinished;
      <span class="keywd">when</span> {hole_depth4}:
        hole_status[line + 1][column] := hole_part;
        hole_status[line + 2][column] := hole_part;
        hole_status[line + 3][column] := hole_part;
        hole_status[line + 4][column] := hole_part;
        hole_status[line + 5][column] := hole_unfinished;
      <span class="keywd">when</span> {hole_finished}:
        <span class="keywd">for</span> depth <span class="keywd">range</span> 1 <span class="keywd">to</span> pred(TRAP_DEPTH) <span class="keywd">do</span>
          hole_status[line + depth][column] := hole_part;
        <span class="keywd">end</span> <span class="keywd">for</span>;
        hole_status[line + TRAP_DEPTH][column] := hole_bottom;
    <span class="keywd">end</span> <span class="keywd">case</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: fall_at_monsters (<span class="keywd">inout</span> <span class="type">monsterObj</span>: currObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> length(monster) <span class="keywd">do</span>
      <span class="keywd">if</span> (currObject.line &lt;> monster[number].line <span class="op">or</span>
          currObject.column &lt;> monster[number].column) <span class="op">and</span>
          collision(currObject, monster[number]) <span class="keywd">then</span>
        <span class="keywd">if</span> hole_status[monster[number].line - TRAP_DEPTH][monster[number].column] >= hole_filled <span class="keywd">then</span>
          <span class="keywd">if</span> monster[number].column = currObject.column <span class="keywd">then</span>
            currObject.basePoints +:= 100 * monster[number].category;
            incr(currObject.holes_passed);
            invisible(monster[number]);
            die(monster[number]);
          <span class="keywd">else</span>
            hole_status[monster[number].line - TRAP_DEPTH][monster[number].column] := hole_pounded;
            decr(currObject.line_direction);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">else</span>
          currObject.points +:= 100 * monster[number].category;
          invisible(monster[number]);
          die(monster[number]);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: check_falling (<span class="keywd">inout</span> <span class="type">monsterObj</span>: currObject, <span class="op">in</span> <span class="type">holeType</span>: curr_hole_status) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> field[currObject.line][currObject.column] <span class="op">and</span>
        (curr_hole_status &lt; hole_finished <span class="op">or</span> curr_hole_status = hole_leaving) <span class="keywd">then</span>
      <span class="keywd">if</span> currObject.line_direction &lt;> 0 <span class="keywd">then</span>
        currObject.line_direction := 0;
        <span class="keywd">if</span> curr_hole_status = hole_leaving <span class="keywd">then</span>
          mark_hole(currObject.line, currObject.column, no_hole);
          draw_hole(currObject.line, currObject.column, no_hole);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        currObject.action_time := time(NOW) + 100000 . MICRO_SECONDS;
      <span class="keywd">elsif</span> time(NOW) >= currObject.action_time <span class="keywd">then</span>
        game.score +:= currObject.points;
        draw_number(24, 10, game.score <span class="op">lpad</span> 6);
        <span class="keywd">if</span> game.score > game.hiScore <span class="keywd">then</span>
          game.hiScore := game.score;
          draw_number(24, 35, game.hiScore <span class="op">lpad</span> 6);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> currObject.category &lt;= currObject.holes_passed <span class="keywd">then</span>
          invisible(currObject);
          currObject.pixmap := [](number_pixmap(str(currObject.points)));
          currObject.actual_pixmap_index := 1;
          currObject.height := height(currObject.pixmap[1]) <span class="op">div</span> PICTURE_SCALE;
          currObject.width := width(currObject.pixmap[1]) <span class="op">div</span> PICTURE_SCALE;
          currObject.line -:= 10;
          currObject.column -:= 6;
          save_overlapping(currObject);
          visible(currObject);
          restore_overlapping(currObject);
          currObject.action_time := time(NOW) + 1 . SECONDS;
        <span class="keywd">else</span>
          currObject.falling := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        currObject.points := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      <span class="keywd">if</span> currObject.points > 0 <span class="keywd">then</span>
        currObject.line_direction := 1;
        <span class="keywd">while</span> currObject.line_direction &lt;= FALL_SPEED <span class="op">and</span>
            currObject.line + currObject.line_direction &lt;= length(field) <span class="op">and</span>
            <span class="op">not</span> field[currObject.line + currObject.line_direction][currObject.column] <span class="keywd">do</span>
          incr(currObject.line_direction);
        <span class="keywd">end</span> <span class="keywd">while</span>;
        fall_at_monsters(currObject);
        <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> currObject.line_direction <span class="keywd">do</span>
          <span class="keywd">if</span> hole_status[currObject.line - number][currObject.column] = hole_finished <span class="op">or</span>
              hole_status[currObject.line - number][currObject.column] = hole_entering <span class="op">or</span>
              hole_status[currObject.line - number][currObject.column] >= hole_filled <span class="keywd">then</span>
            mark_hole(currObject.line - number, currObject.column, no_hole);
            redraw_hole(currObject.line - number, currObject.column, currObject);
            incr(currObject.holes_passed);
            currObject.points +:= currObject.basePoints;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">for</span>;
      <span class="keywd">elsif</span> time(NOW) >= currObject.action_time <span class="keywd">then</span>
        save_overlapping(currObject);
        invisible(currObject);
        restore_overlapping(currObject);
        die(currObject);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: set_direction (<span class="keywd">inout</span> <span class="type">monsterObj</span>: currObject,
    <span class="op">in</span> <span class="type">integer</span>: line, <span class="op">in</span> <span class="type">integer</span>: column) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> abs(currObject.line - line) >= abs(currObject.column - column) <span class="keywd">then</span>
      <span class="keywd">if</span> currObject.line &lt; line <span class="keywd">then</span>
        currObject.line_direction := 1;
      <span class="keywd">elsif</span> currObject.line = line <span class="keywd">then</span>
        currObject.line_direction := 0;
      <span class="keywd">else</span>
        currObject.line_direction := -1;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> abs(currObject.line - line) > abs(currObject.column - column) <span class="keywd">then</span>
        currObject.column_direction := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> abs(currObject.line - line) &lt;= abs(currObject.column - column) <span class="keywd">then</span>
      <span class="keywd">if</span> currObject.column &lt; column <span class="keywd">then</span>
        currObject.column_direction := 1;
      <span class="keywd">elsif</span> currObject.column = column <span class="keywd">then</span>
        currObject.column_direction := 0;
      <span class="keywd">else</span>
        currObject.column_direction := -1;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> abs(currObject.line - line) &lt; abs(currObject.column - column) <span class="keywd">then</span>
        currObject.line_direction := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: player_collision (<span class="keywd">inout</span> <span class="type">monsterObj</span>: currObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> player.living <span class="keywd">then</span>
      player.line_direction := 0;
      player.column_direction := 0;
      player.moving := FALSE;
      player.motionSpeed := CATCH_MOTION;
      player.living := FALSE;
      player.command := <span class="stri">' '</span>;
      currObject.catching := TRUE;
      set_direction(currObject, player.line - 6, player.column);
    <span class="keywd">elsif</span> currObject.catching <span class="keywd">then</span>
      <span class="keywd">if</span> currObject.line_direction &lt;> 0 <span class="op">or</span> currObject.column_direction &lt;> 0 <span class="keywd">then</span>
        <span class="keywd">if</span> currObject.line &lt;> player.line - 6 <span class="op">or</span> currObject.column &lt;> player.column <span class="keywd">then</span>
          set_direction(currObject, player.line - 6, player.column);
        <span class="keywd">else</span>
          currObject.line_direction := 0;
          currObject.column_direction := 0;
          <span class="keywd">if</span> game.num_players > 1 <span class="keywd">then</span>
            currObject.action_time := time(NOW) + 5 . SECONDS;
          <span class="keywd">else</span>
            currObject.action_time := time.value;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> currObject.action_time &lt;> time.value <span class="op">and</span>
          time(NOW) >= currObject.action_time <span class="keywd">then</span>
        game.round_finished := TRUE;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">else</span>
      <span class="keywd">if</span> currObject.column_direction &lt;> 0 <span class="keywd">then</span>
        <span class="keywd">if</span> currObject.column >= player.column <span class="keywd">then</span>
          currObject.column_direction := SPEED;
        <span class="keywd">else</span>
          currObject.column_direction := -SPEED;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> currObject.line_direction &lt;> 0 <span class="keywd">then</span>
        <span class="keywd">if</span> currObject.line >= player.line <span class="keywd">then</span>
          currObject.line_direction := SPEED;
        <span class="keywd">else</span>
          currObject.line_direction := -SPEED;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: check_hole (<span class="keywd">inout</span> <span class="type">monsterObj</span>: currObject, <span class="op">in</span> <span class="type">holeType</span>: curr_hole_status) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> curr_hole_status &lt; hole_finished <span class="keywd">then</span>
      currObject.saved_column_direction := currObject.column_direction;
      currObject.line_direction := SPEED;
      currObject.column_direction := 0;
    <span class="keywd">elsif</span> curr_hole_status = hole_finished <span class="keywd">then</span>
      currObject.saved_column_direction := currObject.column_direction;
      currObject.column_direction := 0;
      <span class="keywd">if</span> collision2(currObject, player) <span class="keywd">then</span>
        player_collision(currObject);
      <span class="keywd">else</span>
        currObject.line_direction := SPEED;
        hole_status[currObject.line][currObject.column] := hole_entering;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> curr_hole_status = hole_leaving <span class="keywd">then</span>
      currObject.line_direction := 0;
      currObject.column_direction := currObject.saved_column_direction;
      currObject.motionSpeed := FULL_MOTION;
      mark_hole(currObject.line, currObject.column, no_hole);
    <span class="keywd">elsif</span> curr_hole_status = hole_part <span class="keywd">then</span>
      noop;
    <span class="keywd">elsif</span> curr_hole_status = hole_unfinished <span class="keywd">then</span>
      <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> TRAP_DEPTH <span class="keywd">do</span>
        <span class="keywd">if</span> currObject.line - number >= 1 <span class="op">and</span>
            hole_status[currObject.line - number][currObject.column] <span class="op">in</span>
            {hole_depth1, hole_depth2, hole_depth3, hole_depth4} <span class="keywd">then</span>
          hole_status[currObject.line - number][currObject.column] := hole_leaving;
          redraw_hole(currObject.line - number, currObject.column, currObject);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
      currObject.line_direction := -SPEED;
      currObject.motionSpeed := LEAVE_MOTION;
    <span class="keywd">elsif</span> curr_hole_status = hole_bottom <span class="keywd">then</span>
      <span class="keywd">if</span> currObject.line_direction &lt;> 0 <span class="keywd">then</span>
        currObject.line_direction := 0;
        currObject.column_direction := 0;
        currObject.action_time := time(NOW) + TIME_IN_HOLE;
        hole_status[currObject.line - TRAP_DEPTH][currObject.column] := hole_filled;
      <span class="keywd">elsif</span> hole_status[currObject.line - TRAP_DEPTH][currObject.column] = hole_pounded <span class="keywd">then</span>
        mark_hole(currObject.line - TRAP_DEPTH, currObject.column, no_hole);
        redraw_hole(currObject.line - TRAP_DEPTH, currObject.column, currObject);
        currObject.line_direction := FALL_SPEED;
        currObject.falling := TRUE;
        currObject.holes_passed := 1;
        currObject.basePoints := 100 * currObject.category;
        currObject.points := currObject.basePoints;
      <span class="keywd">else</span>
        <span class="keywd">if</span> time(NOW) >= currObject.action_time <span class="keywd">then</span>
          hole_status[currObject.line - TRAP_DEPTH][currObject.column] := hole_leaving;
          redraw_hole(currObject.line - TRAP_DEPTH, currObject.column, currObject);
          currObject.line_direction := -SPEED;
          currObject.motionSpeed := LEAVE_MOTION;
          <span class="keywd">if</span> player.falling <span class="op">and</span> collision2(currObject, player) <span class="keywd">then</span>
            player_collision(currObject);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: check_direction (<span class="keywd">inout</span> <span class="type">monsterObj</span>: currObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">holeType</span>: curr_hole_status <span class="keywd">is</span> no_hole;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> currObject.moving <span class="keywd">then</span>
      <span class="keywd">if</span> currObject.line >= 1 <span class="keywd">then</span>
        curr_hole_status := hole_status[currObject.line][currObject.column];
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> currObject.catching <span class="keywd">then</span>
        player_collision(currObject);
      <span class="keywd">elsif</span> currObject.falling <span class="keywd">then</span>
        check_falling(currObject, curr_hole_status);
      <span class="keywd">elsif</span> curr_hole_status &lt;> no_hole <span class="keywd">then</span>
        check_hole(currObject, curr_hole_status);
      <span class="keywd">elsif</span> collision2(currObject, player) <span class="keywd">then</span>
        player_collision(currObject);
      <span class="keywd">elsif</span> currObject.column_direction &lt;> 0 <span class="keywd">then</span>
        <span class="keywd">if</span> field[pred(currObject.line)][currObject.column] <span class="op">or</span>
            field[succ(currObject.line)][currObject.column] <span class="keywd">then</span>
          change_direction(currObject);
        <span class="keywd">elsif</span> <span class="op">not</span> field[currObject.line]
            [currObject.column + currObject.column_direction] <span class="keywd">then</span>
          currObject.column_direction := -currObject.column_direction;
        <span class="keywd">else</span>
          avoid_monster_collision(currObject);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> currObject.line_direction &lt;> 0 <span class="keywd">then</span>
        <span class="keywd">if</span> field[currObject.line][pred(currObject.column)] <span class="op">or</span>
            field[currObject.line][succ(currObject.column)] <span class="keywd">then</span>
          change_direction(currObject);
        <span class="keywd">elsif</span> <span class="op">not</span> field[currObject.line + currObject.line_direction]
            [currObject.column] <span class="keywd">then</span>
          currObject.line_direction := -currObject.line_direction;
        <span class="keywd">else</span>
          avoid_monster_collision(currObject);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        change_direction(currObject);
        check_direction(currObject);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: place_monster (<span class="keywd">inout</span> <span class="type">screenObj</span>: screenObject,
    <span class="op">in</span> <span class="type">integer</span>: number, <span class="op">in</span> <span class="type">integer</span>: line) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: place_is_ok <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <span class="type">integer</span>: num <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    screenObject.line := FIELD_BORDER + line;
    <span class="keywd">repeat</span>
      screenObject.column := rand(succ(FIELD_BORDER), FIELD_COLUMNS - FIELD_BORDER) <span class="op">div</span> SPEED * SPEED;
      place_is_ok := TRUE;
      <span class="keywd">for</span> num <span class="keywd">range</span> 1 <span class="keywd">to</span> pred(number) <span class="keywd">do</span>
        <span class="keywd">if</span> collision(screenObject, monster[num]) <span class="keywd">then</span>
          place_is_ok := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">until</span> place_is_ok;
    place(screenObject, FIELD_BORDER + line, screenObject.column);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: draw_reserve (<span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: num_players) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> num_players > 5 <span class="keywd">then</span>
      num_players := 5;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> num_players <span class="keywd">do</span>
      put((number * 7 - 6) * FIELD_ELEM_STEP,
          succ(186         * FIELD_ELEM_STEP),
          player_reserve_pixmap);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> number <span class="keywd">range</span> succ(num_players) <span class="keywd">to</span> 4 <span class="keywd">do</span>
      rect((number * 7 - 6) * FIELD_ELEM_STEP,
          succ(186          * FIELD_ELEM_STEP),
          7                 * FIELD_ELEM_STEP,
          8                 * FIELD_ELEM_STEP,
          black);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: init_round (<span class="op">in</span> <span class="type">integer</span>: num_round) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">time</span>: start_time <span class="keywd">is</span> time.value;
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    start_time := time(NOW);
    game.round_finished := FALSE;
    field := FIELD_LINES <span class="op">times</span> FIELD_COLUMNS <span class="op">times</span> FALSE;
    hole_status := FIELD_LINES <span class="op">times</span> FIELD_COLUMNS <span class="op">times</span> no_hole;
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> pred(NUM_LEVELS) <span class="keywd">do</span>
      mark_level(level_line[number]);
      draw_level(level_line[number]);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    mark_level(level_line[NUM_LEVELS]);
    draw_base_level(level_line[NUM_LEVELS]);
    init_ladders(layout_description[rand(1, 4)]);
    rect(1   * FIELD_ELEM_STEP,
         182 * FIELD_ELEM_STEP,
         223 * FIELD_ELEM_STEP,
         3   * FIELD_ELEM_STEP,
         light_blue);
    rect(226 * FIELD_ELEM_STEP,
         182 * FIELD_ELEM_STEP,
         41  * FIELD_ELEM_STEP,
         3   * FIELD_ELEM_STEP,
         orange);
    draw_reserve(game.num_players);
    put(succ(6 * 7) * FIELD_ELEM_STEP,
        succ(186    * FIELD_ELEM_STEP),
        score_text_pixmap);
    <span class="keywd">if</span> game.score &lt;> 0 <span class="keywd">then</span>
      draw_number(24, 10, game.score <span class="op">lpad</span> 6);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    game.round_bonus := round_description[num_round][4];
    put(succ(17 * 7) * FIELD_ELEM_STEP,
        succ(186    * FIELD_ELEM_STEP),
        bonus_text_pixmap);
    draw_number(24, 24, game.round_bonus <span class="op">lpad</span> 4);
    put(succ(31 * 7) * FIELD_ELEM_STEP,
        succ(186    * FIELD_ELEM_STEP),
        hiscore_text_pixmap);
    <span class="keywd">if</span> game.hiScore &lt;> 0 <span class="keywd">then</span>
      draw_number(24, 35, game.hiScore <span class="op">lpad</span> 6);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    game.num_monsters := round_description[num_round][1] +
      round_description[num_round][2] +
      round_description[num_round][3];
    monster := game.num_monsters <span class="op">times</span> monsterObj.value;
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> game.num_monsters <span class="keywd">do</span>
      <span class="keywd">if</span> number &lt;= round_description[num_round][1] <span class="keywd">then</span>
        monster[number].pixmap := monster_pixmap[1];
        monster[number].category := 1;
      <span class="keywd">elsif</span> number &lt;= round_description[num_round][1] + round_description[num_round][2] <span class="keywd">then</span>
        monster[number].pixmap := monster_pixmap[2];
        monster[number].category := 2;
      <span class="keywd">else</span>
        monster[number].pixmap := monster_pixmap[3];
        monster[number].category := 3;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      monster[number].actual_pixmap_index := rand(1, length(monster[number].pixmap));
      monster[number].height := height(monster[number].pixmap[1]) <span class="op">div</span> PICTURE_SCALE;
      monster[number].width := width(monster[number].pixmap[1]) <span class="op">div</span> PICTURE_SCALE;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    flushGraphic;
    game_command(getc(KEYBOARD, NO_WAIT));
    <span class="keywd">if</span> <span class="op">not</span> game.round_finished <span class="op">and</span> <span class="op">not</span> game.quit <span class="keywd">then</span>
      await(start_time + 500000 . MICRO_SECONDS);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    number := 1;
    <span class="keywd">while</span> number &lt;= game.num_monsters <span class="op">and</span> <span class="op">not</span> game.round_finished <span class="op">and</span> <span class="op">not</span> game.quit <span class="keywd">do</span>
      start_time := time(NOW);
      place_monster(monster[number], number, level_line[rand(1, pred(NUM_LEVELS))]);
      change_direction(monster[number]);
      incr(number);
      flushGraphic;
      game_command(getc(KEYBOARD, NO_WAIT));
      <span class="keywd">if</span> <span class="op">not</span> game.round_finished <span class="op">and</span> <span class="op">not</span> game.quit <span class="keywd">then</span>
        await(start_time + 500000 . MICRO_SECONDS);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> <span class="op">not</span> game.round_finished <span class="op">and</span> <span class="op">not</span> game.quit <span class="keywd">then</span>
      draw_reserve(pred(game.num_players));
      player := playerObj.value;
      player.moving := FALSE;
      player.pixmap := player_right_pixmap;
      player.actual_pixmap_index := 1;
      player.height := height(player.pixmap[1]) <span class="op">div</span> PICTURE_SCALE;
      player.width := width(player.pixmap[1]) <span class="op">div</span> PICTURE_SCALE;
      place(player, FIELD_BORDER + level_line[length(level_line)], 136 <span class="op">div</span> SPEED * SPEED);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: dig_hole (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject,
    <span class="op">in</span> <span class="type">integer</span>: line, <span class="op">in</span> <span class="type">integer</span>: column) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">holeType</span>: curr_hole_status <span class="keywd">is</span> no_hole;
  <span class="keywd">begin</span>
    curr_hole_status := hole_status[line][column];
    <span class="keywd">if</span> curr_hole_status >= hole_finished <span class="keywd">then</span>
      playerObject.command := <span class="stri">' '</span>;
    <span class="keywd">elsif</span> curr_hole_status &lt; hole_finished <span class="keywd">then</span>
      incr(curr_hole_status);
      mark_hole(line, column, curr_hole_status);
      draw_hole(line, column, curr_hole_status);
      <span class="keywd">if</span> curr_hole_status = hole_finished <span class="keywd">then</span>
        playerObject.command := <span class="stri">' '</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: shut_hole (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject,
    <span class="op">in</span> <span class="type">integer</span>: line, <span class="op">in</span> <span class="type">integer</span>: column) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">holeType</span>: curr_hole_status <span class="keywd">is</span> no_hole;
  <span class="keywd">begin</span>
    curr_hole_status := hole_status[line][column];
    <span class="keywd">if</span> curr_hole_status = no_hole <span class="keywd">then</span>
      playerObject.command := <span class="stri">' '</span>;
    <span class="keywd">elsif</span> curr_hole_status &lt;= hole_finished <span class="keywd">then</span>
      decr(curr_hole_status);
      mark_hole(line, column, curr_hole_status);
      draw_hole(line, column, curr_hole_status);
      <span class="keywd">if</span> curr_hole_status = no_hole <span class="keywd">then</span>
        playerObject.command := <span class="stri">' '</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> curr_hole_status >= hole_filled <span class="op">and</span> curr_hole_status &lt; hole_pounded <span class="keywd">then</span>
      incr(curr_hole_status);
      hole_status[line][column] := curr_hole_status;
      <span class="keywd">if</span> curr_hole_status = hole_pounded <span class="keywd">then</span>
        playerObject.command := <span class="stri">' '</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: do_dig (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> playerObject.digging <span class="op">and</span> playerObject.actual_pixmap_index = 1 <span class="keywd">then</span>
      <span class="keywd">if</span> playerObject.dig_direction > 0 <span class="keywd">then</span>
        <span class="keywd">if</span> playerObject.face_direction &lt; 0 <span class="keywd">then</span>
          dig_hole(playerObject, playerObject.line, playerObject.column - 13);
        <span class="keywd">else</span>
          dig_hole(playerObject, playerObject.line, playerObject.column + 13);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        <span class="keywd">if</span> playerObject.face_direction &lt; 0 <span class="keywd">then</span>
          shut_hole(playerObject, playerObject.line, playerObject.column - 13);
        <span class="keywd">else</span>
          shut_hole(playerObject, playerObject.line, playerObject.column + 13);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: hole_position_ok (<span class="op">in</span> <span class="type">integer</span>: line, <span class="op">in</span> <span class="type">integer</span>: column) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: position_ok <span class="keywd">is</span> TRUE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: col <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> line = FIELD_BORDER + level_line[NUM_LEVELS] <span class="keywd">then</span>
      position_ok := FALSE;
    <span class="keywd">elsif</span> column - 2 &lt; 1 <span class="op">or</span> column + 2 > length(field[line]) <span class="keywd">then</span>
      position_ok := FALSE;
    <span class="keywd">elsif</span> hole_status[line][column] = no_hole <span class="keywd">then</span>
      <span class="keywd">for</span> col <span class="keywd">range</span> column - 14 <span class="keywd">to</span> column + 14 <span class="keywd">do</span>
        <span class="keywd">if</span> col >= 1 <span class="op">and</span> col &lt;= length(field[line]) <span class="op">and</span>
            (field[pred(line)][col] <span class="op">or</span>
            field[succ(line)][col] <span class="op">or</span>
            hole_status[line][col] &lt;> no_hole) <span class="keywd">then</span>
          position_ok := FALSE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> column <span class="op">rem</span> 4 &lt;> 0 <span class="keywd">then</span>
      position_ok := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: ladder_up_direction (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: direction <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: col <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> col <span class="keywd">range</span> playerObject.column - 12 <span class="keywd">to</span> playerObject.column - 1 <span class="keywd">do</span>
      <span class="keywd">if</span> col >= 1 <span class="op">and</span> col &lt;= length(field[playerObject.line]) <span class="op">and</span>
          field[pred(playerObject.line)][col] <span class="keywd">then</span>
        direction := -1;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> col <span class="keywd">range</span> playerObject.column + 1 <span class="keywd">to</span> playerObject.column + 13 <span class="keywd">do</span>
      <span class="keywd">if</span> col >= 1 <span class="op">and</span> col &lt;= length(field[playerObject.line]) <span class="op">and</span>
          field[pred(playerObject.line)][col] <span class="keywd">then</span>
        direction := 1;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: ladder_down_direction (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: direction <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: col <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> col <span class="keywd">range</span> playerObject.column - 12 <span class="keywd">to</span> playerObject.column - 1 <span class="keywd">do</span>
      <span class="keywd">if</span> col >= 1 <span class="op">and</span> col &lt;= length(field[playerObject.line]) <span class="op">and</span>
          field[succ(playerObject.line)][col] <span class="keywd">then</span>
        direction := -1;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> col <span class="keywd">range</span> playerObject.column + 1 <span class="keywd">to</span> playerObject.column + 13 <span class="keywd">do</span>
      <span class="keywd">if</span> col >= 1 <span class="op">and</span> col &lt;= length(field[playerObject.line]) <span class="op">and</span>
          field[succ(playerObject.line)][col] <span class="keywd">then</span>
        direction := 1;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: level_direction (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: direction <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: lin <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> lin <span class="keywd">range</span> playerObject.line - 15 <span class="keywd">to</span> playerObject.line - 1 <span class="keywd">do</span>
      <span class="keywd">if</span> lin >= 1 <span class="op">and</span> lin &lt;= length(field) <span class="op">and</span>
          field[lin][succ(playerObject.column)] <span class="keywd">then</span>
        direction := -1;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> lin <span class="keywd">range</span> playerObject.line + 1 <span class="keywd">to</span> playerObject.line + 6 <span class="keywd">do</span>
      <span class="keywd">if</span> lin >= 1 <span class="op">and</span> lin &lt;= length(field) <span class="op">and</span>
          field[lin][succ(playerObject.column)] <span class="keywd">then</span>
        direction := 1;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: hole_direction (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: direction <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: col <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> col <span class="keywd">range</span> playerObject.column - 14 <span class="keywd">downto</span> playerObject.column - 20 <span class="keywd">do</span>
      <span class="keywd">if</span> col >= 1 <span class="op">and</span> col &lt;= length(hole_status[playerObject.line]) <span class="op">and</span>
          hole_status[playerObject.line][col] &lt;> no_hole <span class="keywd">then</span>
        direction := -1;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">for</span> col <span class="keywd">range</span> playerObject.column + 14 <span class="keywd">to</span> playerObject.column + 20 <span class="keywd">do</span>
      <span class="keywd">if</span> col >= 1 <span class="op">and</span> col &lt;= length(hole_status[playerObject.line]) <span class="op">and</span>
          hole_status[playerObject.line][col] &lt;> no_hole <span class="keywd">then</span>
        direction := 1;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: stop (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    playerObject.line_direction := 0;
    playerObject.column_direction := 0;
    playerObject.moving := FALSE;
    playerObject.digging := FALSE;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: left (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> playerObject.column_direction &lt;> -SPEED <span class="keywd">then</span>
      playerObject.line_direction := 0;
      playerObject.column_direction := -SPEED;
      playerObject.face_direction := -1;
      playerObject.moving := TRUE;
      playerObject.digging := FALSE;
      playerObject.actual_pixmap_index := 1;
      playerObject.pixmap := player_left_pixmap;
      playerObject.width := 14;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: right (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> playerObject.column_direction &lt;> SPEED <span class="keywd">then</span>
      playerObject.line_direction := 0;
      playerObject.column_direction := SPEED;
      playerObject.face_direction := 1;
      playerObject.moving := TRUE;
      playerObject.digging := FALSE;
      playerObject.actual_pixmap_index := 1;
      playerObject.pixmap := player_right_pixmap;
      playerObject.width := 14;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: up (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> playerObject.line_direction &lt;> -SPEED <span class="keywd">then</span>
      playerObject.line_direction := -SPEED;
      playerObject.column_direction := 0;
      playerObject.face_direction := 0;
      playerObject.moving := TRUE;
      playerObject.digging := FALSE;
      playerObject.actual_pixmap_index := 1;
      playerObject.pixmap := player_up_pixmap;
      playerObject.width := 13;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: down (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> playerObject.line_direction &lt;> SPEED <span class="keywd">then</span>
      playerObject.line_direction := SPEED;
      playerObject.column_direction := 0;
      playerObject.face_direction := 0;
      playerObject.moving := TRUE;
      playerObject.digging := FALSE;
      playerObject.actual_pixmap_index := 1;
      playerObject.pixmap := player_down_pixmap;
      playerObject.width := 13;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: dig_left (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> <span class="op">not</span> playerObject.digging <span class="op">or</span> playerObject.dig_direction &lt;> 1 <span class="keywd">then</span>
      playerObject.line_direction := 0;
      playerObject.column_direction := 0;
      playerObject.moving := TRUE;
      playerObject.digging := TRUE;
      playerObject.dig_direction := 1;
      playerObject.actual_pixmap_index := 1;
      playerObject.pixmap := player_dig_left_pixmap;
      playerObject.width := 13;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: dig_right (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> <span class="op">not</span> playerObject.digging <span class="op">or</span> playerObject.dig_direction &lt;> 1 <span class="keywd">then</span>
      playerObject.line_direction := 0;
      playerObject.column_direction := 0;
      playerObject.moving := TRUE;
      playerObject.digging := TRUE;
      playerObject.dig_direction := 1;
      playerObject.actual_pixmap_index := 1;
      playerObject.pixmap := player_dig_right_pixmap;
      playerObject.width := 13;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: shut_left (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> <span class="op">not</span> playerObject.digging <span class="op">or</span> playerObject.dig_direction &lt;> -1 <span class="keywd">then</span>
      playerObject.line_direction := 0;
      playerObject.column_direction := 0;
      playerObject.moving := TRUE;
      playerObject.digging := TRUE;
      playerObject.dig_direction := -1;
      playerObject.actual_pixmap_index := 1;
      playerObject.pixmap := player_dig_left_pixmap;
      playerObject.width := 13;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: shut_right (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> <span class="op">not</span> playerObject.digging <span class="op">or</span> playerObject.dig_direction &lt;> -1 <span class="keywd">then</span>
      playerObject.line_direction := 0;
      playerObject.column_direction := 0;
      playerObject.moving := TRUE;
      playerObject.digging := TRUE;
      playerObject.dig_direction := -1;
      playerObject.actual_pixmap_index := 1;
      playerObject.pixmap := player_dig_right_pixmap;
      playerObject.width := 13;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: go_horizontally (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject, <span class="op">in</span> <span class="type">integer</span>: direction) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> direction = -1 <span class="keywd">then</span>
      left(playerObject);
    <span class="keywd">elsif</span> direction = 1 <span class="keywd">then</span>
      right(playerObject);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: go_vertically (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject, <span class="op">in</span> <span class="type">integer</span>: direction) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> direction = -1 <span class="keywd">then</span>
      up(playerObject);
    <span class="keywd">elsif</span> direction = 1 <span class="keywd">then</span>
      down(playerObject);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: player_falling (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> field[playerObject.line][playerObject.column] <span class="op">and</span>
        hole_status[playerObject.line][playerObject.column] &lt;= hole_depth4 <span class="keywd">then</span>
      playerObject.line_direction := 0;
      playerObject.falling := FALSE;
    <span class="keywd">else</span>
      playerObject.line_direction := SPEED;
      <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> length(monster) <span class="keywd">do</span>
        <span class="keywd">if</span> collision2(monster[number], playerObject) <span class="keywd">then</span>
          playerObject.line_direction := 0;
          <span class="keywd">if</span> monster[number].line_direction = 0 <span class="op">and</span>
              monster[number].column_direction = 0 <span class="keywd">then</span>
            <span class="keywd">if</span> playerObject.command = KEY_LEFT <span class="keywd">then</span>
              <span class="keywd">if</span> pred(playerObject.column) >= succ(FIELD_BORDER) <span class="keywd">then</span>
                left(playerObject);
              <span class="keywd">else</span>
                stop(playerObject);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">elsif</span> playerObject.command = KEY_RIGHT <span class="keywd">then</span>
              <span class="keywd">if</span> succ(playerObject.column) &lt;= FIELD_COLUMNS - FIELD_BORDER <span class="keywd">then</span>
                right(playerObject);
              <span class="keywd">else</span>
                stop(playerObject);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">elsif</span> playerObject.command = <span class="stri">' '</span> <span class="keywd">then</span>
              stop(playerObject);
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">for</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process_command (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> playerObject.command = KEY_UP <span class="keywd">then</span>
      <span class="keywd">if</span> field[pred(playerObject.line)][playerObject.column] <span class="keywd">then</span>
        up(playerObject);
      <span class="keywd">elsif</span> playerObject.column_direction = 0 <span class="keywd">then</span>
        go_horizontally(playerObject, ladder_up_direction(playerObject));
      <span class="keywd">end</span> <span class="keywd">if</span>
    <span class="keywd">elsif</span> playerObject.command = KEY_DOWN <span class="keywd">then</span>
      <span class="keywd">if</span> field[succ(playerObject.line)][playerObject.column] <span class="keywd">then</span>
        down(playerObject);
      <span class="keywd">elsif</span> playerObject.column_direction = 0 <span class="keywd">then</span>
        go_horizontally(playerObject, ladder_down_direction(playerObject));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> playerObject.command = KEY_LEFT <span class="keywd">then</span>
      <span class="keywd">if</span> field[playerObject.line][pred(playerObject.column)] <span class="keywd">then</span>
        left(playerObject);
      <span class="keywd">elsif</span> playerObject.line_direction = 0 <span class="keywd">then</span>
        go_vertically(playerObject, level_direction(playerObject));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> playerObject.command = KEY_RIGHT <span class="keywd">then</span>
      <span class="keywd">if</span> field[playerObject.line][succ(playerObject.column)] <span class="keywd">then</span>
        right(playerObject);
      <span class="keywd">elsif</span> playerObject.line_direction = 0 <span class="keywd">then</span>
        go_vertically(playerObject, level_direction(playerObject));
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> playerObject.command = <span class="stri">'A'</span> <span class="keywd">then</span>
      <span class="keywd">if</span> playerObject.face_direction &lt; 0 <span class="op">and</span>
          hole_position_ok(playerObject.line, playerObject.column - 13) <span class="keywd">then</span>
        dig_left(playerObject);
      <span class="keywd">elsif</span> playerObject.face_direction > 0 <span class="op">and</span>
          hole_position_ok(playerObject.line, playerObject.column + 13) <span class="keywd">then</span>
        dig_right(playerObject);
      <span class="keywd">elsif</span> playerObject.column_direction = 0 <span class="op">and</span>
          playerObject.line &lt;> FIELD_BORDER + level_line[NUM_LEVELS] <span class="keywd">then</span>
        go_horizontally(playerObject, playerObject.face_direction);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> playerObject.command = <span class="stri">'S'</span> <span class="keywd">then</span>
      <span class="keywd">if</span> playerObject.face_direction &lt; 0 <span class="op">and</span>
          playerObject.column > 13 <span class="op">and</span>
          hole_status[playerObject.line][playerObject.column - 13] &lt;> no_hole <span class="keywd">then</span>
        shut_left(playerObject);
      <span class="keywd">elsif</span> playerObject.face_direction > 0 <span class="op">and</span>
          playerObject.column + 13 &lt;= length(hole_status[playerObject.line]) <span class="op">and</span>
          hole_status[playerObject.line][playerObject.column + 13] &lt;> no_hole <span class="keywd">then</span>
        shut_right(playerObject);
      <span class="keywd">elsif</span> playerObject.column_direction = 0 <span class="op">and</span>
          playerObject.face_direction = hole_direction(playerObject) <span class="keywd">then</span>
        go_horizontally(playerObject, playerObject.face_direction);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> playerObject.command = <span class="stri">' '</span> <span class="keywd">then</span>
      stop(playerObject);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: stop_at_hole (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> playerObject.command <span class="op">not</span> <span class="op">in</span> {<span class="stri">'A'</span>, <span class="stri">'S'</span>} <span class="keywd">then</span>
      <span class="keywd">if</span> playerObject.face_direction &lt; 0 <span class="keywd">then</span>
        <span class="keywd">if</span> playerObject.column > 13 <span class="op">and</span>
            hole_status[playerObject.line][playerObject.column - 13] <span class="op">not</span> <span class="op">in</span>
            {no_hole, hole_finished} <span class="keywd">then</span>
          playerObject.moving := FALSE;
          playerObject.column_direction := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> playerObject.face_direction > 0 <span class="keywd">then</span>
        <span class="keywd">if</span> playerObject.column + 13 &lt;= length(hole_status[playerObject.line]) <span class="op">and</span>
            hole_status[playerObject.line][playerObject.column + 13] <span class="op">not</span> <span class="op">in</span>
            {no_hole, hole_finished} <span class="keywd">then</span>
          playerObject.moving := FALSE;
          playerObject.column_direction := 0;
          <span class="keywd">if</span> player.width > 13 <span class="keywd">then</span>
            player.width := 13;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> player.width > 13 <span class="op">and</span>
            playerObject.column +  player.width &lt;= length(hole_status[playerObject.line]) <span class="op">and</span>
            hole_status[playerObject.line][playerObject.column +  player.width] <span class="op">not</span> <span class="op">in</span>
            {no_hole, hole_finished} <span class="keywd">then</span>
          playerObject.moving := FALSE;
          playerObject.column_direction := 0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: process (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> playerObject.falling <span class="keywd">then</span>
      player_falling(playerObject);
    <span class="keywd">elsif</span> hole_status[playerObject.line][playerObject.column] = hole_finished <span class="keywd">then</span>
      playerObject.line_direction := SPEED;
      playerObject.column_direction := 0;
      playerObject.falling := TRUE;
      playerObject.face_direction := 0;
      playerObject.pixmap := player_falling_pixmap;
    <span class="keywd">else</span>
      process_command(playerObject);
      stop_at_hole(playerObject);
      <span class="keywd">if</span> <span class="op">not</span> field[playerObject.line][playerObject.column + playerObject.column_direction] <span class="keywd">then</span>
        playerObject.moving := FALSE;
        playerObject.column_direction := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> <span class="op">not</span> field[playerObject.line + playerObject.line_direction][playerObject.column] <span class="keywd">then</span>
        playerObject.moving := FALSE;
        playerObject.line_direction := 0;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: get_command (<span class="keywd">inout</span> <span class="type">playerObj</span>: playerObject) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: cmd <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    cmd := getc(KEYBOARD, NO_WAIT);
    <span class="keywd">if</span> playerObject.living <span class="keywd">then</span>
      <span class="keywd">case</span> cmd <span class="keywd">of</span>
        <span class="keywd">when</span> {KEY_LEFT, <span class="stri">'J'</span>, <span class="stri">'j'</span>}:
          playerObject.command := KEY_LEFT;
        <span class="keywd">when</span> {KEY_RIGHT, <span class="stri">'K'</span>, <span class="stri">'k'</span>}:
          playerObject.command := KEY_RIGHT;
        <span class="keywd">when</span> {KEY_UP, <span class="stri">'I'</span>, <span class="stri">'i'</span>}:
          playerObject.command := KEY_UP;
        <span class="keywd">when</span> {KEY_DOWN, <span class="stri">'M'</span>, <span class="stri">'m'</span>}:
          playerObject.command := KEY_DOWN;
        <span class="keywd">when</span> {<span class="stri">'A'</span>, <span class="stri">'a'</span>}:
          playerObject.command := <span class="stri">'A'</span>;
        <span class="keywd">when</span> {<span class="stri">'S'</span>, <span class="stri">'s'</span>}:
          playerObject.command := <span class="stri">'S'</span>;
        <span class="keywd">when</span> {<span class="stri">' '</span>}:
          playerObject.command := <span class="stri">' '</span>;
      <span class="keywd">end</span> <span class="keywd">case</span>;
    <span class="keywd">elsif</span> cmd <span class="op">in</span> {<span class="stri">'S'</span>, <span class="stri">'s'</span>} <span class="keywd">then</span>
      game.round_finished := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    game_command(cmd);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: game_round <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: progress <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: blackBarLength <span class="keywd">is</span> -1;
    <span class="keywd">var</span> <span class="type">integer</span>: new_bonus <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: bonus <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    clear(curr_win, black);
    flushGraphic;
    init_round(game.round_number);
    bonus := game.round_bonus;
    game.turn_time := time(NOW);
    <span class="keywd">while</span> <span class="op">not</span> game.round_finished <span class="op">and</span> <span class="op">not</span> game.quit <span class="keywd">do</span>
      <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> length(monster) <span class="keywd">do</span>
        check_direction(monster[number]);
        move(monster[number]);
      <span class="keywd">end</span> <span class="keywd">for</span>;
      get_command(player);
      <span class="keywd">if</span> <span class="op">not</span> game.round_finished <span class="op">and</span> <span class="op">not</span> game.quit <span class="keywd">then</span>
        process(player);
        move(player);
        do_dig(player);
        <span class="keywd">if</span> progress <span class="op">div</span> 62 &lt;> blackBarLength <span class="keywd">then</span>
          blackBarLength := progress <span class="op">div</span> 62;
          rect(1            * FIELD_ELEM_STEP,
             182            * FIELD_ELEM_STEP,
             blackBarLength * FIELD_ELEM_STEP,
             3              * FIELD_ELEM_STEP,
             black);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        new_bonus := (game.round_bonus + 19 - progress <span class="op">div</span> 7) <span class="op">div</span> 20 * 20;
        <span class="keywd">if</span> bonus &lt;> new_bonus <span class="keywd">then</span>
          bonus := new_bonus;
          <span class="keywd">if</span> bonus > 0 <span class="keywd">then</span>
            draw_number(24, 24, bonus <span class="op">lpad</span> 4);
          <span class="keywd">elsif</span> bonus = 0 <span class="keywd">then</span>
            draw_number(24, 24, <span class="stri">"    "</span>);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> progress <span class="op">div</span> 62 = 266 <span class="keywd">then</span>
          game.round_finished := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        incr(progress);
        game.turn_time +:= 30000 . MICRO_SECONDS;
        flushGraphic;
        await(game.turn_time);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">if</span> player.living <span class="op">and</span> game.num_monsters = 0 <span class="keywd">then</span>
      game.score +:= bonus;
      draw_number(24, 10, game.score <span class="op">lpad</span> 6);
      <span class="keywd">if</span> game.score > game.hiScore <span class="keywd">then</span>
        game.hiScore := game.score;
        draw_number(24, 35, game.hiScore <span class="op">lpad</span> 6);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: play_game <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    game.num_players := 3;
    game.round_number := 1;
    game.score := 0;
    game.restart := FALSE;
    game_command(getc(KEYBOARD, NO_WAIT));
    <span class="keywd">while</span> <span class="op">not</span> game.quit <span class="op">and</span> <span class="op">not</span> game.restart <span class="op">and</span> game.num_players &lt;> 0 <span class="keywd">do</span>
      game_round;
      <span class="keywd">if</span> <span class="op">not</span> game.quit <span class="op">and</span> <span class="op">not</span> player.living <span class="keywd">then</span>
        decr(game.num_players);
      <span class="keywd">elsif</span> game.num_monsters = 0 <span class="keywd">then</span>
        <span class="keywd">if</span> game.round_number &lt; length(round_description) <span class="keywd">then</span>
          incr(game.round_number);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        game.num_players +:= round_description[game.round_number][5];
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: writeCentered (<span class="keywd">inout</span> <span class="type">text</span>: screen, <span class="op">in</span> <span class="type">integer</span>: yPos, <span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    setPosXY(screen, (WIN_WIDTH - width(stdFont9, stri)) <span class="op">div</span> 2, yPos);
    writeln(screen, stri);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: cmd <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    screen(WIN_WIDTH, WIN_HEIGHT);
    selectInput(curr_win, KEY_CLOSE, TRUE);
    clear(curr_win, black);
    KEYBOARD := GRAPH_KEYBOARD;
    scr := openPixmapFontFile(curr_win);
    setFont(scr, stdFont9);
    color(scr, white, black);
    writeCentered(scr, 22, <span class="stri">"P A N I C"</span>);
    writeCentered(scr, 66, <span class="stri">"Copyright (C) 2004, 2005  Thomas Mertes"</span>);
    writeCentered(scr, 93, <span class="stri">"This program is free software under the"</span>);
    writeCentered(scr, 108, <span class="stri">"terms of the GNU General Public License"</span>);
    writeCentered(scr, 135, <span class="stri">"Panic is written in the Seed7 programming language"</span>);
    writeCentered(scr, 150, <span class="stri">"Homepage:    http://seed7.sourceforge.net"</span>);
    setPosXY(scr, 65, 205);
    writeln(scr, <span class="stri">"Dig holes and pound the apples through the holes"</span>);
    writeln(scr);
    writeln(scr, <span class="stri">"cursor keys:"</span>);
    writeln(scr, <span class="stri">"space:"</span>);
    writeln(scr, <span class="stri">"A:"</span>);
    writeln(scr, <span class="stri">"S:"</span>);
    writeln(scr);
    writeln(scr, <span class="stri">"ESC or P:"</span>);
    writeln(scr, <span class="stri">"ctrl-R:"</span>);
    writeln(scr, <span class="stri">"Q:"</span>);
    setPosXY(scr, 175, 205);
    writeln(scr);
    writeln(scr);
    writeln(scr, <span class="stri">"Move your man"</span>);
    writeln(scr, <span class="stri">"Stop moving"</span>);
    writeln(scr, <span class="stri">"Dig hole"</span>);
    writeln(scr, <span class="stri">"Pound apples, shut hole and"</span>);
    writeln(scr, <span class="stri">"play again when the game is over"</span>);
    writeln(scr, <span class="stri">"Pause game (press P to continue)"</span>);
    writeln(scr, <span class="stri">"Restart game"</span>);
    writeln(scr, <span class="stri">"Quit game"</span>);
    writeCentered(scr, 378, <span class="stri">"     Wait for a moment     "</span>);
    draw_level(level_line[1]);
    draw_level(level_line[3]);
    draw_base_level(level_line[6]);
    draw_ladder(level_line[1], level_line[6], 8);
    draw_ladder(level_line[1], level_line[6], 260);
    flushGraphic;
    init_pictures;
    writeCentered(scr, 378, <span class="stri">"Press any key to start game"</span>);
    flushGraphic;
    cmd := getc(KEYBOARD);
    <span class="keywd">if</span> cmd <span class="op">in</span> {<span class="stri">'Q'</span>, <span class="stri">'q'</span>, KEY_CLOSE} <span class="keywd">then</span>
      game.quit := TRUE;
    <span class="keywd">elsif</span> cmd = KEY_ESC <span class="keywd">then</span>
      pause_game(TRUE, TRUE);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">while</span> <span class="op">not</span> game.quit <span class="keywd">do</span>
      play_game;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
