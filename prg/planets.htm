<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  planets.sd7   Display information about the planets             *)</span>
<span class="comment">(*  Copyright (C) 2006, 2007  Thomas Mertes                         *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is free software; you can redistribute it and/or   *)</span>
<span class="comment">(*  modify it under the terms of the GNU General Public License as  *)</span>
<span class="comment">(*  published by the Free Software Foundation; either version 2 of  *)</span>
<span class="comment">(*  the License, or (at your option) any later version.             *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This program is distributed in the hope that it will be useful, *)</span>
<span class="comment">(*  but WITHOUT ANY WARRANTY; without even the implied warranty of  *)</span>
<span class="comment">(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   *)</span>
<span class="comment">(*  GNU General Public License for more details.                    *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU General Public       *)</span>
<span class="comment">(*  License along with this program; if not, write to the           *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/seed7_05.htm">seed7_05.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/time.htm">time.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/duration.htm">duration.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/float.htm">float.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/keybd.htm">keybd.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/echo.htm">echo.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/line.htm">line.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/draw.htm">draw.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/graph_file.htm">graph_file.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/window.htm">window.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/stars.htm">stars.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/math.htm">math.s7i</a>"</span>;

<span class="keywd">var</span> <span class="type">text</span>: scr <span class="keywd">is</span> STD_NULL;

<span class="keywd">const</span> <span class="type">float</span>:   julianDayOfEpoch <span class="keywd">is</span> 2451545.0; <span class="comment"># 2000-01-01 12:00:00</span>
<span class="keywd">const</span> <span class="type">integer</span>: numberOfPlanets <span class="keywd">is</span> 9;
<span class="keywd">const</span> <span class="type">integer</span>: centerX <span class="keywd">is</span> 440;
<span class="keywd">const</span> <span class="type">integer</span>: centerY <span class="keywd">is</span> 345;
<span class="keywd">const</span> <span class="type">integer</span>: panoramaHorizont <span class="keywd">is</span> 700;
<span class="keywd">const</span> <span class="type">integer</span>: panoramaXMin <span class="keywd">is</span> 62;
<span class="keywd">const</span> <span class="type">float</span>:   sizePanorama <span class="keywd">is</span> 900.0;
<span class="keywd">const</span> <span class="type">integer</span>: windowWidth <span class="keywd">is</span> 1024;
<span class="keywd">const</span> <span class="type">integer</span>: windowHeight <span class="keywd">is</span> 768;
<span class="keywd">const</span> <span class="type">float</span>:   screenAspect <span class="keywd">is</span> 1.0;
<span class="keywd">const</span> <span class="type">integer</span>: scaleForInnerPlanets <span class="keywd">is</span> 210;
<span class="keywd">const</span> <span class="type">integer</span>: scaleForOuterPlanets <span class="keywd">is</span> 9;
<span class="keywd">const</span> <span class="type">float</span>:   radianToDegrees <span class="keywd">is</span> 57.295779513082320876798154814114;
<span class="keywd">const</span> <span class="type">float</span>:   degreesToRadian <span class="keywd">is</span> 0.017453292519943295769236907684883;

<span class="keywd">var</span> <span class="type">boolean</span>: displayDegreesInDecimal <span class="keywd">is</span> FALSE;
<span class="keywd">var</span> <span class="type">boolean</span>: displayHourAngleInDegrees <span class="keywd">is</span> FALSE;
<span class="keywd">var</span> <span class="type">boolean</span>: displayRAinDegrees <span class="keywd">is</span> FALSE;


<span class="keywd">const</span> <span class="type">type</span>: orbitType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">string</span>: name <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <span class="type">float</span>: orbitalPeriod <span class="keywd">is</span> 0.0;                   <span class="comment"># days</span>
    <span class="keywd">var</span> <span class="type">float</span>: meanLongitudeAtEpoch <span class="keywd">is</span> 0.0;            <span class="comment"># deg</span>
    <span class="keywd">var</span> <span class="type">float</span>: longitudeOfPerihelion <span class="keywd">is</span> 0.0;           <span class="comment"># deg</span>
    <span class="keywd">var</span> <span class="type">float</span>: longitudeOfPerihelionPerCentury <span class="keywd">is</span> 0.0; <span class="comment"># deg/century</span>
    <span class="keywd">var</span> <span class="type">float</span>: eccentricity <span class="keywd">is</span> 0.0;                    <span class="comment"># rad</span>
    <span class="keywd">var</span> <span class="type">float</span>: eccentricityPerCentury <span class="keywd">is</span> 0.0;          <span class="comment"># rad/century</span>
    <span class="keywd">var</span> <span class="type">float</span>: axis <span class="keywd">is</span> 0.0;                            <span class="comment"># AU</span>
    <span class="keywd">var</span> <span class="type">float</span>: axisPerCentury <span class="keywd">is</span> 0.0;                  <span class="comment"># AU/century</span>
    <span class="keywd">var</span> <span class="type">float</span>: inclination <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: longitudeOfTheAscendingNode <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: argumentOfThePerihelion <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: size <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: brightness <span class="keywd">is</span> 0.0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">var</span> <span class="type">array</span> <span class="type">orbitType</span>: orbitDescr <span class="keywd">is</span> numberOfPlanets <span class="op">times</span> orbitType.value;

<span class="keywd">var</span> <span class="type">time</span>: aTime <span class="keywd">is</span> time.value;
<span class="keywd">var</span> <span class="type">integer</span>: currTimeChange <span class="keywd">is</span> 4;

<span class="keywd">const</span> <span class="type">type</span>: heliocentricPlanetType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">float</span>: axis <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: eccentricity <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: meanLongitude <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: longitudeOfPerihelion <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: meanAnomaly <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: heliocentricLongitude <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: trueAnomaly <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: radiusVector <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: heliocentricEclipticLatitude <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: projectedHeliocentricLongitude <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: projectedRadius <span class="keywd">is</span> 0.0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: eclipticalCoordinateType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">float</span>: geocentricEclipticLongitude <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: geocentricLatitude <span class="keywd">is</span> 0.0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: equatorialCoordinateType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">float</span>: rightAscension <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: declination <span class="keywd">is</span> 0.0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: horizontalCoordinateType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">float</span>: azimuth <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: altitude <span class="keywd">is</span> 0.0;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: earthCoordinateType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">float</span>: longitude <span class="keywd">is</span> -16.42;
    <span class="keywd">var</span> <span class="type">float</span>: latitude  <span class="keywd">is</span>  48.25;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">const</span> <span class="type">type</span>: geocentricPlanetType <span class="keywd">is</span> new <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">eclipticalCoordinateType</span>: eclipticalCoordinate <span class="keywd">is</span> eclipticalCoordinateType.value;
    <span class="keywd">var</span> <span class="type">equatorialCoordinateType</span>: equatorialCoordinate <span class="keywd">is</span> equatorialCoordinateType.value;
    <span class="keywd">var</span> <span class="type">float</span>: hourAngle <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">horizontalCoordinateType</span>: horizontalCoordinate <span class="keywd">is</span> horizontalCoordinateType.value;
  <span class="keywd">end</span> <span class="keywd">struct</span>;

<span class="keywd">var</span> <span class="type">earthCoordinateType</span>: posAtEarth <span class="keywd">is</span> earthCoordinateType.value;
<span class="keywd">var</span> <span class="type">float</span>: localSiderealTime <span class="keywd">is</span> 0.0;


<span class="comment">(* Trigonometric functions for degrees *)</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: toDegrees (<span class="op">in</span> <span class="type">float</span>: x) <span class="keywd">is</span>
  <span class="keywd">return</span> x * radianToDegrees;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: toRadians (<span class="op">in</span> <span class="type">float</span>: x) <span class="keywd">is</span>
  <span class="keywd">return</span> x * degreesToRadian;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: sinD (<span class="op">in</span> <span class="type">float</span>: x) <span class="keywd">is</span>
  <span class="keywd">return</span> sin(x * degreesToRadian);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: cosD (<span class="op">in</span> <span class="type">float</span>: x) <span class="keywd">is</span>
  <span class="keywd">return</span> cos(x * degreesToRadian);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: tanD (<span class="op">in</span> <span class="type">float</span>: x) <span class="keywd">is</span>
  <span class="keywd">return</span> tan(x * degreesToRadian);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: asinD (<span class="op">in</span> <span class="type">float</span>: x) <span class="keywd">is</span>
  <span class="keywd">return</span> asin(x) * radianToDegrees;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: acosD (<span class="op">in</span> <span class="type">float</span>: x) <span class="keywd">is</span>
  <span class="keywd">return</span> acos(x) * radianToDegrees;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: atanD (<span class="op">in</span> <span class="type">float</span>: x) <span class="keywd">is</span>
  <span class="keywd">return</span> atan(x) * radianToDegrees;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: atan2D (<span class="op">in</span> <span class="type">float</span>: y, <span class="op">in</span> <span class="type">float</span>: x) <span class="keywd">is</span>
  <span class="keywd">return</span> atan2(y, x) * radianToDegrees;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: frac (<span class="op">in</span> <span class="type">float</span>: x) <span class="keywd">is</span>
  <span class="keywd">return</span> x - flt(trunc(x));


<span class="comment">(* Astronomy functions *)</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: julianDay (<span class="op">in</span> <span class="type">time</span>: aTime) <span class="keywd">is</span>
  <span class="keywd">return</span> flt(julianDayNumber(aTime)) +
      ((flt(aTime.second) / 60.0 + flt(aTime.minute)) / 60.0 + flt(aTime.hour - 12)) / 24.0;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: minutes (<span class="op">in</span> <span class="type">float</span>: time) <span class="keywd">is</span>
  <span class="keywd">return</span> abs(trunc(60.0 * (frac(time))));


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: seconds (<span class="op">in</span> <span class="type">float</span>: time) <span class="keywd">is</span>
  <span class="keywd">return</span> abs(trunc(60.0 * (frac(60.0 * frac(time)))));


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: angleAsDegrees (<span class="op">in</span> <span class="type">float</span>: angle) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: degreesMinutesSeconds <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> displayDegreesInDecimal <span class="keywd">then</span>
      degreesMinutesSeconds &amp;:= angle <span class="op">digits</span> 4 <span class="op">lpad</span> 9;
      degreesMinutesSeconds &amp;:= <span class="stri">"° "</span>;
    <span class="keywd">else</span>
      <span class="keywd">if</span> angle &lt; 0.0 <span class="keywd">then</span>
        degreesMinutesSeconds := <span class="stri">"-"</span>;
      <span class="keywd">else</span>
        degreesMinutesSeconds := <span class="stri">" "</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      degreesMinutesSeconds &amp;:= abs(trunc(angle)) <span class="op">lpad</span> 3;
      degreesMinutesSeconds &amp;:= <span class="stri">"° "</span>;
      degreesMinutesSeconds &amp;:= minutes(angle) <span class="op">lpad</span> 2;
      degreesMinutesSeconds &amp;:= <span class="stri">"' "</span>;
      degreesMinutesSeconds &amp;:= seconds(angle) <span class="op">lpad</span> 2;
      degreesMinutesSeconds &amp;:= <span class="stri">"\""</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: angleAsHours (<span class="op">in</span> <span class="type">float</span>: angle) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: hoursMinutesSeconds <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> displayDegreesInDecimal <span class="keywd">then</span>
      hoursMinutesSeconds &amp;:= angle / 15.0 <span class="op">digits</span> 4 <span class="op">lpad</span> 8;
      hoursMinutesSeconds &amp;:= <span class="stri">"h"</span>;
    <span class="keywd">else</span>
      <span class="keywd">if</span> angle &lt; 0.0 <span class="keywd">then</span>
        hoursMinutesSeconds := <span class="stri">"-"</span>;
      <span class="keywd">else</span>
        hoursMinutesSeconds := <span class="stri">" "</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      hoursMinutesSeconds &amp;:= abs(trunc(angle / 15.0)) <span class="op">lpad</span> 3;
      hoursMinutesSeconds &amp;:= <span class="stri">"h "</span>;
      hoursMinutesSeconds &amp;:= minutes(angle / 15.0) <span class="op">lpad</span> 2;
      hoursMinutesSeconds &amp;:= <span class="stri">"m "</span>;
      hoursMinutesSeconds &amp;:= seconds(angle / 15.0) <span class="op">lpad</span> 2;
      hoursMinutesSeconds &amp;:= <span class="stri">"s"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: anomaly (<span class="op">in</span> <span class="type">float</span>: m, <span class="op">in</span> <span class="type">float</span>: eccentricity) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: anomaly <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">float</span>: d <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: e <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    e := m;
    d := -eccentricity * sin(m);
    <span class="keywd">while</span> abs(d) > 0.000001 <span class="keywd">do</span>
      e := e - d / (1.0 - eccentricity * cos(e));
      d := e - eccentricity * sin(e) - m;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    anomaly := 2.0 * atan(sqrt((1.0 + eccentricity) / (1.0 - eccentricity)) * tan(e / 2.0))
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* anomaly *)</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: anomaly2 (<span class="op">in</span> <span class="type">float</span>: m, <span class="op">in</span> <span class="type">float</span>: eccentricity) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: anomaly <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">float</span>: e <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: deltaM <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: deltaE <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    e := m - eccentricity * sin(m);
    <span class="keywd">repeat</span>
      deltaM := m - e - eccentricity * sin(e);
      deltaE := deltaM / (1.0 - eccentricity * cos(e));
      e +:= deltaE;
    <span class="keywd">until</span> abs(deltaE) &lt; 0.000001;
    anomaly := e;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* anomaly2 *)</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: eclipticalCoordinatesToRightAscension (<span class="op">in</span> <span class="type">float</span>: l, <span class="op">in</span> <span class="type">float</span>: b) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: rightAscension <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">float</span>: x <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: y <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    x := cosD(l);
    y := sinD(l) * 0.91746406 - tanD(b) * 0.397818676;
    rightAscension := atan2D(y, x) / 15.0;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* eclipticalCoordinatesToRightAscension *)</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: eclipticalCoordinatesToDeclination (<span class="op">in</span> <span class="type">float</span>: l, <span class="op">in</span> <span class="type">float</span>: b) <span class="keywd">is</span>
  <span class="keywd">return</span> asinD(sinD(b) * 0.91746406 + cosD(b) * sinD(l) * 0.397818676);


<span class="keywd">const</span> <span class="type">proc</span>: degreesToRange (<span class="keywd">inout</span> <span class="type">float</span>: degrees) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">while</span> degrees > 360.0 <span class="keywd">do</span>
      degrees -:= 360.0;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">while</span> degrees &lt; 0.0 <span class="keywd">do</span>
      degrees +:= 360.0;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: hoursToRange (<span class="keywd">inout</span> <span class="type">float</span>: hours) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">while</span> hours >= 24.0 <span class="keywd">do</span>
      hours -:= 24.0;
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">while</span> hours &lt;  0.0 <span class="keywd">do</span>
      hours +:= 24.0;
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: localSiderealToCivilTime (<span class="op">in</span> <span class="type">float</span>: localSiderealTime,
    <span class="op">in</span> <span class="type">float</span>: longitude, <span class="op">in</span> <span class="type">time</span>: aTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: localCivilTime <span class="keywd">is</span> 0.0
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">float</span>: t <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: b <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: greenwichSiderealTime <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: greenwichMeanTime <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    greenwichSiderealTime := localSiderealTime + longitude / 15.0;
    <span class="keywd">if</span> greenwichSiderealTime > 24.0 <span class="keywd">then</span>
      greenwichSiderealTime -:= 24.0;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> greenwichSiderealTime &lt; 0.0 <span class="keywd">then</span>
      greenwichSiderealTime +:= 24.0;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    t := (julianDay(truncToYear(aTime) - 1 . DAYS) - 2415020.0) / 36525.0;
    b := 24.0 - 6.6460656 - (2400.051262 * t) - (0.00002581 * t * t) +
        flt(24 * (aTime.year - 1900));
    t := greenwichSiderealTime - flt(dayOfYear(aTime)) * 0.0657098 + b;
    hoursToRange(t);
    greenwichMeanTime := t * 0.99727;
    localCivilTime := greenwichMeanTime + flt(aTime.timeZone) / 60.0;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showLocalTime (<span class="keywd">inout</span> <span class="type">text</span>: win) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: timeStri <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">const</span> <span class="type">integer</span>: column <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    timeStri := aTime <span class="op">lpad</span> 19;
    setPos(win, 1, column);
    writeln(win, timeStri);
    color(win, light_cyan);
    <span class="keywd">case</span> currTimeChange <span class="keywd">of</span>
      <span class="keywd">when</span> {1}:
        setPos(win, 1, column);
        write(win, timeStri[.. 4]);
      <span class="keywd">when</span> {2}:
        setPos(win, 1, column + 5);
        write(win, timeStri[6 .. 7]);
      <span class="keywd">when</span> {3}:
        setPos(win, 1, column + 8);
        write(win, timeStri[9 .. 10]);
      <span class="keywd">when</span> {4}:
        setPos(win, 1, column + 11);
        write(win, timeStri[12 .. 13]);
      <span class="keywd">when</span> {5}:
        setPos(win, 1, column + 14);
        write(win, timeStri[15 .. 16]);
      <span class="keywd">when</span> {6}:
        setPos(win, 1, column + 17);
        write(win, timeStri[18 .. 19]);
      <span class="keywd">when</span> {7}:
        setPos(win, 1, column + 20);
        write(win, timeStri[21 .. 26]);
    <span class="keywd">end</span> <span class="keywd">case</span>;
    color(win, white);
    writeln(win);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: calculateGreenwichMeanSiderealTime (<span class="op">in</span> <span class="type">time</span>: gmTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: greenwichMeanSiderealTime <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">float</span>: d <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: d0 <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: h <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">integer</span>: t <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    d := julianDay(gmTime) - julianDayOfEpoch;
    d0 := flt(julianDayNumber(gmTime)) + 0.5 - julianDayOfEpoch;
    h := (flt(gmTime.second) / 60.0 + flt(gmTime.minute)) / 60.0 + flt(gmTime.hour);
    t := round(d) <span class="op">div</span> 36525;
    greenwichMeanSiderealTime := 6.697374558 + 0.06570982441908 * d0 +
                                 1.00273790935 * h + 0.000026 * flt(t * t);
    hoursToRange(greenwichMeanSiderealTime);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: showTime <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">text</span>: win <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">integer</span>: julianDayNumber <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">float</span>: greenwichMeanSiderealTime <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">time</span>: gmTime <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    win := openWindow(scr, 2, 58, 8, 32);
    showLocalTime(win);
    julianDayNumber := julianDayNumber(aTime);
    writeln(win, <span class="stri">"julianDayNum ="</span> &lt;&amp; julianDayNumber <span class="op">lpad</span> 10);
    writeln(win, <span class="stri">"Longitude    = "</span> &lt;&amp; angleAsDegrees(posAtEarth.longitude));
    writeln(win, <span class="stri">"Latitude     = "</span> &lt;&amp; angleAsDegrees(posAtEarth.latitude));
    write(win, <span class="stri">"localCivilTime        = "</span>);
    writeln(win, strTime(aTime));
    gmTime := toUTC(aTime);
    write(win, <span class="stri">"greenwichMeanTime     = "</span>);
    writeln(win, strTime(gmTime));
    greenwichMeanSiderealTime := calculateGreenwichMeanSiderealTime(gmTime);
    write(win, <span class="stri">"greenwichSiderealTime = "</span>);
    write(win, trunc(greenwichMeanSiderealTime) <span class="op">lpad0</span> 2);
    write(win, <span class="stri">":"</span>);
    write(win, minutes(greenwichMeanSiderealTime) <span class="op">lpad0</span> 2);
    write(win, <span class="stri">":"</span>);
    writeln(win, seconds(greenwichMeanSiderealTime) <span class="op">lpad0</span> 2);
    localSiderealTime := greenwichMeanSiderealTime - posAtEarth.longitude / 15.0;
    hoursToRange(localSiderealTime);
    write(win, <span class="stri">"localSiderealTime     = "</span>);
    write(win, trunc(localSiderealTime) <span class="op">lpad0</span> 2);
    write(win, <span class="stri">":"</span>);
    write(win, minutes(localSiderealTime) <span class="op">lpad0</span> 2);
    write(win, <span class="stri">":"</span>);
    write(win, seconds(localSiderealTime) <span class="op">lpad0</span> 2);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* showTime *)</span>


<span class="keywd">const</span> <span class="type">func</span> <span class="type">heliocentricPlanetType</span>: locatePositionOfPlanetInItsOrbitalPlane (
    <span class="op">in</span> <span class="type">orbitType</span>: planetDescr) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">heliocentricPlanetType</span>: planet <span class="keywd">is</span> heliocentricPlanetType.value;
  <span class="keywd">begin</span>
    planet.axis := planetDescr.axis +
        planetDescr.axisPerCentury * (julianDay(aTime) - julianDayOfEpoch) / 36525.0;
    planet.eccentricity := planetDescr.eccentricity +
        planetDescr.eccentricityPerCentury * (julianDay(aTime) - julianDayOfEpoch) / 36525.0;
    planet.meanLongitude := planetDescr.meanLongitudeAtEpoch +
        360.0 / (planetDescr.orbitalPeriod / orbitDescr[3].orbitalPeriod  * 365.2425) *
        (julianDay(aTime) - julianDayOfEpoch);
    degreesToRange(planet.meanLongitude);
    planet.longitudeOfPerihelion := planetDescr.longitudeOfPerihelion +
        planetDescr.longitudeOfPerihelionPerCentury * (julianDay(aTime) - julianDayOfEpoch) / 36525.0;
    planet.meanAnomaly := planet.meanLongitude - planet.longitudeOfPerihelion;
    planet.trueAnomaly := toDegrees(anomaly(toRadians(planet.meanAnomaly), planet.eccentricity));
    planet.heliocentricLongitude := planet.trueAnomaly + planet.longitudeOfPerihelion;
    degreesToRange(planet.heliocentricLongitude);
    planet.radiusVector := planetDescr.axis * (1.0 - planet.eccentricity * planet.eccentricity) /
        (1.0 + planet.eccentricity * cosD(planet.trueAnomaly));
    planet.heliocentricEclipticLatitude := asinD(sinD(planet.heliocentricLongitude -
        planetDescr.longitudeOfTheAscendingNode) * sinD(planetDescr.inclination));
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: plotPlanet (<span class="op">in</span> <span class="type">integer</span>: planetNumber, <span class="op">in</span> <span class="type">integer</span>: scale) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: computeRadiusVector (<span class="op">in</span> <span class="type">heliocentricPlanetType</span>: planet, <span class="op">in</span> <span class="type">integer</span>: angle) <span class="keywd">is</span>
      <span class="keywd">return</span> planet.axis *
             (1.0 - planet.eccentricity * planet.eccentricity) /
             (1.0 + planet.eccentricity * cosD(flt(angle) - planet.longitudeOfPerihelion));

    <span class="keywd">var</span> <span class="type">heliocentricPlanetType</span>: planet <span class="keywd">is</span> heliocentricPlanetType.value;
    <span class="keywd">var</span> <span class="type">integer</span>: oldX <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: oldY <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: newX <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: newY <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: angle <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    planet := locatePositionOfPlanetInItsOrbitalPlane(orbitDescr[planetNumber]);
    newY := round(flt(scale) * planet.radiusVector * sinD(planet.heliocentricLongitude)) +
            centerY;
    newX := round(flt(scale) * planet.radiusVector * cosD(planet.heliocentricLongitude) *
            screenAspect) + centerX;
    fcircle(newX, windowHeight - newY, 3, light_cyan);
    setPosXY(scr, newX + 4, windowHeight - newY);
    write(scr, orbitDescr[planetNumber].name);

    newX := centerX + round(computeRadiusVector(planet, 0) * flt(scale) * screenAspect);
    newY := windowHeight - centerY;
    <span class="keywd">for</span> angle <span class="keywd">range</span> 1 <span class="keywd">to</span> 60 <span class="keywd">do</span>
      oldX := newX;
      oldY := newY;
      newX := round(computeRadiusVector(planet, angle * 6) * flt(scale) * screenAspect
              * cosD(flt(angle * 6))) + centerX;
      newY := windowHeight -
              (round(computeRadiusVector(planet, angle * 6) * flt(scale) * sinD(flt(angle * 6)))
              + centerY);
      lineTo(oldX, oldY, newX, newY, light_cyan);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* plotPlanet *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: showMenu <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: num <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    clear(black);
    showTime;
    setPos(scr, 2, 1);
    writeln(scr, <span class="stri">" P L A N E T S   Display information about the planets"</span>);
    setPos(scr, 4, 1);
    writeln(scr, <span class="stri">" Copyright (C) 2006, 2007  Thomas Mertes"</span>);
    setPos(scr, 6, 1);
    writeln(scr, <span class="stri">" This program is free software under the"</span>);
    writeln(scr, <span class="stri">" terms of the GNU General Public License"</span>);
    setPos(scr, 9, 1);
    writeln(scr, <span class="stri">" Planets is written in the Seed7 programming language"</span>);
    writeln(scr, <span class="stri">" Homepage:    http://seed7.sourceforge.net"</span>);
    writeln(scr);
    writeln(scr);
    writeln(scr, <span class="stri">" Possible commands are:"</span>);
    writeln(scr);
    writeln(scr, <span class="stri">" M  Menu"</span>);
    writeln(scr, <span class="stri">" I  Plot Inner Planets"</span>);
    writeln(scr, <span class="stri">" O  Plot Outer Planets"</span>);
    writeln(scr, <span class="stri">" D  Change Date/Time"</span>);
    writeln(scr, <span class="stri">" L  Change Long/Lat"</span>);
    writeln(scr, <span class="stri">" S  Set_up"</span>);
    writeln(scr, <span class="stri">" Q  Quit"</span>);
    <span class="keywd">for</span> num <span class="keywd">range</span> 1 <span class="keywd">to</span> numberOfPlanets <span class="keywd">do</span>
      setPos(scr, 14 + num, 25);
      writeln(scr, <span class="stri">" "</span> &lt;&amp; num &lt;&amp; <span class="stri">"  "</span> &lt;&amp; orbitDescr[num].name);
    <span class="keywd">end</span> <span class="keywd">for</span>;
    setPos(scr, 15, 42);
    writeln(scr, <span class="stri">"Horizontal cursor keys:"</span>);
    setPos(scr, 16, 42);
    writeln(scr, <span class="stri">"  Select time step"</span>);
    setPos(scr, 18, 42);
    writeln(scr, <span class="stri">"Vertical cursor keys:"</span>);
    setPos(scr, 19, 42);
    write(scr,   <span class="stri">"  Add or subtract a time step"</span>);
    setPos(scr, 25, 1);
    writeln(scr, <span class="stri">" Enter command:"</span>);
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* showMenu *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: setup <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    clear(curr_win);
    setPos(scr, 1, 1);
    writeln(scr, <span class="stri">"Display Degrees in Decimal Degrees (Y/N)? "</span>);
    ch := getc(KEYBOARD);
    <span class="keywd">if</span> upper(ch) = <span class="stri">'Y'</span> <span class="keywd">then</span>
      displayDegreesInDecimal := TRUE;
    <span class="keywd">elsif</span> upper(ch) = <span class="stri">'N'</span> <span class="keywd">then</span>
      displayDegreesInDecimal := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(scr, <span class="stri">"Display Hour Angle in Degrees (Y/N)? "</span>);
    ch := getc(KEYBOARD);
    <span class="keywd">if</span> upper(ch) = <span class="stri">'Y'</span> <span class="keywd">then</span>
      displayHourAngleInDegrees := TRUE;
    <span class="keywd">elsif</span> upper(ch) = <span class="stri">'N'</span> <span class="keywd">then</span>
      displayHourAngleInDegrees := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    writeln(scr, <span class="stri">"Display RA in Degrees (Y/N)? "</span>);
    ch := getc(KEYBOARD);
    <span class="keywd">if</span> upper(ch) = <span class="stri">'Y'</span> <span class="keywd">then</span>
      displayRAinDegrees := TRUE;
    <span class="keywd">elsif</span> upper(ch) = <span class="stri">'N'</span> <span class="keywd">then</span>
      displayRAinDegrees := FALSE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* setup *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: plotInnerPlanets <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">text</span>: win <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">integer</span>: julianDayNumber <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: planetNumber <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    clear(curr_win);
    win := openWindow(scr, 2, 135, 7, 32);
    showLocalTime(win);
    julianDayNumber := julianDayNumber(aTime);
    writeln(win, <span class="stri">"julianDayNum ="</span> &lt;&amp; julianDayNumber <span class="op">lpad</span> 10);
    writeln(win);
    writeln(win, <span class="stri">"Horizontal cursor keys:"</span>);
    writeln(win, <span class="stri">"  Select time step"</span>);
    writeln(win, <span class="stri">"Vertical cursor keys:"</span>);
    write(win,   <span class="stri">"  Add or subtract a time step"</span>);
    fcircle(centerX, windowHeight - centerY, 3, light_cyan);
    setPosXY(scr, centerX + 4, windowHeight - centerY);
    write(scr, <span class="stri">"Sun"</span>);
    <span class="keywd">for</span> planetNumber <span class="keywd">range</span> 1 <span class="keywd">to</span> 4 <span class="keywd">do</span>
      plotPlanet(planetNumber, scaleForInnerPlanets);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* plotInnerPlanets *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: plotOuterPlanets <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">text</span>: win <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">integer</span>: julianDayNumber <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: planetNumber <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    clear(curr_win);
    win := openWindow(scr, 2, 135, 7, 32);
    showLocalTime(win);
    julianDayNumber := julianDayNumber(aTime);
    writeln(win, <span class="stri">"julianDayNum ="</span> &lt;&amp; julianDayNumber <span class="op">lpad</span> 10);
    writeln(win);
    writeln(win, <span class="stri">"Horizontal cursor keys:"</span>);
    writeln(win, <span class="stri">"  Select time step"</span>);
    writeln(win, <span class="stri">"Vertical cursor keys:"</span>);
    write(win,   <span class="stri">"  Add or subtract a time step"</span>);
    point(centerX, windowHeight - centerY, light_cyan);
    plotPlanet(3, scaleForOuterPlanets);
    <span class="keywd">for</span> planetNumber <span class="keywd">range</span> 5 <span class="keywd">to</span> 9 <span class="keywd">do</span>
      plotPlanet(planetNumber, scaleForOuterPlanets);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* plotOuterPlanets *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: changeDateTime <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">text</span>: win <span class="keywd">is</span> STD_NULL;
  <span class="keywd">begin</span>
    clear(curr_win);
    showTime;
    setPos(scr, 1, 1);
    <span class="keywd">case</span> currTimeChange <span class="keywd">of</span>
      <span class="keywd">when</span> {1}:
        write(scr, <span class="stri">"Enter year: "</span>);
        read(aTime.year);
      <span class="keywd">when</span> {2}:
        write(scr, <span class="stri">"Enter month: "</span>);
        read(aTime.month);
      <span class="keywd">when</span> {3}:
        write(scr, <span class="stri">"Enter day: "</span>);
        read(aTime.day);
      <span class="keywd">when</span> {4}:
        write(scr, <span class="stri">"Enter hour: "</span>);
        read(aTime.hour);
      <span class="keywd">when</span> {5}:
        write(scr, <span class="stri">"Enter minute: "</span>);
        read(aTime.minute);
      <span class="keywd">when</span> {6}:
        write(scr, <span class="stri">"Enter second: "</span>);
        read(aTime.second);
    <span class="keywd">end</span> <span class="keywd">case</span>;
    showMenu;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: changeLongLat <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    clear(curr_win);
    showTime;
    setPos(scr, 1, 1);
    writeln(<span class="stri">"Enter Longitude"</span>);
    readln(posAtEarth.longitude);
    writeln(<span class="stri">"Enter Latitude"</span>);
    readln(posAtEarth.latitude);
    showMenu;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: computeProjectedHeliocentricLongitude (<span class="op">in</span> <span class="type">heliocentricPlanetType</span>: planet,
    <span class="op">in</span> <span class="type">orbitType</span>: orbitDescr) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: projectedHeliocentricLongitude <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">float</span>: y <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: x <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: z <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    y := sinD(planet.heliocentricLongitude - orbitDescr.longitudeOfTheAscendingNode) *
         cosD(orbitDescr.inclination);
    x := cosD(planet.heliocentricLongitude - orbitDescr.longitudeOfTheAscendingNode);
    z := atan2D(y, x);
    projectedHeliocentricLongitude := z + orbitDescr.longitudeOfTheAscendingNode;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: ProjectPlanetOntoEclipticalPlane (<span class="keywd">inout</span> <span class="type">heliocentricPlanetType</span>: planet,
    <span class="op">in</span> <span class="type">orbitType</span>: orbitDescr) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    planet.projectedHeliocentricLongitude := computeProjectedHeliocentricLongitude(planet, orbitDescr);
    degreesToRange(planet.projectedHeliocentricLongitude);
    planet.projectedRadius := planet.radiusVector * cosD(planet.heliocentricEclipticLatitude);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">eclipticalCoordinateType</span>: calculateEclipticalCoordinates (<span class="op">in</span> <span class="type">heliocentricPlanetType</span>: planet,
    <span class="op">in</span> <span class="type">heliocentricPlanetType</span>: earth) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">eclipticalCoordinateType</span>: eclipticalCoordinate <span class="keywd">is</span> eclipticalCoordinateType.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> planet.radiusVector &lt; earth.radiusVector <span class="keywd">then</span>
      eclipticalCoordinate.geocentricEclipticLongitude := earth.heliocentricLongitude + 180.0 +
          atanD(planet.projectedRadius * sinD(earth.heliocentricLongitude -
          planet.projectedHeliocentricLongitude) / (earth.radiusVector -
          planet.projectedRadius * cosD(earth.heliocentricLongitude -
          planet.projectedHeliocentricLongitude)));
    <span class="keywd">else</span>
      eclipticalCoordinate.geocentricEclipticLongitude := planet.projectedHeliocentricLongitude +
          atanD(earth.radiusVector * sinD(planet.projectedHeliocentricLongitude -
          earth.heliocentricLongitude) / (planet.projectedRadius -
          earth.radiusVector * cosD(planet.projectedHeliocentricLongitude -
          earth.heliocentricLongitude)));
    <span class="keywd">end</span> <span class="keywd">if</span>;
    degreesToRange(eclipticalCoordinate.geocentricEclipticLongitude);
    eclipticalCoordinate.geocentricLatitude := atanD(planet.projectedRadius *
        tanD(planet.heliocentricEclipticLatitude) *
        sinD(eclipticalCoordinate.geocentricEclipticLongitude -
        planet.projectedHeliocentricLongitude) / (earth.radiusVector *
        sinD(planet.projectedHeliocentricLongitude - earth.heliocentricLongitude)));
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">equatorialCoordinateType</span>: calculateEquatorialCoordinates (
    <span class="op">in</span> <span class="type">eclipticalCoordinateType</span>: eclipticalCoordinate) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">equatorialCoordinateType</span>: equatorialCoordinate <span class="keywd">is</span> equatorialCoordinateType.value;
  <span class="keywd">begin</span>
    equatorialCoordinate.rightAscension := eclipticalCoordinatesToRightAscension(
        eclipticalCoordinate.geocentricEclipticLongitude,
        eclipticalCoordinate.geocentricLatitude);
    equatorialCoordinate.declination := eclipticalCoordinatesToDeclination(
        eclipticalCoordinate.geocentricEclipticLongitude,
        eclipticalCoordinate.geocentricLatitude);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">float</span>: calculateHourAngle (<span class="op">in</span> <span class="type">equatorialCoordinateType</span>: equatorialCoordinate,
    <span class="op">in</span> <span class="type">float</span>: localSiderealTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">float</span>: hourAngle <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    hourAngle := localSiderealTime - equatorialCoordinate.rightAscension;
    <span class="keywd">if</span> hourAngle &lt; 0.0 <span class="keywd">then</span>
      hourAngle +:= 24.0;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">horizontalCoordinateType</span>: calculateHorizontalCoordinates (
    <span class="op">in</span> <span class="type">equatorialCoordinateType</span>: equatorialCoordinate,
    <span class="op">in</span> <span class="type">earthCoordinateType</span>: posAtEarth, <span class="op">in</span> <span class="type">float</span>: hourAngle) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">horizontalCoordinateType</span>: horizontalCoordinate <span class="keywd">is</span> horizontalCoordinateType.value;
  <span class="keywd">begin</span>
    horizontalCoordinate.altitude := asinD(sinD(equatorialCoordinate.declination) * sinD(posAtEarth.latitude) +
        cosD(equatorialCoordinate.declination) * cosD(posAtEarth.latitude) *
        cosD(hourAngle * 15.0));
    horizontalCoordinate.azimuth := acosD((sinD(equatorialCoordinate.declination) -
        sinD(posAtEarth.latitude) * sinD(horizontalCoordinate.altitude)) /
        (cosD(posAtEarth.latitude) * cosD(horizontalCoordinate.altitude)));
    <span class="keywd">if</span> sinD(hourAngle * 15.0) > 0.0 <span class="keywd">then</span>
      horizontalCoordinate.azimuth := 360.0 - horizontalCoordinate.azimuth;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">geocentricPlanetType</span>: genGeocentricPos (<span class="op">in</span> <span class="type">heliocentricPlanetType</span>: planet,
    <span class="op">in</span> <span class="type">heliocentricPlanetType</span>: earth, <span class="op">in</span> <span class="type">float</span>: localSiderealTime,
    <span class="op">in</span> <span class="type">earthCoordinateType</span>: posAtEarth) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">geocentricPlanetType</span>: geocentricPos <span class="keywd">is</span> geocentricPlanetType.value;
  <span class="keywd">begin</span>
    geocentricPos.eclipticalCoordinate := calculateEclipticalCoordinates(planet, earth);
    geocentricPos.equatorialCoordinate := calculateEquatorialCoordinates(geocentricPos.eclipticalCoordinate);
    geocentricPos.hourAngle := calculateHourAngle(geocentricPos.equatorialCoordinate, localSiderealTime);
    geocentricPos.horizontalCoordinate := calculateHorizontalCoordinates(geocentricPos.equatorialCoordinate,
        posAtEarth, geocentricPos.hourAngle);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: panoramaXPos (<span class="op">in</span> <span class="type">float</span>: azimuth) <span class="keywd">is</span>
  <span class="keywd">return</span> panoramaXMin + round(azimuth / 360.0 * sizePanorama);


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: panoramaYPos (<span class="op">in</span> <span class="type">float</span>: altitude) <span class="keywd">is</span>
  <span class="keywd">return</span> panoramaHorizont - round(altitude  / 360.0 * sizePanorama);


<span class="keywd">const</span> <span class="type">proc</span>: drawAllPlanets (<span class="op">in</span> <span class="type">heliocentricPlanetType</span>: earth) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: planetNumber <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">heliocentricPlanetType</span>: planet <span class="keywd">is</span> heliocentricPlanetType.value;
    <span class="keywd">var</span> <span class="type">geocentricPlanetType</span>: geocentricPos <span class="keywd">is</span> geocentricPlanetType.value;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> planetNumber <span class="keywd">range</span> 1 <span class="keywd">to</span> 9 <span class="keywd">do</span>
      <span class="keywd">if</span> planetNumber &lt;> 3 <span class="keywd">then</span>
        planet := locatePositionOfPlanetInItsOrbitalPlane(orbitDescr[planetNumber]);
        ProjectPlanetOntoEclipticalPlane(planet, orbitDescr[planetNumber]);
        geocentricPos := genGeocentricPos(planet, earth, localSiderealTime, posAtEarth);
        <span class="keywd">if</span> geocentricPos.horizontalCoordinate.altitude >= 0.0 <span class="keywd">then</span>
          fcircle(panoramaXPos(geocentricPos.horizontalCoordinate.azimuth),
              panoramaYPos(geocentricPos.horizontalCoordinate.altitude), 2, light_cyan);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: drawSun (<span class="op">in</span> <span class="type">heliocentricPlanetType</span>: earth) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">heliocentricPlanetType</span>: sun <span class="keywd">is</span> heliocentricPlanetType.value;
    <span class="keywd">var</span> <span class="type">geocentricPlanetType</span>: geocentricPos <span class="keywd">is</span> geocentricPlanetType.value;
  <span class="keywd">begin</span>
    geocentricPos := genGeocentricPos(sun, earth, localSiderealTime, posAtEarth);
    <span class="keywd">if</span> geocentricPos.horizontalCoordinate.altitude >= 0.0 <span class="keywd">then</span>
      fcircle(panoramaXPos(geocentricPos.horizontalCoordinate.azimuth),
          panoramaYPos(geocentricPos.horizontalCoordinate.altitude), 4, yellow);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: drawHorizont <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: azimuth <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: length <span class="keywd">is</span> 0;
    <span class="keywd">const</span> <span class="type">array</span> <span class="type">string</span>: name <span class="keywd">is</span> [] (<span class="stri">"North"</span>, <span class="stri">"East"</span>, <span class="stri">"South"</span>, <span class="stri">"West"</span>, <span class="stri">"North"</span>);
    <span class="keywd">var</span> <span class="type">integer</span>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    lineTo(0, panoramaHorizont, 1023, panoramaHorizont, white);
    <span class="keywd">for</span> azimuth <span class="keywd">range</span> 0 <span class="keywd">to</span> 360 <span class="keywd">do</span>
      <span class="keywd">if</span> azimuth <span class="op">rem</span> 90 = 0 <span class="keywd">then</span>
        length := 12;
        setPosXY(scr, panoramaXPos(flt(azimuth)) - 12, panoramaHorizont + 25);
        writeln(scr, name[pos]);
        incr(pos);
      <span class="keywd">elsif</span> azimuth <span class="op">rem</span> 45 = 0 <span class="keywd">then</span>
        length := 10;
      <span class="keywd">elsif</span> azimuth <span class="op">rem</span> 10 = 0 <span class="keywd">then</span>
        length := 8;
      <span class="keywd">elsif</span> azimuth <span class="op">rem</span> 5 = 0 <span class="keywd">then</span>
        length := 6;
      <span class="keywd">elsif</span> azimuth <span class="op">rem</span> 5 = 0 <span class="keywd">then</span>
        length := 4;
      <span class="keywd">else</span>
        length := 2;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      line(panoramaXPos(flt(azimuth)), panoramaHorizont, 0, length, white);
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: writePoint (<span class="op">in</span> <span class="type">integer</span>: x, <span class="op">in</span> <span class="type">integer</span>: y, <span class="op">in</span> <span class="type">float</span>: vis) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> vis >= 5.0 <span class="keywd">then</span>
      point(x, y, dark_gray);
    <span class="keywd">elsif</span> vis >= 4.5 <span class="keywd">then</span>
      point(x, y, Gray);
    <span class="keywd">elsif</span> vis >= 4.0 <span class="keywd">then</span>
      point(x, y, light_gray);
    <span class="keywd">elsif</span> vis >= 3.5 <span class="keywd">then</span>
      point(x, y, white);
    <span class="keywd">elsif</span> vis >= 3.0 <span class="keywd">then</span>
      point(x, y, white);
      point(succ(x), y, dark_gray);
      point(pred(x), y, dark_gray);
      point(x, succ(y), dark_gray);
      point(x, pred(y), dark_gray);
    <span class="keywd">elsif</span> vis >= 2.5 <span class="keywd">then</span>
      point(x, y, white);
      point(succ(x), y, Gray);
      point(pred(x), y, Gray);
      point(x, succ(y), Gray);
      point(x, pred(y), Gray);
    <span class="keywd">elsif</span> vis >= 2.0 <span class="keywd">then</span>
      point(x, y, white);
      point(succ(x), y, light_gray);
      point(pred(x), y, light_gray);
      point(x, succ(y), light_gray);
      point(x, pred(y), light_gray);
    <span class="keywd">elsif</span> vis >= 1.5 <span class="keywd">then</span>
      line(pred(x), y, 2, 0, white);
      point(x, succ(y), white);
      point(x, pred(y), white);
    <span class="keywd">elsif</span> vis >= 1.0 <span class="keywd">then</span>
      line(pred(x), y, 2, 0, white);
      point(x, succ(y), white);
      point(x, pred(y), white);
      point(succ(x), succ(y), dark_gray);
      point(succ(x), pred(y), dark_gray);
      point(pred(x), succ(y), dark_gray);
      point(pred(x), pred(y), dark_gray);
    <span class="keywd">elsif</span> vis >= 0.5 <span class="keywd">then</span>
      line(pred(x), y, 2, 0, white);
      point(x, succ(y), white);
      point(x, pred(y), white);
      point(succ(x), succ(y), Gray);
      point(succ(x), pred(y), Gray);
      point(pred(x), succ(y), Gray);
      point(pred(x), pred(y), Gray);
    <span class="keywd">elsif</span> vis >= 0.0 <span class="keywd">then</span>
      line(pred(x), y, 2, 0, white);
      point(x, succ(y), white);
      point(x, pred(y), white);
      point(succ(x), succ(y), light_gray);
      point(succ(x), pred(y), light_gray);
      point(pred(x), succ(y), light_gray);
      point(pred(x), pred(y), light_gray);
    <span class="keywd">elsif</span> vis >= -0.5 <span class="keywd">then</span>
      rect (pred(x), pred(y), 3, 3, white);
    <span class="keywd">else</span>
      fcircle(x, y, 2, white);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: drawStars <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">equatorialCoordinateType</span>: equatorialCoordinate <span class="keywd">is</span> equatorialCoordinateType.value;
    <span class="keywd">var</span> <span class="type">float</span>: hourAngle <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">horizontalCoordinateType</span>: horizontalCoordinate <span class="keywd">is</span> horizontalCoordinateType.value;
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> length(stars) <span class="keywd">downto</span> 1 <span class="keywd">do</span>
      equatorialCoordinate.rightAscension := stars[index].rightAscension;
      equatorialCoordinate.declination := stars[index].declination;
      hourAngle := calculateHourAngle(equatorialCoordinate, localSiderealTime);
      horizontalCoordinate := calculateHorizontalCoordinates(equatorialCoordinate,
          posAtEarth, hourAngle);
      <span class="keywd">if</span> horizontalCoordinate.altitude >= 0.0 <span class="keywd">then</span>
        xPos := panoramaXPos(horizontalCoordinate.azimuth);
        yPos := panoramaYPos(horizontalCoordinate.altitude);
        writePoint(xPos, yPos, stars[index].magnitude);
        <span class="keywd">if</span> xPos + round(sizePanorama) &lt; windowWidth <span class="keywd">then</span>
          writePoint(xPos + round(sizePanorama), yPos, stars[index].magnitude);
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> xPos - round(sizePanorama) >= 0 <span class="keywd">then</span>
          writePoint(xPos - round(sizePanorama), yPos, stars[index].magnitude);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: locatePlanet (<span class="op">in</span> <span class="type">integer</span>: planetNumber) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">text</span>: win <span class="keywd">is</span> STD_NULL;
    <span class="keywd">var</span> <span class="type">heliocentricPlanetType</span>: planet <span class="keywd">is</span> heliocentricPlanetType.value;
    <span class="keywd">var</span> <span class="type">heliocentricPlanetType</span>: earth <span class="keywd">is</span> heliocentricPlanetType.value;
    <span class="keywd">var</span> <span class="type">geocentricPlanetType</span>: geocentricPos <span class="keywd">is</span> geocentricPlanetType.value;
    <span class="keywd">var</span> <span class="type">float</span>: azimuthOfRise <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: azimuthOfSet <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: localSiderealTime_Rise <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: localSiderealTime_Set  <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: localCivilTime_Rise <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: localCivilTime_Set  <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: phase <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: distanceFromEarth <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: diameter <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">float</span>: magnitude <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    clear(curr_win, black);
    showTime;
    planet := locatePositionOfPlanetInItsOrbitalPlane(orbitDescr[planetNumber]);

    win := openWindow(scr, 2, 3, 7, 51);
    setPos(win, 1, 1);
    write  (win, <span class="stri">"                          "</span>);
    writeln(win, orbitDescr[planetNumber].name);
    writeln(win, <span class="stri">"mean longitude       = "</span> &lt;&amp; angleAsDegrees(planet.meanLongitude));
    writeln(win, <span class="stri">"mean anomaly         = "</span> &lt;&amp; angleAsDegrees(planet.meanAnomaly));
    writeln(win, <span class="stri">"true anomaly         = "</span> &lt;&amp; angleAsDegrees(planet.trueAnomaly));
    writeln(win, <span class="stri">"heliocentric long    = "</span> &lt;&amp; angleAsDegrees(planet.heliocentricLongitude));
    writeln(win, <span class="stri">"radius vector        = "</span> &lt;&amp; planet.radiusVector <span class="op">digits</span> 3 <span class="op">lpad</span> 8 &lt;&amp; <span class="stri">" AU"</span>);
    write  (win, <span class="stri">"helio ecliptic lat.  = "</span> &lt;&amp; angleAsDegrees(planet.heliocentricEclipticLatitude));

    <span class="keywd">if</span> planetNumber &lt;> 3 <span class="keywd">then</span>

      earth := locatePositionOfPlanetInItsOrbitalPlane(orbitDescr[3]);
      win := openWindow(scr, 2, 40, 7, 14);
      setPos(win, 1, 1);
      writeln(win, <span class="stri">"     Earth"</span>);
      writeln(win, angleAsDegrees(earth.meanLongitude));
      writeln(win, angleAsDegrees(earth.meanAnomaly));
      writeln(win, angleAsDegrees(earth.trueAnomaly));
      writeln(win, angleAsDegrees(earth.heliocentricLongitude));
      writeln(win, earth.radiusVector <span class="op">digits</span> 3 <span class="op">lpad</span> 8 &lt;&amp; <span class="stri">" AU"</span>);
      write  (win, angleAsDegrees(0.0));


      <span class="comment">(* Project Position of Planet onto plane of ecliptic *)</span>
      ProjectPlanetOntoEclipticalPlane(planet, orbitDescr[planetNumber]);

      win := openWindow(scr, 11, 12, 2, 68);
      setPos(win, 1, 1);
      write(win, <span class="stri">"Projected Longitude  = "</span>);
      write(win, angleAsDegrees(planet.projectedHeliocentricLongitude));
      writeln(win);
      write(win, <span class="stri">"Projected Radius     = "</span>);
      write(win, planet.projectedRadius <span class="op">digits</span> 3 <span class="op">lpad</span> 8);
      write(win, <span class="stri">" AU"</span>);


      <span class="comment">(* Calculate Ecliptical Coordinates *)</span>
      geocentricPos.eclipticalCoordinate := calculateEclipticalCoordinates(planet, earth);

      win := openWindow(scr, 19, 3, 5, 22);
      setPos(win, 1, 1);
      writeln(win, <span class="stri">"      ECLIPTIC"</span>);
      writeln(win);
      writeln(win, <span class="stri">" Long = "</span> &lt;&amp; angleAsDegrees(
          geocentricPos.eclipticalCoordinate.geocentricEclipticLongitude));
      write(win, <span class="stri">" Lat  = "</span> &lt;&amp; angleAsDegrees(
          geocentricPos.eclipticalCoordinate.geocentricLatitude));


      <span class="comment">(* Calculate Equatorial Coordinates *)</span>
      geocentricPos.equatorialCoordinate := calculateEquatorialCoordinates(
          geocentricPos.eclipticalCoordinate);

      win := openWindow(scr, 19, 29, 5, 23);
      setPos(win, 1, 1);
      writeln(win, <span class="stri">"     EQUATORIAL"</span>);
      writeln(win);
      write(win, <span class="stri">" RA  = "</span>);
      <span class="keywd">if</span> displayRAinDegrees <span class="keywd">then</span>
        writeln(win, angleAsDegrees(geocentricPos.equatorialCoordinate.rightAscension * 15.0));
      <span class="keywd">else</span>
        writeln(win, angleAsHours(geocentricPos.equatorialCoordinate.rightAscension * 15.0));
      <span class="keywd">end</span> <span class="keywd">if</span>;
      writeln(win, <span class="stri">" DEC = "</span> &lt;&amp; angleAsDegrees(geocentricPos.equatorialCoordinate.declination));


      geocentricPos.hourAngle := calculateHourAngle(geocentricPos.equatorialCoordinate, localSiderealTime);
      write(win, <span class="stri">" HA  = "</span>);
      <span class="keywd">if</span> displayHourAngleInDegrees <span class="keywd">then</span>
        write(win, angleAsDegrees(geocentricPos.hourAngle * 15.0));
      <span class="keywd">else</span>
        write(win, angleAsHours(geocentricPos.hourAngle * 15.0));
      <span class="keywd">end</span> <span class="keywd">if</span>;


      <span class="comment">(* Calculate Horizontal Coordinates *)</span>
      geocentricPos.horizontalCoordinate := calculateHorizontalCoordinates(
          geocentricPos.equatorialCoordinate,
          posAtEarth, geocentricPos.hourAngle);

      win := openWindow(scr, 19, 56, 5, 23);
      setPos(win, 1, 1);
      writeln(win, <span class="stri">"      HORIZONTAL"</span>);
      writeln(win);
      writeln(win, <span class="stri">" Alt  = "</span> &lt;&amp; angleAsDegrees(geocentricPos.horizontalCoordinate.altitude));
      write(win, <span class="stri">" Azim = "</span> &lt;&amp; angleAsDegrees(geocentricPos.horizontalCoordinate.azimuth));


      <span class="comment">(* Calculate Time and Position of Rise and Set *)</span>

      win := openWindow(scr, 15, 4, 2, 50);
      setPos(win, 1, 1);
      azimuthOfRise := sinD(geocentricPos.equatorialCoordinate.declination) / cosD(posAtEarth.latitude);
      <span class="keywd">if</span> azimuthOfRise &lt; -1.0 <span class="op">or</span> azimuthOfRise > 1.0 <span class="keywd">then</span>
        <span class="keywd">if</span> geocentricPos.horizontalCoordinate.altitude &lt; 0.0 <span class="keywd">then</span>
          writeln(win, <span class="stri">"never rises above horizon"</span>);
        <span class="keywd">else</span>
          writeln(win, <span class="stri">"never sets below horizon"</span>);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        azimuthOfRise := acosD(azimuthOfRise);
        azimuthOfSet := 360.0 - azimuthOfRise;
        localSiderealTime_Rise := 24.0 + geocentricPos.equatorialCoordinate.rightAscension -
            (acosD(-tanD(posAtEarth.latitude) *
            tanD(geocentricPos.equatorialCoordinate.declination))) / 15.0;
        <span class="keywd">if</span> localSiderealTime_Rise > 24.0 <span class="keywd">then</span>
          localSiderealTime_Rise := localSiderealTime_Rise - 24.0;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        localSiderealTime_Set := geocentricPos.equatorialCoordinate.rightAscension +
            (acosD(-tanD(posAtEarth.latitude) *
            tanD(geocentricPos.equatorialCoordinate.declination))) / 15.0;
        <span class="keywd">if</span> localSiderealTime_Set > 24.0 <span class="keywd">then</span>
          localSiderealTime_Set := localSiderealTime_Set - 24.0;
        <span class="keywd">end</span> <span class="keywd">if</span>;

        localCivilTime_Set := localSiderealToCivilTime(localSiderealTime_Set,
            posAtEarth.longitude, aTime);
        <span class="keywd">if</span> localCivilTime_Set &lt; 0.0 <span class="keywd">then</span>
          localCivilTime_Set := localCivilTime_Set + 24.0;
        <span class="keywd">end</span> <span class="keywd">if</span>;

        localCivilTime_Rise := localSiderealToCivilTime(localSiderealTime_Rise,
            posAtEarth.longitude, aTime);
        <span class="keywd">if</span> localCivilTime_Rise &lt; 0.0 <span class="keywd">then</span>
          localCivilTime_Rise := localCivilTime_Rise + 24.0;
        <span class="keywd">end</span> <span class="keywd">if</span>;

        write(win, <span class="stri">"Rises at "</span>);
        write(win, trunc(localCivilTime_Rise) <span class="op">lpad</span> 2 &lt;&amp; <span class="stri">":"</span> &lt;&amp;
            minutes(localCivilTime_Rise) <span class="op">lpad</span> 2 &lt;&amp; <span class="stri">" local time"</span>);
        write(win, <span class="stri">"  Azimuth "</span>);
        write(win, angleAsDegrees(azimuthOfRise));
        writeln(win);
        write(win, <span class="stri">"Sets at  "</span>);
        write(win, trunc(localCivilTime_Set) <span class="op">lpad</span> 2 &lt;&amp; <span class="stri">":"</span> &lt;&amp;
            minutes(localCivilTime_Set) <span class="op">lpad</span> 2 &lt;&amp; <span class="stri">" local time"</span>);
        write(win, <span class="stri">"  Azimuth "</span>);
        write(win, angleAsDegrees(azimuthOfSet));

        line(panoramaXPos(azimuthOfRise), panoramaHorizont - 4, 0, 4, light_red);
        line(panoramaXPos(azimuthOfSet), panoramaHorizont - 4, 0, 4, light_red);
      <span class="keywd">end</span> <span class="keywd">if</span>;


      <span class="comment">(* Calculate Phase, Distance, Diameter, Magnitude *)</span>

      win := openWindow(scr, 12, 57, 5, 23);
      setPos(win, 1, 1);

      phase := (1.0 + cosD(geocentricPos.eclipticalCoordinate.geocentricEclipticLongitude -
          planet.heliocentricLongitude)) / 2.0;
      write(win, <span class="stri">"Phase     = "</span>);
      write(win, 100.0 * phase <span class="op">digits</span> 2 <span class="op">lpad</span> 6);
      writeln(win, <span class="stri">"%"</span>);
      distanceFromEarth := sqrt(earth.radiusVector * earth.radiusVector
                             + planet.radiusVector * planet.radiusVector
                             - 2.0 * earth.radiusVector * planet.radiusVector *
                             cosD(planet.heliocentricLongitude -
                             earth.heliocentricLongitude));
      write(win, <span class="stri">"Distance  = "</span>);
      write(win, distanceFromEarth <span class="op">digits</span> 2 <span class="op">lpad</span> 6);
      writeln(win, <span class="stri">" AU"</span>);

      diameter := orbitDescr[planetNumber].size / distanceFromEarth;
      write(win, <span class="stri">"Diameter  = "</span>);
      write(win, diameter <span class="op">digits</span> 2 <span class="op">lpad</span> 6);
      writeln(win, <span class="stri">"\""</span>);

      write(win, <span class="stri">"magnitude = "</span>);
      <span class="keywd">if</span> distanceFromEarth * planet.radiusVector /
                   orbitDescr[planetNumber].brightness * sqrt(phase) &lt;> 0.0 <span class="keywd">then</span>
        magnitude := 2.17147 * log(distanceFromEarth * planet.radiusVector /
                     orbitDescr[planetNumber].brightness * sqrt(phase)) - 26.7;
        write(win, magnitude <span class="op">digits</span> 2 <span class="op">lpad</span> 6);
      <span class="keywd">else</span>
        write(win, <span class="stri">"*****"</span> <span class="op">lpad</span> 6);
      <span class="keywd">end</span> <span class="keywd">if</span>;

      drawHorizont;
      drawStars;
      <span class="keywd">if</span> geocentricPos.horizontalCoordinate.altitude >= 0.0 <span class="keywd">then</span>
        fcircle(panoramaXPos(geocentricPos.horizontalCoordinate.azimuth),
            panoramaYPos(geocentricPos.horizontalCoordinate.altitude), 2, light_cyan);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      drawSun(earth);
    <span class="keywd">else</span>
      drawHorizont;
      drawStars;
      drawAllPlanets(planet);
      drawSun(planet);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* locatePlanet *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: showName <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: mouseXPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: mouseYPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">equatorialCoordinateType</span>: equatorialCoordinate <span class="keywd">is</span> equatorialCoordinateType.value;
    <span class="keywd">var</span> <span class="type">float</span>: hourAngle <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <span class="type">horizontalCoordinateType</span>: horizontalCoordinate <span class="keywd">is</span> horizontalCoordinateType.value;
    <span class="keywd">var</span> <span class="type">heliocentricPlanetType</span>: sun <span class="keywd">is</span> heliocentricPlanetType.value;
    <span class="keywd">var</span> <span class="type">heliocentricPlanetType</span>: earth <span class="keywd">is</span> heliocentricPlanetType.value;
    <span class="keywd">var</span> <span class="type">heliocentricPlanetType</span>: planet <span class="keywd">is</span> heliocentricPlanetType.value;
    <span class="keywd">var</span> <span class="type">geocentricPlanetType</span>: geocentricPos <span class="keywd">is</span> geocentricPlanetType.value;
    <span class="keywd">var</span> <span class="type">integer</span>: xPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: yPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: delta <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: minDelta <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: selectedStar <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: selectedPlanet <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">string</span>: name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    mouseXPos := clickedXPos(KEYBOARD);
    mouseYPos := clickedYPos(KEYBOARD);
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length(stars) <span class="keywd">do</span>
      equatorialCoordinate.rightAscension := stars[index].rightAscension;
      equatorialCoordinate.declination := stars[index].declination;
      hourAngle := calculateHourAngle(equatorialCoordinate, localSiderealTime);
      horizontalCoordinate := calculateHorizontalCoordinates(equatorialCoordinate,
          posAtEarth, hourAngle);
      <span class="keywd">if</span> horizontalCoordinate.altitude >= 0.0 <span class="keywd">then</span>
        xPos := panoramaXPos(horizontalCoordinate.azimuth);
        yPos := panoramaYPos(horizontalCoordinate.altitude);
        delta := (mouseXPos - xPos) ** 2 + (mouseYPos - yPos) ** 2;
        <span class="keywd">if</span> selectedStar = 0 <span class="op">or</span> delta &lt; minDelta <span class="keywd">then</span>
          selectedStar := index;
          minDelta := delta;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> xPos + round(sizePanorama) &lt; windowWidth <span class="keywd">then</span>
          delta := (mouseXPos - xPos - round(sizePanorama)) ** 2 + (mouseYPos - yPos) ** 2;
          <span class="keywd">if</span> selectedStar = 0 <span class="op">or</span> delta &lt; minDelta <span class="keywd">then</span>
            selectedStar := index;
            minDelta := delta;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">if</span> xPos - round(sizePanorama) >= 0 <span class="keywd">then</span>
          delta := (mouseXPos - xPos + round(sizePanorama)) ** 2 + (mouseYPos - yPos) ** 2;
          <span class="keywd">if</span> selectedStar = 0 <span class="op">or</span> delta &lt; minDelta <span class="keywd">then</span>
            selectedStar := index;
            minDelta := delta;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    earth := locatePositionOfPlanetInItsOrbitalPlane(orbitDescr[3]);
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 9 <span class="keywd">do</span>
      <span class="keywd">if</span> index &lt;> 3 <span class="keywd">then</span>
        planet := locatePositionOfPlanetInItsOrbitalPlane(orbitDescr[index]);
        ProjectPlanetOntoEclipticalPlane(planet, orbitDescr[index]);
        geocentricPos := genGeocentricPos(planet, earth, localSiderealTime, posAtEarth);
        <span class="keywd">if</span> geocentricPos.horizontalCoordinate.altitude >= 0.0 <span class="keywd">then</span>
          xPos := panoramaXPos(geocentricPos.horizontalCoordinate.azimuth);
          yPos := panoramaYPos(geocentricPos.horizontalCoordinate.altitude);
          delta := (mouseXPos - xPos) ** 2 + (mouseYPos - yPos) ** 2;
          <span class="keywd">if</span> delta &lt;= minDelta <span class="keywd">then</span>
            selectedStar := 0;
            selectedPlanet := index;
            minDelta := delta;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">for</span>;
    geocentricPos := genGeocentricPos(sun, earth, localSiderealTime, posAtEarth);
    <span class="keywd">if</span> geocentricPos.horizontalCoordinate.altitude >= 0.0 <span class="keywd">then</span>
      xPos := panoramaXPos(geocentricPos.horizontalCoordinate.azimuth);
      yPos := panoramaYPos(geocentricPos.horizontalCoordinate.altitude);
      delta := (mouseXPos - xPos) ** 2 + (mouseYPos - yPos) ** 2;
      <span class="keywd">if</span> delta &lt;= minDelta <span class="keywd">then</span>
        selectedStar := 0;
        selectedPlanet := 0;
        minDelta := delta;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> selectedStar &lt;> 0 <span class="keywd">then</span>
      equatorialCoordinate.rightAscension := stars[selectedStar].rightAscension;
      equatorialCoordinate.declination := stars[selectedStar].declination;
      hourAngle := calculateHourAngle(equatorialCoordinate, localSiderealTime);
      horizontalCoordinate := calculateHorizontalCoordinates(equatorialCoordinate,
          posAtEarth, hourAngle);
      xPos := panoramaXPos(horizontalCoordinate.azimuth);
      yPos := panoramaYPos(horizontalCoordinate.altitude);
      name := stars[selectedStar].name;
    <span class="keywd">elsif</span> selectedPlanet &lt;> 0 <span class="keywd">then</span>
      planet := locatePositionOfPlanetInItsOrbitalPlane(orbitDescr[selectedPlanet]);
      ProjectPlanetOntoEclipticalPlane(planet, orbitDescr[selectedPlanet]);
      geocentricPos := genGeocentricPos(planet, earth, localSiderealTime, posAtEarth);
      xPos := panoramaXPos(geocentricPos.horizontalCoordinate.azimuth);
      yPos := panoramaYPos(geocentricPos.horizontalCoordinate.altitude);
      name := orbitDescr[selectedPlanet].name;
    <span class="keywd">else</span>
      geocentricPos := genGeocentricPos(sun, earth, localSiderealTime, posAtEarth);
      xPos := panoramaXPos(geocentricPos.horizontalCoordinate.azimuth);
      yPos := panoramaYPos(geocentricPos.horizontalCoordinate.altitude);
      name := <span class="stri">"Sun"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> minDelta &lt;= 900 <span class="keywd">then</span>
      setPosXY(scr, xPos + 4, yPos);
      write(name);
      <span class="keywd">if</span> xPos + round(sizePanorama) &lt; windowWidth <span class="keywd">then</span>
        setPosXY(scr, xPos + round(sizePanorama) + 4, yPos);
        write(name);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> xPos - round(sizePanorama) >= 0 <span class="keywd">then</span>
        setPosXY(scr, xPos - round(sizePanorama) + 4, yPos);
        write(name);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: initOrbitDescr <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    orbitDescr[1].name :=<span class="stri">"Mercury"</span>;
    orbitDescr[1].orbitalPeriod := 87.96934; <span class="comment"># 0.2408469 years</span>
    orbitDescr[1].meanLongitudeAtEpoch := 252.25032350;
    orbitDescr[1].longitudeOfPerihelion := 77.45779628;
    orbitDescr[1].longitudeOfPerihelionPerCentury := 0.16047689;
    orbitDescr[1].eccentricity := 0.20563593;
    orbitDescr[1].eccentricityPerCentury := 0.00001906;
    orbitDescr[1].axis := 0.38709927;
    orbitDescr[1].axisPerCentury := 0.00000037;
    orbitDescr[1].inclination := 7.00497902;
    orbitDescr[1].longitudeOfTheAscendingNode := 48.33167;
    orbitDescr[1].argumentOfThePerihelion := 29.12478;
    orbitDescr[1].size := 6.74;
    orbitDescr[1].brightness := 0.000001918;

    orbitDescr[2].name :=<span class="stri">"Venus"</span>;
    orbitDescr[2].orbitalPeriod := 224.70069; <span class="comment"># 0.6151970 years</span>
    orbitDescr[2].meanLongitudeAtEpoch := 181.97909950;
    orbitDescr[2].longitudeOfPerihelion := 131.60246718;
    orbitDescr[2].longitudeOfPerihelionPerCentury := 0.00268329;
    orbitDescr[2].eccentricity := 0.00677672;
    orbitDescr[2].eccentricityPerCentury := -0.00004107;
    orbitDescr[2].axis := 0.72333566;
    orbitDescr[2].axisPerCentury := 0.00000390;
    orbitDescr[2].inclination := 3.39467605;
    orbitDescr[2].longitudeOfTheAscendingNode := 76.68069;
    orbitDescr[2].argumentOfThePerihelion := 54.85229;
    orbitDescr[2].size := 16.92;
    orbitDescr[2].brightness := 0.00001721;

    orbitDescr[3].name :=<span class="stri">"Earth"</span>;
    orbitDescr[3].orbitalPeriod := 365.256366; <span class="comment"># 1.0000175 years</span>
    orbitDescr[3].meanLongitudeAtEpoch := 100.46457166;
    orbitDescr[3].longitudeOfPerihelion := 102.93768193;
    orbitDescr[3].longitudeOfPerihelionPerCentury := 0.32327364;
    orbitDescr[3].eccentricity := 0.01671123;
    orbitDescr[3].eccentricityPerCentury := -0.00004392;
    orbitDescr[3].axis := 1.00000261;
    orbitDescr[3].axisPerCentury := 0.00000562;
    orbitDescr[3].inclination := 0.00001531;
    orbitDescr[3].longitudeOfTheAscendingNode := 348.73936;
    orbitDescr[3].argumentOfThePerihelion := 114.20783;
    orbitDescr[3].size := 17.0;
    orbitDescr[3].brightness := 0.0;

    orbitDescr[4].name :=<span class="stri">"Mars"</span>;
    orbitDescr[4].orbitalPeriod := 686.9600; <span class="comment"># 1.8808 years</span>
    orbitDescr[4].meanLongitudeAtEpoch := 355.44656795;
    orbitDescr[4].longitudeOfPerihelion := 336.05637041;
    orbitDescr[4].longitudeOfPerihelionPerCentury := 0.44441088;
    orbitDescr[4].eccentricity := 0.09339410;
    orbitDescr[4].eccentricityPerCentury := 0.00007882;
    orbitDescr[4].axis := 1.52371034;
    orbitDescr[4].axisPerCentury := 0.00001847;
    orbitDescr[4].inclination := 1.84969142;
    orbitDescr[4].longitudeOfTheAscendingNode := 49.57854;
    orbitDescr[4].argumentOfThePerihelion := 286.46230;
    orbitDescr[4].size := 9.36;
    orbitDescr[4].brightness := 0.00000454;

    orbitDescr[5].name :=<span class="stri">"Jupiter"</span>;
    orbitDescr[5].orbitalPeriod := 4333.2867; <span class="comment"># 11.86 years</span>
    orbitDescr[5].meanLongitudeAtEpoch := 34.39644051;
    orbitDescr[5].longitudeOfPerihelion := 14.72847983;
    orbitDescr[5].longitudeOfPerihelionPerCentury := 0.21252668;
    orbitDescr[5].eccentricity := 0.04838624;
    orbitDescr[5].eccentricityPerCentury := -0.00013253;
    orbitDescr[5].axis := 5.20288700;
    orbitDescr[5].axisPerCentury := -0.00011607;
    orbitDescr[5].inclination := 1.30439695;
    orbitDescr[5].longitudeOfTheAscendingNode := 100.55615;
    orbitDescr[5].argumentOfThePerihelion := 274.19770;
    orbitDescr[5].size := 196.74;
    orbitDescr[5].brightness := 0.0001994;

    orbitDescr[6].name :=<span class="stri">"Saturn"</span>;
    orbitDescr[6].orbitalPeriod := 10756.1995; <span class="comment"># 29.45 years</span>
    orbitDescr[6].meanLongitudeAtEpoch := 49.95424423;
    orbitDescr[6].longitudeOfPerihelion := 92.59887831;
    orbitDescr[6].longitudeOfPerihelionPerCentury := -0.41897216;
    orbitDescr[6].eccentricity := 0.05386179;
    orbitDescr[6].eccentricityPerCentury := -0.00050991;
    orbitDescr[6].axis := 9.53667594;
    orbitDescr[6].axisPerCentury := -0.00125060;
    orbitDescr[6].inclination := 2.48599187;
    orbitDescr[6].longitudeOfTheAscendingNode := 113.71504;
    orbitDescr[6].argumentOfThePerihelion := 338.71690;
    orbitDescr[6].size := 165.60;
    orbitDescr[6].brightness := 0.0001740;

    orbitDescr[7].name :=<span class="stri">"Uranus"</span>;
    orbitDescr[7].orbitalPeriod := 30707.4896; <span class="comment"># 84.07 years</span>
    orbitDescr[7].meanLongitudeAtEpoch := 313.23810451;
    orbitDescr[7].longitudeOfPerihelion := 170.95427630;
    orbitDescr[7].longitudeOfPerihelionPerCentury := 0.40805281;
    orbitDescr[7].eccentricity := 0.04725744;
    orbitDescr[7].eccentricityPerCentury := -0.00004397;
    orbitDescr[7].axis := 19.18916464;
    orbitDescr[7].axisPerCentury := -0.00196176;
    orbitDescr[7].inclination := 0.77263783;
    orbitDescr[7].longitudeOfTheAscendingNode := 74.22988;
    orbitDescr[7].argumentOfThePerihelion := 96.73436;
    orbitDescr[7].size := 65.80;
    orbitDescr[7].brightness := 0.00007768;

    orbitDescr[8].name :=<span class="stri">"Neptune"</span>;
    orbitDescr[8].orbitalPeriod := 60223.3528; <span class="comment"># 164.88 years</span>
    orbitDescr[8].meanLongitudeAtEpoch := 304.87997031;
    orbitDescr[8].longitudeOfPerihelion := 44.96476227;
    orbitDescr[8].longitudeOfPerihelionPerCentury := -0.32241464;
    orbitDescr[8].eccentricity := 0.00859048;
    orbitDescr[8].eccentricityPerCentury := 0.00005105;
    orbitDescr[8].axis := 30.06992276;
    orbitDescr[8].axisPerCentury := 0.00026291;
    orbitDescr[8].inclination := 1.77004347;
    orbitDescr[8].longitudeOfTheAscendingNode := 131.72169;
    orbitDescr[8].argumentOfThePerihelion := 273.24966;
    orbitDescr[8].size := 62.20;
    orbitDescr[8].brightness := 0.00007597;

    orbitDescr[9].name :=<span class="stri">"Pluto"</span>;
    orbitDescr[9].orbitalPeriod := 90613.3055; <span class="comment"># 248.09 years</span>
    orbitDescr[9].meanLongitudeAtEpoch := 238.92903833;
    orbitDescr[9].longitudeOfPerihelion := 224.06891629;
    orbitDescr[9].longitudeOfPerihelionPerCentury := -0.04062942;
    orbitDescr[9].eccentricity := 0.24882730;
    orbitDescr[9].eccentricityPerCentury := 0.00005170;
    orbitDescr[9].axis := 39.48211675;
    orbitDescr[9].axisPerCentury := -0.00031596;
    orbitDescr[9].inclination := 17.14001206;
    orbitDescr[9].longitudeOfTheAscendingNode := 110.30347;
    orbitDescr[9].argumentOfThePerihelion := 113.76329;
    orbitDescr[9].size := 8.2;
    orbitDescr[9].brightness := 0.000004073;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment">(* initOrbitDescr *)</span>


<span class="keywd">const</span> <span class="type">proc</span>: main <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">char</span>: command <span class="keywd">is</span> <span class="stri">'M'</span>;
    <span class="keywd">var</span> <span class="type">char</span>: old_command <span class="keywd">is</span> <span class="stri">'M'</span>;
  <span class="keywd">begin</span>
    screen(windowWidth, windowHeight);
    selectInput(curr_win, KEY_CLOSE, TRUE);
    clear(curr_win, black);
    KEYBOARD := GRAPH_KEYBOARD;
    scr := open(curr_win);
    IN := openEcho(KEYBOARD, scr);
    IN := openLine(IN);
    OUT := scr;
    aTime := truncToSecond(time(NOW));
    initOrbitDescr;

    showMenu;
    <span class="keywd">repeat</span>
      ch := getc(KEYBOARD);
      <span class="keywd">if</span> ch = KEY_RIGHT <span class="keywd">then</span>
        <span class="keywd">if</span> currTimeChange &lt; 7 <span class="keywd">then</span>
          incr(currTimeChange);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> ch = KEY_LEFT <span class="keywd">then</span>
        <span class="keywd">if</span> currTimeChange > 1 <span class="keywd">then</span>
          decr(currTimeChange);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">elsif</span> ch = KEY_UP <span class="keywd">then</span>
        <span class="keywd">case</span> currTimeChange <span class="keywd">of</span>
          <span class="keywd">when</span> {1}: aTime -:= 1 . YEARS;
          <span class="keywd">when</span> {2}: aTime -:= 1 . MONTHS;
          <span class="keywd">when</span> {3}: aTime -:= 1 . DAYS;
          <span class="keywd">when</span> {4}: aTime -:= 1 . HOURS;
          <span class="keywd">when</span> {5}: aTime -:= 1 . MINUTES;
          <span class="keywd">when</span> {6}: aTime -:= 1 . SECONDS;
          <span class="keywd">when</span> {7}: <span class="keywd">if</span> aTime.timeZone > -720 <span class="keywd">then</span>
                      aTime.timeZone -:= 60;
                    <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">elsif</span> ch = KEY_DOWN <span class="keywd">then</span>
        <span class="keywd">case</span> currTimeChange <span class="keywd">of</span>
          <span class="keywd">when</span> {1}: aTime +:= 1 . YEARS;
          <span class="keywd">when</span> {2}: aTime +:= 1 . MONTHS;
          <span class="keywd">when</span> {3}: aTime +:= 1 . DAYS;
          <span class="keywd">when</span> {4}: aTime +:= 1 . HOURS;
          <span class="keywd">when</span> {5}: aTime +:= 1 . MINUTES;
          <span class="keywd">when</span> {6}: aTime +:= 1 . SECONDS;
          <span class="keywd">when</span> {7}: <span class="keywd">if</span> aTime.timeZone &lt; 840 <span class="keywd">then</span>
                      aTime.timeZone +:= 60;
                    <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">case</span>;
      <span class="keywd">else</span>
        old_command := command;
        command := ch;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">case</span> command <span class="keywd">of</span>
        <span class="keywd">when</span> {<span class="stri">'M'</span>, <span class="stri">'m'</span>}: showMenu;
        <span class="keywd">when</span> {<span class="stri">'I'</span>, <span class="stri">'i'</span>}: plotInnerPlanets;
        <span class="keywd">when</span> {<span class="stri">'O'</span>, <span class="stri">'o'</span>}: plotOuterPlanets;
        <span class="keywd">when</span> {<span class="stri">'D'</span>, <span class="stri">'d'</span>}: changeDateTime;
                         command := <span class="stri">'M'</span>;
        <span class="keywd">when</span> {<span class="stri">'L'</span>, <span class="stri">'l'</span>}: changeLongLat;
                         command := <span class="stri">'M'</span>;
        <span class="keywd">when</span> {<span class="stri">'S'</span>, <span class="stri">'s'</span>}: setup;
        <span class="keywd">when</span> {<span class="stri">'1'</span>, <span class="stri">'2'</span>, <span class="stri">'3'</span>, <span class="stri">'4'</span>, <span class="stri">'5'</span>, <span class="stri">'6'</span>, <span class="stri">'7'</span>, <span class="stri">'8'</span>, <span class="stri">'9'</span>}:
          locatePlanet(ord(command) - ord(<span class="stri">'0'</span>));
        <span class="keywd">when</span> {KEY_MOUSE1}:
          <span class="keywd">if</span> old_command <span class="op">in</span> {<span class="stri">'1'</span>, <span class="stri">'2'</span>, <span class="stri">'3'</span>, <span class="stri">'4'</span>, <span class="stri">'5'</span>, <span class="stri">'6'</span>, <span class="stri">'7'</span>, <span class="stri">'8'</span>, <span class="stri">'9'</span>} <span class="keywd">then</span>
            showName;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          command := old_command;
        <span class="keywd">otherwise</span>:
          command := old_command;
      <span class="keywd">end</span> <span class="keywd">case</span>;
      setPos(scr, 58, 1);
      write(scr, <span class="stri">"(M)enu (I)nner (O)uter (D)ate (L)ong (Q)uit  (1-9) Planet"</span>);
    <span class="keywd">until</span> ch = <span class="stri">'Q'</span> <span class="op">or</span> ch = <span class="stri">'q'</span> <span class="op">or</span> ch = KEY_CLOSE;
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
