<html>
<head>
<title>
Seed7 Program listing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body>
<pre class="indent">

<span class="comment">(********************************************************************)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  time.s7i      Time and date library                             *)</span>
<span class="comment">(*  Copyright (C) 1991 - 1994, 2005 - 2013 Thomas Mertes            *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  This file is part of the Seed7 Runtime Library.                 *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is free software; you can             *)</span>
<span class="comment">(*  redistribute it and/or modify it under the terms of the GNU     *)</span>
<span class="comment">(*  Lesser General Public License as published by the Free Software *)</span>
<span class="comment">(*  Foundation; either version 2.1 of the License, or (at your      *)</span>
<span class="comment">(*  option) any later version.                                      *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  The Seed7 Runtime Library is distributed in the hope that it    *)</span>
<span class="comment">(*  will be useful, but WITHOUT ANY WARRANTY; without even the      *)</span>
<span class="comment">(*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR *)</span>
<span class="comment">(*  PURPOSE.  See the GNU Lesser General Public License for more    *)</span>
<span class="comment">(*  details.                                                        *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(*  You should have received a copy of the GNU Lesser General       *)</span>
<span class="comment">(*  Public License along with this program; if not, write to the    *)</span>
<span class="comment">(*  Free Software Foundation, Inc., 51 Franklin Street,             *)</span>
<span class="comment">(*  Fifth Floor, Boston, MA  02110-1301, USA.                       *)</span>
<span class="comment">(*                                                                  *)</span>
<span class="comment">(********************************************************************)</span>


<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/enable_io.htm">enable_io.s7i</a>"</span>;


<span class="comment">(**
 *  Describes times and dates.
 *  For dates the proleptic Gregorian calendar is used (which assumes
 *  that the Gregorian calendar was even in effect at dates preceding
 *  its official introduction). This convention is used according to
 *  ISO 8601 which also defines that positive and negative years exist
 *  and that the year preceding 1 is 0. Time is measured in hours,
 *  minutes, seconds and micro seconds. Additionally information about
 *  the difference to UTC and a flag indicating daylight saving time
 *  is maintained also.
 *)</span>
<span class="keywd">const</span> <span class="type">type</span>: time <span class="keywd">is</span> new object <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">integer</span>: year <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: month <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: day <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <span class="type">integer</span>: hour <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: minute <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: second <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: micro_second <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: timeZone <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">boolean</span>: daylightSavingTime <span class="keywd">is</span> FALSE;
  <span class="keywd">end</span> <span class="keywd">struct</span>;


<span class="keywd">const</span> <span class="type">proc</span>: GET_TIME (<span class="keywd">inout</span> <span class="type">integer</span>: year, <span class="keywd">inout</span> <span class="type">integer</span>: month, <span class="keywd">inout</span> <span class="type">integer</span>: day,
    <span class="keywd">inout</span> <span class="type">integer</span>: hour, <span class="keywd">inout</span> <span class="type">integer</span>: minute, <span class="keywd">inout</span> <span class="type">integer</span>: second,
    <span class="keywd">inout</span> <span class="type">integer</span>: micro_second, <span class="keywd">inout</span> <span class="type">integer</span>: timeZone,
    <span class="keywd">inout</span> <span class="type">boolean</span>: daylightSavingTime)                           <span class="keywd">is</span> action <span class="stri">"TIM_NOW"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: AWAIT_TIME (<span class="op">in</span> <span class="type">integer</span>: year, <span class="op">in</span> <span class="type">integer</span>: month, <span class="op">in</span> <span class="type">integer</span>: day,
    <span class="op">in</span> <span class="type">integer</span>: hour, <span class="op">in</span> <span class="type">integer</span>: minute, <span class="op">in</span> <span class="type">integer</span>: second,
    <span class="op">in</span> <span class="type">integer</span>: micro_second, <span class="op">in</span> <span class="type">integer</span>: timeZone)              <span class="keywd">is</span> action <span class="stri">"TIM_AWAIT"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: FROM_TIMESTAMP (<span class="op">in</span> <span class="type">integer</span>: timestamp, <span class="keywd">inout</span> <span class="type">integer</span>: year,
    <span class="keywd">inout</span> <span class="type">integer</span>: month, <span class="keywd">inout</span> <span class="type">integer</span>: day, <span class="keywd">inout</span> <span class="type">integer</span>: hour,
    <span class="keywd">inout</span> <span class="type">integer</span>: minute, <span class="keywd">inout</span> <span class="type">integer</span>: second, <span class="keywd">inout</span> <span class="type">integer</span>: micro_second,
    <span class="keywd">inout</span> <span class="type">integer</span>: timeZone, <span class="keywd">inout</span> <span class="type">boolean</span>: daylightSavingTime)  <span class="keywd">is</span> action <span class="stri">"TIM_FROM_TIMESTAMP"</span>;

<span class="keywd">const</span> <span class="type">proc</span>: SET_LOCAL_TZ (<span class="op">in</span> <span class="type">integer</span>: year, <span class="op">in</span> <span class="type">integer</span>: month, <span class="op">in</span> <span class="type">integer</span>: day,
    <span class="op">in</span> <span class="type">integer</span>: hour, <span class="op">in</span> <span class="type">integer</span>: minute, <span class="op">in</span> <span class="type">integer</span>: second,
    <span class="keywd">inout</span> <span class="type">integer</span>: timeZone, <span class="keywd">inout</span> <span class="type">boolean</span>: daylightSavingTime)  <span class="keywd">is</span> action <span class="stri">"TIM_SET_LOCAL_TZ"</span>;


<span class="comment">(**
 *  Determine if a year is a leap year in the Gregorian calendar.
 *  @return TRUE if the year is a leap year, FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: isLeapYear (<span class="op">in</span> <span class="type">integer</span>: year) <span class="keywd">is</span>
  <span class="keywd">return</span> (year <span class="op">rem</span> 4 = 0 <span class="op">and</span> year <span class="op">rem</span> 100 &lt;> 0) <span class="op">or</span> year <span class="op">rem</span> 400 = 0;


<span class="comment">(**
 *  Determine the number of days in a 'year'.
 *  @return the number of days in the year.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: daysInYear (<span class="op">in</span> <span class="type">integer</span>: year) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: days <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isLeapYear(year) <span class="keywd">then</span>
      days := 366;
    <span class="keywd">else</span>
      days := 365;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the number of days in the 'month' of the given 'year'.
 *  @return the number of days in the month.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: daysInMonth (<span class="op">in</span> <span class="type">integer</span>: year, <span class="op">in</span> <span class="type">integer</span>: month) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: leng <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">set</span> <span class="type">of</span> <span class="type">integer</span>: monthsOfLength31 <span class="keywd">is</span> {1, 3, 5, 7, 8, 10, 12};
  <span class="keywd">begin</span>
    <span class="keywd">if</span> month <span class="op">in</span> monthsOfLength31 <span class="keywd">then</span>
      leng := 31;
    <span class="keywd">else</span>
      <span class="keywd">if</span> month = 2 <span class="keywd">then</span>
        <span class="keywd">if</span> isLeapYear(year) <span class="keywd">then</span>
          leng := 29;
        <span class="keywd">else</span>
          leng := 28;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">else</span>
        leng := 30;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the number of days in the month of a given date.
 *  @return the number of days in the month.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: daysInMonth (<span class="op">in</span> <span class="type">time</span>: date) <span class="keywd">is</span>
  <span class="keywd">return</span> daysInMonth(date.year, date.month);


<span class="comment">(**
 *  Convert a time to a string with ISO 8601 YYYY-MM-DD date format.
 *  @return the string result of the conversion.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: strDate (<span class="op">in</span> <span class="type">time</span>: aTime) <span class="keywd">is</span>
  <span class="keywd">return</span> aTime.year  <span class="op">lpad0</span> 4 &lt;&amp; <span class="stri">"-"</span> &lt;&amp;
         aTime.month <span class="op">lpad0</span> 2 &lt;&amp; <span class="stri">"-"</span> &lt;&amp;
         aTime.day   <span class="op">lpad0</span> 2;


<span class="comment">(**
 *  Convert a time to a string with ISO 8601 hh:mm:ss time format.
 *  @return the string result of the conversion.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: strTime (<span class="op">in</span> <span class="type">time</span>: aTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: isoTime <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    isoTime := aTime.hour   <span class="op">lpad0</span> 2 &lt;&amp; <span class="stri">":"</span> &lt;&amp;
               aTime.minute <span class="op">lpad0</span> 2 &lt;&amp; <span class="stri">":"</span> &lt;&amp;
               aTime.second <span class="op">lpad0</span> 2;
    <span class="keywd">if</span> aTime.micro_second &lt;> 0 <span class="keywd">then</span>
      isoTime &amp;:= <span class="stri">"."</span> &lt;&amp; aTime.micro_second <span class="op">lpad0</span> 6;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: strTimeZone (<span class="op">in</span> <span class="type">time</span>: aTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: timeZone <span class="keywd">is</span> <span class="stri">"UTC"</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> aTime.timeZone &lt;> 0 <span class="keywd">then</span>
      <span class="keywd">if</span> aTime.timeZone > 0 <span class="keywd">then</span>
        timeZone &amp;:= <span class="stri">"+"</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      timeZone &amp;:= str(aTime.timeZone <span class="op">div</span> 60);
      <span class="keywd">if</span> aTime.timeZone <span class="op">rem</span> 60 &lt;> 0 <span class="keywd">then</span>
        timeZone &amp;:= <span class="stri">":"</span> &amp; str(abs(aTime.timeZone) <span class="op">rem</span> 60);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> aTime.daylightSavingTime <span class="keywd">then</span>
      timeZone &amp;:= <span class="stri">" (DST)"</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str_yyyy_mm_dd (<span class="op">in</span> <span class="type">time</span>: aTime, <span class="op">in</span> <span class="type">string</span>: delimiter) <span class="keywd">is</span>
  <span class="keywd">return</span> aTime.year  <span class="op">lpad0</span> 4 &lt;&amp; delimiter &lt;&amp;
         aTime.month <span class="op">lpad0</span> 2 &lt;&amp; delimiter &lt;&amp;
         aTime.day   <span class="op">lpad0</span> 2;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str_yy_mm_dd (<span class="op">in</span> <span class="type">time</span>: aTime, <span class="op">in</span> <span class="type">string</span>: delimiter) <span class="keywd">is</span>
  <span class="keywd">return</span> aTime.year <span class="op">rem</span> 100 <span class="op">lpad0</span> 2 &lt;&amp; delimiter &lt;&amp;
         aTime.month        <span class="op">lpad0</span> 2 &lt;&amp; delimiter &lt;&amp;
         aTime.day          <span class="op">lpad0</span> 2;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str_mm_dd_yyyy (<span class="op">in</span> <span class="type">time</span>: aTime, <span class="op">in</span> <span class="type">string</span>: delimiter) <span class="keywd">is</span>
  <span class="keywd">return</span> aTime.month <span class="op">lpad0</span> 2 &lt;&amp; delimiter &lt;&amp;
         aTime.day   <span class="op">lpad0</span> 2 &lt;&amp; delimiter &lt;&amp;
         aTime.year  <span class="op">lpad0</span> 4;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str_mm_dd_yy (<span class="op">in</span> <span class="type">time</span>: aTime, <span class="op">in</span> <span class="type">string</span>: delimiter) <span class="keywd">is</span>
  <span class="keywd">return</span> aTime.month        <span class="op">lpad0</span> 2 &lt;&amp; delimiter &lt;&amp;
         aTime.day          <span class="op">lpad0</span> 2 &lt;&amp; delimiter &lt;&amp;
         aTime.year <span class="op">rem</span> 100 <span class="op">lpad0</span> 2;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str_dd_mm_yyyy (<span class="op">in</span> <span class="type">time</span>: aTime, <span class="op">in</span> <span class="type">string</span>: delimiter) <span class="keywd">is</span>
  <span class="keywd">return</span> aTime.day   <span class="op">lpad0</span> 2 &lt;&amp; delimiter &lt;&amp;
         aTime.month <span class="op">lpad0</span> 2 &lt;&amp; delimiter &lt;&amp;
         aTime.year  <span class="op">lpad0</span> 4;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str_dd_mm_yy (<span class="op">in</span> <span class="type">time</span>: aTime, <span class="op">in</span> <span class="type">string</span>: delimiter) <span class="keywd">is</span>
  <span class="keywd">return</span> aTime.day   <span class="op">lpad0</span> 2 &lt;&amp; delimiter &lt;&amp;
         aTime.month <span class="op">lpad0</span> 2 &lt;&amp; delimiter &lt;&amp;
         aTime.year  <span class="op">rem</span> 100 <span class="op">lpad0</span> 2;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str_d_m_yyyy (<span class="op">in</span> <span class="type">time</span>: aTime, <span class="op">in</span> <span class="type">string</span>: delimiter) <span class="keywd">is</span>
  <span class="keywd">return</span> str(aTime.day)   &lt;&amp; delimiter &lt;&amp;
         str(aTime.month) &lt;&amp; delimiter &lt;&amp;
         aTime.year  <span class="op">lpad0</span> 4;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str_d_m_yy (<span class="op">in</span> <span class="type">time</span>: aTime, <span class="op">in</span> <span class="type">string</span>: delimiter) <span class="keywd">is</span>
  <span class="keywd">return</span> str(aTime.day)   &lt;&amp; delimiter &lt;&amp;
         str(aTime.month) &lt;&amp; delimiter &lt;&amp;
         aTime.year  <span class="op">rem</span> 100 <span class="op">lpad0</span> 2;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str_hh_mm (<span class="op">in</span> <span class="type">time</span>: aTime, <span class="op">in</span> <span class="type">string</span>: delimiter) <span class="keywd">is</span>
  <span class="keywd">return</span> aTime.hour   <span class="op">lpad0</span> 2 &lt;&amp; delimiter &lt;&amp;
         aTime.minute <span class="op">lpad0</span> 2;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str_hh_mm_ss (<span class="op">in</span> <span class="type">time</span>: aTime, <span class="op">in</span> <span class="type">string</span>: delimiter) <span class="keywd">is</span>
  <span class="keywd">return</span> aTime.hour   <span class="op">lpad0</span> 2 &lt;&amp; delimiter &lt;&amp;
         aTime.minute <span class="op">lpad0</span> 2 &lt;&amp; delimiter &lt;&amp;
         aTime.second <span class="op">lpad0</span> 2;


<span class="comment">(**
 *  Convert a time to a string with ISO 8601 date and time format.
 *  The time is converted to the YYYY-MM-DD hh:mm:ss format.
 *  Microseconds, time zone and information about the daylight
 *  saving time are omitted.
 *  @return the string result of the conversion.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: strDateTime (<span class="op">in</span> <span class="type">time</span>: aTime) <span class="keywd">is</span>
  <span class="keywd">return</span> aTime.year   <span class="op">lpad0</span> 4 &lt;&amp; <span class="stri">"-"</span> &lt;&amp;
         aTime.month  <span class="op">lpad0</span> 2 &lt;&amp; <span class="stri">"-"</span> &lt;&amp;
         aTime.day    <span class="op">lpad0</span> 2 &lt;&amp; <span class="stri">" "</span> &lt;&amp;
         aTime.hour   <span class="op">lpad0</span> 2 &lt;&amp; <span class="stri">":"</span> &lt;&amp;
         aTime.minute <span class="op">lpad0</span> 2 &lt;&amp; <span class="stri">":"</span> &lt;&amp;
         aTime.second <span class="op">lpad0</span> 2;


<span class="comment">(**
 *  Convert a time to a string with ISO 8601 date and time format.
 *  The string has the format YYYY-MM-DD hh:mm:ss.uuuuuu followed by a
 *  time zone in the format UTC+n and (DST), if it is a daylight
 *  saving time. The microseconds (uuuuuu) are omitted, if they are
 *  zero. A time zone of UTC+0 is also omitted.
 *  @return the string result of the conversion.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: str (<span class="op">in</span> <span class="type">time</span>: aTime) <span class="keywd">is</span>
  <span class="keywd">return</span> strDate(aTime) &lt;&amp; <span class="stri">" "</span> &lt;&amp;
         strTime(aTime) &lt;&amp; <span class="stri">" "</span> &lt;&amp;
         strTimeZone(aTime);


<span class="comment">(**
 *  Convert a time to a time literal.
 *  @return the time literal.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">string</span>: literal (<span class="op">in</span> <span class="type">time</span>: aTime) <span class="keywd">is</span>
  <span class="keywd">return</span> <span class="stri">"time("</span> &amp; literal(str(aTime)) &amp; <span class="stri">")"</span>;


<span class="comment">(**
 *  Convert a string in the ISO 8601 date format to a time.
 *  The accepted ISO 8601 date formats are YYYY-MM, YYYY-MM-DD,
 *  YYYY-MM-DDTHH, YYYY-MM-DDTHH:MM, YYYY-MM-DDTHH:MM:SS
 *  Additionally a space is also allowed to separate the date and the
 *  time representations: YYYY-MM-DD HH, YYYY-MM-DD HH:MM,
 *  YYYY-MM-DD HH:MM:SS
 *  @return the time result of the conversion.
 *  @exception RANGE_ERROR If stri contains not a valid time value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: time (<span class="op">in</span> <span class="keywd">var</span> <span class="type">string</span>: stri) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: aTime <span class="keywd">is</span> time.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: checkForTimeZone <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> stri[1] = <span class="stri">'-'</span> <span class="keywd">then</span>
      stri := stri[2 ..];
      aTime.year := -integer(getint(stri));
    <span class="keywd">else</span>
      aTime.year := integer(getint(stri));
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="op">and</span> stri[1] = <span class="stri">'-'</span> <span class="keywd">then</span>
      stri := stri[2 ..];
      aTime.month := integer(getint(stri));
      <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="op">and</span> stri[1] = <span class="stri">'-'</span> <span class="keywd">then</span>
        stri := stri[2 ..];
        aTime.day := integer(getint(stri));
        <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="op">and</span> (stri[1] = <span class="stri">' '</span> <span class="op">or</span> stri[1] = <span class="stri">'T'</span>) <span class="keywd">then</span>
          stri := stri[2 ..];
          aTime.hour := integer(getint(stri));
          <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="op">and</span> stri[1] = <span class="stri">':'</span> <span class="keywd">then</span>
            stri := stri[2 ..];
            aTime.minute := integer(getint(stri));
            <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="op">and</span> stri[1] = <span class="stri">':'</span> <span class="keywd">then</span>
              stri := stri[2 ..];
              aTime.second := integer(getint(stri));
              <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="op">and</span> stri[1] = <span class="stri">'.'</span> <span class="keywd">then</span>
                stri := stri[2 ..];
                aTime.micro_second := integer((getint(stri) &amp; <span class="stri">"00000X"</span>)[.. 6]);
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
          checkForTimeZone := TRUE;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> stri &lt;> <span class="stri">""</span> <span class="op">and</span> stri[1] = <span class="stri">':'</span> <span class="keywd">then</span>
      stri := stri[2 ..];
      aTime.hour := aTime.year;
      aTime.year := 0;
      aTime.minute := integer(getint(stri));
      <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="op">and</span> stri[1] = <span class="stri">':'</span> <span class="keywd">then</span>
        stri := stri[2 ..];
        aTime.second := integer(getint(stri));
        <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="op">and</span> stri[1] = <span class="stri">'.'</span> <span class="keywd">then</span>
          stri := stri[2 ..];
          aTime.micro_second := integer((getint(stri) &amp; <span class="stri">"00000X"</span>)[.. 6]);
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      checkForTimeZone := TRUE;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> checkForTimeZone <span class="keywd">then</span>
      <span class="keywd">if</span> startsWith(stri, <span class="stri">" UTC"</span>) <span class="keywd">then</span>
        stri := stri[5 ..];
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        <span class="keywd">if</span> stri[1] = <span class="stri">'+'</span> <span class="keywd">then</span>
          stri := stri[2 ..];
          aTime.timeZone := integer(getint(stri)) * 60;
          <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="op">and</span> stri[1] = <span class="stri">':'</span> <span class="keywd">then</span>
            stri := stri[2 ..];
            aTime.timeZone +:= integer(getint(stri));
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">elsif</span> stri[1] = <span class="stri">'-'</span> <span class="keywd">then</span>
          stri := stri[2 ..];
          aTime.timeZone := -integer(getint(stri)) * 60;
          <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="op">and</span> stri[1] = <span class="stri">':'</span> <span class="keywd">then</span>
            stri := stri[2 ..];
            aTime.timeZone -:= integer(getint(stri));
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">if</span> stri = <span class="stri">" (DST)"</span> <span class="keywd">then</span>
        aTime.daylightSavingTime := TRUE;
        stri := <span class="stri">""</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> stri &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">if</span> aTime.month &lt; 1 <span class="op">or</span> aTime.month > 12 <span class="op">or</span>
        aTime.day &lt; 1 <span class="op">or</span> aTime.day > daysInMonth(aTime.year, aTime.month) <span class="op">or</span>
        aTime.hour &lt; 0 <span class="op">or</span> aTime.hour > 23 <span class="op">or</span>
        aTime.minute &lt; 0 <span class="op">or</span> aTime.minute > 59 <span class="op">or</span>
        aTime.second &lt; 0 <span class="op">or</span> aTime.second > 59 <span class="keywd">then</span>
      raise RANGE_ERROR;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Convert a string in the ISO 8601 date format to a time.
 *  The accepted ISO 8601 date formats are YYYY-MM, YYYY-MM-DD,
 *  YYYY-MM-DDTHH, YYYY-MM-DDTHH:MM, YYYY-MM-DDTHH:MM:SS
 *  Additionally a space is also allowed to separate the date and the
 *  time representations: YYYY-MM-DD HH, YYYY-MM-DD HH:MM,
 *  YYYY-MM-DD HH:MM:SS
 *  @return the time result of the conversion.
 *  @exception RANGE_ERROR If stri contains not a valid time value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: (attr time) <span class="op">parse</span> (<span class="op">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span>
    <span class="keywd">return</span> time(stri);


enable_io(time);


<span class="comment">(**
 *  Check if two ''time'' values are equal.
 *  @return TRUE if both times are equal, FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">time</span>: aTime1) = (<span class="op">in</span> <span class="type">time</span>: aTime2) <span class="keywd">is</span>
  <span class="keywd">return</span>
    aTime1.year = aTime2.year <span class="op">and</span>
    aTime1.month = aTime2.month <span class="op">and</span>
    aTime1.day = aTime2.day <span class="op">and</span>
    aTime1.hour = aTime2.hour <span class="op">and</span>
    aTime1.minute = aTime2.minute <span class="op">and</span>
    aTime1.second = aTime2.second <span class="op">and</span>
    aTime1.micro_second = aTime2.micro_second;


<span class="comment">(**
 *  Check if two ''time'' values are not equal.
 *  @return FALSE if both times are equal, TRUE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">time</span>: aTime1) &lt;> (<span class="op">in</span> <span class="type">time</span>: aTime2) <span class="keywd">is</span>
  <span class="keywd">return</span>
    aTime1.year &lt;> aTime2.year <span class="op">or</span>
    aTime1.month &lt;> aTime2.month <span class="op">or</span>
    aTime1.day &lt;> aTime2.day <span class="op">or</span>
    aTime1.hour &lt;> aTime2.hour <span class="op">or</span>
    aTime1.minute &lt;> aTime2.minute <span class="op">or</span>
    aTime1.second &lt;> aTime2.second <span class="op">or</span>
    aTime1.micro_second &lt;> aTime2.micro_second;


<span class="comment">(**
 *  Check if ''aTime1'' is less than or equal to ''aTime2''.
 *  @return TRUE if ''aTime1'' is less than or equal to ''aTime2'',
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">time</span>: aTime1) &lt;= (<span class="op">in</span> <span class="type">time</span>: aTime2) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: isLessEqual <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> aTime1.year &lt; aTime2.year <span class="keywd">then</span>
      isLessEqual := TRUE;
    <span class="keywd">elsif</span> aTime1.year = aTime2.year <span class="keywd">then</span>
      <span class="keywd">if</span> aTime1.month &lt; aTime2.month <span class="keywd">then</span>
        isLessEqual := TRUE;
      <span class="keywd">elsif</span> aTime1.month = aTime2.month <span class="keywd">then</span>
        <span class="keywd">if</span> aTime1.day &lt; aTime2.day <span class="keywd">then</span>
          isLessEqual := TRUE;
        <span class="keywd">elsif</span> aTime1.day = aTime2.day <span class="keywd">then</span>
          <span class="keywd">if</span> aTime1.hour &lt; aTime2.hour <span class="keywd">then</span>
            isLessEqual := TRUE;
          <span class="keywd">elsif</span> aTime1.hour = aTime2.hour <span class="keywd">then</span>
            <span class="keywd">if</span> aTime1.minute &lt; aTime2.minute <span class="keywd">then</span>
              isLessEqual := TRUE;
            <span class="keywd">elsif</span> aTime1.minute = aTime2.minute <span class="keywd">then</span>
              <span class="keywd">if</span> aTime1.second &lt; aTime2.second <span class="keywd">then</span>
                isLessEqual := TRUE;
              <span class="keywd">elsif</span> aTime1.second = aTime2.second <span class="keywd">then</span>
                <span class="keywd">if</span> aTime1.micro_second &lt;= aTime2.micro_second <span class="keywd">then</span>
                  isLessEqual := TRUE;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Check if ''aTime1'' is greater than or equal to ''aTime2''.
 *  @return TRUE if ''aTime1'' is greater than or equal to ''aTime2'',
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">time</span>: aTime1) >= (<span class="op">in</span> <span class="type">time</span>: aTime2) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: isGreaterEqual <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> aTime1.year > aTime2.year <span class="keywd">then</span>
      isGreaterEqual := TRUE;
    <span class="keywd">elsif</span> aTime1.year = aTime2.year <span class="keywd">then</span>
      <span class="keywd">if</span> aTime1.month > aTime2.month <span class="keywd">then</span>
        isGreaterEqual := TRUE;
      <span class="keywd">elsif</span> aTime1.month = aTime2.month <span class="keywd">then</span>
        <span class="keywd">if</span> aTime1.day > aTime2.day <span class="keywd">then</span>
          isGreaterEqual := TRUE;
        <span class="keywd">elsif</span> aTime1.day = aTime2.day <span class="keywd">then</span>
          <span class="keywd">if</span> aTime1.hour > aTime2.hour <span class="keywd">then</span>
            isGreaterEqual := TRUE;
          <span class="keywd">elsif</span> aTime1.hour = aTime2.hour <span class="keywd">then</span>
            <span class="keywd">if</span> aTime1.minute > aTime2.minute <span class="keywd">then</span>
              isGreaterEqual := TRUE;
            <span class="keywd">elsif</span> aTime1.minute = aTime2.minute <span class="keywd">then</span>
              <span class="keywd">if</span> aTime1.second > aTime2.second <span class="keywd">then</span>
                isGreaterEqual := TRUE;
              <span class="keywd">elsif</span> aTime1.second = aTime2.second <span class="keywd">then</span>
                <span class="keywd">if</span> aTime1.micro_second >= aTime2.micro_second <span class="keywd">then</span>
                  isGreaterEqual := TRUE;
                <span class="keywd">end</span> <span class="keywd">if</span>;
              <span class="keywd">end</span> <span class="keywd">if</span>;
            <span class="keywd">end</span> <span class="keywd">if</span>;
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Check if ''aTime1'' is less than ''aTime2''.
 *  @return TRUE if ''aTime1'' is less than ''aTime2'',
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">time</span>: aTime1) &lt; (<span class="op">in</span> <span class="type">time</span>: aTime2) <span class="keywd">is</span>
  <span class="keywd">return</span> <span class="op">not</span> aTime1 >= aTime2;


<span class="comment">(**
 *  Check if ''aTime1'' is greater than ''aTime2''.
 *  @return TRUE if ''aTime1'' is greater than ''aTime2'',
 *          FALSE otherwise.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">boolean</span>: (<span class="op">in</span> <span class="type">time</span>: aTime1) > (<span class="op">in</span> <span class="type">time</span>: aTime2) <span class="keywd">is</span>
  <span class="keywd">return</span> <span class="op">not</span> aTime1 &lt;= aTime2;


<span class="comment">(**
 *  Compares two times.
 *  @return -1, 0 or 1 if the first argument is considered to be
 *          respectively less than, equal to, or greater than the
 *          second.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: compare (<span class="op">in</span> <span class="type">time</span>: aTime1, <span class="op">in</span> <span class="type">time</span>: aTime2) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: signumValue <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> aTime1.year &lt; aTime2.year <span class="keywd">then</span>
      signumValue := -1;
    <span class="keywd">elsif</span> aTime1.year > aTime2.year <span class="keywd">then</span>
      signumValue := 1;
    <span class="keywd">elsif</span> aTime1.month &lt; aTime2.month <span class="keywd">then</span>
      signumValue := -1;
    <span class="keywd">elsif</span> aTime1.month > aTime2.month <span class="keywd">then</span>
      signumValue := 1;
    <span class="keywd">elsif</span> aTime1.day &lt; aTime2.day <span class="keywd">then</span>
      signumValue := -1;
    <span class="keywd">elsif</span> aTime1.day > aTime2.day <span class="keywd">then</span>
      signumValue := 1;
    <span class="keywd">elsif</span> aTime1.hour &lt; aTime2.hour <span class="keywd">then</span>
      signumValue := -1;
    <span class="keywd">elsif</span> aTime1.hour > aTime2.hour <span class="keywd">then</span>
      signumValue := 1;
    <span class="keywd">elsif</span> aTime1.minute &lt; aTime2.minute <span class="keywd">then</span>
      signumValue := -1;
    <span class="keywd">elsif</span> aTime1.minute > aTime2.minute <span class="keywd">then</span>
      signumValue := 1;
    <span class="keywd">elsif</span> aTime1.second &lt; aTime2.second <span class="keywd">then</span>
      signumValue := -1;
    <span class="keywd">elsif</span> aTime1.second > aTime2.second <span class="keywd">then</span>
      signumValue := 1;
    <span class="keywd">elsif</span> aTime1.micro_second &lt; aTime2.micro_second <span class="keywd">then</span>
      signumValue := -1;
    <span class="keywd">elsif</span> aTime1.micro_second > aTime2.micro_second <span class="keywd">then</span>
      signumValue := 1;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Compute the hash value of a time.
 *  @return the hash value.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: hashCode (<span class="op">in</span> <span class="type">time</span>: aTime) <span class="keywd">is</span>
  <span class="keywd">return</span> aTime.year &lt;&lt; 6 + aTime.month &lt;&lt; 5 + aTime.day &lt;&lt; 4 +
         aTime.hour &lt;&lt; 3 + aTime.minute &lt;&lt; 2 + aTime.second &lt;&lt; 1 +
         aTime.micro_second;


<span class="comment">(**
 *  Truncate 'aTime' to the beginning of a second.
 *  @return the truncated time.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: truncToSecond (<span class="op">in</span> <span class="type">time</span>: aTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: truncatedTime <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    truncatedTime := aTime;
    truncatedTime.micro_second := 0;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Truncate 'aTime' to the beginning of a minute.
 *  @return the truncated time.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: truncToMinute (<span class="op">in</span> <span class="type">time</span>: aTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: truncatedTime <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    truncatedTime := aTime;
    truncatedTime.second := 0;
    truncatedTime.micro_second := 0;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Truncate 'aTime' to the beginning of a hour.
 *  @return the truncated time.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: truncToHour (<span class="op">in</span> <span class="type">time</span>: aTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: truncatedTime <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    truncatedTime := aTime;
    truncatedTime.minute := 0;
    truncatedTime.second := 0;
    truncatedTime.micro_second := 0;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Truncate 'aTime' to the beginning of a day.
 *  @return the truncated time.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: truncToDay (<span class="op">in</span> <span class="type">time</span>: aTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: truncatedTime <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    truncatedTime := aTime;
    truncatedTime.hour := 0;
    truncatedTime.minute := 0;
    truncatedTime.second := 0;
    truncatedTime.micro_second := 0;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Truncate 'aTime' to the beginning of the first day in the month.
 *  @return the truncated time.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: truncToMonth (<span class="op">in</span> <span class="type">time</span>: aTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: truncatedTime <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    truncatedTime := aTime;
    truncatedTime.day := 1;
    truncatedTime.hour := 0;
    truncatedTime.minute := 0;
    truncatedTime.second := 0;
    truncatedTime.micro_second := 0;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Truncate 'aTime' to the beginning of the first day in the year.
 *  @return the truncated time.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: truncToYear (<span class="op">in</span> <span class="type">time</span>: aTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: truncatedTime <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    truncatedTime := aTime;
    truncatedTime.month := 1;
    truncatedTime.day := 1;
    truncatedTime.hour := 0;
    truncatedTime.minute := 0;
    truncatedTime.second := 0;
    truncatedTime.micro_second := 0;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Return the weekday number of 'aDate'.
 *  @return 1 for monday, 2 for tuesday, and so on up to 7 for sunday.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: dayOfWeek (<span class="op">in</span> <span class="type">time</span>: aDate) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: weekday <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: year <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: month <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    year := aDate.year;
    month := aDate.month;
    <span class="keywd">if</span> month &lt;= 2 <span class="keywd">then</span>
      decr(year);
      month +:= 12;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    weekday := succ(pred(year + year <span class="op">mdiv</span> 4 - year <span class="op">mdiv</span> 100 + year <span class="op">mdiv</span> 400 +
        (31 * (month - 2)) <span class="op">mdiv</span> 12 + aDate.day) <span class="op">mod</span> 7);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Return the day number in the year of 'aDate'.
 *  @return 1 for the 1. of january and successive values up to 366.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: dayOfYear (<span class="op">in</span> <span class="type">time</span>: aDate) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: dayOfYear <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> isLeapYear(aDate.year) <span class="keywd">then</span>
      dayOfYear := [](0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335)[aDate.month] + aDate.day;
    <span class="keywd">else</span>
      dayOfYear := [](0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334)[aDate.month] + aDate.day;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Return the week number of the 'year' for the 'dayOfYear'.
 *  According to ISO 8601: Week number 1 of every year contains the
 *  4. of january. Since 1st to 3rd of january might be in the
 *  previous week there can be also a week number 0.
 *  @return a week number from 0 to 53 for weeks belonging to the year
 *          of the given date.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: weekOfYear (<span class="op">in</span> <span class="keywd">var</span> <span class="type">integer</span>: year, <span class="op">in</span> <span class="type">integer</span>: dayOfYear) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: weekNumber <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: weekDayOfJan4 <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    year := pred(year);
    weekDayOfJan4 := succ(pred(year + year <span class="op">mdiv</span> 4 - year <span class="op">mdiv</span> 100 + year <span class="op">mdiv</span> 400 + 32) <span class="op">mod</span> 7);
    weekNumber := (dayOfYear + weekDayOfJan4 - 5) <span class="op">mdiv</span> 7 + 1;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Return the week number of the year for 'aDate'.
 *  According to ISO 8601: Week number 1 of every year contains the
 *  4. of january. Since 1st to 3rd of january might be in the
 *  previous week there can be also a week number 0.
 *  @return a week number from 0 to 53 for weeks belonging to the year
 *          of the given date.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: weekOfYear (<span class="op">in</span> <span class="type">time</span>: aDate) <span class="keywd">is</span>
  <span class="keywd">return</span> weekOfYear(aDate.year, dayOfYear(aDate));


<span class="comment">(**
 *  Return the year of the ISO 8601 week date for 'aDate'.
 *  At the beginning and the end of an Gregorian calendar year there
 *  might be days which belong to a week of the previous or next year.
 *  For example 2005-01-01 is 2004-W53-6 and 2007-12-31 is 2008-W01-1.
 *  @return the year in the range 'pred(aDate.year)' to
 *          'succ(aDate.year)'.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: weekDateYear (<span class="op">in</span> <span class="type">time</span>: aDate) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: weekDateYear <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: weekNumber <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    weekNumber := weekOfYear(aDate.year, dayOfYear(aDate));
    <span class="keywd">if</span> weekNumber &lt;= 0 <span class="keywd">then</span>
      weekDateYear := pred(aDate.year);
    <span class="keywd">elsif</span> weekNumber >= 53 <span class="op">and</span> aDate.day >= 29 <span class="op">and</span>
        weekOfYear(succ(aDate.year), 31 - aDate.day) = 1 <span class="keywd">then</span>
      weekDateYear := succ(aDate.year);
    <span class="keywd">else</span>
      weekDateYear := aDate.year;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Return the week number of the ISO 8601 week date for 'aDate'.
 *  At the beginning and the end of an Gregorian calendar year there
 *  might be days which belong to a week of the previous or next year.
 *  For example 2005-01-01 is 2004-W53-6 and 2007-12-31 is 2008-W01-1.
 *  @return the week number in the range 1 to 53.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: weekDateWeek (<span class="op">in</span> <span class="type">time</span>: aDate) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: weekNumber <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    weekNumber := weekOfYear(aDate.year, dayOfYear(aDate));
    <span class="keywd">if</span> weekNumber &lt;= 0 <span class="keywd">then</span>
      weekNumber := weekOfYear(pred(aDate.year), 366);
    <span class="keywd">elsif</span> weekNumber >= 53 <span class="op">and</span> aDate.day >= 29 <span class="op">and</span>
        weekOfYear(succ(aDate.year), 31 - aDate.day) = 1 <span class="keywd">then</span>
      weekNumber := 1;
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">proc</span>: NORMALIZE (<span class="keywd">inout</span> <span class="type">time</span>: tim) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: month_length <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    tim.second := tim.second + tim.micro_second <span class="op">mdiv</span> 1000000;
    tim.micro_second := tim.micro_second <span class="op">mod</span> 1000000;
    tim.minute := tim.minute + tim.second <span class="op">mdiv</span> 60;
    tim.second := tim.second <span class="op">mod</span> 60;
    tim.hour := tim.hour + tim.minute <span class="op">mdiv</span> 60;
    tim.minute := tim.minute <span class="op">mod</span> 60;
    tim.day := tim.day + tim.hour <span class="op">mdiv</span> 24;
    tim.hour := tim.hour <span class="op">mod</span> 24;
    tim.year := tim.year + pred(tim.month) <span class="op">mdiv</span> 12;
    tim.month := succ(pred(tim.month) <span class="op">mod</span> 12);
    month_length := daysInMonth(tim.year, tim.month);
    <span class="keywd">while</span> tim.day > month_length <span class="keywd">do</span>
      tim.day := tim.day - month_length;
      <span class="keywd">if</span> tim.month &lt; 12 <span class="keywd">then</span>
        incr(tim.month);
      <span class="keywd">else</span>
        tim.month := 1;
        incr(tim.year);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      month_length := daysInMonth(tim.year, tim.month);
    <span class="keywd">end</span> <span class="keywd">while</span>;
    <span class="keywd">while</span> tim.day &lt; 1 <span class="keywd">do</span>
      <span class="keywd">if</span> tim.month > 1 <span class="keywd">then</span>
        decr(tim.month);
      <span class="keywd">else</span>
        tim.month := 12;
        decr(tim.year);
      <span class="keywd">end</span> <span class="keywd">if</span>;
      tim.day := tim.day + daysInMonth(tim.year, tim.month);
    <span class="keywd">end</span> <span class="keywd">while</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Convert a time to Coordinated Universal Time (UTC).
 *  @return the time in UTC.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: toUTC (<span class="op">in</span> <span class="type">time</span>: aTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: timeInUTC <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    timeInUTC := aTime;
    timeInUTC.minute -:= aTime.timeZone;
    timeInUTC.timeZone := 0;
    NORMALIZE(timeInUTC);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Sets timeZone and daylightSavingTime for a given time.
 *  @return the time in the local time zone.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: setLocalTZ (<span class="op">in</span> <span class="type">time</span>: aTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: localTime <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    localTime := aTime;
    SET_LOCAL_TZ(localTime.year, localTime.month, localTime.day,
        localTime.hour, localTime.minute, localTime.second,
        localTime.timeZone, localTime.daylightSavingTime);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Compute the julian day number of 'aDate'.
 *  The julian day number is the number of days that have elapsed
 *  since January 1, 4713 BC in the proleptic Julian calendar.
 *  @return the julian day number.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: julianDayNumber (<span class="op">in</span> <span class="type">time</span>: aDate) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: julianDayNumber <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: year <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: month <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    year := aDate.year;
    month := aDate.month;
    <span class="keywd">if</span> month &lt;= 2 <span class="keywd">then</span>
      decr(year);
      month +:= 12;
    <span class="keywd">end</span> <span class="keywd">if</span>;
    julianDayNumber := (1461 * (year + 4800)) <span class="op">mdiv</span> 4 +
                       (367 * (month - 2)) <span class="op">mdiv</span> 12 -
                       (3 * ((year + 4900) <span class="op">mdiv</span> 100)) <span class="op">mdiv</span> 4 +
                       aDate.day - 32075;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Return the time of a 'julianDayNumber'.
 *  The julian day number is the number of days that have elapsed
 *  since January 1, 4713 BC in the proleptic Julian calendar.
 *  @return the time 0:00:00 at the day with the 'julianDayNumber'.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: julianDayNumToTime (<span class="op">in</span> <span class="type">integer</span>: julianDayNumber) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: aTime <span class="keywd">is</span> time.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: l <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: n <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: i <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: j <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    l := julianDayNumber + 68569;
    n := (4 * l) <span class="op">mdiv</span> 146097;
    l := l - (146097 * n + 3) <span class="op">mdiv</span> 4;
    i := (4000 * (l + 1)) <span class="op">mdiv</span> 1461001;
    l := l - (1461 * i) <span class="op">mdiv</span> 4 + 31;
    j := (80 * l) <span class="op">mdiv</span> 2447;
    aTime.day := l - (2447 * j) <span class="op">mdiv</span> 80;
    l := j <span class="op">mdiv</span> 11;
    aTime.month := j + 2 - (12 * l);
    aTime.year := 100 * (n - 49) + i + l;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Return a time expressed in seconds since the Unix Epoch.
 *  The Unix Epoch (1970-01-01 00:00:00 UTC) corresponds to 0.
 *  @return the seconds since the Unix Epoch.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: timestamp1970 (<span class="op">in</span> <span class="type">time</span>: aTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: seconds <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">integer</span>: DAYS_FROM_0_TO_1970 <span class="keywd">is</span> 719162; <span class="comment"># Days between 0-01-01 and 1970-01-01</span>
    <span class="keywd">var</span> <span class="type">integer</span>: yearBefore <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    yearBefore := pred(aTime.year);
    seconds := (((yearBefore * 365 +
                  yearBefore <span class="op">mdiv</span> 4 -
                  yearBefore <span class="op">mdiv</span> 100 +
                  yearBefore <span class="op">mdiv</span> 400 -
               DAYS_FROM_0_TO_1970 +
               pred(dayOfYear(aTime))) * 24 +
               aTime.hour) * 60 +
               aTime.minute) * 60 +
               aTime.second -
               aTime.timeZone * 60;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Convert a timestamp into a time from the local time zone.
 *  The timestamp is expressed in seconds since the Unix Epoch.
 *  The Unix Epoch (1970-01-01 00:00:00 UTC) corresponds to 0.
 *  @return the local time that corresponds to the timestamp.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: timestamp1970ToTime (<span class="op">in</span> <span class="type">integer</span>: timestamp) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: aTime <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    FROM_TIMESTAMP(timestamp, aTime.year, aTime.month, aTime.day,
        aTime.hour, aTime.minute, aTime.second,
        aTime.micro_second, aTime.timeZone,
        aTime.daylightSavingTime);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">integer</span>: timestamp1601 (<span class="op">in</span> <span class="type">time</span>: aTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">integer</span>: nanosecs100 <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">integer</span>: SECONDS_1601_1970 <span class="keywd">is</span> 11644473600;
    <span class="keywd">const</span> <span class="type">integer</span>: NANOSECS100_TICK <span class="keywd">is</span> 10000000;
  <span class="keywd">begin</span>
    nanosecs100 := (timestamp1970(aTime) + SECONDS_1601_1970) * NANOSECS100_TICK;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: timestamp1601ToTime (<span class="op">in</span> <span class="type">integer</span>: timestamp) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: aTime <span class="keywd">is</span> time.value;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <span class="type">integer</span>: SECONDS_1601_1970 <span class="keywd">is</span> 11644473600;
    <span class="keywd">const</span> <span class="type">integer</span>: NANOSECS100_TICK <span class="keywd">is</span> 10000000;
    <span class="keywd">var</span> <span class="type">integer</span>: utcSeconds <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    utcSeconds := timestamp <span class="op">div</span> NANOSECS100_TICK - SECONDS_1601_1970;
    aTime := timestamp1970ToTime(utcSeconds);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(*
(*####
 *  Convert a timestamp into Coordinated Universal Time (UTC).
 *)
const func time: timestamp1970ToUTC (in integer: timestamp) is func
  result
    var time: aTime is time.value;
  local
    const integer: SECS_DAY is 24 * 60 * 60;
    var integer: dayclock is 0;
    var integer: dayno is 0;
    var integer: year is 1970;
  begin
    dayclock := timestamp mod SECS_DAY;
    dayno    := timestamp mdiv SECS_DAY;
    aTime.second := dayclock rem 60;
    aTime.minute := (dayclock rem 3600) div 60;
    aTime.hour   := dayclock div 3600;
    if dayno >= 0 then
      while dayno >= daysInYear(year) do
        dayno -:= daysInYear(year);
        incr(year);
      end while;
      aTime.month := 1;
      while dayno >= daysInMonth(year, aTime.month) do
        dayno -:= daysInMonth(year, aTime.month);
        incr(aTime.month);
      end while;
      aTime.day := succ(dayno);
    else
      decr(year);
      dayno := pred(-dayno);
      while dayno >= daysInYear(year) do
        dayno -:= daysInYear(year);
        decr(year);
      end while;
      aTime.month := 12;
      while dayno >= daysInMonth(year, aTime.month) do
        dayno -:= daysInMonth(year, aTime.month);
        decr(aTime.month);
      end while;
      aTime.day := daysInMonth(year, aTime.month) - dayno;
    end if;
    aTime.year := year;
  end func;
*)</span>


<span class="comment">(**
 *  Compute pseudo-random time in the range [low, high].
 *  The random values are uniform distributed.
 *  @return a random time such that low &lt;= rand(low, high) and
 *          rand(low, high) &lt;= high holds.
 *  @exception RANGE_ERROR The range is empty (low > high holds).
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: rand (<span class="op">in</span> <span class="type">time</span>: low, <span class="op">in</span> <span class="type">time</span>: high) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: randomTime <span class="keywd">is</span> time.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">integer</span>: timestampLow <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">integer</span>: timestampHigh <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    timestampLow := timestamp1970(low);
    timestampHigh := timestamp1970(high);
    randomTime := low;
    randomTime.second +:= rand(timestampLow, timestampHigh) - timestampLow;
    <span class="keywd">if</span> randomTime.second = low.second <span class="keywd">then</span>
      <span class="keywd">if</span> randomTime.second = high.second <span class="keywd">then</span>
        randomTime.micro_second := rand(low.micro_second, high.micro_second);
      <span class="keywd">else</span>
        randomTime.micro_second := rand(low.micro_second, 999999);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">elsif</span> randomTime.second = high.second <span class="keywd">then</span>
      randomTime.micro_second := rand(0, high.micro_second);
    <span class="keywd">else</span>
      randomTime.micro_second := rand(0, 999999);
    <span class="keywd">end</span> <span class="keywd">if</span>;
    NORMALIZE(randomTime);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Determine the current local time.
 *  @return the current local time.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: time (NOW) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: localTime <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    GET_TIME(localTime.year, localTime.month, localTime.day,
        localTime.hour, localTime.minute, localTime.second,
        localTime.micro_second, localTime.timeZone,
        localTime.daylightSavingTime);
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Return the specified UTC time.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: time (<span class="op">in</span> <span class="type">integer</span>: year, <span class="op">in</span> <span class="type">integer</span>: month, <span class="op">in</span> <span class="type">integer</span>: day,
    <span class="op">in</span> <span class="type">integer</span>: hour, <span class="op">in</span> <span class="type">integer</span>: minute, <span class="op">in</span> <span class="type">integer</span>: second) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: utcTime <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    utcTime.year   := year;
    utcTime.month  := month;
    utcTime.day    := day;
    utcTime.hour   := hour;
    utcTime.minute := minute;
    utcTime.second := second;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Return the specified time in the specified timeZone.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: timeInTimeZone (<span class="op">in</span> <span class="type">integer</span>: year, <span class="op">in</span> <span class="type">integer</span>: month, <span class="op">in</span> <span class="type">integer</span>: day,
    <span class="op">in</span> <span class="type">integer</span>: hour, <span class="op">in</span> <span class="type">integer</span>: minute, <span class="op">in</span> <span class="type">integer</span>: second, <span class="op">in</span> <span class="type">integer</span>: timeZone) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: aTime <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    aTime.year     := year;
    aTime.month    := month;
    aTime.day      := day;
    aTime.hour     := hour;
    aTime.minute   := minute;
    aTime.second   := second;
    aTime.timeZone := timeZone;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Return the specified UTC date.
 *)</span>
<span class="keywd">const</span> <span class="type">func</span> <span class="type">time</span>: date (<span class="op">in</span> <span class="type">integer</span>: year, <span class="op">in</span> <span class="type">integer</span>: month, <span class="op">in</span> <span class="type">integer</span>: day) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">time</span>: aDate <span class="keywd">is</span> time.value;
  <span class="keywd">begin</span>
    aDate.year  := year;
    aDate.month := month;
    aDate.day   := day;
  <span class="keywd">end</span> <span class="keywd">func</span>;


<span class="comment">(**
 *  Wait until 'aTime' is reached
 *)</span>
<span class="keywd">const</span> <span class="type">proc</span>: await (<span class="keywd">ref</span> <span class="type">time</span>: aTime) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    AWAIT_TIME(aTime.year, aTime.month, aTime.day,
        aTime.hour, aTime.minute, aTime.second,
        aTime.micro_second, aTime.timeZone);
  <span class="keywd">end</span> <span class="keywd">func</span>;
</pre>
</body>
</html>
