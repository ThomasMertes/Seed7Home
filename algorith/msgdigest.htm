<html>
<head>
<meta charset="utf-8" />
<title>
Seed7 Algorithms: Message&nbsp;digest</title>
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style1.css" type="text/css" />
</head>
<body style="margin:0 0 0 0;">
<div style="background-image: url('../images/header1x.png');" class="top_image">
<img style="overflow:hidden;" src="../images/hearts7m.png" height="68" width="50"
 /><img style="overflow:hidden;" src="../images/header3.png" height="68" width="745" />
</div>
<div style="background-image: url('../images/fillpix.png');" class="space_below_top_image">
</div>
<div class="menu">

<a class="head" href="../index.htm"><big>Seed7</big></a>
<a class="menu" href="../faq.htm">FAQ</a>
<a class="menu" href="../manual/index.htm">Manual</a>
<a class="menu" href="../scrshots/index.htm">Programs</a>
<a class="menu" href="../examples/index.htm">Examples</a>
<a class="menu" href="../libraries/index.htm">Libraries</a>
<a class="menu" href="../algorith/index.htm">Algorithms</a>
<a class="menu" href="../benchmks/index.htm">Benchmarks</a>
<a class="menu" href="../subject_index.htm">Index</a>
<a class="menu" href="http://sourceforge.net/project/showfiles.php?group_id=151126">Download</a>
<a class="menu" href="https://github.com/ThomasMertes/seed7">GitHub</a>
<a class="menu" href="../build.htm">Build Seed7</a>
<a class="menu" href="../links.htm">Links</a>

<br />

<a class="head" href="index.htm"><big>Algorithms</big></a>
<a class="menu" href="sorting.htm">Sorting</a>
<a class="menu" href="search.htm">Searching</a>
<a class="menu" href="date.htm">Date&nbsp;&&nbsp;Time</a>
<a class="menu" href="string.htm">String</a>
<a class="menu" href="float.htm">Float</a>
<a class="menu" href="math.htm">Mathematics</a>
<a class="menu" href="msgdigest.htm">Message&nbsp;digest</a>
<a class="menu" href="graphic.htm">Graphics</a>
<a class="menu" href="file.htm">File</a>
<a class="menu" href="puzzles.htm">Puzzles</a>
<a class="menu" href="others.htm">Others</a>
</div>
<div class="content">
<div style="padding-right:20;">
<table width="100%" cellpadding="0" cellspacing="0">
<tr>
<td align="left" width="80">
<a class="head" href="index.htm"><big>Algorithms</big></a>
</td>
<td>
<table width="10">
</table>
</td>
<td align="left" width="60%">
<b><big>Message&nbsp;digest</big></b></td>
<td align="right">
<table border="0" cellspacing="1" bgcolor="blue">
<tr bgcolor="gainsboro">
<td>&nbsp;<a class="navigation" href="../algorith/math.htm">previous</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/index.htm">up</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/graphic.htm">next</a>&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
<p>
</p>

<div><a name="md4"><h3>Compute a message digest with the MD4 message digest algorithm</h3></a>
<p>
The function <tt><a class="func" href="../libraries/msgdigest.htm#md4(in_var_string)">md4</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/msgdigest.htm">msgdigest.s7i</a>"</span> library.
The security of MD4 has been severely compromised.
This function is provided for backward compatibility.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: md4 (<span class="keywd">in</span> var <a class="type" href="../manual/types.htm#string">string</a>: message) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: digest <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="comment"># Specify the per-round shift amounts</span>
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: shiftAmount <span class="keywd">is</span> [] (
        3,  7, 11, 19,  3,  7, 11, 19,  3,  7, 11, 19,  3,  7, 11, 19,
        3,  5,  9, 13,  3,  5,  9, 13,  3,  5,  9, 13,  3,  5,  9, 13,
        3,  9, 11, 15,  3,  9, 11, 15,  3,  9, 11, 15,  3,  9, 11, 15);
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: idx <span class="keywd">is</span> [] (
        1,  9,  5, 13,  3, 11,  7, 15,  2, 10,  6, 14,  4, 12,  8, 16);
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: wordIndex <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: m <span class="keywd">is</span> 16 <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>.value;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: a0 <span class="keywd">is</span> 16#67452301;   <span class="comment"># a</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: b0 <span class="keywd">is</span> 16#efcdab89;   <span class="comment"># b</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: c0 <span class="keywd">is</span> 16#98badcfe;   <span class="comment"># c</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: d0 <span class="keywd">is</span> 16#10325476;   <span class="comment"># d</span>
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: a <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: b <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: c <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: d <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: f <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: g <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: temp <span class="keywd">is</span> bin32(0);
  <span class="keywd">begin</span>
    length := length(message);
    <span class="comment"># Append the bit '1' to the message.</span>
    message &:= '\16#80;';
    <span class="comment"># Append '0' bits, so that the resulting bit length is congruent to 448 (mod 512).</span>
    message &:= "\0;" <a class="op" href="../libraries/string.htm#(in_string)mult(in_integer)">mult</a> 63 - (length + 8) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 64;
    <span class="comment"># Append length of message (before pre-processing), in bits, as 64-bit little-endian integer.</span>
    message &:= <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(8 * length, UNSIGNED, LE, 8);

    <span class="comment"># Process the message in successive 512-bit chunks:</span>
    <span class="keywd">while</span> wordIndex &lt;= length(message) <span class="keywd">do</span>
      <span class="comment"># Break chunk into sixteen 32-bit little-endian words.</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 16 <span class="keywd">do</span>
        m[index] := bin32(<a class="func" href="../libraries/bytedata.htm#bytes2Int(in_string,in_signedness,in_endianess)">bytes2Int</a>(message[wordIndex <span class="keywd">fixLen</span> 4], UNSIGNED, LE));
        wordIndex +:= 4;
      <span class="keywd">end for</span>;

      a := bin32(a0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      b := bin32(b0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      c := bin32(c0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      d := bin32(d0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);

      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 48 <span class="keywd">do</span>
        <span class="keywd">if</span> index &lt;= 16 <span class="keywd">then</span>
          f := d >&lt; (b &amp; (c >&lt; d));
          g := index;
        <span class="keywd">elsif</span> index &lt;= 32 <span class="keywd">then</span>
          f := bin32(ord(b &amp; (c | d) | (c &amp; d)) + 16#5a827999);
          g := (4 * index + 7) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 15 + (index <a class="op" href="../libraries/integer.htm#(in_integer)mdiv(in_integer)">mdiv</a> 32) * 15 + 1;
        <span class="keywd">else</span>
          f := bin32(ord(b >&lt; c >&lt; d) + 16#6ed9eba1);
          g := idx[index - 32];
        <span class="keywd">end if</span>;
        temp := d;
        d := c;
        c := b;
        b := <a class="func" href="../libraries/bin32.htm#rotLeft(in_bin32,in_integer)">rotLeft</a>(bin32((ord(a) + ord(f) + ord(m[g])) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000),
                     shiftAmount[index]);
        a := temp;
      <span class="keywd">end for</span>;

      <span class="comment"># Add this chunk's hash to result so far:</span>
      a0 +:= ord(a);
      b0 +:= ord(b);
      c0 +:= ord(c);
      d0 +:= ord(d);
    <span class="keywd">end while</span>;

    <span class="comment"># Produce the final hash value:</span>
    digest := <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(a0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, LE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(b0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, LE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(c0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, LE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(d0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, LE, 4);
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="md5"><h3>Compute a message digest with the MD5 message digest algorithm</h3></a>
<p>
The function <tt><a class="func" href="../libraries/msgdigest.htm#md5(in_var_string)">md5</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/msgdigest.htm">msgdigest.s7i</a>"</span> library.
MD5 is considered to be cryptographically broken.
This function is provided for backward compatibility.
</p><pre class="indent">
<span class="comment"># Use binary integer part of the sines of integers (Radians) as constants:</span>
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: createMd5Table <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: k <span class="keywd">is</span> 64 <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 64 <span class="keywd">do</span>
      k[index] := trunc(abs(sin(flt(index))) * 2.0 ** 32);
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: md5 (<span class="keywd">in</span> var <a class="type" href="../manual/types.htm#string">string</a>: message) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: digest <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="comment"># Specify the per-round shift amounts</span>
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: shiftAmount <span class="keywd">is</span> [] (
        7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,
        5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,
        4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,
        6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21);
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: k <span class="keywd">is</span> createMd5Table;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: wordIndex <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: m <span class="keywd">is</span> 16 <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>.value;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: a0 <span class="keywd">is</span> 16#67452301;   <span class="comment"># a</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: b0 <span class="keywd">is</span> 16#efcdab89;   <span class="comment"># b</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: c0 <span class="keywd">is</span> 16#98badcfe;   <span class="comment"># c</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: d0 <span class="keywd">is</span> 16#10325476;   <span class="comment"># d</span>
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: a <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: b <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: c <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: d <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: f <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: g <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: temp <span class="keywd">is</span> bin32(0);
  <span class="keywd">begin</span>
    length := length(message);
    <span class="comment"># Append the bit '1' to the message.</span>
    message &:= '\16#80;';
    <span class="comment"># Append '0' bits, so that the resulting bit length is congruent to 448 (mod 512).</span>
    message &:= "\0;" <a class="op" href="../libraries/string.htm#(in_string)mult(in_integer)">mult</a> 63 - (length + 8) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 64;
    <span class="comment"># Append length of message (before pre-processing), in bits, as 64-bit little-endian integer.</span>
    message &:= <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(8 * length, UNSIGNED, LE, 8);

    <span class="comment"># Process the message in successive 512-bit chunks:</span>
    <span class="keywd">while</span> wordIndex &lt;= length(message) <span class="keywd">do</span>
      <span class="comment"># Break chunk into sixteen 32-bit little-endian words.</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 16 <span class="keywd">do</span>
        m[index] := bin32(<a class="func" href="../libraries/bytedata.htm#bytes2Int(in_string,in_signedness,in_endianess)">bytes2Int</a>(message[wordIndex <span class="keywd">fixLen</span> 4], UNSIGNED, LE));
        wordIndex +:= 4;
      <span class="keywd">end for</span>;

      a := bin32(a0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      b := bin32(b0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      c := bin32(c0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      d := bin32(d0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);

      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 64 <span class="keywd">do</span>
        <span class="keywd">if</span> index &lt;= 16 <span class="keywd">then</span>
          f := d >&lt; (b &amp; (c >&lt; d));
          g := index;
        <span class="keywd">elsif</span> index &lt;= 32 <span class="keywd">then</span>
          f := c >&lt; (d &amp; (b >&lt; c));
          g := (5 * index - 4) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16 + 1;
        <span class="keywd">elsif</span> index &lt;= 48 <span class="keywd">then</span>
          f := b >&lt; c >&lt; d;
          g := (3 * index + 2) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16 + 1;
        <span class="keywd">else</span>
          f := c >&lt; (b | (bin32(16#ffffffff) >&lt; d));
          g := (7 * pred(index)) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16 + 1;
        <span class="keywd">end if</span>;

        temp := d;
        d := c;
        c := b;
        b := bin32((ord(b) +
             ord(<a class="func" href="../libraries/bin32.htm#rotLeft(in_bin32,in_integer)">rotLeft</a>(bin32((ord(a) + ord(f) + k[index] + ord(m[g])) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000),
                         shiftAmount[index]))) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
        a := temp;
      <span class="keywd">end for</span>;

      <span class="comment"># Add this chunk's hash to result so far:</span>
      a0 +:= ord(a);
      b0 +:= ord(b);
      c0 +:= ord(c);
      d0 +:= ord(d);
    <span class="keywd">end while</span>;

    <span class="comment"># Produce the final hash value:</span>
    digest := <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(a0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, LE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(b0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, LE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(c0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, LE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(d0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, LE, 4);
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="ripemd160"><h3>Compute a message digest with the RIPEMD-160 message digest algorithm</h3></a>
<p>
The function <tt><a class="func" href="../libraries/msgdigest.htm#ripemd160(in_var_string)">ripemd160</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/msgdigest.htm">msgdigest.s7i</a>"</span> library.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: ripemd160 (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#string">string</a>: message) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: digest <span class="keywd">is</span> "";
  <span class="keywd">local</span>
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: k1 <span class="keywd">is</span> [] (16#00000000, 16#5a827999, 16#6ed9eba1, 16#8f1bbcdc, 16#a953fd4e);
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: k2 <span class="keywd">is</span> [] (16#50a28be6, 16#5c4dd124, 16#6d703ef3, 16#7a6d76e9, 16#00000000);
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: r1 <span class="keywd">is</span> [] (
         1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
         8,  5, 14,  2, 11,  7, 16,  4, 13,  1, 10,  6,  3, 15, 12,  9,
         4, 11, 15,  5, 10, 16,  9,  2,  3,  8,  1,  7, 14, 12,  6, 13,
         2, 10, 12, 11,  1,  9, 13,  5, 14,  4,  8, 16, 15,  6,  7,  3,
         5,  1,  6, 10,  8, 13,  3, 11, 15,  2,  4,  9, 12,  7, 16, 14);
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: r2 <span class="keywd">is</span> [] (
         6, 15,  8,  1, 10,  3, 12,  5, 14,  7, 16,  9,  2, 11,  4, 13,
         7, 12,  4,  8,  1, 14,  6, 11, 15, 16,  9, 13,  5, 10,  2,  3,
        16,  6,  2,  4,  8, 15,  7, 10, 12,  9, 13,  3, 11,  1,  5, 14,
         9,  7,  5,  2,  4, 12, 16,  1,  6, 13,  3, 14, 10,  8, 11, 15,
        13, 16, 11,  5,  2,  6,  9,  8,  7,  3, 14, 15,  1,  4, 10, 12);
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: s1 <span class="keywd">is</span> [] (
        11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
         7,  6,  8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
        11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
         9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6);
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: s2 <span class="keywd">is</span> [] (
         8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
         9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
         9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
         8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11);
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: wordIndex <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: x <span class="keywd">is</span> 16 <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h0 <span class="keywd">is</span> 16#67452301;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h1 <span class="keywd">is</span> 16#efcdab89;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h2 <span class="keywd">is</span> 16#98badcfe;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h3 <span class="keywd">is</span> 16#10325476;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h4 <span class="keywd">is</span> 16#c3d2e1f0;
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: a1 <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: b1 <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: c1 <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: d1 <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: e1 <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: a2 <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: b2 <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: c2 <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: d2 <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: e2 <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: t1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: t2 <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    length := length(message);
    <span class="comment"># Append the bit '1' to the message.</span>
    message &:= '\16#80;';
    <span class="comment"># Append '0' bits, so that the resulting bit length is congruent to 448 (mod 512).</span>
    message &:= "\0;" <a class="op" href="../libraries/string.htm#(in_string)mult(in_integer)">mult</a> 63 - (length + 8) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 64;
    <span class="comment"># Append length of message (before pre-processing), in bits, as 64-bit little-endian integer.</span>
    message &:= <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(8 * length, UNSIGNED, LE, 8);

    <span class="comment"># Process the message in successive 512-bit chunks:</span>
    <span class="keywd">while</span> wordIndex &lt;= length(message) <span class="keywd">do</span>
      <span class="comment"># Break chunk into sixteen 32-bit little-endian words.</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 16 <span class="keywd">do</span>
        x[index] := <a class="func" href="../libraries/bytedata.htm#bytes2Int(in_string,in_signedness,in_endianess)">bytes2Int</a>(message[wordIndex <span class="keywd">fixLen</span> 4], UNSIGNED, LE);
        wordIndex +:= 4;
      <span class="keywd">end for</span>;

      a1 := bin32(h0);
      b1 := bin32(h1);
      c1 := bin32(h2);
      d1 := bin32(h3);
      e1 := bin32(h4);
      a2 := bin32(h0);
      b2 := bin32(h1);
      c2 := bin32(h2);
      d2 := bin32(h3);
      e2 := bin32(h4);

      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 80 <span class="keywd">do</span>
        <span class="keywd">case</span> index <span class="keywd">of</span>
          <span class="keywd">when</span> {1 .. 16}:
            t1 := ord(b1 >&lt; c1 >&lt; d1);  <span class="comment"># + k1[1];</span>
            t2 := ord(b2 >&lt; (c2 | ~d2)) + k2[1];
          <span class="keywd">when</span> {17 .. 32}:
            t1 := ord((b1 &amp; c1) | (~b1 &amp; d1)) + k1[2];
            t2 := ord((b2 &amp; d2) | (c2 &amp; ~d2)) + k2[2];
          <span class="keywd">when</span> {33 .. 48}:
            t1 := ord((b1 | ~c1) >&lt; d1) + k1[3];
            t2 := ord((b2 | ~c2) >&lt; d2) + k2[3];
          <span class="keywd">when</span> {49 .. 64}:
            t1 := ord((b1 &amp; d1) | (c1 &amp; ~d1)) + k1[4];
            t2 := ord((b2 &amp; c2) | (~b2 &amp; d2)) + k2[4];
          <span class="keywd">when</span> {65 .. 80}:
            t1 := ord(b1 >&lt; (c1 | ~d1)) + k1[5];
            t2 := ord(b2 >&lt; c2 >&lt; d2);  <span class="comment"># + k2[5];</span>
        <span class="keywd">end case</span>;
        t1 +:= ord(a1) + x[r1[index]];
        t1 := ord(<a class="func" href="../libraries/bin32.htm#rotLeft(in_bin32,in_integer)">rotLeft</a>(bin32(t1 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000), s1[index])) + ord(e1);
        a1 := e1;
        e1 := d1;
        d1 := <a class="func" href="../libraries/bin32.htm#rotLeft(in_bin32,in_integer)">rotLeft</a>(c1, 10);
        c1 := b1;
        b1 := bin32(t1 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
        t2 +:= ord(a2) + x[r2[index]];
        t2 := ord(<a class="func" href="../libraries/bin32.htm#rotLeft(in_bin32,in_integer)">rotLeft</a>(bin32(t2 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000), s2[index])) + ord(e2);
        a2 := e2;
        e2 := d2;
        d2 := <a class="func" href="../libraries/bin32.htm#rotLeft(in_bin32,in_integer)">rotLeft</a>(c2, 10);
        c2 := b2;
        b2 := bin32(t2 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      <span class="keywd">end for</span>;

      t1 := (h1 + ord(c1) + ord(d2)) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000;
      h1 := (h2 + ord(d1) + ord(e2)) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000;
      h2 := (h3 + ord(e1) + ord(a2)) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000;
      h3 := (h4 + ord(a1) + ord(b2)) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000;
      h4 := (h0 + ord(b1) + ord(c2)) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000;
      h0 := t1;
    <span class="keywd">end while</span>;

    <span class="comment"># Produce the final hash value:</span>
    digest := <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h0, UNSIGNED, LE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h1, UNSIGNED, LE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h2, UNSIGNED, LE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h3, UNSIGNED, LE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h4, UNSIGNED, LE, 4);
  end func;
</pre></div>

<div><a name="sha1"><h3>Compute a secure hash value with the SHA-1 algorithm</h3></a>
<p>
The function <tt><a class="func" href="../libraries/msgdigest.htm#sha1(in_var_string)">sha1</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/msgdigest.htm">msgdigest.s7i</a>"</span> library.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: sha1 (<span class="keywd">in</span> var <a class="type" href="../manual/types.htm#string">string</a>: message) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: digest <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: wordIndex <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: w <span class="keywd">is</span> 80 <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>.value;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h0 <span class="keywd">is</span> 16#67452301;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h1 <span class="keywd">is</span> 16#efcdab89;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h2 <span class="keywd">is</span> 16#98badcfe;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h3 <span class="keywd">is</span> 16#10325476;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h4 <span class="keywd">is</span> 16#c3d2e1f0;
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: a <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: b <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: c <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: d <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: e <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: f <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: g <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: temp <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: k <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    length := length(message);
    <span class="comment"># Append the bit '1' to the message.</span>
    message &:= '\16#80;';
    <span class="comment"># Append '0' bits, so that the resulting bit length is congruent to 448 (mod 512).</span>
    message &:= "\0;" <a class="op" href="../libraries/string.htm#(in_string)mult(in_integer)">mult</a> 63 - (length + 8) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 64;
    <span class="comment"># Append length of message (before pre-processing), in bits, as 64-bit big-endian integer.</span>
    message &:= <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(8 * length, UNSIGNED, BE, 8);

    <span class="comment"># Process the message in successive 512-bit chunks:</span>
    <span class="keywd">while</span> wordIndex &lt;= length(message) <span class="keywd">do</span>
      <span class="comment"># Break chunk into sixteen 32-bit big-endian words.</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 16 <span class="keywd">do</span>
        w[index] := bin32(<a class="func" href="../libraries/bytedata.htm#bytes2Int(in_string,in_signedness,in_endianess)">bytes2Int</a>(message[wordIndex <span class="keywd">fixLen</span> 4], UNSIGNED, BE));
        wordIndex +:= 4;
      <span class="keywd">end for</span>;

      <span class="comment"># Extend the sixteen 32-bit words into eighty 32-bit words.</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 17 <span class="keywd">to</span> 80 <span class="keywd">do</span>
        g := w[index-3] >&lt; w[index-8] >&lt; w[index-14] >&lt; w[index-16];
        w[index] := <a class="func" href="../libraries/bin32.htm#rotLeft(in_bin32,in_integer)">rotLeft</a>(g, 1);
      <span class="keywd">end for</span>;

      a := bin32(h0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      b := bin32(h1 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      c := bin32(h2 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      d := bin32(h3 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      e := bin32(h4 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);

      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 80 <span class="keywd">do</span>
        <span class="keywd">if</span> index &lt;= 20 <span class="keywd">then</span>
          f := d >&lt; (b &amp; (c >&lt; d));
          k := 16#5a827999;
        <span class="keywd">elsif</span> index &lt;= 40 <span class="keywd">then</span>
          f := b >&lt; c >&lt; d;
          k := 16#6ed9eba1;
        <span class="keywd">elsif</span> index &lt;= 60 <span class="keywd">then</span>
          f := (b &amp; c) | (d &amp; (b | c));
          k := 16#8f1bbcdc;
        <span class="keywd">else</span>
          f := b >&lt; c >&lt; d;
          k := 16#ca62c1d6;
        <span class="keywd">end if</span>;

        temp := ord(<a class="func" href="../libraries/bin32.htm#rotLeft(in_bin32,in_integer)">rotLeft</a>(a, 5));
        temp +:= ord(f) + ord(e) + k + ord(w[index]);
        e := d;
        d := c;
        c := <a class="func" href="../libraries/bin32.htm#rotLeft(in_bin32,in_integer)">rotLeft</a>(b, 30);
        b := a;
        a := bin32(temp <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      <span class="keywd">end for</span>;

      <span class="comment"># Add this chunk's hash to result so far:</span>
      h0 +:= ord(a);
      h1 +:= ord(b);
      h2 +:= ord(c);
      h3 +:= ord(d);
      h4 +:= ord(e);
    <span class="keywd">end while</span>;

    <span class="comment"># Produce the final hash value:</span>
    digest := <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h1 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h2 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h3 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h4 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4);
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="sha224"><h3>Compute a secure hash value with the SHA-224 algorithm</h3></a>
<p>
The function <tt><a class="func" href="../libraries/msgdigest.htm#sha224(in_var_string)">sha224</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/msgdigest.htm">msgdigest.s7i</a>"</span> library.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: sha224 (<span class="keywd">in</span> var <a class="type" href="../manual/types.htm#string">string</a>: message) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: digest <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="comment"># Initialize array of round constants with the first 32 bits of</span>
    <span class="comment"># the fractional parts of the cube roots of the first 64 primes 2..311.</span>
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: k <span class="keywd">is</span> [] (
        16#428a2f98, 16#71374491, 16#b5c0fbcf, 16#e9b5dba5, 16#3956c25b, 16#59f111f1, 16#923f82a4, 16#ab1c5ed5,
        16#d807aa98, 16#12835b01, 16#243185be, 16#550c7dc3, 16#72be5d74, 16#80deb1fe, 16#9bdc06a7, 16#c19bf174,
        16#e49b69c1, 16#efbe4786, 16#0fc19dc6, 16#240ca1cc, 16#2de92c6f, 16#4a7484aa, 16#5cb0a9dc, 16#76f988da,
        16#983e5152, 16#a831c66d, 16#b00327c8, 16#bf597fc7, 16#c6e00bf3, 16#d5a79147, 16#06ca6351, 16#14292967,
        16#27b70a85, 16#2e1b2138, 16#4d2c6dfc, 16#53380d13, 16#650a7354, 16#766a0abb, 16#81c2c92e, 16#92722c85,
        16#a2bfe8a1, 16#a81a664b, 16#c24b8b70, 16#c76c51a3, 16#d192e819, 16#d6990624, 16#f40e3585, 16#106aa070,
        16#19a4c116, 16#1e376c08, 16#2748774c, 16#34b0bcb5, 16#391c0cb3, 16#4ed8aa4a, 16#5b9cca4f, 16#682e6ff3,
        16#748f82ee, 16#78a5636f, 16#84c87814, 16#8cc70208, 16#90befffa, 16#a4506ceb, 16#bef9a3f7, 16#c67178f2);
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: wordIndex <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: w <span class="keywd">is</span> 64 <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>.value;
    <span class="comment"># Initialize hash values with the second 32 bits of</span>
    <span class="comment"># the fractional parts of the square roots of the 9th through 16th primes 23..53.</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h0 <span class="keywd">is</span> 16#c1059ed8;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h1 <span class="keywd">is</span> 16#367cd507;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h2 <span class="keywd">is</span> 16#3070dd17;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h3 <span class="keywd">is</span> 16#f70e5939;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h4 <span class="keywd">is</span> 16#ffc00b31;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h5 <span class="keywd">is</span> 16#68581511;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h6 <span class="keywd">is</span> 16#64f98fa7;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h7 <span class="keywd">is</span> 16#befa4fa4;
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: a <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: b <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: c <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: d <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: e <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: f <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: g <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: h <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: s0 <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: s1 <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: temp1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: temp2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: ch <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: maj <span class="keywd">is</span> bin32(0);
  <span class="keywd">begin</span>
    length := length(message);
    <span class="comment"># Append the bit '1' to the message.</span>
    message &:= '\16#80;';
    <span class="comment"># Append '0' bits, so that the resulting bit length is congruent to 448 (mod 512).</span>
    message &:= "\0;" <a class="op" href="../libraries/string.htm#(in_string)mult(in_integer)">mult</a> 63 - (length + 8) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 64;
    <span class="comment"># Append length of message (before pre-processing), in bits, as 64-bit big-endian integer.</span>
    message &:= <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(8 * length, UNSIGNED, BE, 8);

    <span class="comment"># Process the message in successive 512-bit chunks:</span>
    <span class="keywd">while</span> wordIndex &lt;= length(message) <span class="keywd">do</span>
      <span class="comment"># Break chunk into sixteen 32-bit big-endian words.</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 16 <span class="keywd">do</span>
        w[index] := bin32(<a class="func" href="../libraries/bytedata.htm#bytes2Int(in_string,in_signedness,in_endianess)">bytes2Int</a>(message[wordIndex <span class="keywd">fixLen</span> 4], UNSIGNED, BE));
        wordIndex +:= 4;
      <span class="keywd">end for</span>;

      <span class="comment"># Extend the first 16 words into the remaining 48 words of message schedule array:</span>
      <span class="keywd">for</span> index <span class="keywd">range </span>17 <span class="keywd">to</span> 64 <span class="keywd">do</span>
        w[index] := bin32(ord(w[index-16]) +
                          ord(<a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(w[index-15], 7) >&lt; <a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(w[index-15], 18) >&lt; (w[index-15] >> 3)) +
                          ord(w[index-7]) +
                          ord(<a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(w[index-2], 17) >&lt; <a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(w[index-2], 19) >&lt; (w[index-2] >> 10))) &
                    bin32(16#ffffffff);
      <span class="keywd">end for</span>;

      <span class="comment"># Initialize working variables to current hash value:</span>
      a := bin32(h0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      b := bin32(h1 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      c := bin32(h2 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      d := bin32(h3 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      e := bin32(h4 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      f := bin32(h5 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      g := bin32(h6 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      h := bin32(h7 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);

      <span class="comment"># Compression function main loop:</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 64 <span class="keywd">do</span>
        s1 := <a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(e, 6) >&lt; <a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(e, 11) >&lt; <a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(e, 25);
        ch := (e &amp; f) >&lt; ((bin32(16#ffffffff) >&lt; e) &amp; g);
        temp1 := ord(h) + ord(s1) + ord(ch) + k[index] + ord(w[index]);
        s0 := <a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(a, 2) >&lt; <a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(a, 13) >&lt; <a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(a, 22);
        maj := (a &amp; b) >&lt; (a &amp; c) >&lt; (b &amp; c);
        temp2 := ord(s0) + ord(maj);

        h := g;
        g := f;
        f := e;
        e := bin32((ord(d) + temp1) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
        d := c;
        c := b;
        b := a;
        a := bin32((temp1 + temp2) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      <span class="keywd">end for</span>;

      <span class="comment"># Add the compressed chunk to the current hash value:</span>
      h0 +:= ord(a);
      h1 +:= ord(b);
      h2 +:= ord(c);
      h3 +:= ord(d);
      h4 +:= ord(e);
      h5 +:= ord(f);
      h6 +:= ord(g);
      h7 +:= ord(h);
    <span class="keywd">end while</span>;

    <span class="comment"># Produce the final hash value:</span>
    digest := <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h1 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h2 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h3 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h4 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h5 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h6 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4);
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="sha256"><h3>Compute a secure hash value with the SHA-256 algorithm</h3></a>
<p>
The function <tt><a class="func" href="../libraries/msgdigest.htm#sha256(in_var_string)">sha256</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/msgdigest.htm">msgdigest.s7i</a>"</span> library.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: sha256 (<span class="keywd">in</span> var <a class="type" href="../manual/types.htm#string">string</a>: message) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: digest <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="comment"># Initialize array of round constants with the first 32 bits of</span>
    <span class="comment"># the fractional parts of the cube roots of the first 64 primes 2..311.</span>
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: k <span class="keywd">is</span> [] (
        16#428a2f98, 16#71374491, 16#b5c0fbcf, 16#e9b5dba5, 16#3956c25b, 16#59f111f1, 16#923f82a4, 16#ab1c5ed5,
        16#d807aa98, 16#12835b01, 16#243185be, 16#550c7dc3, 16#72be5d74, 16#80deb1fe, 16#9bdc06a7, 16#c19bf174,
        16#e49b69c1, 16#efbe4786, 16#0fc19dc6, 16#240ca1cc, 16#2de92c6f, 16#4a7484aa, 16#5cb0a9dc, 16#76f988da,
        16#983e5152, 16#a831c66d, 16#b00327c8, 16#bf597fc7, 16#c6e00bf3, 16#d5a79147, 16#06ca6351, 16#14292967,
        16#27b70a85, 16#2e1b2138, 16#4d2c6dfc, 16#53380d13, 16#650a7354, 16#766a0abb, 16#81c2c92e, 16#92722c85,
        16#a2bfe8a1, 16#a81a664b, 16#c24b8b70, 16#c76c51a3, 16#d192e819, 16#d6990624, 16#f40e3585, 16#106aa070,
        16#19a4c116, 16#1e376c08, 16#2748774c, 16#34b0bcb5, 16#391c0cb3, 16#4ed8aa4a, 16#5b9cca4f, 16#682e6ff3,
        16#748f82ee, 16#78a5636f, 16#84c87814, 16#8cc70208, 16#90befffa, 16#a4506ceb, 16#bef9a3f7, 16#c67178f2);
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: wordIndex <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: w <span class="keywd">is</span> 64 <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>.value;
    <span class="comment"># Initialize hash values with the first 32 bits of</span>
    <span class="comment"># the fractional parts of the square roots of the first 8 primes 2..19.</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h0 <span class="keywd">is</span> 16#6a09e667;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h1 <span class="keywd">is</span> 16#bb67ae85;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h2 <span class="keywd">is</span> 16#3c6ef372;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h3 <span class="keywd">is</span> 16#a54ff53a;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h4 <span class="keywd">is</span> 16#510e527f;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h5 <span class="keywd">is</span> 16#9b05688c;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h6 <span class="keywd">is</span> 16#1f83d9ab;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: h7 <span class="keywd">is</span> 16#5be0cd19;
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: a <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: b <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: c <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: d <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: e <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: f <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: g <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: h <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: s0 <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: s1 <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: temp1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: temp2 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: ch <span class="keywd">is</span> bin32(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin32.htm#bin32">bin32</a>: maj <span class="keywd">is</span> bin32(0);
  <span class="keywd">begin</span>
    length := length(message);
    <span class="comment"># Append the bit '1' to the message.</span>
    message &:= '\16#80;';
    <span class="comment"># Append '0' bits, so that the resulting bit length is congruent to 448 (mod 512).</span>
    message &:= "\0;" <a class="op" href="../libraries/string.htm#(in_string)mult(in_integer)">mult</a> 63 - (length + 8) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 64;
    <span class="comment"># Append length of message (before pre-processing), in bits, as 64-bit big-endian integer.</span>
    message &:= <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(8 * length, UNSIGNED, BE, 8);

    <span class="comment"># Process the message in successive 512-bit chunks:</span>
    <span class="keywd">while</span> wordIndex &lt;= length(message) <span class="keywd">do</span>
      <span class="comment"># Break chunk into sixteen 32-bit big-endian words.</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 16 <span class="keywd">do</span>
        w[index] := bin32(<a class="func" href="../libraries/bytedata.htm#bytes2Int(in_string,in_signedness,in_endianess)">bytes2Int</a>(message[wordIndex <span class="keywd">fixLen</span> 4], UNSIGNED, BE));
        wordIndex +:= 4;
      <span class="keywd">end for</span>;

      <span class="comment"># Extend the first 16 words into the remaining 48 words of message schedule array:</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 17 <span class="keywd">to</span> 64 <span class="keywd">do</span>
        w[index] := bin32(ord(w[index-16]) +
                          ord(<a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(w[index-15], 7) >&lt; <a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(w[index-15], 18) >&lt; (w[index-15] >> 3)) +
                          ord(w[index-7]) +
                          ord(<a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(w[index-2], 17) >&lt; <a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(w[index-2], 19) >&lt; (w[index-2] >> 10))) &
                    bin32(16#ffffffff);
      <span class="keywd">end for</span>;

      <span class="comment"># Initialize working variables to current hash value:</span>
      a := bin32(h0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      b := bin32(h1 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      c := bin32(h2 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      d := bin32(h3 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      e := bin32(h4 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      f := bin32(h5 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      g := bin32(h6 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      h := bin32(h7 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);

      <span class="comment"># Compression function main loop:</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 64 <span class="keywd">do</span>
        s1 := <a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(e, 6) >&lt; <a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(e, 11) >&lt; <a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(e, 25);
        ch := (e &amp; f) >&lt; ((bin32(16#ffffffff) >&lt; e) &amp; g);
        temp1 := ord(h) + ord(s1) + ord(ch) + k[index] + ord(w[index]);
        s0 := <a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(a, 2) >&lt; <a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(a, 13) >&lt; <a class="func" href="../libraries/bin32.htm#rotRight(in_bin32,in_integer)">rotRight</a>(a, 22);
        maj := (a &amp; b) >&lt; (a &amp; c) >&lt; (b &amp; c);
        temp2 := ord(s0) + ord(maj);

        h := g;
        g := f;
        f := e;
        e := bin32((ord(d) + temp1) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
        d := c;
        c := b;
        b := a;
        a := bin32((temp1 + temp2) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000);
      <span class="keywd">end for</span>;

      <span class="comment"># Add the compressed chunk to the current hash value:</span>
      h0 +:= ord(a);
      h1 +:= ord(b);
      h2 +:= ord(c);
      h3 +:= ord(d);
      h4 +:= ord(e);
      h5 +:= ord(f);
      h6 +:= ord(g);
      h7 +:= ord(h);
    <span class="keywd">end while</span>;

    <span class="comment"># Produce the final hash value:</span>
    digest := <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h0 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h1 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h2 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h3 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h4 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h5 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h6 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4) &
              <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(h7 <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#100000000, UNSIGNED, BE, 4);
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="sha384"><h3>Compute a secure hash value with the SHA-384 algorithm</h3></a>
<p>
Compute a message digest with the SHA-384 secure hash algorithm.
The SHA-384 message digest is a string of 48 bytes.
</p><pre class="indent">
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/bytedata.htm">bytedata.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/bin64.htm">bin64.s7i</a>"</span>;

<span class="keywd">const</span> func <a class="type" href="../manual/types.htm#string">string</a>: sha384 (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#string">string</a>: message) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: digest <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: powTwo64 <span class="keywd">is</span> 2_**64;
    <span class="comment"># Initialize array of round constants with the first 64 bits of</span>
    <span class="comment"># the fractional parts of the cube roots of the first 80 primes 2..409.</span>
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: k <span class="keywd">is</span> [] (
        bin64(16#428a2f98d728ae22_), bin64(16#7137449123ef65cd_), bin64(16#b5c0fbcfec4d3b2f_), bin64(16#e9b5dba58189dbbc_),
        bin64(16#3956c25bf348b538_), bin64(16#59f111f1b605d019_), bin64(16#923f82a4af194f9b_), bin64(16#ab1c5ed5da6d8118_),
        bin64(16#d807aa98a3030242_), bin64(16#12835b0145706fbe_), bin64(16#243185be4ee4b28c_), bin64(16#550c7dc3d5ffb4e2_),
        bin64(16#72be5d74f27b896f_), bin64(16#80deb1fe3b1696b1_), bin64(16#9bdc06a725c71235_), bin64(16#c19bf174cf692694_),
        bin64(16#e49b69c19ef14ad2_), bin64(16#efbe4786384f25e3_), bin64(16#0fc19dc68b8cd5b5_), bin64(16#240ca1cc77ac9c65_),
        bin64(16#2de92c6f592b0275_), bin64(16#4a7484aa6ea6e483_), bin64(16#5cb0a9dcbd41fbd4_), bin64(16#76f988da831153b5_),
        bin64(16#983e5152ee66dfab_), bin64(16#a831c66d2db43210_), bin64(16#b00327c898fb213f_), bin64(16#bf597fc7beef0ee4_),
        bin64(16#c6e00bf33da88fc2_), bin64(16#d5a79147930aa725_), bin64(16#06ca6351e003826f_), bin64(16#142929670a0e6e70_),
        bin64(16#27b70a8546d22ffc_), bin64(16#2e1b21385c26c926_), bin64(16#4d2c6dfc5ac42aed_), bin64(16#53380d139d95b3df_),
        bin64(16#650a73548baf63de_), bin64(16#766a0abb3c77b2a8_), bin64(16#81c2c92e47edaee6_), bin64(16#92722c851482353b_),
        bin64(16#a2bfe8a14cf10364_), bin64(16#a81a664bbc423001_), bin64(16#c24b8b70d0f89791_), bin64(16#c76c51a30654be30_),
        bin64(16#d192e819d6ef5218_), bin64(16#d69906245565a910_), bin64(16#f40e35855771202a_), bin64(16#106aa07032bbd1b8_),
        bin64(16#19a4c116b8d2d0c8_), bin64(16#1e376c085141ab53_), bin64(16#2748774cdf8eeb99_), bin64(16#34b0bcb5e19b48a8_),
        bin64(16#391c0cb3c5c95a63_), bin64(16#4ed8aa4ae3418acb_), bin64(16#5b9cca4f7763e373_), bin64(16#682e6ff3d6b2b8a3_),
        bin64(16#748f82ee5defb2fc_), bin64(16#78a5636f43172f60_), bin64(16#84c87814a1f0ab72_), bin64(16#8cc702081a6439ec_),
        bin64(16#90befffa23631e28_), bin64(16#a4506cebde82bde9_), bin64(16#bef9a3f7b2c67915_), bin64(16#c67178f2e372532b_),
        bin64(16#ca273eceea26619c_), bin64(16#d186b8c721c0c207_), bin64(16#eada7dd6cde0eb1e_), bin64(16#f57d4f7fee6ed178_),
        bin64(16#06f067aa72176fba_), bin64(16#0a637dc5a2c898a6_), bin64(16#113f9804bef90dae_), bin64(16#1b710b35131c471b_),
        bin64(16#28db77f523047d84_), bin64(16#32caab7b40c72493_), bin64(16#3c9ebe0a15c9bebc_), bin64(16#431d67c49c100d4c_),
        bin64(16#4cc5d4becb3e42b6_), bin64(16#597f299cfc657e2a_), bin64(16#5fcb6fab3ad6faec_), bin64(16#6c44198c4a475817_));
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: chunkIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: w <span class="keywd">is</span> 80 <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>.value;
    <span class="comment"># Initialize hash values with the first 64 bits of</span>
    <span class="comment"># the fractional parts of the square roots of the first 8 primes 2..19.</span>
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: h0 <span class="keywd">is</span> bin64(16#cbbb9d5dc1059ed8_);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: h1 <span class="keywd">is</span> bin64(16#629a292a367cd507_);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: h2 <span class="keywd">is</span> bin64(16#9159015a3070dd17_);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: h3 <span class="keywd">is</span> bin64(16#152fecd8f70e5939_);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: h4 <span class="keywd">is</span> bin64(16#67332667ffc00b31_);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: h5 <span class="keywd">is</span> bin64(16#8eb44a8768581511_);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: h6 <span class="keywd">is</span> bin64(16#db0c2e0d64f98fa7_);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: h7 <span class="keywd">is</span> bin64(16#47b5481dbefa4fa4_);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: a <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: b <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: c <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: d <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: e <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: f <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: g <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: h <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: s0 <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: s1 <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: temp1 <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: temp2 <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: ch <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: maj <span class="keywd">is</span> bin64(0);
  <span class="keywd">begin</span>
    length := length(message);
    <span class="comment"># Append the bit '1' to the message.</span>
    message &:= '\16#80;';
    <span class="comment"># Append '0' bits, so that the resulting bit length is congruent to 448 (mod 1024).</span>
    message &:= "\0;" <a class="op" href="../libraries/string.htm#(in_string)mult(in_integer)">mult</a> 127 - (length + 8) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 128;
    <span class="comment"># Append length of message (before pre-processing), in bits, as 64-bit big-endian integer.</span>
    message &:= <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(8 * length, UNSIGNED, BE, 8);

    <span class="comment"># Process the message in successive 1024-bit chunks:</span>
    <span class="keywd">for</span> chunkIndex <span class="keywd">range</span> 1 <span class="keywd">to</span> length(message) <span class="keywd">step</span> 128 <span class="keywd">do</span>
      <span class="comment"># Check that the input contains no character beyond '\255;'.</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 0 <span class="keywd">to</span> 127 <span class="keywd">do</span>
        <span class="keywd">if</span> ord(message[chunkIndex + index]) > 255 <span class="keywd">then</span>
          <span class="keywd">raise</span> RANGE_ERROR;
        <span class="keywd">end if</span>;
      <span class="keywd">end for</span>;

      <span class="comment"># Break chunk into sixteen 64-bit big-endian words.</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 16 <span class="keywd">do</span>
        w[index] := bin64(message[chunkIndex + 8 * pred(index) <span class="keywd">fixLen</span> 8], BE);
      <span class="keywd">end for</span>;

      <span class="comment"># Extend the first 16 words into the remaining 64 words of message schedule array:</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 17 <span class="keywd">to</span> 80 <span class="keywd">do</span>
        w[index] := bin64((big(w[index-16]) +
                           big(<a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(w[index-15], 1) ><
                               <a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(w[index-15], 8) ><
                               (w[index-15] >> 7)) +
                           big(w[index-7]) +
                           big(<a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(w[index-2], 19) ><
                               <a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(w[index-2], 61) ><
                               (w[index-2] >> 6))) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> powTwo64);
      <span class="keywd">end for</span>;

      <span class="comment"># Initialize working variables to current hash value:</span>
      a := h0;
      b := h1;
      c := h2;
      d := h3;
      e := h4;
      f := h5;
      g := h6;
      h := h7;

      <span class="comment"># Compression function main loop:</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 80 <span class="keywd">do</span>
        s1 := <a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(e, 14) >&lt; <a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(e, 18) >&lt; <a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(e, 41);
        ch := (e &amp; f) >&lt; (~e &amp; g);
        temp1 := bin64((big(h) + big(s1) + big(ch) + big(k[index]) + big(w[index])) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> powTwo64);
        s0 := <a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(a, 28) >&lt; <a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(a, 34) >&lt; <a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(a, 39);
        maj := (a &amp; b) >&lt; (a &amp; c) >&lt; (b &amp; c);
        temp2 := bin64((big(s0) + big(maj)) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> powTwo64);

        h := g;
        g := f;
        f := e;
        e := bin64((big(d) + big(temp1)) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> powTwo64);
        d := c;
        c := b;
        b := a;
        a := bin64((big(temp1) + big(temp2)) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> powTwo64);
      <span class="keywd">end for</span>;

      <span class="comment"># Add the compressed chunk to the current hash value:</span>
      h0 := bin64((big(h0) + big(a)) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> powTwo64);
      h1 := bin64((big(h1) + big(b)) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> powTwo64);
      h2 := bin64((big(h2) + big(c)) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> powTwo64);
      h3 := bin64((big(h3) + big(d)) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> powTwo64);
      h4 := bin64((big(h4) + big(e)) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> powTwo64);
      h5 := bin64((big(h5) + big(f)) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> powTwo64);
      h6 := bin64((big(h6) + big(g)) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> powTwo64);
      h7 := bin64((big(h7) + big(h)) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> powTwo64);
    <span class="keywd">end for</span>;

    <span class="comment"># Produce the final hash value:</span>
    digest := <a class="func" href="../libraries/bin64.htm#bytes(in_bin64,BE,in_integer)">bytes</a>(h0, BE, 8) &
              <a class="func" href="../libraries/bin64.htm#bytes(in_bin64,BE,in_integer)">bytes</a>(h1, BE, 8) &
              <a class="func" href="../libraries/bin64.htm#bytes(in_bin64,BE,in_integer)">bytes</a>(h2, BE, 8) &
              <a class="func" href="../libraries/bin64.htm#bytes(in_bin64,BE,in_integer)">bytes</a>(h3, BE, 8) &
              <a class="func" href="../libraries/bin64.htm#bytes(in_bin64,BE,in_integer)">bytes</a>(h4, BE, 8) &
              <a class="func" href="../libraries/bin64.htm#bytes(in_bin64,BE,in_integer)">bytes</a>(h5, BE, 8);
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="sha512"><h3>Compute a secure hash value with the SHA-512 algorithm</h3></a>
<p>
Compute a message digest with the SHA-512 secure hash algorithm.
The SHA-512 message digest is a string of 64 bytes.
</p><pre class="indent">
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/bytedata.htm">bytedata.s7i</a>"</span>;
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/bin64.htm">bin64.s7i</a>"</span>;

<span class="keywd">const</span> func <a class="type" href="../manual/types.htm#string">string</a>: sha512 (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#string">string</a>: message) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: digest <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: powTwo64 <span class="keywd">is</span> 2_**64;
    <span class="comment"># Initialize array of round constants with the first 64 bits of</span>
    <span class="comment"># the fractional parts of the cube roots of the first 80 primes 2..409.</span>
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: k <span class="keywd">is</span> [] (
        bin64(16#428a2f98d728ae22_), bin64(16#7137449123ef65cd_), bin64(16#b5c0fbcfec4d3b2f_), bin64(16#e9b5dba58189dbbc_),
        bin64(16#3956c25bf348b538_), bin64(16#59f111f1b605d019_), bin64(16#923f82a4af194f9b_), bin64(16#ab1c5ed5da6d8118_),
        bin64(16#d807aa98a3030242_), bin64(16#12835b0145706fbe_), bin64(16#243185be4ee4b28c_), bin64(16#550c7dc3d5ffb4e2_),
        bin64(16#72be5d74f27b896f_), bin64(16#80deb1fe3b1696b1_), bin64(16#9bdc06a725c71235_), bin64(16#c19bf174cf692694_),
        bin64(16#e49b69c19ef14ad2_), bin64(16#efbe4786384f25e3_), bin64(16#0fc19dc68b8cd5b5_), bin64(16#240ca1cc77ac9c65_),
        bin64(16#2de92c6f592b0275_), bin64(16#4a7484aa6ea6e483_), bin64(16#5cb0a9dcbd41fbd4_), bin64(16#76f988da831153b5_),
        bin64(16#983e5152ee66dfab_), bin64(16#a831c66d2db43210_), bin64(16#b00327c898fb213f_), bin64(16#bf597fc7beef0ee4_),
        bin64(16#c6e00bf33da88fc2_), bin64(16#d5a79147930aa725_), bin64(16#06ca6351e003826f_), bin64(16#142929670a0e6e70_),
        bin64(16#27b70a8546d22ffc_), bin64(16#2e1b21385c26c926_), bin64(16#4d2c6dfc5ac42aed_), bin64(16#53380d139d95b3df_),
        bin64(16#650a73548baf63de_), bin64(16#766a0abb3c77b2a8_), bin64(16#81c2c92e47edaee6_), bin64(16#92722c851482353b_),
        bin64(16#a2bfe8a14cf10364_), bin64(16#a81a664bbc423001_), bin64(16#c24b8b70d0f89791_), bin64(16#c76c51a30654be30_),
        bin64(16#d192e819d6ef5218_), bin64(16#d69906245565a910_), bin64(16#f40e35855771202a_), bin64(16#106aa07032bbd1b8_),
        bin64(16#19a4c116b8d2d0c8_), bin64(16#1e376c085141ab53_), bin64(16#2748774cdf8eeb99_), bin64(16#34b0bcb5e19b48a8_),
        bin64(16#391c0cb3c5c95a63_), bin64(16#4ed8aa4ae3418acb_), bin64(16#5b9cca4f7763e373_), bin64(16#682e6ff3d6b2b8a3_),
        bin64(16#748f82ee5defb2fc_), bin64(16#78a5636f43172f60_), bin64(16#84c87814a1f0ab72_), bin64(16#8cc702081a6439ec_),
        bin64(16#90befffa23631e28_), bin64(16#a4506cebde82bde9_), bin64(16#bef9a3f7b2c67915_), bin64(16#c67178f2e372532b_),
        bin64(16#ca273eceea26619c_), bin64(16#d186b8c721c0c207_), bin64(16#eada7dd6cde0eb1e_), bin64(16#f57d4f7fee6ed178_),
        bin64(16#06f067aa72176fba_), bin64(16#0a637dc5a2c898a6_), bin64(16#113f9804bef90dae_), bin64(16#1b710b35131c471b_),
        bin64(16#28db77f523047d84_), bin64(16#32caab7b40c72493_), bin64(16#3c9ebe0a15c9bebc_), bin64(16#431d67c49c100d4c_),
        bin64(16#4cc5d4becb3e42b6_), bin64(16#597f299cfc657e2a_), bin64(16#5fcb6fab3ad6faec_), bin64(16#6c44198c4a475817_));
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: chunkIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: w <span class="keywd">is</span> 80 <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>.value;
    <span class="comment"># Initialize hash values with the first 64 bits of</span>
    <span class="comment"># the fractional parts of the square roots of the first 8 primes 2..19.</span>
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: h0 <span class="keywd">is</span> bin64(16#6a09e667f3bcc908_);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: h1 <span class="keywd">is</span> bin64(16#bb67ae8584caa73b_);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: h2 <span class="keywd">is</span> bin64(16#3c6ef372fe94f82b_);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: h3 <span class="keywd">is</span> bin64(16#a54ff53a5f1d36f1_);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: h4 <span class="keywd">is</span> bin64(16#510e527fade682d1_);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: h5 <span class="keywd">is</span> bin64(16#9b05688c2b3e6c1f_);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: h6 <span class="keywd">is</span> bin64(16#1f83d9abfb41bd6b_);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: h7 <span class="keywd">is</span> bin64(16#5be0cd19137e2179_);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: a <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: b <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: c <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: d <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: e <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: f <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: g <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: h <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: s0 <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: s1 <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: temp1 <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: temp2 <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: ch <span class="keywd">is</span> bin64(0);
    <span class="keywd">var</span> <a class="type" href="../libraries/bin64.htm#bin64">bin64</a>: maj <span class="keywd">is</span> bin64(0);
  begin
    length := length(message);
    <span class="comment"># Append the bit '1' to the message.</span>
    message &:= '\16#80;';
    <span class="comment"># Append '0' bits, so that the resulting bit length is congruent to 448 (mod 1024).</span>
    message &:= "\0;" <a class="op" href="../libraries/string.htm#(in_string)mult(in_integer)">mult</a> 127 - (length + 8) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 128;
    <span class="comment"># Append length of message (before pre-processing), in bits, as 64-bit big-endian integer.</span>
    message &:= <a class="func" href="../libraries/bytedata.htm#bytes(in_integer,in_signedness,in_endianness,in_integer)">bytes</a>(8 * length, UNSIGNED, BE, 8);

    <span class="comment"># Process the message in successive 1024-bit chunks:</span>
    <span class="keywd">for</span> chunkIndex <span class="keywd">range</span> 1 <span class="keywd">to</span> length(message) <span class="keywd">step</span> 128 <span class="keywd">do</span>
      <span class="comment"># Check that the input contains no character beyond '\255;'.</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 0 <span class="keywd">to</span> 127 <span class="keywd">do</span>
        <span class="keywd">if</span> ord(message[chunkIndex + index]) > 255 <span class="keywd">then</span>
          <span class="keywd">raise</span> RANGE_ERROR;
        <span class="keywd">end if</span>;
      <span class="keywd">end for</span>;

      <span class="comment"># Break chunk into sixteen 64-bit big-endian words.</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 16 <span class="keywd">do</span>
        w[index] := bin64(message[chunkIndex + 8 * pred(index) <span class="keywd">fixLen</span> 8], BE);
      <span class="keywd">end for</span>;

      <span class="comment"># Extend the first 16 words into the remaining 64 words of message schedule array:</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 17 <span class="keywd">to</span> 80 <span class="keywd">do</span>
        w[index] := bin64((big(w[index-16]) +
                           big(<a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(w[index-15], 1) ><
                               <a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(w[index-15], 8) ><
                               (w[index-15] >> 7)) +
                           big(w[index-7]) +
                           big(<a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(w[index-2], 19) ><
                               <a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(w[index-2], 61) ><
                               (w[index-2] >> 6))) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> powTwo64);
      <span class="keywd">end for</span>;

      <span class="comment"># Initialize working variables to current hash value:</span>
      a := h0;
      b := h1;
      c := h2;
      d := h3;
      e := h4;
      f := h5;
      g := h6;
      h := h7;

      <span class="comment"># Compression function main loop:</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> 80 <span class="keywd">do</span>
        s1 := <a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(e, 14) >&lt; <a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(e, 18) >&lt; <a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(e, 41);
        ch := (e &amp; f) >&lt; (~e &amp; g);
        temp1 := bin64((big(h) + big(s1) + big(ch) + big(k[index]) + big(w[index])) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> powTwo64);
        s0 := <a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(a, 28) >&lt; <a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(a, 34) >&lt; <a class="func" href="../libraries/bin64.htm#rotRight(in_bin64,in_integer)">rotRight</a>(a, 39);
        maj := (a &amp; b) >&lt; (a &amp; c) >&lt; (b &amp; c);
        temp2 := bin64((big(s0) + big(maj)) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> powTwo64);

        h := g;
        g := f;
        f := e;
        e := bin64((big(d) + big(temp1)) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> powTwo64);
        d := c;
        c := b;
        b := a;
        a := bin64((big(temp1) + big(temp2)) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> powTwo64);
      <span class="keywd">end for</span>;

      <span class="comment"># Add the compressed chunk to the current hash value:</span>
      h0 := bin64((big(h0) + big(a)) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> powTwo64);
      h1 := bin64((big(h1) + big(b)) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> powTwo64);
      h2 := bin64((big(h2) + big(c)) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> powTwo64);
      h3 := bin64((big(h3) + big(d)) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> powTwo64);
      h4 := bin64((big(h4) + big(e)) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> powTwo64);
      h5 := bin64((big(h5) + big(f)) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> powTwo64);
      h6 := bin64((big(h6) + big(g)) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> powTwo64);
      h7 := bin64((big(h7) + big(h)) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> powTwo64);
    <span class="keywd">end for</span>;

    <span class="comment"># Produce the final hash value:</span>
    digest := <a class="func" href="../libraries/bin64.htm#bytes(in_bin64,BE,in_integer)">bytes</a>(h0, BE, 8) &
              <a class="func" href="../libraries/bin64.htm#bytes(in_bin64,BE,in_integer)">bytes</a>(h1, BE, 8) &
              <a class="func" href="../libraries/bin64.htm#bytes(in_bin64,BE,in_integer)">bytes</a>(h2, BE, 8) &
              <a class="func" href="../libraries/bin64.htm#bytes(in_bin64,BE,in_integer)">bytes</a>(h3, BE, 8) &
              <a class="func" href="../libraries/bin64.htm#bytes(in_bin64,BE,in_integer)">bytes</a>(h4, BE, 8) &
              <a class="func" href="../libraries/bin64.htm#bytes(in_bin64,BE,in_integer)">bytes</a>(h5, BE, 8) &
              <a class="func" href="../libraries/bin64.htm#bytes(in_bin64,BE,in_integer)">bytes</a>(h6, BE, 8) &
              <a class="func" href="../libraries/bin64.htm#bytes(in_bin64,BE,in_integer)">bytes</a>(h7, BE, 8);
  <span class="keywd">end func</span>;
</pre></div>
<table width="100%" cellpadding="0" cellspacing="0">
<tr>
<td align="left" width="60%">
<b><big><hr \></big></b></td>
<td align="right">
<table border="0" cellspacing="1" bgcolor="blue">
<tr bgcolor="gainsboro">
<td>&nbsp;<a class="navigation" href="../algorith/math.htm">previous</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/index.htm">up</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/graphic.htm">next</a>&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</div>
  </body>
</html>
