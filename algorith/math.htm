<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>
Seed7 Algorithms: Mathematics</title>
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body style="margin:0 0 0 0;">
<div style="background-image: url('../images/header1x.png');" class="top_image">
<img style="overflow:hidden;" src="../images/hearts7m.png" height="68" width="50"
 /><img style="overflow:hidden;" src="../images/header3.png" height="68" width="745" />
</div>
<div style="background-image: url('../images/fillpix.png');" class="space_below_top_image">
</div>
<div class="menu">

<a class="head" href="../index.htm"><big>Seed7</big></a>
<a class="menu" href="../faq.htm">FAQ</a>
<a class="menu" href="../manual/index.htm">Manual</a>
<a class="menu" href="../demo.htm">Demo</a>
<a class="menu" href="../scrshots/index.htm">Screenshots</a>
<a class="menu" href="../examples/index.htm">Examples</a>
<a class="menu" href="../libraries/index.htm">Libraries</a>
<a class="menu" href="../algorith/index.htm">Algorithms</a>
<a class="menu" href="../benchmks/index.htm">Benchmarks</a>
<a class="menu" href="../subject_index.htm">Index</a>
<a class="menu" href="http://sourceforge.net/project/showfiles.php?group_id=151126">Download</a>
<a class="menu" href="https://github.com/ThomasMertes/seed7">GitHub</a>
<a class="menu" href="../build.htm">Build Seed7</a>
<a class="menu" href="../links.htm">Links</a>

<br />

<a class="head" href="index.htm"><big>Algorithms</big></a>
<a class="menu" href="sorting.htm">Sorting</a>
<a class="menu" href="search.htm">Searching</a>
<a class="menu" href="date.htm">Date&nbsp;&&nbsp;Time</a>
<a class="menu" href="string.htm">String</a>
<a class="menu" href="float.htm">Float</a>
<a class="menu" href="math.htm">Mathematics</a>
<a class="menu" href="msgdigest.htm">Message&nbsp;digest</a>
<a class="menu" href="graphic.htm">Graphics</a>
<a class="menu" href="file.htm">File</a>
<a class="menu" href="puzzles.htm">Puzzles</a>
<a class="menu" href="others.htm">Others</a>
</div>
<div class="content">
<div style="padding-right:20;">
<table width="100%" cellpadding="0" cellspacing="0">
<tr>
<td align="left" width="80">
<a class="head" href="index.htm"><big>Algorithms</big></a>
</td>
<td>
<table width="10">
</table>
</td>
<td align="left" width="60%">
<b><big>Mathematics</big></b></td>
<td align="right">
<table border="0" cellspacing="1" bgcolor="blue">
<tr bgcolor="gainsboro">
<td>&nbsp;<a class="navigation" href="../algorith/float.htm">previous</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/index.htm">up</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/msgdigest.htm">next</a>&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
<p>
</p>

<div><a name="isPrime"><h3>Determine wether a given integer number is prime</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#boolean">boolean</a>: isPrime (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#integer">integer</a>: number) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#boolean">boolean</a>: prime <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: upTo <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: testNum <span class="keywd">is</span> 3;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> number = 2 <span class="keywd">then</span>
      prime := TRUE;
    <span class="keywd">elsif</span> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(number) <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> number > 2 <span class="keywd">then</span>
      upTo := <a class="func" href="../libraries/integer.htm#sqrt(in_integer)">sqrt</a>(number);
      <span class="keywd">while</span> number <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> testNum &lt;> 0 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> testNum &lt;= upTo <span class="keywd">do</span>
        testNum +:= 2;
      <span class="keywd">end while</span>;
      prime := testNum > upTo;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="sieve_of_eratosthenes"><h3>Sieve of Eratosthenes</h3></a>
<p>
The program below computes the number of primes between 1 and 10000000:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/seed7_05.htm">seed7_05.s7i</a>"</span>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#set">set</a> <span class="type">of</span> <a class="type" href="../manual/types.htm#integer">integer</a>: eratosthenes (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#integer">integer</a>: n) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#set">set</a> <span class="type">of</span> <a class="type" href="../manual/types.htm#integer">integer</a>: sieve <span class="keywd">is</span> EMPTY_SET;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: i <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: j <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    sieve := {2 .. n};
    <span class="keywd">for</span> i <span class="keywd">range</span> 2 <span class="keywd">to</span> <a class="func" href="../libraries/integer.htm#sqrt(in_integer)">sqrt</a>(n) <span class="keywd">do</span>
      <span class="keywd">if</span> i <a class="op" href="../libraries/bitset.htm#(in_integer)in(in_bitset)">in</a> sieve <span class="keywd">then</span>
        <span class="keywd">for</span> j <span class="keywd">range</span> i ** 2 <span class="keywd">to</span> n <span class="keywd">step</span> i <span class="keywd">do</span>
          excl(sieve, j);
        <span class="keywd">end for</span>;
      <span class="keywd">end if</span>;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    writeln(card(eratosthenes(10000000)));
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="goldbach"><h3>Verify Goldbach's conjecture up to 10000000</h3></a>
<p>
Goldbach's conjecture states that all even integers greater than 2
can be expressed as the sum of two primes. Goldbach's conjecture
is one of the oldest unsolved problems. The program below checks
all even numbers between 4 and 10000000:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/seed7_05.htm">seed7_05.s7i</a>"</span>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#set">set</a> <span class="type">of</span> <a class="type" href="../manual/types.htm#integer">integer</a>: eratosthenes (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#integer">integer</a>: n) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#set">set</a> <span class="type">of</span> <a class="type" href="../manual/types.htm#integer">integer</a>: sieve <span class="keywd">is</span> EMPTY_SET;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: i <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: j <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    sieve := {2 .. n};
    <span class="keywd">for</span> i <span class="keywd">range</span> 2 <span class="keywd">to</span> <a class="func" href="../libraries/integer.htm#sqrt(in_integer)">sqrt</a>(n) <span class="keywd">do</span>
      <span class="keywd">if</span> i <a class="op" href="../libraries/bitset.htm#(in_integer)in(in_bitset)">in</a> sieve <span class="keywd">then</span>
        <span class="keywd">for</span> j <span class="keywd">range</span> i ** 2 <span class="keywd">to</span> n <span class="keywd">step</span> i <span class="keywd">do</span>
          excl(sieve, j);
        <span class="keywd">end for</span>;
      <span class="keywd">end if</span>;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#integer">integer</a>: limit <span class="keywd">is</span> 10000000;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#boolean">boolean</a>: isGoldbachNumber (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#integer">integer</a>: number) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#boolean">boolean</a>: isGoldbachNumber <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#set">set</a> <span class="type">of</span> <a class="type" href="../manual/types.htm#integer">integer</a>: primes <span class="keywd">is</span> eratosthenes(limit);
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: testNum <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> testNum <span class="keywd">range</span> primes <span class="keywd">until</span> isGoldbachNumber <span class="keywd">do</span>
      isGoldbachNumber := (number - testNum) <a class="op" href="../libraries/bitset.htm#(in_integer)in(in_bitset)">in</a> primes;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> number <span class="keywd">range</span> 4 <span class="keywd">to</span> limit <span class="keywd">step</span> 2 <span class="keywd">do</span>
      <span class="keywd">if</span> <a class="op" href="../libraries/boolean.htm#not(in_boolean)">not</a> isGoldbachNumber(number) <span class="keywd">then</span>
        writeln(number &lt;&amp; <span class="stri">" is not a Goldbach number"</span>);
      <span class="keywd">end if</span>;
      <span class="keywd">if</span> number <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> 16384 = 0 <span class="keywd">then</span>
        write(<span class="stri">"."</span>);
        flush(OUT);
      <span class="keywd">end if</span>;
    <span class="keywd">end for</span>;
    writeln;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="factorise"><h3>Function to calculate the prime factors of a number</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: factorise (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: number) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: factors <span class="keywd">is</span> 0 <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: checker <span class="keywd">is</span> 2;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> checker * checker &lt;= number <span class="keywd">do</span>
      <span class="keywd">if</span> number <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> checker = 0 <span class="keywd">then</span>
        factors &:= [](checker);
        number := number <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> checker;
      <span class="keywd">else</span>
        incr(checker);
      <span class="keywd">end if</span>;
    <span class="keywd">end while</span>;
    <span class="keywd">if</span> number &lt;> 1 <span class="keywd">then</span>
      factors &:= [](number);
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="lucasLehmerTest"><h3>Verify if a given Mersenne number is prime</h3></a>
<p>
A Mersenne number is a number that is one less than a power of two (<tt>2**p-1</tt>).
The Lucas-Lehmer test allows to check if a given Mersenne number is prime:
For the odd prime p, the Mersenne number <tt>2**p-1</tt> is prime if and
only if <tt>S(p-1) rem 2**p-1 = 0</tt> where <tt>S(1)=4 and S(n)=S(n-1)**2-2</tt>.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#boolean">boolean</a>: lucasLehmerTest (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#integer">integer</a>: p) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#boolean">boolean</a>: prime <span class="keywd">is</span> TRUE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: m_p <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: s <span class="keywd">is</span> 4_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: i <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> p &lt;> 2 <span class="keywd">then</span>
      m_p := 2_ ** p - 1_;
      <span class="keywd">for</span> i <span class="keywd">range</span> 2 <span class="keywd">to</span> pred(p) <span class="keywd">do</span>
        s := (s ** 2 - 2_) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)rem(in_bigInteger)">rem</a> m_p;
      <span class="keywd">end for</span>;
      prime := s = 0_;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="millerRabin"><h3>Miller-Rabin primality test</h3></a>
<p>
The Miller-Rabin primality test is a probabilistic algorithm,
which determines whether a given number is prime or not.
The number of tests is specified with the parameter <tt>k</tt>.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#boolean">boolean</a>: millerRabin (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: n, <span class="keywd">in</span> <a class="type" href="../manual/types.htm#integer">integer</a>: k) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#boolean">boolean</a>: probablyPrime <span class="keywd">is</span> TRUE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: d <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: r <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: s <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: a <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: x <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: tests <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> n &lt; 2_ <a class="op" href="../libraries/boolean.htm#(in_boolean)or(ref_func_boolean)">or</a> (n > 2_ <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> <a class="op" href="../libraries/boolean.htm#not(in_boolean)">not</a> <a class="func" href="../libraries/bigint.htm#odd(in_bigInteger)">odd</a>(n)) <span class="keywd">then</span>
      probablyPrime := FALSE;
    <span class="keywd">elsif</span> n > 3_ <span class="keywd">then</span>
      d := pred(n);
      s := <a class="func" href="../libraries/bigint.htm#lowestSetBit(in_bigInteger)">lowestSetBit</a>(d);
      d >>:= s;
      <span class="keywd">while</span> tests &lt; k <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> probablyPrime <span class="keywd">do</span>
        a := <a class="func" href="../libraries/bigint.htm#rand(in_bigInteger,in_bigInteger)">rand</a>(2_, pred(n));
        x := <a class="func" href="../libraries/bigint.htm#modPow(in_var_bigInteger,in_var_bigInteger,in_bigInteger)">modPow</a>(a, d, n);
        <span class="keywd">if</span> x &lt;> 1_ <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> x &lt;> pred(n) <span class="keywd">then</span>
          r := 1;
          <span class="keywd">while</span> r &lt; s <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> x &lt;> 1_ <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> x &lt;> pred(n) <span class="keywd">do</span>
            x := <a class="func" href="../libraries/bigint.htm#modPow(in_var_bigInteger,in_var_bigInteger,in_bigInteger)">modPow</a>(x, 2_, n);
            incr(r);
          <span class="keywd">end while</span>;
          probablyPrime := x = pred(n);
        <span class="keywd">end if</span>;
        incr(tests);
      <span class="keywd">end while</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="gcd"><h3>Determine the greatest common divisor of two positive integer numbers</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#integer">integer</a>: gcd (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: a, <span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: b) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: gcd <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: help <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> a &lt;> 0 <span class="keywd">do</span>
      help := b <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> a;
      b := a;
      a := help;
    <span class="keywd">end while</span>;
    gcd := b;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="lcm"><h3>Determine the least common multiple of two positive integer numbers</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#integer">integer</a>: lcm (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#integer">integer</a>: a, <span class="keywd">in</span> <a class="type" href="../manual/types.htm#integer">integer</a>: b) <span class="keywd">is</span>
  <span class="keywd">return</span> a div gcd(a, b) * b;
</pre></div>

<div><a name="int_binaryGcd"><h3>Binary greatest common divisor algorithm for two positive integer numbers</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#integer">integer</a>: binaryGcd (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: a, <span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: b) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: gcd <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: shift <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: diff <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> a = 0 <span class="keywd">then</span>
      gcd := b;
    <span class="keywd">elsif</span> b = 0 <span class="keywd">then</span>
      gcd := a;
    <span class="keywd">else</span>
      <span class="comment">(* Let shift := log2(K), where K is the greatest power of 2
         dividing both a and b. *)</span>
      <span class="keywd">while</span> <a class="op" href="../libraries/boolean.htm#not(in_boolean)">not</a> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(a) <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> <a class="op" href="../libraries/boolean.htm#not(in_boolean)">not</a> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(b) <span class="keywd">do</span>
          a >>:= 1;
          b >>:= 1;
        incr(shift);
      <span class="keywd">end while</span>;

      <span class="keywd">while</span> <a class="op" href="../libraries/boolean.htm#not(in_boolean)">not</a> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(a) <span class="keywd">do</span>
        a >>:= 1;
      <span class="keywd">end while</span>;

      <span class="comment">(* From here on, a is always odd. *)</span>
      <span class="keywd">repeat</span>
        <span class="keywd">while</span> <a class="op" href="../libraries/boolean.htm#not(in_boolean)">not</a> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(b) <span class="keywd">do</span>
          b >>:= 1;
        <span class="keywd">end while</span>;

        <span class="comment">(* Now a and b are both odd, so diff(a, b) is even.
           Let a := min(a, b); b := diff(a, b)/2; *)</span>
        <span class="keywd">if</span> a &lt; b <span class="keywd">then</span>
          b -:= a;
        <span class="keywd">else</span>
          diff := a - b;
          a := b;
          b := diff;
        <span class="keywd">end if</span>;
        b >>:= 1;
      <span class="keywd">until</span> b = 0;

      gcd := a &lt;&lt; shift;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="big_binaryGcd"><h3>Binary greatest common divisor algorithm for two bigInteger numbers</h3></a>
<p>
The library <span class="stri">"<a class="lib" href="../libraries/bigint.htm">bigint.s7i</a>"</span> defines the
<tt><a class="type" href="../manual/types.htm#bigInteger">bigInteger</a></tt> function <tt><a class="func" href="../libraries/bigint.htm#gcd(in_bigInteger,in_bigInteger)">gcd</a></tt>.
The function <tt>'binaryGcd'</tt> below uses the binary greatest common divisor algorithm:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: binaryGcd (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: a, <span class="keywd">in var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: b) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: gcd <span class="keywd">is</span> 0_;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: lowestSetBitA <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: shift <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: diff <span class="keywd">is</span> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> a = 0_ <span class="keywd">then</span>
      gcd := b;
    <span class="keywd">elsif</span> b = 0_ <span class="keywd">then</span>
      gcd := a;
    <span class="keywd">else</span>
      <span class="keywd">if</span> a &lt; 0_ <span class="keywd">then</span>
        a := -a;
      <span class="keywd">end if</span>;
      <span class="keywd">if</span> b &lt; 0_ <span class="keywd">then</span>
        b := -b;
      <span class="keywd">end if</span>;
      lowestSetBitA := <a class="func" href="../libraries/bigint.htm#lowestSetBit(in_bigInteger)">lowestSetBit</a>(a);
      shift := <a class="func" href="../libraries/bigint.htm#lowestSetBit(in_bigInteger)">lowestSetBit</a>(b);
      <span class="keywd">if</span> lowestSetBitA &lt; shift <span class="keywd">then</span>
        shift := lowestSetBitA;
      <span class="keywd">end if</span>;
      a >>:= lowestSetBitA;
      <span class="keywd">repeat</span>
        b >>:= <a class="func" href="../libraries/bigint.htm#lowestSetBit(in_bigInteger)">lowestSetBit</a>(b);
        <span class="keywd">if</span> a &lt; b <span class="keywd">then</span>
          b -:= a;
        <span class="keywd">else</span>
          diff := a - b;
          a := b;
          b := diff;
        <span class="keywd">end if</span>;
      <span class="keywd">until</span> b = 0_;
      gcd := a &lt;&lt; shift;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="modInverse"><h3>Return the modular multiplicative inverse of a modulo b</h3></a>
<p>
The library <span class="stri">"<a class="lib" href="../libraries/bigint.htm">bigint.s7i</a>"</span> defines the
<tt><a class="type" href="../manual/types.htm#bigInteger">bigInteger</a></tt> function <tt><a class="func" href="../libraries/bigint.htm#modInverse(in_var_bigInteger,in_var_bigInteger)">modInverse</a></tt>.
It returns the modular multiplicative inverse of a modulo b if
a and b are coprime (<tt><a class="func" href="../libraries/bigint.htm#gcd(in_bigInteger,in_bigInteger)">gcd</a>(a, b) = 1</tt>). If a and b are not coprime
(<tt><a class="func" href="../libraries/bigint.htm#gcd(in_bigInteger,in_bigInteger)">gcd</a>(a, b) &lt;> 1</tt>) the <a class="link" href="../manual/errors.htm#Exceptions">exception</a> RANGE_ERROR is raised.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: modInverse (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: a,
    <span class="keywd">in var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: b) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: inverse <span class="keywd">is</span> 0_;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: b_bak <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: x <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: y <span class="keywd">is</span> 1_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: lastx <span class="keywd">is</span> 1_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: lasty <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: temp <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: quotient <span class="keywd">is</span> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> b &lt; 0_ <span class="keywd">then</span>
      <span class="keywd">raise</span> RANGE_ERROR;
    <span class="keywd">end if</span>;
    <span class="keywd">if</span> a &lt; 0_ <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> b &lt;> 0_ <span class="keywd">then</span>
      a := a <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> b;
    <span class="keywd">end if</span>;
    b_bak := b;
    <span class="keywd">while</span> b &lt;> 0_ <span class="keywd">do</span>
      temp := b;
      quotient := a <a class="op" href="../libraries/bigint.htm#(in_bigInteger)div(in_bigInteger)">div</a> b;
      b := a <a class="op" href="../libraries/bigint.htm#(in_bigInteger)rem(in_bigInteger)">rem</a> b;
      a := temp;

      temp := x;
      x := lastx - quotient * x;
      lastx := temp;

      temp := y;
      y := lasty - quotient * y;
      lasty := temp;
    <span class="keywd">end while</span>;
    <span class="keywd">if</span> a = 1_ <span class="keywd">then</span>
      inverse := lastx;
      <span class="keywd">if</span> inverse &lt; 0_ <span class="keywd">then</span>
        inverse +:= b_bak;
      <span class="keywd">end if</span>;
    <span class="keywd">else</span>
      <span class="keywd">raise</span> RANGE_ERROR;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="modPow"><h3>Modular exponentiation with the binary method</h3></a>
<p>
The function <tt><a class="func" href="../libraries/bigint.htm#modPow(in_var_bigInteger,in_var_bigInteger,in_bigInteger)">modPow</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/bigint.htm">bigint.s7i</a>"</span> library.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: modPow (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: base,
    <span class="keywd">in var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: exponent, <span class="keywd">in</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: modulus) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: power <span class="keywd">is</span> 1_;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> exponent &lt; 0_ <a class="op" href="../libraries/boolean.htm#(in_boolean)or(ref_func_boolean)">or</a> modulus &lt; 0_ <span class="keywd">then</span>
      <span class="keywd">raise</span> RANGE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">while</span> exponent > 0_ <span class="keywd">do</span>
        <span class="keywd">if</span> <a class="func" href="../libraries/bigint.htm#odd(in_bigInteger)">odd</a>(exponent) <span class="keywd">then</span>
          power := (power * base) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> modulus;
        <span class="keywd">end if</span>;
        exponent >>:= 1;
        base := base ** 2 <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> modulus;
      <span class="keywd">end while</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="compute_pi_machin"><h3>Compute PI with 1000 decimal digits using John Machin's formula</h3></a>
<p>
The function <tt>'compute_pi_machin'</tt> approximates PI as <tt><a class="type" href="../manual/types.htm#bigRational">bigRational</a></tt> number.
To compute PI with more digits the upper bound of the <a class="keywd" href="../manual/stats.htm#for-statement">for-loop</a> needs to be adjusted, together
with the right operand of the <tt><a class="keywd" href="../libraries/bigrat.htm#(in_bigRational)digits(in_integer)">digits</a></tt> operator. E.g.: For 2000 digits the upper bound of the <a class="keywd" href="../manual/stats.htm#for-statement">for-loop</a> must be 1429 instead of 713.
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/seed7_05.htm">seed7_05.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/bigint.htm">bigint.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/bigrat.htm">bigrat.s7i</a>"</span>;

<span class="comment"># John Machin's formula from 1706:</span>
<span class="comment"># PI = 16 * arctan(1 / 5) - 4 * arctan(1 / 239)</span>

<span class="comment"># Taylor series for arctan:</span>
<span class="comment"># arctan(x) = sum_n_from_0_to_inf((-1) ** n / succ(2 * n) * x ** succ(2 * n))</span>

<span class="comment"># Taylor series of John Machin's formula:</span>
<span class="comment"># PI = sum_n_from_0_to_inf(16 * (-1) ** n / (succ(2 * n) *   5 ** succ(2 * n)) -</span>
<span class="comment">#                           4 * (-1) ** n / (succ(2 * n) * 239 ** succ(2 * n)))</span>

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigRational">bigRational</a>: compute_pi_machin <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigRational">bigRational</a>: sum <span class="keywd">is</span> 0_ / 1_;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: n <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> n <span class="keywd">range</span> 0 <span class="keywd">to</span> 713 <span class="keywd">do</span>
      sum +:= 16_ * (-1_) ** n / (<a class="type" href="../manual/types.htm#bigInteger">bigInteger</a> <a class="op" href="../libraries/bigint.htm#(attr_bigInteger)conv(in_integer)">conv</a> succ(2 * n) *   5_ ** succ(2 * n)) -
               4_ * (-1_) ** n / (<a class="type" href="../manual/types.htm#bigInteger">bigInteger</a> <a class="op" href="../libraries/bigint.htm#(attr_bigInteger)conv(in_integer)">conv</a> succ(2 * n) * 239_ ** succ(2 * n));
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    writeln(compute_pi_machin <a class="op" href="../libraries/bigrat.htm#(in_bigRational)digits(in_integer)">digits</a> 1000);
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="compute_pi_bailey_borwein_plouffe"><h3>Compute PI with 1000 decimal digits using the Bailey/Borwein/Plouffe formula</h3></a>
<p>
The function <tt>'compute_pi_bailey_borwein_plouffe'</tt> approximates PI as <tt><a class="type" href="../manual/types.htm#bigRational">bigRational</a></tt> number.
To compute PI with more digits the upper bound of the <a class="keywd" href="../manual/stats.htm#for-statement">for-loop</a> needs to be adjusted, together
with the right operand of the <tt><a class="keywd" href="../libraries/bigrat.htm#(in_bigRational)digits(in_integer)">digits</a></tt> operator. E.g.: For 2000 digits the upper bound of the <a class="keywd" href="../manual/stats.htm#for-statement">for-loop</a> must be 1655 instead of 825.
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/seed7_05.htm">seed7_05.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/bigint.htm">bigint.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/bigrat.htm">bigrat.s7i</a>"</span>;

<span class="comment"># In 1997, David H. Bailey, Peter Borwein and Simon Plouffe published a</span>
<span class="comment"># paper (Bailey, 1997) on a new formula for PI as an infinite series:</span>

<span class="comment"># PI = sum_n_from_0_to_inf(16 ** (-n) *</span>
<span class="comment">#      (4 / (8 * n + 1) - 2 / (8 * n + 4) - 1 / (8 * n + 5) - 1 / (8 * n + 6)))</span>

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigRational">bigRational</a>: compute_pi_bailey_borwein_plouffe <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigRational">bigRational</a>: sum <span class="keywd">is</span> 0_ / 1_;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: n <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: k8 <span class="keywd">is</span> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> n <span class="keywd">range</span> 0 <span class="keywd">to</span> 825 <span class="keywd">do</span>
      k8 := bigInteger <a class="op" href="../libraries/bigint.htm#(attr_bigInteger)conv(in_integer)">conv</a> (8 * n);
      sum +:= 1_ / 16_ ** n *
          (4_ / (k8 + 1_) - 2_ / (k8 + 4_) - 1_ / (k8 + 5_) - 1_ / (k8 + 6_));
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    writeln(compute_pi_bailey_borwein_plouffe <a class="op" href="../libraries/bigrat.htm#(in_bigRational)digits(in_integer)">digits</a> 1000);
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="compute_pi_newton"><h3>Write PI with 1000 decimal digits using Newtons formula</h3></a>
<p>
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/seed7_05.htm">seed7_05.s7i</a>"</span>;

<span class="comment"># Newtons formula for PI is:</span>
<span class="comment"># PI / 2 = sum_n_from_0_to_inf(n! / (2 * n + 1)!!)</span>

<span class="comment"># This can be written as:</span>
<span class="comment"># PI / 2 = 1 + 1/3 * (1 + 2/5 * (1 + 3/7 * (1 + 4/9 * (1 + ... ))))</span>

<span class="comment"># This algorithm puts 2 * 1000 on the right side and computes everything from inside out.</span>

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#integer">integer</a>: SCALE <span class="keywd">is</span> 10000;
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#integer">integer</a>: MAXARR <span class="keywd">is</span> 3500;
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#integer">integer</a>: ARRINIT <span class="keywd">is</span> 2000;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: i <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: j <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: carry <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: arr <span class="keywd">is</span> MAXARR <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> ARRINIT;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: sum <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> i <span class="keywd">range</span> MAXARR <span class="keywd">downto</span> 1 <span class="keywd">step</span> 14 <span class="keywd">do</span>
      sum := 0;
      <span class="keywd">for</span> j <span class="keywd">range</span> i <span class="keywd">downto</span> 1 <span class="keywd">do</span>
        sum := sum*j + SCALE*arr[j];
        arr[j] := sum <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> pred(j*2);
        sum := sum <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> pred(j*2);
      <span class="keywd">end for</span>;
      write(carry + sum <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> SCALE <span class="op">lpad0</span> 4);
      carry := sum <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> SCALE;
    <span class="keywd">end for</span>;
    writeln;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="pi_spigot_algorithm"><h3>Write the decimal digits of PI with a spigot algorithm</h3></a>
<p>
The program below uses the unbounded spigot algorithm published by Jeremy Gibbons.
The digits of PI are calculated and written in succession.
To stop the program press ctrl-C followed by * and ENTER.
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/seed7_05.htm">seed7_05.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/bigint.htm">bigint.s7i</a>"</span>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: q <span class="keywd">is</span> 1_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: r <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: t <span class="keywd">is</span> 1_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: k <span class="keywd">is</span> 1_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: n <span class="keywd">is</span> 3_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: l <span class="keywd">is</span> 3_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: nn <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: nr <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#boolean">boolean</a>: first <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> TRUE <span class="keywd">do</span>
      <span class="keywd">if</span> 4_ * q + r - t &lt; n * t <span class="keywd">then</span>
        write(n);
        <span class="keywd">if</span> first <span class="keywd">then</span>
          write(<span class="stri">"."</span>);
          first := FALSE;
        <span class="keywd">end if</span>;
        nr := 10_ * (r - n * t);
        n := 10_ * (3_ * q + r) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)div(in_bigInteger)">div</a> t - 10_ * n;
        q *:= 10_;
        r := nr;
        flush(OUT);
      <span class="keywd">else</span>
        nr := (2_ * q + r) * l;
        nn := (q * (7_ * k + 2_) + r * l) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)div(in_bigInteger)">div</a> (t * l);
        q *:= k;
        t *:= l;
        l +:= 2_;
        incr(k);
        n := nn;
        r := nr;
      <span class="keywd">end if</span>;
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="intSqrt"><h3>Determine the truncated square root of a big integer number</h3></a>
<p>
The library <span class="stri">"<a class="lib" href="../libraries/bigint.htm">bigint.s7i</a>"</span> defines the
<tt><a class="type" href="../manual/types.htm#bigInteger">bigInteger</a></tt> function <tt><a class="func" href="../libraries/bigint.htm#sqrt(in_var_bigInteger)">sqrt</a></tt>.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: sqrt (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: number) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: root <span class="keywd">is</span> 0_;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: res2 <span class="keywd">is</span> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> number > 0_ <span class="keywd">then</span>
      res2 := number;
      <span class="keywd">repeat</span>
        root := res2;
        res2 := (root + number <a class="op" href="../libraries/bigint.htm#(in_bigInteger)div(in_bigInteger)">div</a> root) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)div(in_bigInteger)">div</a> 2_;
      <span class="keywd">until</span> root &lt;= res2;
    <span class="keywd">else</span>
      <span class="keywd">raise</span> NUMERIC_ERROR;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="nthRoot"><h3>Function to compute the nth root of a positive float number</h3></a>
<p>
The nth root of the number <tt>'a'</tt> can be computed with
the exponentiation operator: <tt>'a <a class="keywd" href="../libraries/float.htm#(in_float)**(in_float)">**</a> (1.0 / <a class="func" href="../libraries/float.htm#flt(in_integer)">flt</a>(n))'</tt>.
An alternate function which uses Newton's method is:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#float">float</a>: nthRoot (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#integer">integer</a>: n, <span class="keywd">in</span> <a class="type" href="../manual/types.htm#float">float</a>: a) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#float">float</a>: x1 <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#float">float</a>: x0 <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    x0 := a;
    x1 := a / <a class="func" href="../libraries/float.htm#flt(in_integer)">flt</a>(n);
    <span class="keywd">while</span> abs(x1 - x0) >= abs(x0 * 1.0E-9) <span class="keywd">do</span>
      x0 := x1;
      x1 := (<a class="func" href="../libraries/float.htm#flt(in_integer)">flt</a>(pred(n)) * x0 + a / x0 ** pred(n)) / <a class="func" href="../libraries/float.htm#flt(in_integer)">flt</a>(n);
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="intPow"><h3>Exponentiation function for integers</h3></a>
<p>
The type <tt><a class="type" href="../manual/types.htm#integer">integer</a></tt> defines an exponentiation operator which
can be called with <tt>'base <a class="keywd" href="../libraries/integer.htm#(in_integer)**(in_integer)">**</a> exponent'</tt>. The Seed7 runtime library
contains the function <tt>'intPow'</tt> which implements the
<tt><a class="keywd" href="../libraries/integer.htm#(in_integer)**(in_integer)">**</a></tt> operator. This function uses the exponentiation
by squaring algorithm. The Seed7 version of <tt>'intPow'</tt> is:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#integer">integer</a>: intPow (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: base, <span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: exponent) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: power <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> exponent &lt; 0 <span class="keywd">then</span>
      raise(NUMERIC_ERROR);
    <span class="keywd">else</span>
      <span class="keywd">if</span> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(exponent) <span class="keywd">then</span>
        power := base;
      <span class="keywd">else</span>
        power := 1;
      <span class="keywd">end if</span>;
      exponent := exponent <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> 2;
      <span class="keywd">while</span> exponent &lt;> 0 <span class="keywd">do</span>
        base *:= base;
        <span class="keywd">if</span> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(exponent) <span class="keywd">then</span>
          power *:= base;
        <span class="keywd">end if</span>;
        exponent := exponent <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> 2;
      <span class="keywd">end while</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="fltIPow"><h3>Exponentiation function for float base and integer exponent</h3></a>
<p>
The type <tt><a class="type" href="../manual/types.htm#float">float</a></tt> defines an exponentiation operator which
can be called with <tt>'base <a class="keywd" href="../libraries/float.htm#(in_float)**(in_integer)">**</a> exponent'</tt>. The Seed7 runtime library
contains the function <tt>'fltIPow'</tt> which implements the
<tt><a class="keywd" href="../libraries/float.htm#(in_float)**(in_integer)">**</a></tt> operator. This function uses the exponentiation
by squaring algorithm. The Seed7 version of <tt>'fltIPow'</tt> is:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#float">float</a>: fltIPow (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#float">float</a>: base, <span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: exponent) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#float">float</a>: power <span class="keywd">is</span> 1.0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: stop <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> base = 0.0 <span class="keywd">then</span>
      <span class="keywd">if</span> exponent &lt; 0 <span class="keywd">then</span>
        power := <a class="var" href="../libraries/float.htm#Infinity">Infinity</a>;
      <span class="keywd">elsif</span> exponent > 0 <span class="keywd">then</span>
        power := 0.0;
      <span class="keywd">end if</span>;
    <span class="keywd">else</span>
      <span class="keywd">if</span> exponent &lt; 0 <span class="keywd">then</span>
        stop := -1;
      <span class="keywd">end if</span>;
      <span class="keywd">if</span> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(exponent) <span class="keywd">then</span>
        power := base;
      <span class="keywd">end if</span>;
      exponent >>:= 1;
      <span class="keywd">while</span> exponent &lt;> stop <span class="keywd">do</span>
        base *:= base;
        <span class="keywd">if</span> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(exponent) <span class="keywd">then</span>
          power *:= base;
        <span class="keywd">end if</span>;
        exponent >>:= 1;
      <span class="keywd">end while</span>;
      <span class="keywd">if</span> stop = -1 <span class="keywd">then</span>
        power := 1.0 / power;
      <span class="keywd">end if</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="peasantMult"><h3>Multiply integers using the peasant multiplication</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#integer">integer</a>: peasantMult (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: a, <span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: b) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: product <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> a &lt;> 0 <span class="keywd">do</span>
      <span class="keywd">if</span> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(a) <span class="keywd">then</span>
        product +:= b;
      <span class="keywd">end if</span>;
      a := a <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> 2;
      b *:= 2;
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="binomial_coefficient"><h3>Binomial coefficient</h3></a>
<p>
The type <tt><a class="type" href="../manual/types.htm#integer">integer</a></tt> defines the infix operator <tt><a class="keywd" href="../libraries/integer.htm#(in_integer)!(in_integer)">!</a></tt> to compute the binomial
coefficient. Below is the definition of the <tt><a class="type" href="../manual/types.htm#bigInteger">bigInteger</a></tt> infix operator
<tt><a class="keywd" href="../libraries/bigint.htm#(in_bigInteger)!(in_var_bigInteger)">!</a></tt> from the library <span class="stri">"<a class="lib" href="../libraries/bigint.htm">bigint.s7i</a>"</span>.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: n) ! (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: k) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: binom <span class="keywd">is</span> 0_;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: numerator <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: denominator <span class="keywd">is</span> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> n >= 0_ <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> k > n >> 1 <span class="keywd">then</span>
      k := n - k;
    <span class="keywd">end if</span>;
    <span class="keywd">if</span> k &lt; 0_ <span class="keywd">then</span>
      binom := 0_;
    <span class="keywd">elsif</span> k = 0_ <span class="keywd">then</span>
      binom := 1_;
    <span class="keywd">else</span>
      binom := n;
      numerator := pred(n);
      denominator := 2_;
      <span class="keywd">while</span> denominator &lt;= k <span class="keywd">do</span>
        binom *:= numerator;
        binom := binom <a class="op" href="../libraries/bigint.htm#(in_bigInteger)div(in_bigInteger)">div</a> denominator;
        decr(numerator);
        incr(denominator);
      <span class="keywd">end while</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="gamma"><h3>Gamma function</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#float">float</a>: gamma (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#float">float</a>: X) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#float">float</a>: gamma <span class="keywd">is</span> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#float">float</a>: A <span class="keywd">is</span> [] (
         1.00000000000000000000,  0.57721566490153286061,
        -0.65587807152025388108, -0.04200263503409523553,
         0.16653861138229148950, -0.04219773455554433675,
        -0.00962197152787697356,  0.00721894324666309954,
        -0.00116516759185906511, -0.00021524167411495097,
         0.00012805028238811619, -0.00002013485478078824,
        -0.00000125049348214267,  0.00000113302723198170,
        -0.00000020563384169776,  0.00000000611609510448,
         0.00000000500200764447, -0.00000000118127457049,
         0.00000000010434267117,  0.00000000000778226344,
        -0.00000000000369680562,  0.00000000000051003703,
        -0.00000000000002058326, -0.00000000000000534812,
         0.00000000000000122678, -0.00000000000000011813,
         0.00000000000000000119,  0.00000000000000000141,
        -0.00000000000000000023,  0.00000000000000000002);
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#float">float</a>: Y <span class="keywd">is</span> 0.0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#float">float</a>: Sum <span class="keywd">is</span> A[maxIdx(A)];
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: N <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    Y := X - 1.0;
    <span class="keywd">for</span> N <span class="keywd">range</span> pred(maxIdx(A)) <span class="keywd">downto</span> minIdx(A) <span class="keywd">do</span>
      Sum := Sum * Y + A[N];
    <span class="keywd">end for</span>;
    gamma := 1.0 / Sum;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="madd"><h3>Matrix addition</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#type">type</a>: matrix <span class="keywd">is</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#float">float</a>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <span class="type">matrix</span>: (<span class="keywd">in</span> <span class="type">matrix</span>: summand1) + (<span class="keywd">in</span> <span class="type">matrix</span>: summand2) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">matrix</span>: sum <span class="keywd">is</span> <span class="type">matrix</span>.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: i <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: j <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(summand1) &lt;> length(summand2) <a class="op" href="../libraries/boolean.htm#(in_boolean)or(ref_func_boolean)">or</a>
        length(summand1[1]) &lt;> length(summand2[1]) <span class="keywd">then</span>
      <span class="keywd">raise</span> RANGE_ERROR;
    <span class="keywd">else</span>
      sum := length(summand1) <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> length(summand1[1]) <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> 0.0;
      <span class="keywd">for</span> i <span class="keywd">range</span> 1 <span class="keywd">to</span> length(summand1) <span class="keywd">do</span>
        <span class="keywd">for</span> j <span class="keywd">range</span> 1 <span class="keywd">to</span> length(summand1[i]) <span class="keywd">do</span>
          sum[i][j] := summand1[i][j] + summand2[i][j];
        <span class="keywd">end for</span>;
      <span class="keywd">end for</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="mmult"><h3>Matrix multiplication</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#type">type</a>: matrix <span class="keywd">is</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#float">float</a>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <span class="type">matrix</span>: (<span class="keywd">in</span> <span class="type">matrix</span>: factor1) * (<span class="keywd">in</span> <span class="type">matrix</span>: factor2) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">matrix</span>: product <span class="keywd">is</span> <span class="type">matrix</span>.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: i <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: j <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: k <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#float">float</a>: accumulator <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(factor1[1]) &lt;> length(factor2) <span class="keywd">then</span>
      <span class="keywd">raise</span> RANGE_ERROR;
    <span class="keywd">else</span>
      product := length(factor1) <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> length(factor2[1]) <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> 0.0;
      <span class="keywd">for</span> i <span class="keywd">range</span> 1 <span class="keywd">to</span> length(factor1) <span class="keywd">do</span>
        <span class="keywd">for</span> j <span class="keywd">range</span> 1 <span class="keywd">to</span> length(factor2) <span class="keywd">do</span>
          accumulator := 0.0;
          <span class="keywd">for</span> k <span class="keywd">range</span> 1 <span class="keywd">to</span> length(factor1) <span class="keywd">do</span>
            accumulator +:= factor1[i][k] * factor2[k][j];
          <span class="keywd">end for</span>;
          product[i][j] := accumulator;
        <span class="keywd">end for</span>;
      <span class="keywd">end for</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="matrix_exponentiation"><h3>Matrix exponentiation with integer exponent</h3></a>
<p>
Based on the <a class="link" href="#mmult">matrix multiplication</a> and the type <tt><span class="type">matrix</span></tt>
a matrix exponentiation with an integer exponent can be defined:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <span class="type">matrix</span>: (<span class="keywd">in var</span> <span class="type">matrix</span>: base) ** (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: exponent) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">matrix</span>: power <span class="keywd">is</span> matrix.value;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: row <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: column <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> exponent &lt; 0 <span class="keywd">then</span>
      <span class="keywd">raise</span> NUMERIC_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(exponent) <span class="keywd">then</span>
        power := base;
      <span class="keywd">else</span>
        <span class="comment"># Create identity matrix</span>
        power := length(base) <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> length(base) <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> 0.0;
        <span class="keywd">for</span> row <span class="keywd">range</span> 1 <span class="keywd">to</span> length(base) <span class="keywd">do</span>
          <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> length(base) <span class="keywd">do</span>
            <span class="keywd">if</span> row = column <span class="keywd">then</span>
              power[row][column] := 1.0;
            <span class="keywd">end if</span>;
          <span class="keywd">end for</span>;
        <span class="keywd">end for</span>;
      <span class="keywd">end if</span>;
      exponent := exponent <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> 2;
      <span class="keywd">while</span> exponent > 0 <span class="keywd">do</span>
        base := base * base;
        <span class="keywd">if</span> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(exponent) <span class="keywd">then</span>
          power := power * base;
        <span class="keywd">end if</span>;
        exponent := exponent <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> 2;
      <span class="keywd">end while</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="toRowEchelonForm"><h3>Convert a matrix to row echelon form</h3></a>
<p>
A matrix is in row echelon form if<ul>
  <li>All rows with at least one nonzero element are above any rows with all zeroes.</li>
  <li>The first nonzero number from the left, of a nonzero row is always strictly to the right of the first nonzero number from the left, in the row above it.</li></ul>
<dl><dt>The function below converts a matrix like</dt><dd><table>
<tr><td align="right">2.0</td>  <td width="20"></td> <td align="right">1.0</td>  <td width="20"></td> <td align="right">-1.0</td> <td width="20"></td> <td align="right">8.0</td></tr>
<tr><td align="right">-3.0</td> <td width="20"></td> <td align="right">-1.0</td> <td width="20"></td> <td align="right">2.0</td> <td width="20"></td> <td align="right">-11.0</td></tr>
<tr><td align="right">-2.0</td> <td width="20"></td> <td align="right">1.0</td>  <td width="20"></td> <td align="right">2.0</td> <td width="20"></td> <td align="right">-3.0</td></tr></table></dd>
<dt>into its row echelon form</dt><dd><table>
<tr><td align="right">2.0</td> <td width="20"></td> <td align="right">1.0</td> <td width="20"></td> <td align="right">-1.0</td> <td width="20"></td> <td align="right">8.0</td></tr>
<tr><td align="right">0.0</td> <td width="20"></td> <td align="right">0.5</td> <td width="20"></td> <td align="right">0.5</td>  <td width="20"></td> <td align="right">1.0</td></tr>
<tr><td align="right">0.0</td> <td width="20"></td> <td align="right">0.0</td> <td width="20"></td> <td align="right">-1.0</td> <td width="20"></td> <td align="right">1.0</td></tr></table></dd></dl>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#type">type</a>: matrix <span class="keywd">is</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#float">float</a>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: toRowEchelonForm (<span class="keywd">inout</span> <span class="type">matrix</span>: mat) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: numRows <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: numColumns <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: row <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: pivot <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#float">float</a>: factor <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    numRows := length(mat);
    numColumns := length(mat[1]);
    <span class="keywd">for</span> row <span class="keywd">range</span> numRows <span class="keywd">downto</span> 1 <span class="keywd">do</span>
      column := 1;
      <span class="keywd">while</span> column &lt;= numColumns <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> mat[row][column] = 0.0 <span class="keywd">do</span>
        incr(column);
      <span class="keywd">end while</span>;
      <span class="keywd">if</span> column > numColumns <span class="keywd">then</span>
        <span class="comment"># Empty rows are moved to the bottom</span>
        mat := mat[.. pred(row)] &amp; mat[succ(row) ..] &amp; [] (mat[row]);
        decr(numRows);
      <span class="keywd">end if</span>;
    <span class="keywd">end for</span>;
    <span class="keywd">for</span> pivot <span class="keywd">range</span> 1 <span class="keywd">to</span> numRows <span class="keywd">do</span>
      <span class="keywd">if</span> mat[pivot][pivot] = 0.0 <span class="keywd">then</span>
        <span class="comment"># Find a row were the pivot column is not zero</span>
        row := 1;
        <span class="keywd">while</span> row &lt;= numRows <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> mat[row][pivot] = 0.0 <span class="keywd">do</span>
          incr(row);
        <span class="keywd">end while</span>;
        <span class="comment"># Add row were the pivot column is not zero</span>
        <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> numColumns <span class="keywd">do</span>
          mat[pivot][column] +:= mat[row][column];
        <span class="keywd">end for</span>;
      <span class="keywd">end if</span>;
      <span class="keywd">for</span> row <span class="keywd">range</span> succ(pivot) <span class="keywd">to</span> numRows <span class="keywd">do</span>
        <span class="keywd">if</span> mat[row][pivot] &lt;> 0.0 <span class="keywd">then</span>
          <span class="comment"># Make sure that the pivot column contains zero in all rows below the pivot row</span>
          factor := -mat[row][pivot] / mat[pivot][pivot];
          <span class="keywd">for</span> column <span class="keywd">range</span> pivot <span class="keywd">to</span> numColumns <span class="keywd">do</span>
            mat[row][column] +:= mat[pivot][column] * factor;
          <span class="keywd">end for</span>;
        <span class="keywd">end if</span>;
      <span class="keywd">end for</span>;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="toReducedRowEchelonForm"><h3>Convert a matrix to reduced row echelon form</h3></a>
<p>
A matrix is in reduced row echelon form if<ul>
  <li>All rows with at least one nonzero element are above any rows with all zeroes.</li>
  <li>The first nonzero number from the left, of a nonzero row is always strictly to the right of the first nonzero number from the left, in the row above it.</li>
  <li>Every leading coefficient is 1 and is the only nonzero entry in its column</li></ul>
<dl><dt>The function below converts a matrix like</dt><dd><table>
<tr><td align="right">2.0</td>  <td width="20"></td> <td align="right">1.0</td>  <td width="20"></td> <td align="right">-1.0</td> <td width="20"></td> <td align="right">8.0</td></tr>
<tr><td align="right">-3.0</td> <td width="20"></td> <td align="right">-1.0</td> <td width="20"></td> <td align="right">2.0</td> <td width="20"></td> <td align="right">-11.0</td></tr>
<tr><td align="right">-2.0</td> <td width="20"></td> <td align="right">1.0</td>  <td width="20"></td> <td align="right">2.0</td> <td width="20"></td> <td align="right">-3.0</td></tr></table></dd>
<dt>into its reduced row echelon form</dt><dd><table>
<tr><td align="right">1.0</td> <td width="20"></td> <td align="right">0.0</td> <td width="20"></td> <td align="right">0.0</td> <td width="20"></td> <td align="right">2.0</td></tr>
<tr><td align="right">0.0</td> <td width="20"></td> <td align="right">1.0</td> <td width="20"></td> <td align="right">0.0</td> <td width="20"></td> <td align="right">3.0</td></tr>
<tr><td align="right">0.0</td> <td width="20"></td> <td align="right">0.0</td> <td width="20"></td> <td align="right">1.0</td> <td width="20"></td> <td align="right">-1.0</td></tr></table></dd></dl>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#type">type</a>: matrix <span class="keywd">is</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#float">float</a>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: toReducedRowEchelonForm (<span class="keywd">inout</span> <span class="type">matrix</span>: mat) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: numRows <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: numColumns <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: row <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: column <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: pivot <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#float">float</a>: factor <span class="keywd">is</span> 0.0;
  <span class="keywd">begin</span>
    numRows := length(mat);
    numColumns := length(mat[1]);
    <span class="keywd">for</span> row <span class="keywd">range</span> numRows <span class="keywd">downto</span> 1 <span class="keywd">do</span>
      column := 1;
      <span class="keywd">while</span> column &lt;= numColumns <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> mat[row][column] = 0.0 <span class="keywd">do</span>
        incr(column);
      <span class="keywd">end while</span>;
      <span class="keywd">if</span> column > numColumns <span class="keywd">then</span>
        <span class="comment"># Empty rows are moved to the bottom</span>
        mat := mat[.. pred(row)] &amp; mat[succ(row) ..] &amp; [] (mat[row]);
        decr(numRows);
      <span class="keywd">end if</span>;
    <span class="keywd">end for</span>;
    <span class="keywd">for</span> pivot <span class="keywd">range</span> 1 <span class="keywd">to</span> numRows <span class="keywd">do</span>
      <span class="keywd">if</span> mat[pivot][pivot] = 0.0 <span class="keywd">then</span>
        <span class="comment"># Find a row were the pivot column is not zero</span>
        row := 1;
        <span class="keywd">while</span> row &lt;= numRows <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> mat[row][pivot] = 0.0 <span class="keywd">do</span>
          incr(row);
        <span class="keywd">end while</span>;
        <span class="comment"># Add row were the pivot column is not zero</span>
        <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> numColumns <span class="keywd">do</span>
          mat[pivot][column] +:= mat[row][column];
        <span class="keywd">end for</span>;
      <span class="keywd">end if</span>;
      <span class="keywd">if</span> mat[pivot][pivot] &lt;> 1.0 <span class="keywd">then</span>
        <span class="comment"># Make sure that the pivot element is 1.0</span>
        factor := 1.0 / mat[pivot][pivot];
        <span class="keywd">for</span> column <span class="keywd">range</span> pivot <span class="keywd">to</span> numColumns <span class="keywd">do</span>
          mat[pivot][column] := mat[pivot][column] * factor;
        <span class="keywd">end for</span>;
      <span class="keywd">end if</span>;
      <span class="keywd">for</span> row <span class="keywd">range</span> 1 <span class="keywd">to</span> numRows <span class="keywd">do</span>
        <span class="keywd">if</span> row &lt;> pivot <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> mat[row][pivot] &lt;> 0.0 <span class="keywd">then</span>
          <span class="comment"># Make sure that in all other rows the pivot column contains zero</span>
          factor := -mat[row][pivot];
          <span class="keywd">for</span> column <span class="keywd">range</span> pivot <span class="keywd">to</span> numColumns <span class="keywd">do</span>
            mat[row][column] +:= mat[pivot][column] * factor;
          <span class="keywd">end for</span>;
        <span class="keywd">end if</span>;
      <span class="keywd">end for</span>;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="dotProd"><h3>Dot product</h3></a>
<p>
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/seed7_05.htm">seed7_05.s7i</a>"</span>;

$ <span class="keywd">syntax</span> <a class="type" href="../manual/types.htm#expr">expr</a>: .().dot.() <span class="keywd">is</span>  -> 6;  <span class="comment"># priority of dot operator</span>

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#integer">integer</a>: (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: a) dot (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: b) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: sum <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">if</a> <a class="func" href="../libraries/array.htm#minIdx(in_arrayType)">minIdx</a>(a) <a class="op_no_ul" href="../libraries/integer.htm#(in_integer)<>(in_integer)">&lt;></a> <a class="func" href="../libraries/array.htm#minIdx(in_arrayType)">minIdx</a>(b) <a class="op_no_ul" href="../libraries/boolean.htm#(in_boolean)or(ref_func_boolean)">or</a> <a class="func" href="../libraries/array.htm#maxIdx(in_arrayType)">maxIdx</a>(a) <a class="op_no_ul" href="../libraries/integer.htm#(in_integer)<>(in_integer)">&lt;></a> <a class="func" href="../libraries/array.htm#maxIdx(in_arrayType)">maxIdx</a>(b) <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">then</a>
      <a class="keywd_no_ul" href="../manual/errors.htm#Exceptions">raise</a> <a class="exception" href="../manual/errors.htm#RANGE_ERROR">RANGE_ERROR</a>;
    <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">else</a>
      <a class="keywd_no_ul" href="../manual/stats.htm#for-key-statement">for</a> <a class="keywd_no_ul" href="../manual/stats.htm#for-key-statement">key</a> index <a class="keywd_no_ul" href="../manual/stats.htm#for-key-statement">range</a> a <a class="keywd_no_ul" href="../manual/stats.htm#for-key-statement">do</a>
        sum <a class="op_no_ul" href="../libraries/integer.htm#(inout_integer)+:=(in_integer)">+:=</a> a[index] <a class="op_no_ul" href="../libraries/integer.htm#(in_integer)*(in_integer)">*</a> b[index];
      <a class="keywd_no_ul" href="../manual/stats.htm#for-key-statement">end</a> <a class="keywd_no_ul" href="../manual/stats.htm#for-key-statement">for</a>;
    <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">end</a> <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">if</a>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    writeln([](1, 3, -5) <span class="op">dot</span> [](4, -2, -1));
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="rand_32"><h3>Random number generator</h3></a>
<p>
The function <tt>'rand'</tt>, which creates a random value between
a lower and an upper bound, is predefined for many types (<tt><a class="type" href="../manual/types.htm#boolean">boolean</a></tt>,
<tt><a class="type" href="../manual/types.htm#integer">integer</a></tt>, <tt><a class="type" href="../manual/types.htm#bigInteger">bigInteger</a></tt>, <tt><a class="type" href="../manual/types.htm#float">float</a></tt>, <tt><a class="type" href="../manual/types.htm#char">char</a></tt>).
The random generator below delivers random numbers between 0 and 2**32-1.
To get a different pseudorandom sequence the variable <tt>'seed'</tt> can be initialized with another value.
</p><pre class="indent">
<span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: seed <span class="keywd">is</span> 987654321_;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: rand_32 <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: randomNumber <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    seed := (seed * 1103515245_ + 12345_ <a class="op" href="../libraries/bigint.htm#(in_bigInteger)rem(in_bigInteger)">rem</a> 2_ ** 64;
    randomNumber := seed <a class="op" href="../libraries/bigint.htm#(in_bigInteger)div(in_bigInteger)">div</a> 2_ ** 32;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="fib"><h3>Recursive fibonacci function</h3></a>
<p>
This algorithm just uses the recursive definition of the fibonacci function.
It can be used as benchmark to test the performance of recursive calls.
For a solution with better scalability use the iterative fibonacci function below.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#integer">integer</a>: fib (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#integer">integer</a>: number) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: fib <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> number > 2 <span class="keywd">then</span>
      fib := fib(pred(number)) + fib(number - 2);
    <span class="keywd">elsif</span> number = 0 <span class="keywd">then</span>
      fib := 0;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="iterative_fib"><h3>Iterative fibonacci function</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: fib (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#integer">integer</a>: number) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: fib <span class="keywd">is</span> 1_;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: i <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: a <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: c <span class="keywd">is</span> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> i <span class="keywd">range</span> 1 <span class="keywd">to</span> pred(number) <span class="keywd">do</span>
      c := a;
      a := fib;
      fib +:= c;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="fibonacci_sequence"><h3>Display 100 numbers of the fibonacci sequence</h3></a>
<p>
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/seed7_05.htm">seed7_05.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/bigint.htm">bigint.s7i</a>"</span>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: i <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: a <span class="keywd">is</span> 0_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: b <span class="keywd">is</span> 1_;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: c <span class="keywd">is</span> 0_;
  <span class="keywd">begin</span>
    writeln(a);
    <span class="keywd">for</span> i <span class="keywd">range</span> 1 <span class="keywd">to</span> 100 <span class="keywd">do</span>
      writeln(b);
      c := a;
      a := b;
      b +:= c;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="tak"><h3>The tak function</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#integer">integer</a>: tak (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#integer">integer</a>: x, <span class="keywd">in</span> <a class="type" href="../manual/types.htm#integer">integer</a>: y, <span class="keywd">in</span> <a class="type" href="../manual/types.htm#integer">integer</a>: z) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: tak <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> y >= x <span class="keywd">then</span>
      tak := z;
    <span class="keywd">else</span>
      tak := tak(tak(pred(x), y, z),
                 tak(pred(y), z, x),
                 tak(pred(z), x, y));
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="ackermann"><h3>The ackermann function</h3></a>
<p>
The ackermann function grows rapidly, even for small inputs:
</p><dl><dd>
  ackermann(4, 1) is 65533</dd><dd>
  ackermann(4, 2) has 19729 decimal digits.
</dd></dl><p>
Below is a simple implementation of the ackermann function,
that follows the original specification. The recursion depth
of ackermann grows so fast that computing ackermann(4, 1),
with the implementation below, might trigger a stack overflow.
In practice the <tt><a class="type" href="../manual/types.htm#bigInteger">bigInteger</a></tt> ackermann function implementation
further below should be preferred.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#integer">integer</a>: ackermann (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#integer">integer</a>: m, <span class="keywd">in</span> <a class="type" href="../manual/types.htm#integer">integer</a>: n) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: ackermann <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> m = 0 <span class="keywd">then</span>
      ackermann := succ(n);
    <span class="keywd">elsif</span> n = 0 <span class="keywd">then</span>
      ackermann := ackermann(pred(m), 1);
    <span class="keywd">else</span>
      ackermann := ackermann(pred(m), ackermann(m, pred(n)));
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="bigInteger_ackermann"><h3>The bigInteger ackermann function</h3></a>
<p>
This implementation of the ackermann function uses <tt><a class="type" href="../manual/types.htm#bigInteger">bigInteger</a></tt>
instead of <tt><a class="type" href="../manual/types.htm#integer">integer</a></tt>. Additionally there are optimizations
for special cases, to reduce the recursion depth. Because of
these improvements the ackermann implementation below can
compute ackermann(4, 2) without problems.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: ackermann (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: m, <span class="keywd">in</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: n) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: ackermann <span class="keywd">is</span> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> m <span class="keywd">of</span>
      <span class="keywd">when</span> {0_}: ackermann := succ(n);
      <span class="keywd">when</span> {1_}: ackermann := n + 2_;
      <span class="keywd">when</span> {2_}: ackermann := 3_ + 2_ * n;
      <span class="keywd">when</span> {3_}: ackermann := 5_ + 8_ * pred(2_ ** ord(n));
      <span class="keywd">otherwise</span>:
        <span class="keywd">if</span> n = 0_ <span class="keywd">then</span>
          ackermann := ackermann(pred(m), 1_);
        <span class="keywd">else</span>
          ackermann := ackermann(pred(m), ackermann(m, pred(n)));
        <span class="keywd">end if</span>;
    <span class="keywd">end case</span>;
  <span class="keywd">end func</span>;
</pre></div>
<table width="100%" cellpadding="0" cellspacing="0">
<tr>
<td align="left" width="60%">
<b><big><hr \></big></b></td>
<td align="right">
<table border="0" cellspacing="1" bgcolor="blue">
<tr bgcolor="gainsboro">
<td>&nbsp;<a class="navigation" href="../algorith/float.htm">previous</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/index.htm">up</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/msgdigest.htm">next</a>&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</div>
  </body>
</html>
