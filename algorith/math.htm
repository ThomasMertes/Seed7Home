<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>
Seed7 Algorithms: Mathematics</title>
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body style="margin:0 0 0 0;">
<div style="background-image: url('../images/header1x.png');" class="top_image">
<img style="overflow:hidden;" src="../images/hearts7m.png" height="68" width="50"
 /><img style="overflow:hidden;" src="../images/header3.png" height="68" width="745" />
</div>
<div style="background-image: url('../images/fillpix.png');" class="space_below_top_image">
</div>
<div class="menu">

<a class="head" href="../index.htm"><big>Seed7</big></a>
<a class="menu" href="../faq.htm">FAQ</a>
<a class="menu" href="../manual/index.htm">Manual</a>
<a class="menu" href="../demo.htm">Demo</a>
<a class="menu" href="../scrshots/index.htm">Screenshots</a>
<a class="menu" href="../examples/index.htm">Examples</a>
<a class="menu" href="../libraries/index.htm">Libraries</a>
<a class="menu" href="../algorith/index.htm">Algorithms</a>
<a class="menu" href="../benchmks/index.htm">Benchmarks</a>
<a class="menu" href="../subject_index.htm">Index</a>
<a class="menu" href="http://sourceforge.net/project/showfiles.php?group_id=151126">Download</a>
<a class="menu" href="https://github.com/ThomasMertes/seed7">GitHub</a>
<a class="menu" href="../build.htm">Build Seed7</a>
<a class="menu" href="../links.htm">Links</a>

<br />

<a class="head" href="index.htm"><big>Algorithms</big></a>
<a class="menu" href="sorting.htm">Sorting</a>
<a class="menu" href="search.htm">Searching</a>
<a class="menu" href="date.htm">Date&nbsp;&&nbsp;Time</a>
<a class="menu" href="string.htm">String</a>
<a class="menu" href="float.htm">Float</a>
<a class="menu" href="math.htm">Mathematics</a>
<a class="menu" href="msgdigest.htm">Message&nbsp;digest</a>
<a class="menu" href="graphic.htm">Graphics</a>
<a class="menu" href="file.htm">File</a>
<a class="menu" href="puzzles.htm">Puzzles</a>
<a class="menu" href="others.htm">Others</a>
</div>
<div class="content">
<div style="padding-right:20;">
<table width="100%" cellpadding="0" cellspacing="0">
<tr>
<td align="left" width="80">
<a class="head" href="index.htm"><big>Algorithms</big></a>
</td>
<td>
<table width="10">
</table>
</td>
<td align="left" width="60%">
<b><big>Mathematics</big></b></td>
<td align="right">
<table border="0" cellspacing="1" bgcolor="blue">
<tr bgcolor="gainsboro">
<td>&nbsp;<a class="navigation" href="../algorith/float.htm">previous</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/index.htm">up</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/msgdigest.htm">next</a>&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
<p>
</p>

<div><a name="isPrime"><h3>Determine wether a given integer number is prime</h3></a>
<p>
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#boolean">boolean</a>: isPrime (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: number) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#boolean">boolean</a>: prime <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> FALSE;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: upTo <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: testNum <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 3;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> number = 2 <span class="keywd">then</span>
      prime <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> TRUE;
    <span class="keywd">elsif</span> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(number) <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> number > 2 <span class="keywd">then</span>
      upTo <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> <a class="func" href="../libraries/integer.htm#sqrt(in_integer)">sqrt</a>(number);
      <span class="keywd">while</span> number <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> testNum &lt;> 0 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> testNum &lt;= upTo <span class="keywd">do</span>
        testNum +:= 2;
      <span class="keywd">end while</span>;
      prime <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> testNum > upTo;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="sieve_of_eratosthenes"><h3>Sieve of Eratosthenes</h3></a>
<p>
The program below computes the number of primes between 1 and 10000000:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/seed7_05.htm">seed7_05.s7i</a>"</span>;

<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#set">set</a> <span class="type">of</span> <a class="type" href="../manual/types.htm#integer">integer</a>: eratosthenes (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: n) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#set">set</a> <span class="type">of</span> <a class="type" href="../manual/types.htm#integer">integer</a>: sieve <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> EMPTY_SET;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: i <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: j <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    sieve <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> {2 .. n};
    <a class="keywd_no_ul" href="../manual/stats.htm#for-statement">for</a> i <a class="keywd_no_ul" href="../manual/stats.htm#for-statement">range</a> 2 <a class="keywd_no_ul" href="../manual/stats.htm#for-statement">to</a> <a class="func" href="../libraries/integer.htm#sqrt(in_integer)">sqrt</a>(n) <a class="keywd_no_ul" href="../manual/stats.htm#for-statement">do</a>
      <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">if</a> i <a class="op_no_ul" href="../libraries/bitset.htm#(in_integer)in(in_bitset)">in</a> sieve <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">then</a>
        <a class="keywd_no_ul" href="../manual/stats.htm#for-step-statement">for</a> j <a class="keywd_no_ul" href="../manual/stats.htm#for-step-statement">range</a> i ** 2 <a class="keywd_no_ul" href="../manual/stats.htm#for-step-statement">to</a> n <a class="keywd_no_ul" href="../manual/stats.htm#for-step-statement">step</a> i <a class="keywd_no_ul" href="../manual/stats.htm#for-step-statement">do</a>
          <a class="func" href="../libraries/bitset.htm#excl(inout_bitset,in_integer)">excl</a>(sieve, j);
        <a class="keywd_no_ul" href="../manual/stats.htm#for-step-statement">end</a> <a class="keywd_no_ul" href="../manual/stats.htm#for-step-statement">for</a>;
      <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">end</a> <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">if</a>;
    <a class="keywd_no_ul" href="../manual/stats.htm#for-statement">end</a> <a class="keywd_no_ul" href="../manual/stats.htm#for-statement">for</a>;
  <span class="keywd">end func</span>;

<a class="keywd_no_ul" href="../manual/decls.htm#Procedure_declarations">const</a> <a class="type" href="../manual/types.htm#proc">proc</a>: main <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(<a class="func" href="../libraries/bitset.htm#card(in_bitset)">card</a>(eratosthenes(10000000)));
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="goldbach"><h3>Verify Goldbach's conjecture up to 10000000</h3></a>
<p>
Goldbach's conjecture states that all even integers greater than 2
can be expressed as the sum of two primes. Goldbach's conjecture
is one of the oldest unsolved problems. The program below checks
all even numbers between 4 and 10000000:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/seed7_05.htm">seed7_05.s7i</a>"</span>;

<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#set">set</a> <span class="type">of</span> <a class="type" href="../manual/types.htm#integer">integer</a>: eratosthenes (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: n) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#set">set</a> <span class="type">of</span> <a class="type" href="../manual/types.htm#integer">integer</a>: sieve <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> EMPTY_SET;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: i <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: j <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    sieve <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> {2 .. n};
    <a class="keywd_no_ul" href="../manual/stats.htm#for-statement">for</a> i <a class="keywd_no_ul" href="../manual/stats.htm#for-statement">range</a> 2 <a class="keywd_no_ul" href="../manual/stats.htm#for-statement">to</a> <a class="func" href="../libraries/integer.htm#sqrt(in_integer)">sqrt</a>(n) <a class="keywd_no_ul" href="../manual/stats.htm#for-statement">do</a>
      <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">if</a> i <a class="op_no_ul" href="../libraries/bitset.htm#(in_integer)in(in_bitset)">in</a> sieve <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">then</a>
        <a class="keywd_no_ul" href="../manual/stats.htm#for-step-statement">for</a> j <a class="keywd_no_ul" href="../manual/stats.htm#for-step-statement">range</a> i ** 2 <a class="keywd_no_ul" href="../manual/stats.htm#for-step-statement">to</a> n <a class="keywd_no_ul" href="../manual/stats.htm#for-step-statement">step</a> i <a class="keywd_no_ul" href="../manual/stats.htm#for-step-statement">do</a>
          <a class="func" href="../libraries/bitset.htm#excl(inout_bitset,in_integer)">excl</a>(sieve, j);
        <a class="keywd_no_ul" href="../manual/stats.htm#for-step-statement">end</a> <a class="keywd_no_ul" href="../manual/stats.htm#for-step-statement">for</a>;
      <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">end</a> <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">if</a>;
    <a class="keywd_no_ul" href="../manual/stats.htm#for-statement">end</a> <a class="keywd_no_ul" href="../manual/stats.htm#for-statement">for</a>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#integer">integer</a>: limit <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 10000000;

<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#boolean">boolean</a>: isGoldbachNumber (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: number) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#boolean">boolean</a>: isGoldbachNumber <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#set">set</a> <span class="type">of</span> <a class="type" href="../manual/types.htm#integer">integer</a>: primes <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> eratosthenes(limit);
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: testNum <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> testNum <span class="keywd">range</span> primes <span class="keywd">until</span> isGoldbachNumber <span class="keywd">do</span>
      isGoldbachNumber <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> (number - testNum) <a class="op" href="../libraries/bitset.htm#(in_integer)in(in_bitset)">in</a> primes;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;

<a class="keywd_no_ul" href="../manual/decls.htm#Procedure_declarations">const</a> <a class="type" href="../manual/types.htm#proc">proc</a>: main <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: number <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> number <span class="keywd">range</span> 4 <span class="keywd">to</span> limit <span class="keywd">step</span> 2 <span class="keywd">do</span>
      <span class="keywd">if</span> <a class="op" href="../libraries/boolean.htm#not(in_boolean)">not</a> isGoldbachNumber(number) <span class="keywd">then</span>
        writeln(number &lt;&amp; <span class="stri">" is not a Goldbach number"</span>);
      <span class="keywd">end if</span>;
      <span class="keywd">if</span> number <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> 16384 = 0 <span class="keywd">then</span>
        write(<span class="stri">"."</span>);
        flush(OUT);
      <span class="keywd">end if</span>;
    <span class="keywd">end for</span>;
    writeln;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="factorise"><h3>Function to calculate the prime factors of a number</h3></a>
<p>
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: factorise (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: number) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: factors <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0 <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> 0;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: checker <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 2;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> checker * checker &lt;= number <span class="keywd">do</span>
      <span class="keywd">if</span> number <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> checker = 0 <span class="keywd">then</span>
        factors &:= [](checker);
        number <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> number <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> checker;
      <span class="keywd">else</span>
        incr(checker);
      <span class="keywd">end if</span>;
    <span class="keywd">end while</span>;
    <span class="keywd">if</span> number &lt;> 1 <span class="keywd">then</span>
      factors &:= [](number);
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="lucasLehmerTest"><h3>Verify if a given Mersenne number is prime</h3></a>
<p>
A Mersenne number is a number that is one less than a power of two (<tt>2**p-1</tt>).
The Lucas-Lehmer test allows to check if a given Mersenne number is prime:
For the odd prime p, the Mersenne number <tt>2**p-1</tt> is prime if and
only if <tt>S(p-1) rem 2**p-1 = 0</tt> where <tt>S(1)=4 and S(n)=S(n-1)**2-2</tt>.
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#boolean">boolean</a>: lucasLehmerTest (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: p) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#boolean">boolean</a>: prime <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> TRUE;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: m_p <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: s <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 4_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: i <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> p &lt;> 2 <span class="keywd">then</span>
      m_p <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 2_ ** p - 1_;
      <span class="keywd">for</span> i <span class="keywd">range</span> 2 <span class="keywd">to</span> pred(p) <span class="keywd">do</span>
        s <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> (s ** 2 - 2_) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)rem(in_bigInteger)">rem</a> m_p;
      <span class="keywd">end for</span>;
      prime <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> s = 0_;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="millerRabin"><h3>Miller-Rabin primality test</h3></a>
<p>
The Miller-Rabin primality test is a probabilistic algorithm,
which determines whether a given number is prime or not.
The number of tests is specified with the parameter <tt>k</tt>.
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#boolean">boolean</a>: millerRabin (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: n, <a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: k) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#boolean">boolean</a>: probablyPrime <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> TRUE;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: d <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: r <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: s <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: a <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: x <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: tests <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> n &lt; 2_ <a class="op" href="../libraries/boolean.htm#(in_boolean)or(ref_func_boolean)">or</a> (n > 2_ <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> <a class="op" href="../libraries/boolean.htm#not(in_boolean)">not</a> <a class="func" href="../libraries/bigint.htm#odd(in_bigInteger)">odd</a>(n)) <span class="keywd">then</span>
      probablyPrime <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> FALSE;
    <span class="keywd">elsif</span> n > 3_ <span class="keywd">then</span>
      d <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> pred(n);
      s <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> <a class="func" href="../libraries/bigint.htm#lowestSetBit(in_bigInteger)">lowestSetBit</a>(d);
      d >>:= s;
      <span class="keywd">while</span> tests &lt; k <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> probablyPrime <span class="keywd">do</span>
        a <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> <a class="func" href="../libraries/bigint.htm#rand(in_bigInteger,in_bigInteger)">rand</a>(2_, pred(n));
        x <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> <a class="func" href="../libraries/bigint.htm#modPow(in_var_bigInteger,in_var_bigInteger,in_bigInteger)">modPow</a>(a, d, n);
        <span class="keywd">if</span> x &lt;> 1_ <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> x &lt;> pred(n) <span class="keywd">then</span>
          r <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 1;
          <span class="keywd">while</span> r &lt; s <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> x &lt;> 1_ <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> x &lt;> pred(n) <span class="keywd">do</span>
            x <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> <a class="func" href="../libraries/bigint.htm#modPow(in_var_bigInteger,in_var_bigInteger,in_bigInteger)">modPow</a>(x, 2_, n);
            incr(r);
          <span class="keywd">end while</span>;
          probablyPrime <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> x = pred(n);
        <span class="keywd">end if</span>;
        incr(tests);
      <span class="keywd">end while</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="gcd"><h3>Determine the greatest common divisor of two positive integer numbers</h3></a>
<p>
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#integer">integer</a>: gcd (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: a, <span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: b) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: gcd <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: help <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> a &lt;> 0 <span class="keywd">do</span>
      help <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> b <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> a;
      b <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> a;
      a <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> help;
    <span class="keywd">end while</span>;
    gcd <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> b;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="lcm"><h3>Determine the least common multiple of two positive integer numbers</h3></a>
<p>
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#integer">integer</a>: lcm (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: a, <a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: b) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a>
  <span class="keywd">return</span> a div gcd(a, b) * b;
</pre></div>

<div><a name="int_binaryGcd"><h3>Binary greatest common divisor algorithm for two positive integer numbers</h3></a>
<p>
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#integer">integer</a>: binaryGcd (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: a, <span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: b) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: gcd <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: shift <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: diff <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> a = 0 <span class="keywd">then</span>
      gcd <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> b;
    <span class="keywd">elsif</span> b = 0 <span class="keywd">then</span>
      gcd <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> a;
    <span class="keywd">else</span>
      <a class="comment" href="../manual/tokens.htm#Comments">(* Let shift := log2(K), where K is the greatest power of 2
         dividing both a and b. *)</a>
      <span class="keywd">while</span> <a class="op" href="../libraries/boolean.htm#not(in_boolean)">not</a> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(a) <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> <a class="op" href="../libraries/boolean.htm#not(in_boolean)">not</a> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(b) <span class="keywd">do</span>
          a >>:= 1;
          b >>:= 1;
        incr(shift);
      <span class="keywd">end while</span>;

      <span class="keywd">while</span> <a class="op" href="../libraries/boolean.htm#not(in_boolean)">not</a> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(a) <span class="keywd">do</span>
        a >>:= 1;
      <span class="keywd">end while</span>;

      <a class="comment" href="../manual/tokens.htm#Comments">(* From here on, a is always odd. *)</a>
      <span class="keywd">repeat</span>
        <span class="keywd">while</span> <a class="op" href="../libraries/boolean.htm#not(in_boolean)">not</a> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(b) <span class="keywd">do</span>
          b >>:= 1;
        <span class="keywd">end while</span>;

        <a class="comment" href="../manual/tokens.htm#Comments">(* Now a and b are both odd, so diff(a, b) is even.
           Let a := min(a, b); b := diff(a, b)/2; *)</a>
        <span class="keywd">if</span> a &lt; b <span class="keywd">then</span>
          b -:= a;
        <span class="keywd">else</span>
          diff <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> a - b;
          a <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> b;
          b <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> diff;
        <span class="keywd">end if</span>;
        b >>:= 1;
      <span class="keywd">until</span> b = 0;

      gcd <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> a &lt;&lt; shift;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="big_binaryGcd"><h3>Binary greatest common divisor algorithm for two bigInteger numbers</h3></a>
<p>
The library <span class="stri">"<a class="lib" href="../libraries/bigint.htm">bigint.s7i</a>"</span> defines the
<tt><a class="type" href="../manual/types.htm#bigInteger">bigInteger</a></tt> function <tt><a class="func" href="../libraries/bigint.htm#gcd(in_bigInteger,in_bigInteger)">gcd</a></tt>.
The function <tt>'binaryGcd'</tt> below uses the binary greatest common divisor algorithm:
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: binaryGcd (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: a, <span class="keywd">in var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: b) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: gcd <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: lowestSetBitA <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: shift <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: diff <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> a = 0_ <span class="keywd">then</span>
      gcd <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> b;
    <span class="keywd">elsif</span> b = 0_ <span class="keywd">then</span>
      gcd <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> a;
    <span class="keywd">else</span>
      <span class="keywd">if</span> a &lt; 0_ <span class="keywd">then</span>
        a <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> -a;
      <span class="keywd">end if</span>;
      <span class="keywd">if</span> b &lt; 0_ <span class="keywd">then</span>
        b <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> -b;
      <span class="keywd">end if</span>;
      lowestSetBitA <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> <a class="func" href="../libraries/bigint.htm#lowestSetBit(in_bigInteger)">lowestSetBit</a>(a);
      shift <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> <a class="func" href="../libraries/bigint.htm#lowestSetBit(in_bigInteger)">lowestSetBit</a>(b);
      <span class="keywd">if</span> lowestSetBitA &lt; shift <span class="keywd">then</span>
        shift <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> lowestSetBitA;
      <span class="keywd">end if</span>;
      a >>:= lowestSetBitA;
      <span class="keywd">repeat</span>
        b >>:= <a class="func" href="../libraries/bigint.htm#lowestSetBit(in_bigInteger)">lowestSetBit</a>(b);
        <span class="keywd">if</span> a &lt; b <span class="keywd">then</span>
          b -:= a;
        <span class="keywd">else</span>
          diff <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> a - b;
          a <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> b;
          b <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> diff;
        <span class="keywd">end if</span>;
      <span class="keywd">until</span> b = 0_;
      gcd <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> a &lt;&lt; shift;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="modInverse"><h3>Return the modular multiplicative inverse of a modulo b</h3></a>
<p>
The library <span class="stri">"<a class="lib" href="../libraries/bigint.htm">bigint.s7i</a>"</span> defines the
<tt><a class="type" href="../manual/types.htm#bigInteger">bigInteger</a></tt> function <tt><a class="func" href="../libraries/bigint.htm#modInverse(in_var_bigInteger,in_var_bigInteger)">modInverse</a></tt>.
It returns the modular multiplicative inverse of a modulo b if
a and b are coprime (<tt><a class="func" href="../libraries/bigint.htm#gcd(in_bigInteger,in_bigInteger)">gcd</a>(a, b) = 1</tt>). If a and b are not coprime
(<tt><a class="func" href="../libraries/bigint.htm#gcd(in_bigInteger,in_bigInteger)">gcd</a>(a, b) &lt;> 1</tt>) the <a class="link" href="../manual/errors.htm#Exceptions">exception</a> RANGE_ERROR is raised.
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: modInverse (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: a,
    <span class="keywd">in var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: b) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: inverse <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: b_bak <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: x <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: y <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 1_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: lastx <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 1_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: lasty <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: temp <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: quotient <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> b &lt; 0_ <span class="keywd">then</span>
      <span class="keywd">raise</span> RANGE_ERROR;
    <span class="keywd">end if</span>;
    <span class="keywd">if</span> a &lt; 0_ <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> b &lt;> 0_ <span class="keywd">then</span>
      a <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> a <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> b;
    <span class="keywd">end if</span>;
    b_bak <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> b;
    <span class="keywd">while</span> b &lt;> 0_ <span class="keywd">do</span>
      temp <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> b;
      quotient <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> a <a class="op" href="../libraries/bigint.htm#(in_bigInteger)div(in_bigInteger)">div</a> b;
      b <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> a <a class="op" href="../libraries/bigint.htm#(in_bigInteger)rem(in_bigInteger)">rem</a> b;
      a <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> temp;

      temp <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> x;
      x <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> lastx - quotient * x;
      lastx <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> temp;

      temp <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> y;
      y <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> lasty - quotient * y;
      lasty <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> temp;
    <span class="keywd">end while</span>;
    <span class="keywd">if</span> a = 1_ <span class="keywd">then</span>
      inverse <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> lastx;
      <span class="keywd">if</span> inverse &lt; 0_ <span class="keywd">then</span>
        inverse +:= b_bak;
      <span class="keywd">end if</span>;
    <span class="keywd">else</span>
      <span class="keywd">raise</span> RANGE_ERROR;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="modPow"><h3>Modular exponentiation with the binary method</h3></a>
<p>
The function <tt><a class="func" href="../libraries/bigint.htm#modPow(in_var_bigInteger,in_var_bigInteger,in_bigInteger)">modPow</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/bigint.htm">bigint.s7i</a>"</span> library.
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: modPow (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: base,
    <span class="keywd">in var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: exponent, <a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: modulus) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: power <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 1_;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> exponent &lt; 0_ <a class="op" href="../libraries/boolean.htm#(in_boolean)or(ref_func_boolean)">or</a> modulus &lt; 0_ <span class="keywd">then</span>
      <span class="keywd">raise</span> RANGE_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">while</span> exponent > 0_ <span class="keywd">do</span>
        <span class="keywd">if</span> <a class="func" href="../libraries/bigint.htm#odd(in_bigInteger)">odd</a>(exponent) <span class="keywd">then</span>
          power <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> (power * base) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> modulus;
        <span class="keywd">end if</span>;
        exponent >>:= 1;
        base <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> base ** 2 <a class="op" href="../libraries/bigint.htm#(in_bigInteger)mod(in_bigInteger)">mod</a> modulus;
      <span class="keywd">end while</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="compute_pi_machin"><h3>Compute PI with 1000 decimal digits using John Machin's formula</h3></a>
<p>
The function <tt>'compute_pi_machin'</tt> approximates PI as <tt><a class="type" href="../manual/types.htm#bigRational">bigRational</a></tt> number.
To compute PI with more digits the upper bound of the <a class="keywd" href="../manual/stats.htm#for-statement">for-loop</a> needs to be adjusted, together
with the right operand of the <tt><a class="keywd" href="../libraries/bigrat.htm#(in_bigRational)digits(in_integer)">digits</a></tt> operator. E.g.: For 2000 digits the upper bound of the <a class="keywd" href="../manual/stats.htm#for-statement">for-loop</a> must be 1429 instead of 713.
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/seed7_05.htm">seed7_05.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bigint.htm">bigint.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bigrat.htm">bigrat.s7i</a>"</span>;

<a class="comment" href="../manual/tokens.htm#Line_comments"># John Machin's formula from 1706:</a>
<a class="comment" href="../manual/tokens.htm#Line_comments"># PI = 16 * arctan(1 / 5) - 4 * arctan(1 / 239)</a>

<a class="comment" href="../manual/tokens.htm#Line_comments"># Taylor series for arctan:</a>
<a class="comment" href="../manual/tokens.htm#Line_comments"># arctan(x) = sum_n_from_0_to_inf((-1) ** n / succ(2 * n) * x ** succ(2 * n))</a>

<a class="comment" href="../manual/tokens.htm#Line_comments"># Taylor series of John Machin's formula:</a>
<a class="comment" href="../manual/tokens.htm#Line_comments"># PI = sum_n_from_0_to_inf(16 * (-1) ** n / (succ(2 * n) *   5 ** succ(2 * n)) -</a>
<a class="comment" href="../manual/tokens.htm#Line_comments">#                           4 * (-1) ** n / (succ(2 * n) * 239 ** succ(2 * n)))</a>

<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigRational">bigRational</a>: compute_pi_machin <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigRational">bigRational</a>: sum <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_ / 1_;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: n <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> n <span class="keywd">range</span> 0 <span class="keywd">to</span> 713 <span class="keywd">do</span>
      sum +:= 16_ * (-1_) ** n / (<a class="type" href="../manual/types.htm#bigInteger">bigInteger</a> <a class="op" href="../libraries/bigint.htm#(attr_bigInteger)conv(in_integer)">conv</a> succ(2 * n) *   5_ ** succ(2 * n)) -
               4_ * (-1_) ** n / (<a class="type" href="../manual/types.htm#bigInteger">bigInteger</a> <a class="op" href="../libraries/bigint.htm#(attr_bigInteger)conv(in_integer)">conv</a> succ(2 * n) * 239_ ** succ(2 * n));
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;

<a class="keywd_no_ul" href="../manual/decls.htm#Procedure_declarations">const</a> <a class="type" href="../manual/types.htm#proc">proc</a>: main <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(compute_pi_machin <a class="op" href="../libraries/bigrat.htm#(in_bigRational)digits(in_integer)">digits</a> 1000);
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="compute_pi_bailey_borwein_plouffe"><h3>Compute PI with 1000 decimal digits using the Bailey/Borwein/Plouffe formula</h3></a>
<p>
The function <tt>'compute_pi_bailey_borwein_plouffe'</tt> approximates PI as <tt><a class="type" href="../manual/types.htm#bigRational">bigRational</a></tt> number.
To compute PI with more digits the upper bound of the <a class="keywd" href="../manual/stats.htm#for-statement">for-loop</a> needs to be adjusted, together
with the right operand of the <tt><a class="keywd" href="../libraries/bigrat.htm#(in_bigRational)digits(in_integer)">digits</a></tt> operator. E.g.: For 2000 digits the upper bound of the <a class="keywd" href="../manual/stats.htm#for-statement">for-loop</a> must be 1655 instead of 825.
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/seed7_05.htm">seed7_05.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bigint.htm">bigint.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bigrat.htm">bigrat.s7i</a>"</span>;

<a class="comment" href="../manual/tokens.htm#Line_comments"># In 1997, David H. Bailey, Peter Borwein and Simon Plouffe published a</a>
<a class="comment" href="../manual/tokens.htm#Line_comments"># paper (Bailey, 1997) on a new formula for PI as an infinite series:</a>

<a class="comment" href="../manual/tokens.htm#Line_comments"># PI = sum_n_from_0_to_inf(16 ** (-n) *</a>
<a class="comment" href="../manual/tokens.htm#Line_comments">#      (4 / (8 * n + 1) - 2 / (8 * n + 4) - 1 / (8 * n + 5) - 1 / (8 * n + 6)))</a>

<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigRational">bigRational</a>: compute_pi_bailey_borwein_plouffe <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigRational">bigRational</a>: sum <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_ / 1_;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: n <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: k8 <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> n <span class="keywd">range</span> 0 <span class="keywd">to</span> 825 <span class="keywd">do</span>
      k8 <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> bigInteger <a class="op" href="../libraries/bigint.htm#(attr_bigInteger)conv(in_integer)">conv</a> (8 * n);
      sum +:= 1_ / 16_ ** n *
          (4_ / (k8 + 1_) - 2_ / (k8 + 4_) - 1_ / (k8 + 5_) - 1_ / (k8 + 6_));
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;

<a class="keywd_no_ul" href="../manual/decls.htm#Procedure_declarations">const</a> <a class="type" href="../manual/types.htm#proc">proc</a>: main <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln(compute_pi_bailey_borwein_plouffe <a class="op" href="../libraries/bigrat.htm#(in_bigRational)digits(in_integer)">digits</a> 1000);
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="compute_pi_newton"><h3>Write PI with 1000 decimal digits using Newtons formula</h3></a>
<p>
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/seed7_05.htm">seed7_05.s7i</a>"</span>;

<a class="comment" href="../manual/tokens.htm#Line_comments"># Newtons formula for PI is:</a>
<a class="comment" href="../manual/tokens.htm#Line_comments"># PI / 2 = sum_n_from_0_to_inf(n! / (2 * n + 1)!!)</a>

<a class="comment" href="../manual/tokens.htm#Line_comments"># This can be written as:</a>
<a class="comment" href="../manual/tokens.htm#Line_comments"># PI / 2 = 1 + 1/3 * (1 + 2/5 * (1 + 3/7 * (1 + 4/9 * (1 + ... ))))</a>

<a class="comment" href="../manual/tokens.htm#Line_comments"># This algorithm puts 2 * 1000 on the right side and computes everything from inside out.</a>

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#integer">integer</a>: SCALE <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 10000;
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#integer">integer</a>: MAXARR <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 3500;
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#integer">integer</a>: ARRINIT <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 2000;

<a class="keywd_no_ul" href="../manual/decls.htm#Procedure_declarations">const</a> <a class="type" href="../manual/types.htm#proc">proc</a>: main <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: i <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: j <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: carry <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: arr <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> MAXARR <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> ARRINIT;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: sum <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> i <span class="keywd">range</span> MAXARR <span class="keywd">downto</span> 1 <span class="keywd">step</span> 14 <span class="keywd">do</span>
      sum <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 0;
      <span class="keywd">for</span> j <span class="keywd">range</span> i <span class="keywd">downto</span> 1 <span class="keywd">do</span>
        sum <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> sum*j + SCALE*arr[j];
        arr[j] <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> sum <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> pred(j*2);
        sum <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> sum <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> pred(j*2);
      <span class="keywd">end for</span>;
      write(carry + sum <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> SCALE <span class="op">lpad0</span> 4);
      carry <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> sum <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> SCALE;
    <span class="keywd">end for</span>;
    writeln;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="pi_spigot_algorithm"><h3>Write the decimal digits of PI with a spigot algorithm</h3></a>
<p>
The program below uses the unbounded spigot algorithm published by Jeremy Gibbons.
The digits of PI are calculated and written in succession.
To stop the program press ctrl-C followed by * and ENTER.
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/seed7_05.htm">seed7_05.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bigint.htm">bigint.s7i</a>"</span>;

<a class="keywd_no_ul" href="../manual/decls.htm#Procedure_declarations">const</a> <a class="type" href="../manual/types.htm#proc">proc</a>: main <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: q <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 1_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: r <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: t <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 1_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: k <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 1_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: n <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 3_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: l <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 3_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: nn <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: nr <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#boolean">boolean</a>: first <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> TRUE <span class="keywd">do</span>
      <span class="keywd">if</span> 4_ * q + r - t &lt; n * t <span class="keywd">then</span>
        write(n);
        <span class="keywd">if</span> first <span class="keywd">then</span>
          write(<span class="stri">"."</span>);
          first <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> FALSE;
        <span class="keywd">end if</span>;
        nr <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 10_ * (r - n * t);
        n <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 10_ * (3_ * q + r) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)div(in_bigInteger)">div</a> t - 10_ * n;
        q *:= 10_;
        r <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> nr;
        flush(OUT);
      <span class="keywd">else</span>
        nr <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> (2_ * q + r) * l;
        nn <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> (q * (7_ * k + 2_) + r * l) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)div(in_bigInteger)">div</a> (t * l);
        q *:= k;
        t *:= l;
        l +:= 2_;
        incr(k);
        n <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> nn;
        r <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> nr;
      <span class="keywd">end if</span>;
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="intSqrt"><h3>Determine the truncated square root of a big integer number</h3></a>
<p>
The library <span class="stri">"<a class="lib" href="../libraries/bigint.htm">bigint.s7i</a>"</span> defines the
<tt><a class="type" href="../manual/types.htm#bigInteger">bigInteger</a></tt> function <tt><a class="func" href="../libraries/bigint.htm#sqrt(in_var_bigInteger)">sqrt</a></tt>.
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: sqrt (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: number) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: root <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: res2 <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> number > 0_ <span class="keywd">then</span>
      res2 <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> number;
      <span class="keywd">repeat</span>
        root <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> res2;
        res2 <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> (root + number <a class="op" href="../libraries/bigint.htm#(in_bigInteger)div(in_bigInteger)">div</a> root) <a class="op" href="../libraries/bigint.htm#(in_bigInteger)div(in_bigInteger)">div</a> 2_;
      <span class="keywd">until</span> root &lt;= res2;
    <span class="keywd">else</span>
      <span class="keywd">raise</span> NUMERIC_ERROR;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="nthRoot"><h3>Function to compute the nth root of a positive float number</h3></a>
<p>
The nth root of the number <tt>'a'</tt> can be computed with
the exponentiation operator: <tt>'a <a class="keywd" href="../libraries/float.htm#(in_float)**(in_float)">**</a> (1.0 / <a class="func" href="../libraries/float.htm#float(in_integer)">float</a>(n))'</tt>.
An alternate function which uses Newton's method is:
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#float">float</a>: nthRoot (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: n, <a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#float">float</a>: a) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#float">float</a>: x1 <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0.0;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#float">float</a>: x0 <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0.0;
  <span class="keywd">begin</span>
    x0 <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> a;
    x1 <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> a / <a class="func" href="../libraries/float.htm#float(in_integer)">float</a>(n);
    <span class="keywd">while</span> abs(x1 - x0) >= abs(x0 * 1.0E-9) <span class="keywd">do</span>
      x0 <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> x1;
      x1 <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> (<a class="func" href="../libraries/float.htm#float(in_integer)">float</a>(pred(n)) * x0 + a / x0 ** pred(n)) / <a class="func" href="../libraries/float.htm#float(in_integer)">float</a>(n);
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="intPow"><h3>Exponentiation function for integers</h3></a>
<p>
The type <tt><a class="type" href="../manual/types.htm#integer">integer</a></tt> defines an exponentiation operator which
can be called with <tt>'base <a class="keywd" href="../libraries/integer.htm#(in_integer)**(in_integer)">**</a> exponent'</tt>. The Seed7 runtime library
contains the function <tt>'intPow'</tt> which implements the
<tt><a class="keywd" href="../libraries/integer.htm#(in_integer)**(in_integer)">**</a></tt> operator. This function uses the exponentiation
by squaring algorithm. The Seed7 version of <tt>'intPow'</tt> is:
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#integer">integer</a>: intPow (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: base, <span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: exponent) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: power <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> exponent &lt; 0 <span class="keywd">then</span>
      raise(NUMERIC_ERROR);
    <span class="keywd">else</span>
      <span class="keywd">if</span> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(exponent) <span class="keywd">then</span>
        power <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> base;
      <span class="keywd">else</span>
        power <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 1;
      <span class="keywd">end if</span>;
      exponent <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> exponent <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> 2;
      <span class="keywd">while</span> exponent &lt;> 0 <span class="keywd">do</span>
        base *:= base;
        <span class="keywd">if</span> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(exponent) <span class="keywd">then</span>
          power *:= base;
        <span class="keywd">end if</span>;
        exponent <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> exponent <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> 2;
      <span class="keywd">end while</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="fltIPow"><h3>Exponentiation function for float base and integer exponent</h3></a>
<p>
The type <tt><a class="type" href="../manual/types.htm#float">float</a></tt> defines an exponentiation operator which
can be called with <tt>'base <a class="keywd" href="../libraries/float.htm#(in_float)**(in_integer)">**</a> exponent'</tt>. The Seed7 runtime library
contains the function <tt>'fltIPow'</tt> which implements the
<tt><a class="keywd" href="../libraries/float.htm#(in_float)**(in_integer)">**</a></tt> operator. This function uses the exponentiation
by squaring algorithm. The Seed7 version of <tt>'fltIPow'</tt> is:
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#float">float</a>: fltIPow (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#float">float</a>: base, <span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: exponent) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#float">float</a>: power <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 1.0;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: stop <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> base = 0.0 <span class="keywd">then</span>
      <span class="keywd">if</span> exponent &lt; 0 <span class="keywd">then</span>
        power <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> <a class="var" href="../libraries/float.htm#Infinity">Infinity</a>;
      <span class="keywd">elsif</span> exponent > 0 <span class="keywd">then</span>
        power <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 0.0;
      <span class="keywd">end if</span>;
    <span class="keywd">else</span>
      <span class="keywd">if</span> exponent &lt; 0 <span class="keywd">then</span>
        stop <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> -1;
      <span class="keywd">end if</span>;
      <span class="keywd">if</span> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(exponent) <span class="keywd">then</span>
        power <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> base;
      <span class="keywd">end if</span>;
      exponent >>:= 1;
      <span class="keywd">while</span> exponent &lt;> stop <span class="keywd">do</span>
        base *:= base;
        <span class="keywd">if</span> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(exponent) <span class="keywd">then</span>
          power *:= base;
        <span class="keywd">end if</span>;
        exponent >>:= 1;
      <span class="keywd">end while</span>;
      <span class="keywd">if</span> stop = -1 <span class="keywd">then</span>
        power <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 1.0 / power;
      <span class="keywd">end if</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="peasantMult"><h3>Multiply integers using the peasant multiplication</h3></a>
<p>
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#integer">integer</a>: peasantMult (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: a, <span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: b) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: product <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> a &lt;> 0 <span class="keywd">do</span>
      <span class="keywd">if</span> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(a) <span class="keywd">then</span>
        product +:= b;
      <span class="keywd">end if</span>;
      a <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> a <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> 2;
      b *:= 2;
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="binomial_coefficient"><h3>Binomial coefficient</h3></a>
<p>
The type <tt><a class="type" href="../manual/types.htm#integer">integer</a></tt> defines the infix operator <tt><a class="keywd" href="../libraries/integer.htm#(in_integer)!(in_integer)">!</a></tt> to compute the binomial
coefficient. Below is the definition of the <tt><a class="type" href="../manual/types.htm#bigInteger">bigInteger</a></tt> infix operator
<tt><a class="keywd" href="../libraries/bigint.htm#(in_bigInteger)!(in_var_bigInteger)">!</a></tt> from the library <span class="stri">"<a class="lib" href="../libraries/bigint.htm">bigint.s7i</a>"</span>.
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: n) ! (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: k) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: binom <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: numerator <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: denominator <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> n >= 0_ <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> k > n >> 1 <span class="keywd">then</span>
      k <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> n - k;
    <span class="keywd">end if</span>;
    <span class="keywd">if</span> k &lt; 0_ <span class="keywd">then</span>
      binom <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 0_;
    <span class="keywd">elsif</span> k = 0_ <span class="keywd">then</span>
      binom <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 1_;
    <span class="keywd">else</span>
      binom <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> n;
      numerator <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> pred(n);
      denominator <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 2_;
      <span class="keywd">while</span> denominator &lt;= k <span class="keywd">do</span>
        binom *:= numerator;
        binom <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> binom <a class="op" href="../libraries/bigint.htm#(in_bigInteger)div(in_bigInteger)">div</a> denominator;
        decr(numerator);
        incr(denominator);
      <span class="keywd">end while</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="gamma"><h3>Gamma function</h3></a>
<p>
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#float">float</a>: gamma (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#float">float</a>: X) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#float">float</a>: gamma <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0.0;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#float">float</a>: A <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> [] (
         1.00000000000000000000,  0.57721566490153286061,
        -0.65587807152025388108, -0.04200263503409523553,
         0.16653861138229148950, -0.04219773455554433675,
        -0.00962197152787697356,  0.00721894324666309954,
        -0.00116516759185906511, -0.00021524167411495097,
         0.00012805028238811619, -0.00002013485478078824,
        -0.00000125049348214267,  0.00000113302723198170,
        -0.00000020563384169776,  0.00000000611609510448,
         0.00000000500200764447, -0.00000000118127457049,
         0.00000000010434267117,  0.00000000000778226344,
        -0.00000000000369680562,  0.00000000000051003703,
        -0.00000000000002058326, -0.00000000000000534812,
         0.00000000000000122678, -0.00000000000000011813,
         0.00000000000000000119,  0.00000000000000000141,
        -0.00000000000000000023,  0.00000000000000000002);
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#float">float</a>: Y <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0.0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#float">float</a>: Sum <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> A[maxIdx(A)];
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: N <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    Y <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> X - 1.0;
    <span class="keywd">for</span> N <span class="keywd">range</span> pred(maxIdx(A)) <span class="keywd">downto</span> minIdx(A) <span class="keywd">do</span>
      Sum <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> Sum * Y + A[N];
    <span class="keywd">end for</span>;
    gamma <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 1.0 / Sum;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="madd"><h3>Matrix addition</h3></a>
<p>
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Type_declarations">const</a> <a class="type" href="../manual/types.htm#type">type</a>: matrix <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#float">float</a>;

<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <span class="type">matrix</span>: (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <span class="type">matrix</span>: summand1) + (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <span class="type">matrix</span>: summand2) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <span class="type">matrix</span>: sum <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="type">matrix</span>.value;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: i <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: j <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(summand1) &lt;> length(summand2) <a class="op" href="../libraries/boolean.htm#(in_boolean)or(ref_func_boolean)">or</a>
        length(summand1[1]) &lt;> length(summand2[1]) <span class="keywd">then</span>
      <span class="keywd">raise</span> RANGE_ERROR;
    <span class="keywd">else</span>
      sum <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> length(summand1) <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> length(summand1[1]) <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> 0.0;
      <span class="keywd">for</span> i <span class="keywd">range</span> 1 <span class="keywd">to</span> length(summand1) <span class="keywd">do</span>
        <span class="keywd">for</span> j <span class="keywd">range</span> 1 <span class="keywd">to</span> length(summand1[i]) <span class="keywd">do</span>
          sum[i][j] <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> summand1[i][j] + summand2[i][j];
        <span class="keywd">end for</span>;
      <span class="keywd">end for</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="mmult"><h3>Matrix multiplication</h3></a>
<p>
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Type_declarations">const</a> <a class="type" href="../manual/types.htm#type">type</a>: matrix <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#float">float</a>;

<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <span class="type">matrix</span>: (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <span class="type">matrix</span>: factor1) * (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <span class="type">matrix</span>: factor2) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <span class="type">matrix</span>: product <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="type">matrix</span>.value;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: i <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: j <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: k <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#float">float</a>: accumulator <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0.0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(factor1[1]) &lt;> length(factor2) <span class="keywd">then</span>
      <span class="keywd">raise</span> RANGE_ERROR;
    <span class="keywd">else</span>
      product <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> length(factor1) <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> length(factor2[1]) <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> 0.0;
      <span class="keywd">for</span> i <span class="keywd">range</span> 1 <span class="keywd">to</span> length(factor1) <span class="keywd">do</span>
        <span class="keywd">for</span> j <span class="keywd">range</span> 1 <span class="keywd">to</span> length(factor2) <span class="keywd">do</span>
          accumulator <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 0.0;
          <span class="keywd">for</span> k <span class="keywd">range</span> 1 <span class="keywd">to</span> length(factor1) <span class="keywd">do</span>
            accumulator +:= factor1[i][k] * factor2[k][j];
          <span class="keywd">end for</span>;
          product[i][j] <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> accumulator;
        <span class="keywd">end for</span>;
      <span class="keywd">end for</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="matrix_exponentiation"><h3>Matrix exponentiation with integer exponent</h3></a>
<p>
Based on the <a class="link" href="#mmult">matrix multiplication</a> and the type <tt><span class="type">matrix</span></tt>
a matrix exponentiation with an integer exponent can be defined:
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <span class="type">matrix</span>: (<span class="keywd">in var</span> <span class="type">matrix</span>: base) ** (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: exponent) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <span class="type">matrix</span>: power <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> matrix.value;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: row <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: column <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> exponent &lt; 0 <span class="keywd">then</span>
      <span class="keywd">raise</span> NUMERIC_ERROR;
    <span class="keywd">else</span>
      <span class="keywd">if</span> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(exponent) <span class="keywd">then</span>
        power <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> base;
      <span class="keywd">else</span>
        <a class="comment" href="../manual/tokens.htm#Line_comments"># Create identity matrix</a>
        power <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> length(base) <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> length(base) <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> 0.0;
        <span class="keywd">for</span> row <span class="keywd">range</span> 1 <span class="keywd">to</span> length(base) <span class="keywd">do</span>
          <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> length(base) <span class="keywd">do</span>
            <span class="keywd">if</span> row = column <span class="keywd">then</span>
              power[row][column] <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 1.0;
            <span class="keywd">end if</span>;
          <span class="keywd">end for</span>;
        <span class="keywd">end for</span>;
      <span class="keywd">end if</span>;
      exponent <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> exponent <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> 2;
      <span class="keywd">while</span> exponent > 0 <span class="keywd">do</span>
        base <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> base * base;
        <span class="keywd">if</span> <a class="func" href="../libraries/integer.htm#odd(in_integer)">odd</a>(exponent) <span class="keywd">then</span>
          power <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> power * base;
        <span class="keywd">end if</span>;
        exponent <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> exponent <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> 2;
      <span class="keywd">end while</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="toRowEchelonForm"><h3>Convert a matrix to row echelon form</h3></a>
<p>
A matrix is in row echelon form if<ul>
  <li>All rows with at least one nonzero element are above any rows with all zeroes.</li>
  <li>The first nonzero number from the left, of a nonzero row is always strictly to the right of the first nonzero number from the left, in the row above it.</li></ul>
<dl><dt>The function below converts a matrix like</dt><dd><table>
<tr><td align="right">2.0</td>  <td width="20"></td> <td align="right">1.0</td>  <td width="20"></td> <td align="right">-1.0</td> <td width="20"></td> <td align="right">8.0</td></tr>
<tr><td align="right">-3.0</td> <td width="20"></td> <td align="right">-1.0</td> <td width="20"></td> <td align="right">2.0</td> <td width="20"></td> <td align="right">-11.0</td></tr>
<tr><td align="right">-2.0</td> <td width="20"></td> <td align="right">1.0</td>  <td width="20"></td> <td align="right">2.0</td> <td width="20"></td> <td align="right">-3.0</td></tr></table></dd>
<dt>into its row echelon form</dt><dd><table>
<tr><td align="right">2.0</td> <td width="20"></td> <td align="right">1.0</td> <td width="20"></td> <td align="right">-1.0</td> <td width="20"></td> <td align="right">8.0</td></tr>
<tr><td align="right">0.0</td> <td width="20"></td> <td align="right">0.5</td> <td width="20"></td> <td align="right">0.5</td>  <td width="20"></td> <td align="right">1.0</td></tr>
<tr><td align="right">0.0</td> <td width="20"></td> <td align="right">0.0</td> <td width="20"></td> <td align="right">-1.0</td> <td width="20"></td> <td align="right">1.0</td></tr></table></dd></dl>
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Type_declarations">const</a> <a class="type" href="../manual/types.htm#type">type</a>: matrix <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#float">float</a>;

<a class="keywd_no_ul" href="../manual/decls.htm#Procedure_declarations">const</a> <a class="type" href="../manual/types.htm#proc">proc</a>: toRowEchelonForm (<a class="keywd_no_ul" href="../manual/params.htm#inout_parameter">inout</a> <span class="type">matrix</span>: mat) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: numRows <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: numColumns <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: row <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: column <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: pivot <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#float">float</a>: factor <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0.0;
  <span class="keywd">begin</span>
    numRows <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> length(mat);
    numColumns <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> length(mat[1]);
    <span class="keywd">for</span> row <span class="keywd">range</span> numRows <span class="keywd">downto</span> 1 <span class="keywd">do</span>
      column <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 1;
      <span class="keywd">while</span> column &lt;= numColumns <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> mat[row][column] = 0.0 <span class="keywd">do</span>
        incr(column);
      <span class="keywd">end while</span>;
      <span class="keywd">if</span> column > numColumns <span class="keywd">then</span>
        <a class="comment" href="../manual/tokens.htm#Line_comments"># Empty rows are moved to the bottom</a>
        mat <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> mat[.. pred(row)] &amp; mat[succ(row) ..] &amp; [] (mat[row]);
        decr(numRows);
      <span class="keywd">end if</span>;
    <span class="keywd">end for</span>;
    <span class="keywd">for</span> pivot <span class="keywd">range</span> 1 <span class="keywd">to</span> numRows <span class="keywd">do</span>
      <span class="keywd">if</span> mat[pivot][pivot] = 0.0 <span class="keywd">then</span>
        <a class="comment" href="../manual/tokens.htm#Line_comments"># Find a row were the pivot column is not zero</a>
        row <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 1;
        <span class="keywd">while</span> row &lt;= numRows <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> mat[row][pivot] = 0.0 <span class="keywd">do</span>
          incr(row);
        <span class="keywd">end while</span>;
        <a class="comment" href="../manual/tokens.htm#Line_comments"># Add row were the pivot column is not zero</a>
        <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> numColumns <span class="keywd">do</span>
          mat[pivot][column] +:= mat[row][column];
        <span class="keywd">end for</span>;
      <span class="keywd">end if</span>;
      <span class="keywd">for</span> row <span class="keywd">range</span> succ(pivot) <span class="keywd">to</span> numRows <span class="keywd">do</span>
        <span class="keywd">if</span> mat[row][pivot] &lt;> 0.0 <span class="keywd">then</span>
          <a class="comment" href="../manual/tokens.htm#Line_comments"># Make sure that the pivot column contains zero in all rows below the pivot row</a>
          factor <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> -mat[row][pivot] / mat[pivot][pivot];
          <span class="keywd">for</span> column <span class="keywd">range</span> pivot <span class="keywd">to</span> numColumns <span class="keywd">do</span>
            mat[row][column] +:= mat[pivot][column] * factor;
          <span class="keywd">end for</span>;
        <span class="keywd">end if</span>;
      <span class="keywd">end for</span>;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="toReducedRowEchelonForm"><h3>Convert a matrix to reduced row echelon form</h3></a>
<p>
A matrix is in reduced row echelon form if<ul>
  <li>All rows with at least one nonzero element are above any rows with all zeroes.</li>
  <li>The first nonzero number from the left, of a nonzero row is always strictly to the right of the first nonzero number from the left, in the row above it.</li>
  <li>Every leading coefficient is 1 and is the only nonzero entry in its column</li></ul>
<dl><dt>The function below converts a matrix like</dt><dd><table>
<tr><td align="right">2.0</td>  <td width="20"></td> <td align="right">1.0</td>  <td width="20"></td> <td align="right">-1.0</td> <td width="20"></td> <td align="right">8.0</td></tr>
<tr><td align="right">-3.0</td> <td width="20"></td> <td align="right">-1.0</td> <td width="20"></td> <td align="right">2.0</td> <td width="20"></td> <td align="right">-11.0</td></tr>
<tr><td align="right">-2.0</td> <td width="20"></td> <td align="right">1.0</td>  <td width="20"></td> <td align="right">2.0</td> <td width="20"></td> <td align="right">-3.0</td></tr></table></dd>
<dt>into its reduced row echelon form</dt><dd><table>
<tr><td align="right">1.0</td> <td width="20"></td> <td align="right">0.0</td> <td width="20"></td> <td align="right">0.0</td> <td width="20"></td> <td align="right">2.0</td></tr>
<tr><td align="right">0.0</td> <td width="20"></td> <td align="right">1.0</td> <td width="20"></td> <td align="right">0.0</td> <td width="20"></td> <td align="right">3.0</td></tr>
<tr><td align="right">0.0</td> <td width="20"></td> <td align="right">0.0</td> <td width="20"></td> <td align="right">1.0</td> <td width="20"></td> <td align="right">-1.0</td></tr></table></dd></dl>
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Type_declarations">const</a> <a class="type" href="../manual/types.htm#type">type</a>: matrix <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#float">float</a>;

<a class="keywd_no_ul" href="../manual/decls.htm#Procedure_declarations">const</a> <a class="type" href="../manual/types.htm#proc">proc</a>: toReducedRowEchelonForm (<a class="keywd_no_ul" href="../manual/params.htm#inout_parameter">inout</a> <span class="type">matrix</span>: mat) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: numRows <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: numColumns <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: row <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: column <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: pivot <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#float">float</a>: factor <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0.0;
  <span class="keywd">begin</span>
    numRows <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> length(mat);
    numColumns <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> length(mat[1]);
    <span class="keywd">for</span> row <span class="keywd">range</span> numRows <span class="keywd">downto</span> 1 <span class="keywd">do</span>
      column <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 1;
      <span class="keywd">while</span> column &lt;= numColumns <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> mat[row][column] = 0.0 <span class="keywd">do</span>
        incr(column);
      <span class="keywd">end while</span>;
      <span class="keywd">if</span> column > numColumns <span class="keywd">then</span>
        <a class="comment" href="../manual/tokens.htm#Line_comments"># Empty rows are moved to the bottom</a>
        mat <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> mat[.. pred(row)] &amp; mat[succ(row) ..] &amp; [] (mat[row]);
        decr(numRows);
      <span class="keywd">end if</span>;
    <span class="keywd">end for</span>;
    <span class="keywd">for</span> pivot <span class="keywd">range</span> 1 <span class="keywd">to</span> numRows <span class="keywd">do</span>
      <span class="keywd">if</span> mat[pivot][pivot] = 0.0 <span class="keywd">then</span>
        <a class="comment" href="../manual/tokens.htm#Line_comments"># Find a row were the pivot column is not zero</a>
        row <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 1;
        <span class="keywd">while</span> row &lt;= numRows <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> mat[row][pivot] = 0.0 <span class="keywd">do</span>
          incr(row);
        <span class="keywd">end while</span>;
        <a class="comment" href="../manual/tokens.htm#Line_comments"># Add row were the pivot column is not zero</a>
        <span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> numColumns <span class="keywd">do</span>
          mat[pivot][column] +:= mat[row][column];
        <span class="keywd">end for</span>;
      <span class="keywd">end if</span>;
      <span class="keywd">if</span> mat[pivot][pivot] &lt;> 1.0 <span class="keywd">then</span>
        <a class="comment" href="../manual/tokens.htm#Line_comments"># Make sure that the pivot element is 1.0</a>
        factor <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 1.0 / mat[pivot][pivot];
        <span class="keywd">for</span> column <span class="keywd">range</span> pivot <span class="keywd">to</span> numColumns <span class="keywd">do</span>
          mat[pivot][column] <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> mat[pivot][column] * factor;
        <span class="keywd">end for</span>;
      <span class="keywd">end if</span>;
      <span class="keywd">for</span> row <span class="keywd">range</span> 1 <span class="keywd">to</span> numRows <span class="keywd">do</span>
        <span class="keywd">if</span> row &lt;> pivot <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> mat[row][pivot] &lt;> 0.0 <span class="keywd">then</span>
          <a class="comment" href="../manual/tokens.htm#Line_comments"># Make sure that in all other rows the pivot column contains zero</a>
          factor <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> -mat[row][pivot];
          <span class="keywd">for</span> column <span class="keywd">range</span> pivot <span class="keywd">to</span> numColumns <span class="keywd">do</span>
            mat[row][column] +:= mat[pivot][column] * factor;
          <span class="keywd">end for</span>;
        <span class="keywd">end if</span>;
      <span class="keywd">end for</span>;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="dotProd"><h3>Dot product</h3></a>
<p>
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/seed7_05.htm">seed7_05.s7i</a>"</span>;

$ <a class="keywd_no_ul" href="../manual/syntax.htm#The_Seed7_Structured_Syntax_Description">syntax</a> <a class="type" href="../manual/types.htm#expr">expr</a>: .().dot.()     <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a>  -> 6;  <a class="comment" href="../manual/tokens.htm#Line_comments"># priority of dot operator</a>

<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#integer">integer</a>: (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: a) dot (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: b) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: sum <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: index <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">if</a> <a class="func" href="../libraries/array.htm#minIdx(in_arrayType)">minIdx</a>(a) <a class="op_no_ul" href="../libraries/integer.htm#(in_integer)<>(in_integer)">&lt;></a> <a class="func" href="../libraries/array.htm#minIdx(in_arrayType)">minIdx</a>(b) <a class="op_no_ul" href="../libraries/boolean.htm#(in_boolean)or(ref_func_boolean)">or</a> <a class="func" href="../libraries/array.htm#maxIdx(in_arrayType)">maxIdx</a>(a) <a class="op_no_ul" href="../libraries/integer.htm#(in_integer)<>(in_integer)">&lt;></a> <a class="func" href="../libraries/array.htm#maxIdx(in_arrayType)">maxIdx</a>(b) <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">then</a>
      <a class="keywd_no_ul" href="../manual/errors.htm#Exceptions">raise</a> <a class="exception" href="../manual/errors.htm#RANGE_ERROR">RANGE_ERROR</a>;
    <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">else</a>
      <a class="keywd_no_ul" href="../manual/stats.htm#for-key-statement">for</a> <a class="keywd_no_ul" href="../manual/stats.htm#for-key-statement">key</a> index <a class="keywd_no_ul" href="../manual/stats.htm#for-key-statement">range</a> a <a class="keywd_no_ul" href="../manual/stats.htm#for-key-statement">do</a>
        sum <a class="op_no_ul" href="../libraries/integer.htm#(inout_integer)+:=(in_integer)">+:=</a> a[index] <a class="op_no_ul" href="../libraries/integer.htm#(in_integer)*(in_integer)">*</a> b[index];
      <a class="keywd_no_ul" href="../manual/stats.htm#for-key-statement">end</a> <a class="keywd_no_ul" href="../manual/stats.htm#for-key-statement">for</a>;
    <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">end</a> <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">if</a>;
  <span class="keywd">end func</span>;

<a class="keywd_no_ul" href="../manual/decls.htm#Procedure_declarations">const</a> <a class="type" href="../manual/types.htm#proc">proc</a>: main <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    writeln([](1, 3, -5) <span class="op">dot</span> [](4, -2, -1));
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="floatDotProd"><h3>Float dot product</h3></a>
<p>
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/seed7_05.htm">seed7_05.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/float.htm">float.s7i</a>"</span>;

$ <a class="keywd_no_ul" href="../manual/syntax.htm#The_Seed7_Structured_Syntax_Description">syntax</a> <a class="type" href="../manual/types.htm#expr">expr</a>: .().dot.()     <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a>  -> 6;  <a class="comment" href="../manual/tokens.htm#Line_comments"># priority of dot operator</a>

<a class="keywd_no_ul" href="../manual/decls.htm#Type_declarations">const</a> <a class="type" href="../manual/types.htm#type">type</a>: floatVector <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <a class="type" href="../libraries/basearray.htm#array_[(in_integer).._](in_type)">array</a> [1 ..] <a class="type" href="../manual/types.htm#float">float</a>;

<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#float">float</a>: (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <span class="type">floatVector</span>: a) dot (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <span class="type">floatVector</span>: b) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  result
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#float">float</a>: sum is 0.0;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: index <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">if</a> <a class="func" href="../libraries/array.htm#length(in_arrayType)">length</a>(a) <a class="op_no_ul" href="../libraries/integer.htm#(in_integer)<>(in_integer)">&lt;></a> <a class="func" href="../libraries/array.htm#length(in_arrayType)">length</a>(b) <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">then</a>
      <a class="keywd_no_ul" href="../manual/errors.htm#Exceptions">raise</a> <a class="exception" href="../manual/errors.htm#RANGE_ERROR">RANGE_ERROR</a>;
    <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">else</a>
      <a class="keywd_no_ul" href="../manual/stats.htm#for-key-statement">for</a> <a class="keywd_no_ul" href="../manual/stats.htm#for-key-statement">key</a> index <a class="keywd_no_ul" href="../manual/stats.htm#for-key-statement">range</a> a <a class="keywd_no_ul" href="../manual/stats.htm#for-key-statement">do</a>
        sum <a class="op_no_ul" href="../libraries/integer.htm#(inout_integer)+:=(in_integer)">+:=</a> a<a class="op_no_ul" href="../libraries/basearray.htm#(in_arrayType)[(in_integer)]">[</a>index<a class="op_no_ul" href="../libraries/basearray.htm#(in_arrayType)[(in_integer)]">]</a> <a class="op_no_ul" href="../libraries/integer.htm#(in_integer)*(in_integer)">*</a> b<a class="op_no_ul" href="../libraries/basearray.htm#(in_arrayType)[(in_integer)]">[</a>index<a class="op_no_ul" href="../libraries/basearray.htm#(in_arrayType)[(in_integer)]">]</a>;
      <a class="keywd_no_ul" href="../manual/stats.htm#for-key-statement">end</a> <a class="keywd_no_ul" href="../manual/stats.htm#for-key-statement">for</a>;
    <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">end</a> <a class="keywd_no_ul" href="../manual/stats.htm#if-statement">if</a>;
  <span class="keywd">end func</span>;

<a class="keywd_no_ul" href="../manual/decls.htm#Procedure_declarations">const</a> <a class="type" href="../manual/types.htm#proc">proc</a>: main <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">begin</span>
    <a class="func_no_ul" href="../libraries/enable_io.htm#writeln(in_aType)">writeln</a>(<span class="type">floatVector</span>[](2.4, 3.5, -0.1) <span class="op">dot</span> <span class="type">floatVector</span>[](4.3, -2.1, -1.7));
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="rand_32"><h3>Random number generator</h3></a>
<p>
The function <tt>'rand'</tt>, which creates a random value between
a lower and an upper bound, is predefined for many types (<tt><a class="type" href="../manual/types.htm#boolean">boolean</a></tt>,
<tt><a class="type" href="../manual/types.htm#integer">integer</a></tt>, <tt><a class="type" href="../manual/types.htm#bigInteger">bigInteger</a></tt>, <tt><a class="type" href="../manual/types.htm#float">float</a></tt>, <tt><a class="type" href="../manual/types.htm#char">char</a></tt>).
The random generator below delivers random numbers between 0 and 2**32-1.
To get a different pseudorandom sequence the variable <tt>'seed'</tt> can be initialized with another value.
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: seed <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 987654321_;

<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: rand_32 <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: randomNumber <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    seed <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> (seed * 1103515245_ + 12345_ <a class="op" href="../libraries/bigint.htm#(in_bigInteger)rem(in_bigInteger)">rem</a> 2_ ** 64;
    randomNumber <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> seed <a class="op" href="../libraries/bigint.htm#(in_bigInteger)div(in_bigInteger)">div</a> 2_ ** 32;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="fib"><h3>Recursive fibonacci function</h3></a>
<p>
This algorithm just uses the recursive definition of the fibonacci function.
It can be used as benchmark to test the performance of recursive calls.
For a solution with better scalability use the iterative fibonacci function below.
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#integer">integer</a>: fib (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: number) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: fib <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 1;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> number > 2 <span class="keywd">then</span>
      fib <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> fib(pred(number)) + fib(number - 2);
    <span class="keywd">elsif</span> number = 0 <span class="keywd">then</span>
      fib <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 0;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="iterative_fib"><h3>Iterative fibonacci function</h3></a>
<p>
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: fib (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: number) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: fib <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 1_;
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: i <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: a <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: c <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> i <span class="keywd">range</span> 1 <span class="keywd">to</span> pred(number) <span class="keywd">do</span>
      c <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> a;
      a <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> fib;
      fib +:= c;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="fibonacci_sequence"><h3>Display 100 numbers of the fibonacci sequence</h3></a>
<p>
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/seed7_05.htm">seed7_05.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="stri">"<a class="lib" href="../lib/bigint.htm">bigint.s7i</a>"</span>;

<a class="keywd_no_ul" href="../manual/decls.htm#Procedure_declarations">const</a> <a class="type" href="../manual/types.htm#proc">proc</a>: main <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: i <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: a <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: b <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 1_;
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: c <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
  <span class="keywd">begin</span>
    writeln(a);
    <span class="keywd">for</span> i <span class="keywd">range</span> 1 <span class="keywd">to</span> 100 <span class="keywd">do</span>
      writeln(b);
      c <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> a;
      a <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> b;
      b +:= c;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="tak"><h3>The tak function</h3></a>
<p>
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#integer">integer</a>: tak (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: x, <a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: y, <a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: z) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: tak <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> y >= x <span class="keywd">then</span>
      tak <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> z;
    <span class="keywd">else</span>
      tak <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> tak(tak(pred(x), y, z),
                 tak(pred(y), z, x),
                 tak(pred(z), x, y));
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="ackermann"><h3>The ackermann function</h3></a>
<p>
The ackermann function grows rapidly, even for small inputs:
</p><dl><dd>
  ackermann(4, 1) is 65533</dd><dd>
  ackermann(4, 2) has 19729 decimal digits.
</dd></dl><p>
Below is a simple implementation of the ackermann function,
that follows the original specification. The recursion depth
of ackermann grows so fast that computing ackermann(4, 1),
with the implementation below, might trigger a stack overflow.
In practice the <tt><a class="type" href="../manual/types.htm#bigInteger">bigInteger</a></tt> ackermann function implementation
further below should be preferred.
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#integer">integer</a>: ackermann (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: m, <a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: n) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#integer">integer</a>: ackermann <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> m = 0 <span class="keywd">then</span>
      ackermann <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> succ(n);
    <span class="keywd">elsif</span> n = 0 <span class="keywd">then</span>
      ackermann <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> ackermann(pred(m), 1);
    <span class="keywd">else</span>
      ackermann <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> ackermann(pred(m), ackermann(m, pred(n)));
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="bigInteger_ackermann"><h3>The bigInteger ackermann function</h3></a>
<p>
This implementation of the ackermann function uses <tt><a class="type" href="../manual/types.htm#bigInteger">bigInteger</a></tt>
instead of <tt><a class="type" href="../manual/types.htm#integer">integer</a></tt>. Additionally there are optimizations
for special cases, to reduce the recursion depth. Because of
these improvements the ackermann implementation below can
compute ackermann(4, 2) without problems.
</p><pre class="indent">
<a class="keywd_no_ul" href="../manual/decls.htm#Function_declarations">const</a> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: ackermann (<a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: m, <a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: n) <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> <span class="keywd">func</span>
  <span class="keywd">result</span>
    <a class="keywd_no_ul" href="../manual/decls.htm#Variable_declarations">var</a> <a class="type" href="../manual/types.htm#bigInteger">bigInteger</a>: ackermann <a class="keywd_no_ul" href="../faq.htm#initialization_with_is">is</a> 0_;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> m <span class="keywd">of</span>
      <span class="keywd">when</span> {0_}: ackermann <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> succ(n);
      <span class="keywd">when</span> {1_}: ackermann <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> n + 2_;
      <span class="keywd">when</span> {2_}: ackermann <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 3_ + 2_ * n;
      <span class="keywd">when</span> {3_}: ackermann <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> 5_ + 8_ * pred(2_ ** ord(n));
      <span class="keywd">otherwise</span>:
        <span class="keywd">if</span> n = 0_ <span class="keywd">then</span>
          ackermann <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> ackermann(pred(m), 1_);
        <span class="keywd">else</span>
          ackermann <a class="op_no_ul" href="../manual/stats.htm#Assignment">:=</a> ackermann(pred(m), ackermann(m, pred(n)));
        <span class="keywd">end if</span>;
    <span class="keywd">end case</span>;
  <span class="keywd">end func</span>;
</pre></div>
<table width="100%" cellpadding="0" cellspacing="0">
<tr>
<td align="left" width="60%">
<b><big><hr \></big></b></td>
<td align="right">
<table border="0" cellspacing="1" bgcolor="blue">
<tr bgcolor="gainsboro">
<td>&nbsp;<a class="navigation" href="../algorith/float.htm">previous</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/index.htm">up</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/msgdigest.htm">next</a>&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</div>
  </body>
</html>
