<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>
Seed7 Algorithms: Sorting</title>
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body style="margin:0 0 0 0;">
<div style="background-image: url('../images/header1x.png');" class="top_image">
<img style="overflow:hidden;" src="../images/hearts7m.png" height="68" width="50"
 /><img style="overflow:hidden;" src="../images/header3.png" height="68" width="745" />
</div>
<div style="background-image: url('../images/fillpix.png');" class="space_below_top_image">
</div>
<div class="menu">

<a class="head" href="../index.htm"><big>Seed7</big></a>
<a class="menu" href="../faq.htm">FAQ</a>
<a class="menu" href="../manual/index.htm">Manual</a>
<a class="menu" href="../demo.htm">Demo</a>
<a class="menu" href="../scrshots/index.htm">Screenshots</a>
<a class="menu" href="../examples/index.htm">Examples</a>
<a class="menu" href="../libraries/index.htm">Libraries</a>
<a class="menu" href="../algorith/index.htm">Algorithms</a>
<a class="menu" href="../benchmks/index.htm">Benchmarks</a>
<a class="menu" href="../subject_index.htm">Index</a>
<a class="menu" href="http://sourceforge.net/project/showfiles.php?group_id=151126">Download</a>
<a class="menu" href="https://github.com/ThomasMertes/seed7">GitHub</a>
<a class="menu" href="../build.htm">Build Seed7</a>
<a class="menu" href="../links.htm">Links</a>

<br />

<a class="head" href="index.htm"><big>Algorithms</big></a>
<a class="menu" href="sorting.htm">Sorting</a>
<a class="menu" href="search.htm">Searching</a>
<a class="menu" href="date.htm">Date&nbsp;&&nbsp;Time</a>
<a class="menu" href="string.htm">String</a>
<a class="menu" href="float.htm">Float</a>
<a class="menu" href="math.htm">Mathematics</a>
<a class="menu" href="msgdigest.htm">Message&nbsp;digest</a>
<a class="menu" href="graphic.htm">Graphics</a>
<a class="menu" href="file.htm">File</a>
<a class="menu" href="puzzles.htm">Puzzles</a>
<a class="menu" href="others.htm">Others</a>
</div>
<div class="content">
<div style="padding-right:20;">
<table width="100%" cellpadding="0" cellspacing="0">
<tr>
<td align="left" width="80">
<a class="head" href="index.htm"><big>Algorithms</big></a>
</td>
<td>
<table width="10">
</table>
</td>
<td align="left" width="60%">
<b><big>Sorting</big></b></td>
<td align="right">
<table border="0" cellspacing="1" bgcolor="blue">
<tr bgcolor="gainsboro">
<td>&nbsp;<a class="navigation" href="../algorith/index.htm">previous</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/index.htm">up</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/search.htm">next</a>&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
<p>
Seed7 contains a sort function to sort arrays with the quicksort algorithm.
The argorithms below (<a class="link" href="#bubbleSort">bubble sort</a>,
<a class="link" href="#cocktailSort">cocktail sort</a>, <a class="link" href="#selectionSort">selection sort</a>,
<a class="link" href="#shakerSort">shaker sort</a>, <a class="link" href="#insertionSort">insertion sort</a>,
<a class="link" href="#mergeSort">merge sort</a>, <a class="link" href="#heapSort">heap sort</a>,
<a class="link" href="#shellSort">shell sort</a> and <a class="link" href="#quickSort">quicksort</a>)
are in-place sorting methods which are based on a comparison of two elements.
</p>

<div><a name="bubbleSort"><h3>Bubble sort</h3></a>
<p>
Bubble sort works by repeatedly stepping through the array, comparing each
pair of adjacent items and swapping them if they are in the wrong order.
The bubble sort algorithm executes in O(n<sup>2</sup>) time.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: bubbleSort (<span class="keywd">inout</span> <a class="type" href="../manual/types.htm#array">array</a> <span class="type">elemType</span>: arr) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#boolean">boolean</a>: swapped <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: i <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">elemType</span>: help <span class="keywd">is</span> <span class="type">elemType</span>.value;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      swapped := FALSE;
      <span class="keywd">for</span> i <span class="keywd">range</span> 1 <span class="keywd">to</span> length(arr) - 1 <span class="keywd">do</span>
        <span class="keywd">if</span> arr[i] > arr[i + 1] <span class="keywd">then</span>
          help := arr[i];
          arr[i] := arr[i + 1];
          arr[i + 1] := help;
          swapped := TRUE;
        <span class="keywd">end if</span>;
      <span class="keywd">end for</span>;
    <span class="keywd">until</span> <span class="op">not</span> swapped;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="cocktailSort"><h3>Cocktail sort</h3></a>
<p>
Cocktail sort is an improvement over Bubble Sort. The search for
adjacent items with wrong order is done in both directions.
The cocktail sort algorithm executes in O(n<sup>2</sup>) time.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: cocktailSort (<span class="keywd">inout</span> <a class="type" href="../manual/types.htm#array">array</a> <span class="type">elemType</span>: arr) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#boolean">boolean</a>: swapped <span class="keywd">is</span> FALSE;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: i <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">elemType</span>: help <span class="keywd">is</span> <span class="type">elemType</span>.value;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      swapped := FALSE;
      <span class="keywd">for</span> i <span class="keywd">range</span> 1 <span class="keywd">to</span> length(arr) - 1 <span class="keywd">do</span>
        <span class="keywd">if</span> arr[i] > arr[i + 1] <span class="keywd">then</span>
          help := arr[i];
          arr[i] := arr[i + 1];
          arr[i + 1] := help;
          swapped := TRUE;
        <span class="keywd">end if</span>;
      <span class="keywd">end for</span>;
      <span class="keywd">if</span> swapped <span class="keywd">then</span>
        swapped := FALSE;
        <span class="keywd">for</span> i <span class="keywd">range</span> length(arr) - 1 <span class="keywd">downto</span> 1 <span class="keywd">do</span>
          <span class="keywd">if</span> arr[i] > arr[i + 1] <span class="keywd">then</span>
            help := arr[i];
            arr[i] := arr[i + 1];
            arr[i + 1] := help;
            swapped := TRUE;
          <span class="keywd">end if</span>;
        <span class="keywd">end for</span>;
      <span class="keywd">end if</span>;
    <span class="keywd">until</span> not swapped;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="selectionSort"><h3>Selection sort</h3></a>
<p>
Selection sort searches the minimum value in the array and swaps
it with the value in the first position. After that the process is
repeated for the remainder of the array.
The selection sort algorithm executes in O(n<sup>2</sup>) time.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: selectionSort (<span class="keywd">inout</span> <a class="type" href="../manual/types.htm#array">array</a> <span class="type">elemType</span>: arr) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: i <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: j <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: min <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">elemType</span>: help <span class="keywd">is</span> <span class="type">elemType</span>.value;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> i <span class="keywd">range</span> 1 <span class="keywd">to</span> length(arr) - 1 <span class="keywd">do</span>
      min := i;
      <span class="keywd">for</span> j <span class="keywd">range</span> i + 1 <span class="keywd">to</span> length(arr) <span class="keywd">do</span>
        <span class="keywd">if</span> arr[j] &lt; arr[min] <span class="keywd">then</span>
          min := j;
        <span class="keywd">end if</span>;
      <span class="keywd">end for</span>;
      help := arr[min];
      arr[min] := arr[i];
      arr[i] := help;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="shakerSort"><h3>Shaker sort</h3></a>
<p>
Shaker sort is a variant of selection sort. It searches the
minimum and maximum values in the array and swaps them with
the values in the first and the last position respectively.
After that the process is repeated for the remainder of the
array. Note that the term shaker sort can also refer to
<a class="link" href="#cocktailSort">cocktail sort</a>, which is a variant of <a class="link" href="#bubbleSort">bubble sort</a>.
The shaker sort algorithm executes in O(n<sup>2</sup>) time.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: shakerSort (<span class="keywd">inout</span> <a class="type" href="../manual/types.htm#array">array</a> <span class="type">elemType</span>: arr) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: i <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: j <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: k <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: min <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: max <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">elemType</span>: help <span class="keywd">is</span> <span class="type">elemType</span>.value;
  <span class="keywd">begin</span>
    k := length(arr);
    <span class="keywd">while</span> i &lt; k  <span class="keywd">do</span>
      min := i;
      max := i;
      <span class="keywd">for</span> j <span class="keywd">range</span> succ(i) <span class="keywd">to</span> k <span class="keywd">do</span>
        <span class="keywd">if</span> arr[j] &lt; arr[min] <span class="keywd">then</span>
          min := j;
        <span class="keywd">end if</span>;
        <span class="keywd">if</span> arr[j] > arr[max] <span class="keywd">then</span>
          max := j;
        <span class="keywd">end if</span>;
      <span class="keywd">end for</span>;
      help := arr[min];
      arr[min] := arr[i];
      arr[i] := help;
      <span class="keywd">if</span> max = i <span class="keywd">then</span>
        help := arr[min];
        arr[min] := arr[k];
        arr[k] := help;
      <span class="keywd">else</span>
        help := arr[max];
        arr[max] := arr[k];
        arr[k] := help;
      <span class="keywd">end if</span>;
      incr(i);
      decr(k);
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="insertionSort"><h3>Insertion sort</h3></a>
<p>
Insertion sort forms a growing sorted list at the beginning of
the array. Elements are removed from the array and then they are
inserted into the correct position of the already-sorted list.
The insertion sort algorithm executes in O(n<sup>2</sup>) time.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: insertionSort (<span class="keywd">inout</span> <a class="type" href="../manual/types.htm#array">array</a> <span class="type">elemType</span>: arr) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: i <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: j <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">elemType</span>: help <span class="keywd">is</span> <span class="type">elemType</span>.value;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> i <span class="keywd">range</span> 2 <span class="keywd">to</span> length(arr) <span class="keywd">do</span>
      j := i;
      help := arr[i];
      <span class="keywd">while</span> j > 1 <span class="op">and</span> arr[pred(j)] > help <span class="keywd">do</span>
        arr[j] := arr[pred(j)];
        decr(j);
      <span class="keywd">end while</span>;
      arr[j] := help;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="mergeSort"><h3>Merge sort</h3></a>
<p>
Merge sort recognizes that a list with 0 or 1 elements is
already sorted. Otherwise merge sort divides the unsorted
list into two sublists of about half the size. Then each
sublist is sorted by recursively calling merge sort.
Afterwards the two sublists are merged into one sorted
list. The merge sort algorithm executes in O(n log n) time.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: mergeSort (<span class="keywd">inout</span> <a class="type" href="../manual/types.htm#array">array</a> <span class="type">elemType</span>: arr, <span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: low, <a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: high) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: mid <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">elemType</span>: help <span class="keywd">is</span> <span class="type">elemType</span>.value;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: k <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> low &lt; high <span class="keywd">then</span>
      mid := (low + high) <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> 2;
      mergeSort(arr, low, mid);
      mergeSort(arr, succ(mid), high);
      incr(mid);
      <span class="keywd">while</span> low &lt; mid <span class="op">and</span> mid &lt;= high <span class="keywd">do</span>
        <span class="keywd">if</span> arr[low] &lt; arr[mid] <span class="keywd">then</span>
          incr(low);
        <span class="keywd">else</span>
          help := arr[mid];
          <span class="keywd">for</span> k <span class="keywd">range</span> mid <span class="keywd">downto</span> succ(low) <span class="keywd">do</span>
            arr[k] := arr[pred(k)];
          <span class="keywd">end for</span>;
          arr[low] := help;
          incr(low);
          incr(mid);
        <span class="keywd">end if</span>;
      <span class="keywd">end while</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: mergeSort (<span class="keywd">inout</span> <a class="type" href="../manual/types.htm#array">array</a> <span class="type">elemType</span>: arr) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    mergeSort(arr, 1, length(arr));
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="mergeSort2"><h3>Merge sort with additional storage</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: mergeSort2 (<span class="keywd">inout</span> <a class="type" href="../manual/types.htm#array">array</a> <span class="type">elemType</span>: arr, <a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: low, <a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: high, <span class="keywd">inout</span> <a class="type" href="../manual/types.htm#array">array</a> <span class="type">elemType</span>: scratch) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: mid <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: k <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: t_low <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: t_high <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> low &lt; high <span class="keywd">then</span>
      mid := (low + high) <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> 2;
      mergeSort2(arr, low, mid, scratch);
      mergeSort2(arr, succ(mid), high, scratch);
      t_low := low;
      t_high := succ(mid);
      <span class="keywd">for</span> k <span class="keywd">range</span> low <span class="keywd">to</span> high <span class="keywd">do</span>
        <span class="keywd">if</span> t_low &lt;= mid <span class="op">and</span> (t_high > high <span class="op">or</span> arr[t_low] &lt; arr[t_high]) <span class="keywd">then</span>
          scratch[k] := arr[t_low];
          incr(t_low);
        <span class="keywd">else</span>
          scratch[k] := arr[t_high];
          incr(t_high);
        <span class="keywd">end if</span>;
      <span class="keywd">end for</span>;
      <span class="keywd">for</span> k <span class="keywd">range</span> low <span class="keywd">to</span> high <span class="keywd">do</span>
        arr[k] := scratch[k];
      <span class="keywd">end for</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: mergeSort2 (<span class="keywd">inout</span> <a class="type" href="../manual/types.htm#array">array</a> <span class="type">elemType</span>: arr) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#array">array</a> <span class="type">elemType</span>: scratch <span class="keywd">is</span> 0 <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> <span class="type">elemType</span>.value;
  <span class="keywd">begin</span>
    scratch := length(arr) <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> <span class="type">elemType</span>.value;
    mergeSort2(arr, 1, length(arr), scratch);
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="heapSort"><h3>Heap sort</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: downheap (<span class="keywd">inout</span> <a class="type" href="../manual/types.htm#array">array</a> <span class="type">elemType</span>: arr, <span class="keywd">in var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: k, <a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: n) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">elemType</span>: help <span class="keywd">is</span> <span class="type">elemType</span>.value;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: j <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> k &lt;= n <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> 2 <span class="keywd">then</span>
      help := arr[k];
      <span class="keywd">repeat</span>
        j := 2 * k;
        <span class="keywd">if</span> j &lt; n <span class="op">and</span> arr[j] &lt; arr[succ(j)] <span class="keywd">then</span>
          incr(j);
        <span class="keywd">end if</span>;
        <span class="keywd">if</span> help &lt; arr[j] <span class="keywd">then</span>
          arr[k] := arr[j];
          k := j;
        <span class="keywd">end if</span>;
      <span class="keywd">until</span> help >= arr[j] <span class="op">or</span> k > n <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> 2;
      arr[k] := help;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: heapSort (<span class="keywd">inout</span> <a class="type" href="../manual/types.htm#array">array</a> <span class="type">elemType</span>: arr) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: n <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: k <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">elemType</span>: help <span class="keywd">is</span> <span class="type">elemType</span>.value;
  <span class="keywd">begin</span>
    n := length(arr);
    <span class="keywd">for</span> k <span class="keywd">range</span> n <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> 2 <span class="keywd">downto</span> 1 <span class="keywd">do</span>
      downheap(arr, k, n);
    <span class="keywd">end for</span>;
    <span class="keywd">repeat</span>
      help := arr[1];
      arr[1] := arr[n];
      arr[n] := help;
      decr(n);
      downheap(arr, 1, n);
    <span class="keywd">until</span> n &lt;= 1;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="shellSort"><h3>Shell sort</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: shellSort (<span class="keywd">inout</span> <a class="type" href="../manual/types.htm#array">array</a> <span class="type">elemType</span>: arr) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: i <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: j <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: increment <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">elemType</span>: help <span class="keywd">is</span> <span class="type">elemType</span>.value;
  <span class="keywd">begin</span>
    increment := length(arr) <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> 2;
    <span class="keywd">while</span> increment > 0 <span class="keywd">do</span>
      <span class="keywd">for</span> i <span class="keywd">range</span> 1 <span class="keywd">to</span> length(arr) <span class="keywd">do</span>
        j := i;
        help := arr[i];
        <span class="keywd">while</span> j > increment <span class="op">and</span> arr[j - increment] > help <span class="keywd">do</span>
          arr[j] := arr[j - increment];
          j -:= increment;
        <span class="keywd">end while</span>;
        arr[j] := help;
      <span class="keywd">end for</span>;
      increment := increment <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> 2;
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="quickSort"><h3>Quicksort</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: quickSort (<span class="keywd">inout</span> <a class="type" href="../manual/types.htm#array">array</a> <span class="type">elemType</span>: arr, <a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: left, <a class="keywd_no_ul" href="../manual/params.htm#in_parameter">in</a> <a class="type" href="../manual/types.htm#integer">integer</a>: right) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">elemType</span>: compare_elem <span class="keywd">is</span> <span class="type">elemType</span>.value;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: less_idx <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: greater_idx <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <span class="type">elemType</span>: help <span class="keywd">is</span> <span class="type">elemType</span>.value;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> right > left <span class="keywd">then</span>
      compare_elem := arr[right];
      less_idx := pred(left);
      greater_idx := right;
      <span class="keywd">repeat</span>
        <span class="keywd">repeat</span>
          incr(less_idx);
        <span class="keywd">until</span> arr[less_idx] >= compare_elem;
        <span class="keywd">repeat</span>
          decr(greater_idx);
        <span class="keywd">until</span> arr[greater_idx] &lt;= compare_elem <span class="op">or</span> greater_idx = left;
        <span class="keywd">if</span> less_idx &lt; greater_idx <span class="keywd">then</span>
          help := arr[less_idx];
          arr[less_idx] := arr[greater_idx];
          arr[greater_idx] := help;
        <span class="keywd">end if</span>;
      <span class="keywd">until</span> less_idx >= greater_idx;
      arr[right] := arr[less_idx];
      arr[less_idx] := compare_elem;
      quickSort(arr, left, pred(less_idx));
      quickSort(arr, succ(less_idx), right);
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: quickSort (<span class="keywd">inout</span> <a class="type" href="../manual/types.htm#array">array</a> <span class="type">elemType</span>: arr) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    quickSort(arr, 1, length(arr));
  <span class="keywd">end func</span>;
</pre></div>

<table width="100%" cellpadding="0" cellspacing="0">
<tr>
<td align="left" width="60%">
<b><big><hr \></big></b></td>
<td align="right">
<table border="0" cellspacing="1" bgcolor="blue">
<tr bgcolor="gainsboro">
<td>&nbsp;<a class="navigation" href="../algorith/index.htm">previous</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/index.htm">up</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/search.htm">next</a>&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</div>
  </body>
</html>
