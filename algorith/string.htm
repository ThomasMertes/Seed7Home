<html>
<head>
<meta charset="utf-8" />
<title>
Seed7 Algorithms: String</title>
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body style="margin:0 0 0 0;">
<div style="background-image: url('../images/header1x.png');" class="top_image">
<img style="overflow:hidden;" src="../images/hearts7m.png" height="68" width="50"
 /><img style="overflow:hidden;" src="../images/header3.png" height="68" width="745" />
</div>
<div style="background-image: url('../images/fillpix.png');" class="space_below_top_image">
</div>
<div class="menu">

<a class="head" href="../index.htm"><big>Seed7</big></a>
<a class="menu" href="../faq.htm">FAQ</a>
<a class="menu" href="../manual/index.htm">Manual</a>
<a class="menu" href="../scrshots/index.htm">Programs</a>
<a class="menu" href="../examples/index.htm">Examples</a>
<a class="menu" href="../libraries/index.htm">Libraries</a>
<a class="menu" href="../algorith/index.htm">Algorithms</a>
<a class="menu" href="../benchmks/index.htm">Benchmarks</a>
<a class="menu" href="../subject_index.htm">Index</a>
<a class="menu" href="http://sourceforge.net/project/showfiles.php?group_id=151126">Download</a>
<a class="menu" href="https://github.com/ThomasMertes/seed7">GitHub</a>
<a class="menu" href="../build.htm">Build Seed7</a>
<a class="menu" href="../links.htm">Links</a>

<br />

<a class="head" href="index.htm"><big>Algorithms</big></a>
<a class="menu" href="sorting.htm">Sorting</a>
<a class="menu" href="search.htm">Searching</a>
<a class="menu" href="date.htm">Date&nbsp;&&nbsp;Time</a>
<a class="menu" href="string.htm">String</a>
<a class="menu" href="float.htm">Float</a>
<a class="menu" href="math.htm">Mathematics</a>
<a class="menu" href="msgdigest.htm">Message&nbsp;digest</a>
<a class="menu" href="graphic.htm">Graphics</a>
<a class="menu" href="file.htm">File</a>
<a class="menu" href="puzzles.htm">Puzzles</a>
<a class="menu" href="others.htm">Others</a>
</div>
<div class="content">
<div style="padding-right:20;">
<table width="100%" cellpadding="0" cellspacing="0">
<tr>
<td align="left" width="80">
<a class="head" href="index.htm"><big>Algorithms</big></a>
</td>
<td>
<table width="10">
</table>
</td>
<td align="left" width="60%">
<b><big>String</big></b></td>
<td align="right">
<table border="0" cellspacing="1" bgcolor="blue">
<tr bgcolor="gainsboro">
<td>&nbsp;<a class="navigation" href="../algorith/date.htm">previous</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/index.htm">up</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/float.htm">next</a>&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
<p>
</p>

<div><a name="delTabs"><h3>Replace tabs with the corresponding number of spaces</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: delTabs (<span class="keywd">inout</span> <a class="type" href="../manual/types.htm#string">string</a>: stri, <span class="keywd">in</span> <a class="type" href="../manual/types.htm#integer">integer</a>: tabJump) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: tabPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: blankCount <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    tabPos := pos(stri, <span class="stri">"\t"</span>);
    <span class="keywd">while</span> tabPos &lt;> 0 <span class="keywd">do</span>
      blankCount := tabJump - pred(tabPos) <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> tabJump;
      stri := stri[ .. pred(tabPos)] &
          <span class="stri">" "</span> <span class="op">mult</span> blankCount &amp; stri[succ(tabPos) .. ];
      tabPos := pos(stri, <span class="stri">"\t"</span>);
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="insertLeadingTabs"><h3>Replace leading spaces with the corresponding number of tabs</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: insertLeadingTabs (<span class="keywd">inout</span> <a class="type" href="../manual/types.htm#string">string</a>: stri, <span class="keywd">in</span> <a class="type" href="../manual/types.htm#integer">integer</a>: tabJump) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: blankCount <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: tabCount <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> blankCount &lt;= length(stri) <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> stri[blankCount] = <span class="stri">' '</span> <span class="keywd">do</span>
      incr(blankCount);
    <span class="keywd">end while</span>;
    decr(blankCount);
    <span class="keywd">if</span> blankCount >= tabJump <span class="keywd">then</span>
      tabCount := blankCount <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> tabJump;
      stri := <span class="stri">"\t"</span> <span class="op">mult</span> tabCount &amp; stri[succ(tabCount * tabJump) .. ];
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="insertTabs"><h3>Replace spaces with the corresponding number of tabs</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#proc">proc</a>: insertTabs (<span class="keywd">inout</span> <a class="type" href="../manual/types.htm#string">string</a>: stri, <span class="keywd">in</span> <a class="type" href="../manual/types.htm#integer">integer</a>: tabJump) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: blankPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: tabCount1 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: tabCount2 <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    blankPos := rpos(stri, <span class="stri">' '</span>);
    <span class="keywd">while</span> blankPos &lt;> 0 <span class="keywd">do</span>
      pos := pred(blankPos);
      <span class="keywd">while</span> pos >= 1 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> stri[pos] = <span class="stri">' '</span> <span class="keywd">do</span>
        decr(pos);
      <span class="keywd">end while</span>;
      tabCount1 := pos <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> tabJump;
      tabCount2 := blankPos <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> tabJump;
      <span class="keywd">if</span> blankPos - pos >= 2 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> tabCount2 > tabCount1 <span class="keywd">then</span>
        stri := stri[.. pos] &amp; <span class="stri">"\t"</span> <span class="op">mult</span> (tabCount2 - tabCount1) &
            stri[succ(tabCount2 * tabJump) ..];
      <span class="keywd">end if</span>;
      blankPos := rpos(stri, <span class="stri">' '</span>, pos);
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="toUtf8"><h3>Convert an Unicode UTF-32 string to UTF-8</h3></a>
<p>
The <span class="stri">"<a class="lib" href="../libraries/unicode.htm">unicode.s7i</a>"</span> library defines <tt><a class="func" href="../libraries/unicode.htm#toUtf8(in_string)">toUtf8</a></tt>, which converts an UTF-32 string to UTF-8. The function <tt>'toUtf8_2'</tt> below shows how <tt><a class="func" href="../libraries/unicode.htm#toUtf8(in_string)">toUtf8</a></tt> works:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: toUtf8_2 (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: stri) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: stri8 <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#char">char</a>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: pos <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    stri8 := <span class="stri">"\0;"</span> <span class="op">mult</span> (6 * length(stri));
    <span class="keywd">for</span> ch <span class="keywd">range</span> stri <span class="keywd">do</span>
      <span class="keywd">if</span> ch &lt;= <span class="stri">'\16#7f;'</span> <span class="keywd">then</span>
        stri8 @:= [pos] ch;
        incr(pos);
      <span class="keywd">elsif</span> ch &lt;= <span class="stri">'\16#7ff;'</span> <span class="keywd">then</span>
        stri8 @:= [pos    ] chr(16#C0 + ( ord(ch) >>  6));
        stri8 @:= [pos + 1] chr(16#80 + ( ord(ch)        <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        pos +:= 2;
      <span class="keywd">elsif</span> ch &lt;= <span class="stri">'\16#ffff;'</span> <span class="keywd">then</span>
        stri8 @:= [pos    ] chr(16#E0 + ( ord(ch) >> 12));
        stri8 @:= [pos + 1] chr(16#80 + ((ord(ch) >>  6) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        stri8 @:= [pos + 2] chr(16#80 + ( ord(ch)        <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        pos +:= 3;
      <span class="keywd">elsif</span> ch &lt;= <span class="stri">'\16#1fffff;'</span> <span class="keywd">then</span>
        stri8 @:= [pos    ] chr(16#F0 + ( ord(ch) >> 18));
        stri8 @:= [pos + 1] chr(16#80 + ((ord(ch) >> 12) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        stri8 @:= [pos + 2] chr(16#80 + ((ord(ch) >>  6) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        stri8 @:= [pos + 3] chr(16#80 + ( ord(ch)        <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        pos +:= 4;
      <span class="keywd">elsif</span> ch &lt;= <span class="stri">'\16#3ffffff;'</span> <span class="keywd">then</span>
        stri8 @:= [pos    ] chr(16#F8 + ( ord(ch) >> 24));
        stri8 @:= [pos + 1] chr(16#80 + ((ord(ch) >> 18) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        stri8 @:= [pos + 2] chr(16#80 + ((ord(ch) >> 12) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        stri8 @:= [pos + 3] chr(16#80 + ((ord(ch) >>  6) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        stri8 @:= [pos + 4] chr(16#80 + ( ord(ch)        <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        pos +:= 5;
      <span class="keywd">else</span>
        stri8 @:= [pos    ] chr(16#FC + ( ord(ch) >> 30));
        stri8 @:= [pos + 1] chr(16#80 + ((ord(ch) >> 24) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        stri8 @:= [pos + 2] chr(16#80 + ((ord(ch) >> 18) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        stri8 @:= [pos + 3] chr(16#80 + ((ord(ch) >> 12) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        stri8 @:= [pos + 4] chr(16#80 + ((ord(ch) >>  6) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        stri8 @:= [pos + 5] chr(16#80 + ( ord(ch)        <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        pos +:= 6;
      <span class="keywd">end if</span>;
    <span class="keywd">end for</span>;
    stri8 := stri8[.. pred(pos)];
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="fromUtf8"><h3>Convert an Unicode UTF-8 string to UTF-32</h3></a>
<p>
The <span class="stri">"<a class="lib" href="../libraries/unicode.htm">unicode.s7i</a>"</span> library defines <tt><a class="func" href="../libraries/unicode.htm#fromUtf8(in_string)">fromUtf8</a></tt>, which converts an UTF-8 string to UTF-32. The function <tt>'fromUtf8_2'</tt> below shows how <tt><a class="func" href="../libraries/unicode.htm#fromUtf8(in_string)">fromUtf8</a></tt> works:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: fromUtf8_2 (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: stri8) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: pos8 <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#boolean">boolean</a>: okay <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    length := length(stri8);
    stri := <span class="stri">"\0;"</span> <span class="op">mult</span> length;
    pos8 := 1;
    pos := 0;
    <span class="keywd">while</span> length > 0 <span class="keywd">do</span>
      incr(pos);
      <span class="keywd">if</span> ord(stri8[pos8]) &lt;= 16#7F <span class="keywd">then</span>
        stri @:= [pos] stri8[pos8];
        incr(pos8);
        decr(length);
      <span class="keywd">elsif</span> ord(stri8[pos8    ]) >> 5 = 16#06 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> length >= 2 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
            ord(stri8[pos8 + 1]) >> 6 = 16#02 <span class="keywd">then</span>
        stri @:= [pos] chr((ord(stri8[pos8    ]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#20 << 6) +
                           (ord(stri8[pos8 + 1]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        pos8 +:= 2;
        length -:= 2;
      <span class="keywd">elsif</span> ord(stri8[pos8    ]) >> 4 = 16#0E <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> length >= 3 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
            ord(stri8[pos8 + 1]) >> 6 = 16#02 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
            ord(stri8[pos8 + 2]) >> 6 = 16#02 <span class="keywd">then</span>
        stri @:= [pos] chr((ord(stri8[pos8    ]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#10 << 12) +
                           (ord(stri8[pos8 + 1]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40 <<  6) +
                           (ord(stri8[pos8 + 2]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        pos8 +:= 3;
        length -:= 3;
      <span class="keywd">elsif</span> ord(stri8[pos8    ]) >> 3 = 16#1E <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> length >= 4 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
            ord(stri8[pos8 + 1]) >> 6 = 16#02 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
            ord(stri8[pos8 + 2]) >> 6 = 16#02 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
            ord(stri8[pos8 + 3]) >> 6 = 16#02 <span class="keywd">then</span>
        stri @:= [pos] chr((ord(stri8[pos8    ]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#08 << 18) +
                           (ord(stri8[pos8 + 1]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40 << 12) +
                           (ord(stri8[pos8 + 2]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40 <<  6) +
                           (ord(stri8[pos8 + 3]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        pos8 +:= 4;
        length -:= 4;
      <span class="keywd">elsif</span> ord(stri8[pos8    ]) >> 2 = 16#3E <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> length >= 5 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
            ord(stri8[pos8 + 1]) >> 6 = 16#02 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
            ord(stri8[pos8 + 2]) >> 6 = 16#02 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
            ord(stri8[pos8 + 3]) >> 6 = 16#02 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
            ord(stri8[pos8 + 4]) >> 6 = 16#02 <span class="keywd">then</span>
        stri @:= [pos] chr((ord(stri8[pos8    ]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#04 << 24) +
                           (ord(stri8[pos8 + 1]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40 << 18) +
                           (ord(stri8[pos8 + 2]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40 << 12) +
                           (ord(stri8[pos8 + 3]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40 <<  6) +
                           (ord(stri8[pos8 + 4]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        pos8 +:= 5;
        length -:= 5;
      <span class="keywd">elsif</span> ord(stri8[pos8    ]) >> 2 = 16#3F <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> length >= 6 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
            ord(stri8[pos8 + 1]) >> 6 = 16#02 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
            ord(stri8[pos8 + 2]) >> 6 = 16#02 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
            ord(stri8[pos8 + 3]) >> 6 = 16#02 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
            ord(stri8[pos8 + 4]) >> 6 = 16#02 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
            ord(stri8[pos8 + 5]) >> 6 = 16#02 <span class="keywd">then</span>
        stri @:= [pos] chr((ord(stri8[pos8    ]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#04 << 30) +
                           (ord(stri8[pos8 + 1]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40 << 24) +
                           (ord(stri8[pos8 + 2]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40 << 18) +
                           (ord(stri8[pos8 + 3]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40 << 12) +
                           (ord(stri8[pos8 + 4]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40 <<  6) +
                           (ord(stri8[pos8 + 5]) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 16#40));
        pos8 +:= 6;
        length -:= 6;
      <span class="keywd">else</span>
        okay := FALSE;
        length := 0;
      <span class="keywd">end if</span>;
    <span class="keywd">end while</span>;
    <span class="keywd">if</span> okay <span class="keywd">then</span>
      stri := stri[.. pos];
    <span class="keywd">else</span>
      raise RANGE_ERROR;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="toBase64"><h3>Encode a string with the Base64 encoding</h3></a>
<p>
The function <tt><a class="func" href="../libraries/encoding.htm#toBase64(in_string)">toBase64</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/encoding.htm">encoding.s7i</a>"</span> library.
Base64 encodes a byte string as ASCII string. This is done by
taking packs of 6-bits and translating them into a radix-64
representation. The radix-64 digits are encoded with letters,
digits and the characters '+' and '/'.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: toBase64 (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: byteStri) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: base64 <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#string">string</a>: coding <span class="keywd">is</span> <span class="stri">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span>;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: subIndex <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#char">char</a>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: threeBytes <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: fourBytes <span class="keywd">is</span> <span class="stri">"    "</span>;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: posToAddNewline <span class="keywd">is</span> 58;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length(byteStri) <span class="keywd">step</span> 3 <span class="keywd">do</span>
      threeBytes := 0;
      <span class="keywd">for</span> subIndex <span class="keywd">range</span> index <span class="keywd">to</span> index + 2 <span class="keywd">do</span>
        threeBytes <<:= 8;
        <span class="keywd">if</span> subIndex &lt;= length(byteStri) <span class="keywd">then</span>
          ch := byteStri[subIndex];
          <span class="keywd">if</span> ch >= <span class="stri">'\256;'</span> <span class="keywd">then</span>
            <span class="keywd">raise</span> RANGE_ERROR;
          <span class="keywd">end if</span>;
          threeBytes +:= ord(ch);
        <span class="keywd">end if</span>;
      <span class="keywd">end for</span>;
      fourBytes @:= [1] coding[succ( threeBytes >> 18)];
      fourBytes @:= [2] coding[succ((threeBytes >> 12) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 64)];
      fourBytes @:= [3] coding[succ((threeBytes >>  6) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 64)];
      fourBytes @:= [4] coding[succ( threeBytes        <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 64)];
      <span class="keywd">if</span> index = posToAddNewline <span class="keywd">then</span>
        base64 &:= <span class="stri">"\n"</span>;
        posToAddNewline +:= 57;
      <span class="keywd">end if</span>;
      base64 &:= fourBytes;
    <span class="keywd">end for</span>;
    index := length(base64);
    <span class="keywd">if</span> length(byteStri) <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> 3 = 2 <span class="keywd">then</span>
      base64 @:= [index] <span class="stri">'='</span>;
    <span class="keywd">elsif</span> length(byteStri) <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> 3 = 1 <span class="keywd">then</span>
      base64 @:= [pred(index)] <span class="stri">"=="</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="fromBase64"><h3>Decode a Base64 encoded string</h3></a>
<p>
The function <tt><a class="func" href="../libraries/encoding.htm#fromBase64(in_string)">fromBase64</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/encoding.htm">encoding.s7i</a>"</span> library.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: fromBase64 (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: base64) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: decoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#integer">integer</a>: decode <span class="keywd">is</span> [] (                      <span class="comment"># -1 is illegal</span>
        62, -1, -1, -1, 63,                                  <span class="comment"># + /</span>
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61,              <span class="comment"># 0 - 9</span>
        -1, -1, -1,  0, -1, -1, -1,                          <span class="comment"># =</span>
         0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,  <span class="comment"># A - M</span>
        13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,  <span class="comment"># N - Z</span>
        -1, -1, -1, -1, -1, -1,
        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,  <span class="comment"># a - m</span>
        39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51); <span class="comment"># n - z</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: subIndex <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: fourBytes <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: threeBytes <span class="keywd">is</span> <span class="stri">"   "</span>;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> index &lt;= length(base64) - 3 <span class="keywd">do</span>
      <span class="keywd">if</span> base64[index] >= <span class="stri">'+'</span> <span class="keywd">then</span>
        fourBytes := 0;
        <span class="keywd">for</span> subIndex <span class="keywd">range</span> index <span class="keywd">to</span> index + 3 <span class="keywd">do</span>
          number := decode[ord(base64[subIndex]) - ord(pred(<span class="stri">'+'</span>))];
          <span class="keywd">if</span> number = -1 <span class="keywd">then</span>
            <span class="keywd">raise</span> RANGE_ERROR;
          <span class="keywd">end if</span>;
          fourBytes := (fourBytes << 6) + number;
        <span class="keywd">end for</span>;
        threeBytes @:= [1] chr( fourBytes >> 16);
        threeBytes @:= [2] chr((fourBytes >>  8) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 256);
        threeBytes @:= [3] chr( fourBytes        <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 256);
        decoded &:= threeBytes;
        index +:= 4;
      <span class="keywd">elsif</span> base64[index] = <span class="stri">'\n'</span> <a class="op" href="../libraries/boolean.htm#(in_boolean)or(ref_func_boolean)">or</a> base64[index] = <span class="stri">'\r'</span> <span class="keywd">then</span>
        incr(index);
      <span class="keywd">else</span>
        <span class="keywd">raise</span> RANGE_ERROR;
      <span class="keywd">end if</span>;
    <span class="keywd">end while</span>;
    <span class="keywd">if</span> index &lt;> succ(length(base64)) <a class="op" href="../libraries/boolean.htm#(in_boolean)or(ref_func_boolean)">or</a>
        (length(base64) >= 2 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
         pos(base64[.. length(base64) - 2], '=') &lt;> 0) <span class="keywd">then</span>
      <span class="keywd">raise</span> RANGE_ERROR;
    <span class="keywd">end if</span>;
    <span class="keywd">if</span> length(base64) >= 2 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> base64[pred(length(base64)) <span class="keywd">fixLen</span> 2] = <span class="stri">"=="</span> <span class="keywd">then</span>
      decoded := decoded[.. length(decoded) - 2];
    <span class="keywd">elsif</span> length(base64) >= 1 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> base64[length(base64)] = <span class="stri">'='</span> <span class="keywd">then</span>
      decoded := decoded[.. pred(length(decoded))];
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="toQuotedPrintable"><h3>Encode a string with the Quoted-printable encoding</h3></a>
<p>
The function <tt><a class="func" href="../libraries/encoding.htm#toQuotedPrintable(in_string)">toQuotedPrintable</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/encoding.htm">encoding.s7i</a>"</span> library.
Quoted-printable encodes a byte string as ASCII string. This
is done by encoding printable ASCII characters except '=' as
themself. Other byte values are encoded with '=' followed by two
hexadecimal digits representing the byte's numeric value.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: toQuotedPrintable (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: byteStri) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: quoted <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: startPos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: counter <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#char">char</a>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length(byteStri) <span class="keywd">do</span>
      ch := byteStri[index];
      <span class="keywd">if</span> ch >= <span class="stri">'\256;'</span> <span class="keywd">then</span>
        <span class="keywd">raise</span> RANGE_ERROR;
      <span class="keywd">elsif</span> ch = <span class="stri">'\n'</span> <a class="op" href="../libraries/boolean.htm#(in_boolean)or(ref_func_boolean)">or</a> (ch = <span class="stri">'\r'</span> <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
          index &lt; length(byteStri) <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> byteStri[succ(index)] = <span class="stri">'\n'</span>) <span class="keywd">then</span>
        <span class="keywd">if</span> index > 1 <span class="keywd">then</span>
          ch := byteStri[pred(index)];
          <span class="keywd">if</span> ch = <span class="stri">' '</span> <a class="op" href="../libraries/boolean.htm#(in_boolean)or(ref_func_boolean)">or</a> ch = <span class="stri">'\t'</span> <span class="keywd">then</span>
            quoted &:= byteStri[startPos .. index - 2];
            <span class="keywd">if</span> counter >= 76 <span class="keywd">then</span>
              quoted &:= <span class="stri">"=\n"</span>;
              counter := 1;
            <span class="keywd">end if</span>;
            quoted &:= <span class="stri">"="</span> &lt;&amp; ord(byteStri[pred(index)]) <a class="op" href="../libraries/integer.htm#(in_integer)RADIX(in_integer)">RADIX</a> 16 <a class="op" href="../libraries/string.htm#(in_string)lpad0(in_integer)">lpad0</a> 2;
            counter +:= 3;
            startPos := index;
          <span class="keywd">end if</span>;
        <span class="keywd">end if</span>;
        counter := 1;
      <span class="keywd">elsif</span> ch >= <span class="stri">'\127;'</span> <a class="op" href="../libraries/boolean.htm#(in_boolean)or(ref_func_boolean)">or</a> ch = <span class="stri">'='</span> <a class="op" href="../libraries/boolean.htm#(in_boolean)or(ref_func_boolean)">or</a> (ch &lt; <span class="stri">' '</span> <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> ch &lt;> <span class="stri">'\9;'</span>) <span class="keywd">then</span>
        quoted &:= byteStri[startPos .. pred(index)];
        <span class="keywd">if</span> counter >= 74 <span class="keywd">then</span>
          quoted &:= <span class="stri">"=\n"</span>;
          counter := 1;
        <span class="keywd">end if</span>;
        quoted &:= <span class="stri">"="</span> &lt;&amp; ord(ch) <a class="op" href="../libraries/integer.htm#(in_integer)RADIX(in_integer)">RADIX</a> 16 <a class="op" href="../libraries/string.htm#(in_string)lpad0(in_integer)">lpad0</a> 2;
        startPos := succ(index);
        counter +:= 3;
      <span class="keywd">elsif</span> counter >= 76 <span class="keywd">then</span>
        quoted &:= byteStri[startPos .. pred(index)] &amp; <span class="stri">"=\n"</span>;
        startPos := index;
        counter := 2;
      <span class="keywd">else</span>
        incr(counter);
      <span class="keywd">end if</span>;
    <span class="keywd">end for</span>;
    quoted &:= byteStri[startPos ..];
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="fromQuotedPrintable"><h3>Decode a Quoted-printable encoded string</h3></a>
<p>
The function <tt><a class="func" href="../libraries/encoding.htm#fromQuotedPrintable(in_string)">fromQuotedPrintable</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/encoding.htm">encoding.s7i</a>"</span> library.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: fromQuotedPrintable (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: quoted) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: decoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: startPos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: equalSignPos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: twoChars <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    equalSignPos := pos(quoted, <span class="stri">"="</span>);
    <span class="keywd">while</span> equalSignPos &lt;> 0 <span class="keywd">do</span>
      decoded &:= quoted[startPos .. pred(equalSignPos)];
      <span class="keywd">if</span> equalSignPos &lt; length(quoted) <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
          quoted[succ(equalSignPos)] = <span class="stri">'\n'</span> <span class="keywd">then</span>
        startPos := equalSignPos + 2;
      <span class="keywd">elsif</span> equalSignPos &lt;= length(quoted) - 2 <span class="keywd">then</span>
        twoChars := quoted[succ(equalSignPos) <span class="keywd">fixLen</span> 2];
        <span class="keywd">if</span> twoChars[1] <a class="op" href="../libraries/bitsetof.htm#(in_baseType)in(in_setType)">in</a> hexdigit_char <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
            twoChars[2] <a class="op" href="../libraries/bitsetof.htm#(in_baseType)in(in_setType)">in</a> hexdigit_char <span class="keywd">then</span>
          decoded &:= chr(integer(twoChars, 16));
        <span class="keywd">elsif</span> twoChars &lt;> <span class="stri">"\r\n"</span> <span class="keywd">then</span>
          <span class="keywd">raise</span> RANGE_ERROR;
        <span class="keywd">end if</span>;
        startPos := equalSignPos + 3;
      <span class="keywd">else</span>
        <span class="keywd">raise</span> RANGE_ERROR;
      <span class="keywd">end if</span>;
      equalSignPos := pos(quoted, <span class="stri">"="</span>, startPos);
    <span class="keywd">end while</span>;
    decoded &:= quoted[startPos ..];
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="toUuencoded"><h3>Uuencode a string</h3></a>
<p>
The function <tt><a class="func" href="../libraries/encoding.htm#toUuencoded(in_string)">toUuencoded</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/encoding.htm">encoding.s7i</a>"</span> library.
Uuencode encodes a byte string as ASCII string. This is done
by taking packs of 6-bits and translating them into a radix-64
representation. The radix-64 digits are encoded with consecutive
ASCII characters starting from ' ' (which represents 0). Every
line starts with a radix-64 digit character indicating the number
of data bytes encoded on that line.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: toUuencoded (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: byteStri) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: uuencoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: subIndex <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#char">char</a>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: threeBytes <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: fourBytes <span class="keywd">is</span> <span class="stri">"    "</span>;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: posToAddNewline <span class="keywd">is</span> 43;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> length(byteStri) &lt;> 0 <span class="keywd">then</span>
      <span class="keywd">if</span> length(byteStri) &lt; 45 <span class="keywd">then</span>
        uuencoded &:= chr(32 + length(byteStri));
      <span class="keywd">else</span>
        uuencoded &:= <span class="stri">"M"</span>;
      <span class="keywd">end if</span>;
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length(byteStri) <span class="keywd">step</span> 3 <span class="keywd">do</span>
        threeBytes := 0;
        <span class="keywd">for</span> subIndex <span class="keywd">range</span> index <span class="keywd">to</span> index + 2 <span class="keywd">do</span>
          threeBytes <<:= 8;
          <span class="keywd">if</span> subIndex &lt;= length(byteStri) <span class="keywd">then</span>
            ch := byteStri[subIndex];
            <span class="keywd">if</span> ch >= <span class="stri">'\256;'</span> <span class="keywd">then</span>
              <span class="keywd">raise</span> RANGE_ERROR;
            <span class="keywd">end if</span>;
            threeBytes +:= ord(ch);
          <span class="keywd">end if</span>;
        <span class="keywd">end for</span>;
        fourBytes @:= [1] chr(32 + (threeBytes >> 18));
        fourBytes @:= [2] chr(32 + (threeBytes >> 12) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 64);
        fourBytes @:= [3] chr(32 + (threeBytes >>  6) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 64);
        fourBytes @:= [4] chr(32 +  threeBytes        <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 64);
        uuencoded &:= fourBytes;
        <span class="keywd">if</span> index = posToAddNewline <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> length(byteStri) > index + 2 <span class="keywd">then</span>
          <span class="keywd">if</span> length(byteStri) - index - 2 &lt; 45 <span class="keywd">then</span>
            uuencoded &:= <span class="stri">"\n"</span> &lt;&amp; chr(32 + length(byteStri) - index - 2);
          <span class="keywd">else</span>
            uuencoded &:= <span class="stri">"\nM"</span>;
          <span class="keywd">end if</span>;
          posToAddNewline +:= 45;
        <span class="keywd">end if</span>;
      <span class="keywd">end for</span>;
      uuencoded &:= <span class="stri">"\n"</span>;
    <span class="keywd">end if</span>;
    uuencoded &:= <span class="stri">"`\n"</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="fromUuencoded"><h3>Decode an uuencoded string</h3></a>
<p>
The function <tt><a class="func" href="../libraries/encoding.htm#fromUuencoded(in_string)">fromUuencoded</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/encoding.htm">encoding.s7i</a>"</span> library.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: fromUuencoded (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: uuencoded) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: decoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: lineLength <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: subIndex <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: fourBytes <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: threeBytes <span class="keywd">is</span> <span class="stri">"   "</span>;
  <span class="keywd">begin</span>
    lineLength := ord(uuencoded[1]) - 32;
    <span class="keywd">while</span> lineLength &lt;> 0 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> lineLength &lt;> 64 <span class="keywd">do</span>
      incr(index);
      <span class="keywd">while</span> lineLength >= 1 <span class="keywd">do</span>
        fourBytes := 0;
        <span class="keywd">for</span> subIndex <span class="keywd">range</span> index <span class="keywd">to</span> index + 3 <span class="keywd">do</span>
          number := ord(uuencoded[subIndex]) - 32;
          <span class="keywd">if</span> number = 64 <span class="keywd">then</span>
            number := 0;
          <span class="keywd">elsif</span> number &lt; 0 <a class="op" href="../libraries/boolean.htm#(in_boolean)or(ref_func_boolean)">or</a> number > 64 <span class="keywd">then</span>
            <span class="keywd">raise</span> RANGE_ERROR;
          <span class="keywd">end if</span>;
          fourBytes := (fourBytes << 6) + number;
        <span class="keywd">end for</span>;
        threeBytes @:= [1] chr( fourBytes >> 16);
        threeBytes @:= [2] chr((fourBytes >>  8) <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 256);
        threeBytes @:= [3] chr( fourBytes        <a class="op" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a> 256);
        decoded &:= threeBytes[ .. lineLength];
        lineLength -:= 3;
        index +:= 4;
      <span class="keywd">end while</span>;
      <span class="keywd">while</span> index &lt;= length(uuencoded) <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> uuencoded[index] &lt;> <span class="stri">'\n'</span> <span class="keywd">do</span>
        incr(index);
      <span class="keywd">end while</span>;
      <span class="keywd">if</span> index &lt; length(uuencoded) <span class="keywd">then</span>
        incr(index);
        lineLength := ord(uuencoded[index]) - 32;
      <span class="keywd">else</span>
        lineLength := 0;
      <span class="keywd">end if</span>;
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="toPercentEncoded"><h3>Encode a string with percent encoding</h3></a>
<p>
The function <tt><a class="func" href="../libraries/encoding.htm#toPercentEncoded(in_string)">toPercentEncoded</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/encoding.htm">encoding.s7i</a>"</span> library.
Percent-encoding encodes a byte string as ASCII string. This is done
by encoding all characters, which are not in the set of unreserved
characters (A-Z, a-z, 0-9 - _ . ~). The encoding uses a percent sign
('%') followed by two hexadecimal digits, which represent the ordinal
value of the encoded character.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: toPercentEncoded (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: byteStri) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: percentEncoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#set">set of</a> <a class="type" href="../manual/types.htm#char">char</a>: unreservedChars <span class="keywd">is</span> alphanum_char | {<span class="stri">'-'</span>, <span class="stri">'_'</span>, <span class="stri">'.'</span>, <span class="stri">'~'</span>};
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: start <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#char">char</a>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> ch <span class="keywd">key</span> pos <span class="keywd">range</span> byteStri <span class="keywd">do</span>
      <span class="keywd">if</span> ch > <span class="stri">'\255;'</span> <span class="keywd">then</span>
        raise RANGE_ERROR;
      <span class="keywd">elsif</span> ch <span class="op">not in</span> unreservedChars <span class="keywd">then</span>
        percentEncoded &:= byteStri[start .. pred(pos)];
        percentEncoded &:= <span class="stri">"%"</span> <& ord(ch) <span class="op">RADIX</span> 16 <span class="op">lpad0</span> 2;
        start := succ(pos);
      <span class="keywd">end if</span>;
    <span class="keywd">end for</span>;
    percentEncoded &:= byteStri[start ..];
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="fromPercentEncoded"><h3>Decode a percent encoded string</h3></a>
<p>
The function <tt><a class="func" href="../libraries/encoding.htm#fromPercentEncoded(in_string)">fromPercentEncoded</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/encoding.htm">encoding.s7i</a>"</span> library.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: fromPercentEncoded (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: percentEncoded) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: decoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: pos <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    decoded := percentEncoded;
    pos := pos(decoded, <span class="stri">'%'</span>);
    <span class="keywd">while</span> pos <> 0 <span class="keywd">do</span>
      <span class="keywd">if</span> pos <= length(decoded) - 2 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
          decoded[succ(pos)] in hexdigit_char <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
          decoded[pos + 2] in hexdigit_char <span class="keywd">then</span>
        decoded := decoded[.. pred(pos)] &
            str(chr(integer(decoded[succ(pos) fixLen 2], 16))) &
            decoded[pos + 3 ..];
      <span class="keywd">end if</span>;
      pos := pos(decoded, <span class="stri">'%'</span>, succ(pos));
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="toUrlEncoded"><h3>Encode a string with the URL encoding</h3></a>
<p>
The function <tt><a class="func" href="../libraries/encoding.htm#toUrlEncoded(in_string)">toUrlEncoded</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/encoding.htm">encoding.s7i</a>"</span> library.
URL encoding encodes a byte string as ASCII string. This is done
by encoding all characters, which are not in the set of unreserved
characters (A-Z, a-z, 0-9 - _ . ~). The encoding uses a percent sign
('%') followed by two hexadecimal digits, which represent the ordinal
value of the encoded character. A plus sign ('+') is used to encode
a space (' ').
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: toUrlEncoded (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: byteStri) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: urlEncoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#set">set of</a> <a class="type" href="../manual/types.htm#char">char</a>: unreservedChars <span class="keywd">is</span> alphanum_char | {<span class="stri">'-'</span>, <span class="stri">'_'</span>, <span class="stri">'.'</span>, <span class="stri">'~'</span>};
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: start <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#char">char</a>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> ch <span class="keywd">key</span> pos <span class="keywd">range</span> byteStri <span class="keywd">do</span>
      <span class="keywd">if</span> ch > <span class="stri">'\255;'</span> <span class="keywd">then</span>
        raise RANGE_ERROR;
      <span class="keywd">elsif</span> ch = <span class="stri">' '</span> <span class="keywd">then</span>
        urlEncoded &:= byteStri[start .. pred(pos)];
        urlEncoded &:= <span class="stri">'+'</span>;
        start := succ(pos);
      <span class="keywd">elsif</span> ch <span class="op">not in</span> unreservedChars <span class="keywd">then</span>
        urlEncoded &:= byteStri[start .. pred(pos)];
        urlEncoded &:= <span class="stri">"%"</span> <& ord(ch) <span class="op">RADIX</span> 16 <span class="op">lpad0</span> 2;
        start := succ(pos);
      <span class="keywd">end if</span>;
    <span class="keywd">end for</span>;
    urlEncoded &:= byteStri[start ..];
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="fromUrlEncoded"><h3>Decode an URL encoded string</h3></a>
<p>
The function <tt><a class="func" href="../libraries/encoding.htm#toUrlEncoded(in_string)">toUrlEncoded</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/encoding.htm">encoding.s7i</a>"</span> library.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: fromUrlEncoded (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: urlEncoded) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: decoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: pos <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: start <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#char">char</a>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> ch <span class="keywd">key</span> pos <span class="keywd">range</span> urlEncoded <span class="keywd">do</span>
      <span class="keywd">if</span> ch = <span class="stri">'%'</span> <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> pos <= length(urlEncoded) - 2 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
          urlEncoded[succ(pos)] in hexdigit_char <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
          urlEncoded[pos + 2] in hexdigit_char <span class="keywd">then</span>
        decoded &:= urlEncoded[start .. pred(pos)];
        decoded &:= chr(integer(urlEncoded[succ(pos) fixLen 2], 16));
        pos +:= 2;
        start := succ(pos);
      <span class="keywd">elsif</span> ch = <span class="stri">'+'</span> <span class="keywd">then</span>
        decoded &:= urlEncoded[start .. pred(pos)];
        decoded &:= <span class="stri">' '</span>;
        start := succ(pos);
      <span class="keywd">end if</span>;
    <span class="keywd">end for</span>;
    decoded &:= urlEncoded[start ..];
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="toAscii85"><h3>Encode a string with the Ascii85 encoding</h3></a>
<p>
The function <tt><a class="func" href="../libraries/encoding.htm#toAscii85(in_string)">toAscii85</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/encoding.htm">encoding.s7i</a>"</span> library.
Ascii85 encodes a byte string as ASCII string. This is done by
encoded every four bytes with five printable ASCII characters.
Five radix 85 digits provide enough possible values to encode
the possible values of four bytes. The radix 85 digits are encoded
with the characters <tt><span class="stri">'!'</span></tt> (encodes 0) through <tt><span class="stri">'u'</span></tt> (encodes 84).
If the last block of the byte string contains fewer than 4 bytes,
the block is padded with up to three null bytes before encoding.
After encoding, as many bytes as were added as padding are removed
from the end of the output. In files the end of an Ascii85 encoding
is marked with <tt><span class="stri">"~>"</span></tt> (this end marker is not added by <tt><a class="func" href="../libraries/encoding.htm#toAscii85(in_string)">toAscii85</a></tt>).
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: toAscii85 (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: byteStri) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: ascii85 <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: subIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: fourBytes <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: fiveBytes <span class="keywd">is</span> <span class="stri">"     "</span>;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#char">char</a>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length(byteStri) <span class="keywd">step</span> 4 <span class="keywd">do</span>
      fourBytes := 0;
      <span class="keywd">for</span> subIndex <span class="keywd">range</span> index <span class="keywd">to</span> index + 3 <span class="keywd">do</span>
        fourBytes <<:= 8;
        <span class="keywd">if</span> subIndex <= length(byteStri) <span class="keywd">then</span>
          ch := byteStri[subIndex];
          <span class="keywd">if</span> ch >= <span class="stri">'\256;'</span> <span class="keywd">then</span>
            raise RANGE_ERROR;
          <span class="keywd">end if</span>;
          fourBytes +:= ord(ch);
        <span class="keywd">end if</span>;
      <span class="keywd">end for</span>;
      <span class="keywd">if</span> fourBytes = 0 <span class="keywd">then</span>
        ascii85 &:= <span class="stri">'z'</span>;
      <span class="keywd">else</span>
        <span class="keywd">for</span> subIndex <span class="keywd">range</span> 5 <span class="keywd">downto</span> 1 <span class="keywd">do</span>
          fiveBytes @:= [subIndex] chr(ord(<span class="stri">'!'</span>) + fourBytes <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> 85);
          fourBytes := fourBytes <a class="op" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a> 85;
        <span class="keywd">end for</span>;
        ascii85 &:= fiveBytes;
      <span class="keywd">end if</span>;
    <span class="keywd">end for</span>;
    <span class="keywd">if</span> length(byteStri) <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> 4 <> 0 <span class="keywd">then</span>
      ascii85 := ascii85[.. length(ascii85) - 4 + length(byteStri) <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> 4];
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="fromAscii85"><h3>Decode a Ascii85 encoded string</h3></a>
<p>
The function <tt><a class="func" href="../libraries/encoding.htm#fromAscii85(in_string)">fromAscii85</a></tt> is part of the <span class="stri">"<a class="lib" href="../libraries/encoding.htm">encoding.s7i</a>"</span> library.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: fromAscii85 (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: ascii85) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: decoded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">const</span> <a class="type" href="../manual/types.htm#set">set of</a> <a class="type" href="../manual/types.htm#char">char</a>: whiteSpace <span class="keywd">is</span> {<span class="stri">'\0;'</span>, <span class="stri">'\t'</span>, <span class="stri">'\n'</span>, <span class="stri">'\f'</span>, <span class="stri">'\r'</span>, <span class="stri">' '</span>};
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#char">char</a>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: digitIndex <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: base85Number <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: idx <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> ch <span class="keywd">range</span> ascii85 <span class="keywd">until</span> ch = <span class="stri">'~'</span> <span class="keywd">do</span>
      <span class="keywd">if</span> ch >= <span class="stri">'!'</span> <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> ch <= <span class="stri">'u'</span> <span class="keywd">then</span>
        incr(digitIndex);
        base85Number := base85Number * 85 + (ord(ch) - ord(<span class="stri">'!'</span>));
        <span class="keywd">if</span> digitIndex = 5 <span class="keywd">then</span>
          decoded &:= bytes(base85Number, UNSIGNED, BE, 4);
          digitIndex := 0;
          base85Number := 0;
        <span class="keywd">end if</span>;
      <span class="keywd">elsif</span> ch = <span class="stri">'z'</span> <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> digitIndex = 0 <span class="keywd">then</span>
        decoded &:= <span class="stri">"\0;\0;\0;\0;"</span>;
      <span class="keywd">elsif</span> ch <span class="op">not in</span> whiteSpace <span class="keywd">then</span>
        raise RANGE_ERROR;
      <span class="keywd">end if</span>;
    <span class="keywd">end for</span>;
    <span class="keywd">if</span> digitIndex <> 0 <span class="keywd">then</span>
      <span class="keywd">for</span> idx <span class="keywd">range</span> 1 <span class="keywd">to</span> 5 - digitIndex <span class="keywd">do</span>
        base85Number := base85Number * 85 + 84;
      <span class="keywd">end for</span>;
      decoded &:= bytes(base85Number, UNSIGNED, BE, 4)[.. pred(digitIndex)];
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="lzwCompress"><h3>Compress a string using the Lempel Ziv Welch (LZW) compression</h3></a>
<p>
This algorithm compresses a byte string to a string of tokens which
contains characters >= 256. To write this to a byte file it is necessary
to add an algorithm which writes the tokens with 9 or more bits.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: lzwCompress (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: uncompressed) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: compressed <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#char">char</a>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">hash [string] char</span>: mydict <span class="keywd">is</span> (<span class="type">hash [string] char</span>).value;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: buffer <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: xstr <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> ch <span class="keywd">range</span> chr(0) <span class="keywd">to</span> chr(255) <span class="keywd">do</span>
      mydict @:= [str(ch)] ch;
    <span class="keywd">end for</span>;
    <span class="keywd">for</span> ch <span class="keywd">range</span> uncompressed <span class="keywd">do</span>
      xstr := buffer &amp; str(ch);
      <span class="keywd">if</span> xstr <a class="op" href="../libraries/hashsetof.htm#(in_baseType)in(in_setType)">in</a> mydict <span class="keywd">then</span>
        buffer &:= str(ch)
      <span class="keywd">else</span>
        compressed &:= str(mydict[buffer]);
        mydict @:= [xstr] chr(length(mydict));
        buffer := str(ch);
      <span class="keywd">end if</span>;
    <span class="keywd">end for</span>;
    <span class="keywd">if</span> buffer &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      compressed &:= str(mydict[buffer]);
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="lzwDecompress"><h3>Decompress a Lempel Ziv Welch (LZW) compressed string</h3></a>
<p>
The compressed string consists of a sequence of tokens (which contain
also characters >= 256). The decompress algorithm produces a byte
string.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: lzwDecompress (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: compressed) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: uncompressed <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#char">char</a>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
    <span class="keywd">var</span> <span class="type">hash [char] string</span>: mydict <span class="keywd">is</span> (<span class="type">hash [char] string</span>).value;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: buffer <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: current <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: chain <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> ch <span class="keywd">range</span> chr(0) <span class="keywd">to</span> chr(255) <span class="keywd">do</span>
      mydict @:= [ch] str(ch);
    <span class="keywd">end for</span>;
    <span class="keywd">for</span> ch <span class="keywd">range</span> compressed <span class="keywd">do</span>
      <span class="keywd">if</span> buffer = <span class="stri">""</span> <span class="keywd">then</span>
        buffer := mydict[ch];
        uncompressed &:= buffer;
      <span class="keywd">elsif</span> ch &lt;= chr(255) <span class="keywd">then</span>
        current := mydict[ch];
        uncompressed &:= current;
        chain := buffer &amp; current;
        mydict @:= [chr(length(mydict))] chain;
        buffer := current;
      <span class="keywd">else</span>
        <span class="keywd">if</span> ch <a class="op" href="../libraries/bitsetof.htm#(in_baseType)in(in_setType)">in</a> mydict <span class="keywd">then</span>
          chain := mydict[ch];
        <span class="keywd">else</span>
          chain := buffer &amp; str(buffer[1]);
        <span class="keywd">end if</span>;
        uncompressed &:= chain;
        mydict @:= [chr(length(mydict))] buffer &amp; str(chain[1]);
        buffer := chain;
      <span class="keywd">end if</span>;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="bzip2RleCompress"><h3>Compress a string using the run length encoding of bzip2</h3></a>
<p>
A sequence of 4 to 259 identical characters is replaced by four identical
characters followed by a repeat length between 0 and 255. This run length
encoding is used as first compression technique in the bzip2 compression.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: bzip2RleCompress (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: uncompressed) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: compressed <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: oldpos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#char">char</a>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> index &lt;= length(uncompressed) - 3 <span class="keywd">do</span>
      ch := uncompressed[index];
      <span class="keywd">if</span>  uncompressed[succ(index)] = ch <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
          uncompressed[index + 2] = ch <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
          uncompressed[index + 3] = ch <span class="keywd">then</span>
        index +:= 4;
        compressed &:= uncompressed[oldpos .. pred(index)];
        oldpos := index;
        <span class="keywd">while</span> index &lt;= length(uncompressed) <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
            uncompressed[index] = ch <span class="keywd">do</span>
          incr(index);
        <span class="keywd">end while</span>;
        compressed &:= chr(index - oldpos);
        oldpos := index;
      <span class="keywd">else</span>
        incr(index);
      <span class="keywd">end if</span>;
    <span class="keywd">end while</span>;
    compressed &:= uncompressed[oldpos ..];
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="bzip2RleDecompress"><h3>Decompress a string using the run length encoding of bzip2</h3></a>
<p>
A sequence of 4 identical characters followed by a repeat length between
0 and 255 is replaced by 4 to 259 identical characters. This run length
decoding is used as last decompression technique in the bzip2 decompression.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: bzip2RleDecompress (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: compressed) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: uncompressed <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: oldpos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#char">char</a>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> index &lt;= length(compressed) - 3 <span class="keywd">do</span>
      ch := compressed[index];
      <span class="keywd">if</span>  compressed[succ(index)] = ch <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
          compressed[index + 2] = ch <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
          compressed[index + 3] = ch <span class="keywd">then</span>
        index +:= 4;
        uncompressed &:= compressed[oldpos .. pred(index)] &amp; str(ch) mult ord(compressed[index]);
        incr(index);
        oldpos := index;
      <span class="keywd">else</span>
        incr(index);
      <span class="keywd">end if</span>;
    <span class="keywd">end while</span>;
    uncompressed &:= compressed[oldpos ..];
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="packBits"><h3>Compress a string using the run length encoding of PackBits</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: packBits (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: uncompressed) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: compressed <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: oldpos <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#char">char</a>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> index &lt;= length(uncompressed) - 2 <span class="keywd">do</span>
      ch := uncompressed[index];
      <span class="keywd">if</span>  uncompressed[succ(index)] = ch <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a>
          uncompressed[index + 2] = ch <span class="keywd">then</span>
        <span class="keywd">while</span> index - oldpos >= 128 <span class="keywd">do</span>
          compressed &:= <span class="stri">"\127;"</span> &amp; uncompressed[oldpos <span class="keywd">fixLen</span> 128];
          oldpos +:= 128;
        <span class="keywd">end while</span>;
        <span class="keywd">if</span> index > oldpos <span class="keywd">then</span>
          compressed &:= str(chr(pred(index - oldpos))) &amp; uncompressed[oldpos .. pred(index)];
          oldpos := index;
        <span class="keywd">end if</span>;
        index +:= 3;
        <span class="keywd">while</span> index &lt;= length(uncompressed) <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> uncompressed[index] = ch <span class="keywd">do</span>
          incr(index);
        <span class="keywd">end while</span>;
        <span class="keywd">while</span> index - oldpos >= 128 <span class="keywd">do</span>
          compressed &:= <span class="stri">"\129;"</span> &amp; str(ch);
          oldpos +:= 128;
        <span class="keywd">end while</span>;
        <span class="keywd">if</span> pred(index) > oldpos <span class="keywd">then</span>
          compressed &:= str(chr(257 - (index - oldpos))) &amp; str(ch);
          oldpos := index;
        <span class="keywd">end if</span>;
      <span class="keywd">else</span>
        incr(index);
      <span class="keywd">end if</span>;
    <span class="keywd">end while</span>;
    index := succ(length(uncompressed));
    <span class="keywd">while</span> index - oldpos >= 128 <span class="keywd">do</span>
      compressed &:= <span class="stri">"\127;"</span> &amp; uncompressed[oldpos <span class="keywd">fixLen</span> 128];
      oldpos +:= 128;
    <span class="keywd">end while</span>;
    <span class="keywd">if</span> index > oldpos <span class="keywd">then</span>
      compressed &:= str(chr(pred(index - oldpos))) &amp; uncompressed[oldpos ..];
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="unpackBits"><h3>Decompress a string using the run length encoding of PackBits</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: unpackBits (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: compressed) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: uncompressed <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#char">char</a>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> index &lt;= length(compressed) <span class="keywd">do</span>
      ch := compressed[index];
      <span class="keywd">if</span> ch &lt;= chr(127) <span class="keywd">then</span>
        uncompressed &:= compressed[succ(index) <span class="keywd">fixLen</span> succ(ord(ch))];
        index +:= ord(ch) + 2;
      <span class="keywd">else</span>
        uncompressed &:= str(compressed[succ(index)]) <span class="op">mult</span> (257 - ord(ch));
        index +:= 2;
      <span class="keywd">end if</span>;
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="burrowsWheelerTransformConcept"><h3>Burrows-Wheeler transform (basic concept)</h3></a>
<p>
This algorithm demonstrates the basic concept of the Burrows-Wheeler transform.
It is not intended to be used for big data blocks.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: burrowsWheelerTransformConcept (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: stri) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: transformed <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#string">string</a>: rotations <span class="keywd">is</span> 0 <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    length := succ(length(stri));
    rotations := length <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> <span class="stri">""</span>;
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length <span class="keywd">do</span>
      rotations[index] := stri[index ..] &amp; <span class="stri">"\256;"</span> &amp; stri[.. pred(index)];
    <span class="keywd">end for</span>;
    rotations := sort(rotations);
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length <span class="keywd">do</span>
      transformed &:= rotations[index][length];
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="inverseBurrowsWheelerTransformConcept"><h3>Inverse Burrows-Wheeler transform (basic concept)</h3></a>
<p>
This algorithm demonstrates the basic concept of the Burrows-Wheeler transform.
It is not intended to be used for big data blocks.
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: inverseBurrowsWheelerTransformConcept (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: transformed) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: count <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: index <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#string">string</a>: rotations <span class="keywd">is</span> 0 <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    length := length(transformed);
    rotations := length <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> <span class="stri">""</span>;
    <span class="keywd">for</span> count <span class="keywd">range</span> 1 <span class="keywd">to</span> length <span class="keywd">do</span>
      <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length <span class="keywd">do</span>
        rotations[index] := str(transformed[index]) &amp; rotations[index];
      <span class="keywd">end for</span>;
      rotations := sort(rotations);
    <span class="keywd">end for</span>;
    stri := rotations[1];
    index := pos(stri, <span class="stri">"\256;"</span>);
    stri := stri[succ(index) ..] &amp; stri[.. pred(index)];
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="stringToMorse"><h3>Convert a character string to morse code</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: charToMorse (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#char">char</a>: ch) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: morseCode <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">case</span> ch <span class="keywd">of</span>
      <span class="keywd">when</span> {<span class="stri">'a'</span>, <span class="stri">'A'</span>}: morseCode := <span class="stri">".-"</span>;
      <span class="keywd">when</span> {<span class="stri">'b'</span>, <span class="stri">'B'</span>}: morseCode := <span class="stri">"-..."</span>;
      <span class="keywd">when</span> {<span class="stri">'c'</span>, <span class="stri">'C'</span>}: morseCode := <span class="stri">"-.-."</span>;
      <span class="keywd">when</span> {<span class="stri">'d'</span>, <span class="stri">'D'</span>}: morseCode := <span class="stri">"-.."</span>;
      <span class="keywd">when</span> {<span class="stri">'e'</span>, <span class="stri">'E'</span>}: morseCode := <span class="stri">"."</span>;
      <span class="keywd">when</span> {<span class="stri">'f'</span>, <span class="stri">'F'</span>}: morseCode := <span class="stri">"..-."</span>;
      <span class="keywd">when</span> {<span class="stri">'g'</span>, <span class="stri">'G'</span>}: morseCode := <span class="stri">"--."</span>;
      <span class="keywd">when</span> {<span class="stri">'h'</span>, <span class="stri">'H'</span>}: morseCode := <span class="stri">"...."</span>;
      <span class="keywd">when</span> {<span class="stri">'i'</span>, <span class="stri">'I'</span>}: morseCode := <span class="stri">".."</span>;
      <span class="keywd">when</span> {<span class="stri">'j'</span>, <span class="stri">'J'</span>}: morseCode := <span class="stri">".---"</span>;
      <span class="keywd">when</span> {<span class="stri">'k'</span>, <span class="stri">'K'</span>}: morseCode := <span class="stri">"-.-"</span>;
      <span class="keywd">when</span> {<span class="stri">'l'</span>, <span class="stri">'L'</span>}: morseCode := <span class="stri">".-.."</span>;
      <span class="keywd">when</span> {<span class="stri">'m'</span>, <span class="stri">'M'</span>}: morseCode := <span class="stri">"--"</span>;
      <span class="keywd">when</span> {<span class="stri">'n'</span>, <span class="stri">'N'</span>}: morseCode := <span class="stri">"-."</span>;
      <span class="keywd">when</span> {<span class="stri">'o'</span>, <span class="stri">'O'</span>}: morseCode := <span class="stri">"---"</span>;
      <span class="keywd">when</span> {<span class="stri">'p'</span>, <span class="stri">'P'</span>}: morseCode := <span class="stri">".--."</span>;
      <span class="keywd">when</span> {<span class="stri">'q'</span>, <span class="stri">'Q'</span>}: morseCode := <span class="stri">"--.-"</span>;
      <span class="keywd">when</span> {<span class="stri">'r'</span>, <span class="stri">'R'</span>}: morseCode := <span class="stri">".-."</span>;
      <span class="keywd">when</span> {<span class="stri">'s'</span>, <span class="stri">'S'</span>}: morseCode := <span class="stri">"..."</span>;
      <span class="keywd">when</span> {<span class="stri">'t'</span>, <span class="stri">'T'</span>}: morseCode := <span class="stri">"-"</span>;
      <span class="keywd">when</span> {<span class="stri">'u'</span>, <span class="stri">'U'</span>}: morseCode := <span class="stri">"..-"</span>;
      <span class="keywd">when</span> {<span class="stri">'v'</span>, <span class="stri">'V'</span>}: morseCode := <span class="stri">"...-"</span>;
      <span class="keywd">when</span> {<span class="stri">'w'</span>, <span class="stri">'W'</span>}: morseCode := <span class="stri">".--"</span>;
      <span class="keywd">when</span> {<span class="stri">'x'</span>, <span class="stri">'X'</span>}: morseCode := <span class="stri">"-..-"</span>;
      <span class="keywd">when</span> {<span class="stri">'y'</span>, <span class="stri">'Y'</span>}: morseCode := <span class="stri">"-.--"</span>;
      <span class="keywd">when</span> {<span class="stri">'z'</span>, <span class="stri">'Z'</span>}: morseCode := <span class="stri">"--.."</span>;
      <span class="keywd">when</span> {<span class="stri">'&Auml;'</span>, <span class="stri">'&AElig;'</span>}: morseCode := <span class="stri">".-.-"</span>;
      <span class="keywd">when</span> {<span class="stri">'&Agrave;'</span>, <span class="stri">'&Aring;'</span>}: morseCode := <span class="stri">".--.-"</span>;
      <span class="keywd">when</span> {<span class="stri">'&Ccedil;'</span>, <span class="stri">'&#264;'</span>}: morseCode := <span class="stri">"-.-.."</span>;
      <span class="keywd">when</span> {<span class="stri">'&ETH;'</span>}:      morseCode := <span class="stri">"..--."</span>;
      <span class="keywd">when</span> {<span class="stri">'&Egrave;'</span>}:      morseCode := <span class="stri">".-..-"</span>;
      <span class="keywd">when</span> {<span class="stri">'&Eacute;'</span>}:      morseCode := <span class="stri">"..-.."</span>;
      <span class="keywd">when</span> {<span class="stri">'&#284;'</span>}:      morseCode := <span class="stri">"--.-."</span>;
      <span class="keywd">when</span> {<span class="stri">'&#308;'</span>}:      morseCode := <span class="stri">".---."</span>;
      <span class="keywd">when</span> {<span class="stri">'&Ntilde;'</span>}:      morseCode := <span class="stri">"--.--"</span>;
      <span class="keywd">when</span> {<span class="stri">'&Ouml;'</span>, <span class="stri">'&Oslash;'</span>}: morseCode := <span class="stri">"---."</span>;
      <span class="keywd">when</span> {<span class="stri">'&#348;'</span>}:      morseCode := <span class="stri">"...-."</span>;
      <span class="keywd">when</span> {<span class="stri">'&Uuml;'</span>, <span class="stri">'&#364;'</span>}: morseCode := <span class="stri">"..--"</span>;
      <span class="keywd">when</span> {<span class="stri">'&THORN;'</span>}:      morseCode := <span class="stri">".--.."</span>;
      <span class="keywd">when</span> {<span class="stri">'0'</span>}:      morseCode := <span class="stri">"-----"</span>;
      <span class="keywd">when</span> {<span class="stri">'1'</span>}:      morseCode := <span class="stri">".----"</span>;
      <span class="keywd">when</span> {<span class="stri">'2'</span>}:      morseCode := <span class="stri">"..---"</span>;
      <span class="keywd">when</span> {<span class="stri">'3'</span>}:      morseCode := <span class="stri">"...--"</span>;
      <span class="keywd">when</span> {<span class="stri">'4'</span>}:      morseCode := <span class="stri">"....-"</span>;
      <span class="keywd">when</span> {<span class="stri">'5'</span>}:      morseCode := <span class="stri">"....."</span>;
      <span class="keywd">when</span> {<span class="stri">'6'</span>}:      morseCode := <span class="stri">"-...."</span>;
      <span class="keywd">when</span> {<span class="stri">'7'</span>}:      morseCode := <span class="stri">"--..."</span>;
      <span class="keywd">when</span> {<span class="stri">'8'</span>}:      morseCode := <span class="stri">"---.."</span>;
      <span class="keywd">when</span> {<span class="stri">'9'</span>}:      morseCode := <span class="stri">"----."</span>;
      <span class="keywd">when</span> {<span class="stri">'!'</span>}:      morseCode := <span class="stri">"-.-.--"</span>;
      <span class="keywd">when</span> {<span class="stri">'"'</span>}:      morseCode := <span class="stri">".-..-."</span>;
      <span class="keywd">when</span> {<span class="stri">'$'</span>}:      morseCode := <span class="stri">"...-..-"</span>;
      <span class="keywd">when</span> {<span class="stri">'''</span>}:      morseCode := <span class="stri">".----."</span>;
      <span class="keywd">when</span> {<span class="stri">'('</span>}:      morseCode := <span class="stri">"-.--."</span>;
      <span class="keywd">when</span> {<span class="stri">')'</span>}:      morseCode := <span class="stri">"-.--.-"</span>;
      <span class="keywd">when</span> {<span class="stri">'+'</span>}:      morseCode := <span class="stri">".-.-."</span>;
      <span class="keywd">when</span> {<span class="stri">','</span>}:      morseCode := <span class="stri">"--..--"</span>;
      <span class="keywd">when</span> {<span class="stri">'-'</span>}:      morseCode := <span class="stri">"-....-"</span>;
      <span class="keywd">when</span> {<span class="stri">'.'</span>}:      morseCode := <span class="stri">".-.-.-"</span>;
      <span class="keywd">when</span> {<span class="stri">'/'</span>}:      morseCode := <span class="stri">"-..-."</span>;
      <span class="keywd">when</span> {<span class="stri">':'</span>}:      morseCode := <span class="stri">"---..."</span>;
      <span class="keywd">when</span> {<span class="stri">';'</span>}:      morseCode := <span class="stri">"-.-.-."</span>;
      <span class="keywd">when</span> {<span class="stri">'='</span>}:      morseCode := <span class="stri">"-...-"</span>;
      <span class="keywd">when</span> {<span class="stri">'?'</span>}:      morseCode := <span class="stri">"..--.."</span>;
      <span class="keywd">when</span> {<span class="stri">'@'</span>}:      morseCode := <span class="stri">".--.-."</span>;
      <span class="keywd">when</span> {<span class="stri">' '</span>}:      morseCode := <span class="stri">" "</span>;
    <span class="keywd">end case</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: stringToMorse (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: stri) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: morseCode <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#char">char</a>: ch <span class="keywd">is</span> ' ';
  <span class="keywd">begin</span>
    <span class="keywd">for</span> ch <span class="keywd">range</span> stri <span class="keywd">do</span>
      morseCode &:= charToMorse(ch) &amp; <span class="stri">" "</span>;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="morseToString"><h3>Convert morse code to a character string</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func char</span>: morseToChar (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: morseLetter) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#char">char</a>: ch <span class="keywd">is</span> ' ';
  <span class="keywd">begin</span>
    <span class="keywd">if</span>    morseLetter = <span class="stri">""</span> <span class="keywd">then</span>        ch := <span class="stri">' '</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"."</span> <span class="keywd">then</span>       ch := <span class="stri">'E'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-"</span> <span class="keywd">then</span>       ch := <span class="stri">'T'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".."</span> <span class="keywd">then</span>      ch := <span class="stri">'I'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".-"</span> <span class="keywd">then</span>      ch := <span class="stri">'A'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-."</span> <span class="keywd">then</span>      ch := <span class="stri">'N'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"--"</span> <span class="keywd">then</span>      ch := <span class="stri">'M'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"..."</span> <span class="keywd">then</span>     ch := <span class="stri">'S'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"..-"</span> <span class="keywd">then</span>     ch := <span class="stri">'U'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".-."</span> <span class="keywd">then</span>     ch := <span class="stri">'R'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".--"</span> <span class="keywd">then</span>     ch := <span class="stri">'W'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-.."</span> <span class="keywd">then</span>     ch := <span class="stri">'D'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-.-"</span> <span class="keywd">then</span>     ch := <span class="stri">'K'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"--."</span> <span class="keywd">then</span>     ch := <span class="stri">'G'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"---"</span> <span class="keywd">then</span>     ch := <span class="stri">'O'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"...."</span> <span class="keywd">then</span>    ch := <span class="stri">'H'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"...-"</span> <span class="keywd">then</span>    ch := <span class="stri">'V'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"..-."</span> <span class="keywd">then</span>    ch := <span class="stri">'F'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"..--"</span> <span class="keywd">then</span>    ch := <span class="stri">'&Uuml;'</span>; <span class="comment"># also '&#364;'</span>
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".-.."</span> <span class="keywd">then</span>    ch := <span class="stri">'L'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".-.-"</span> <span class="keywd">then</span>    ch := <span class="stri">'&Auml;'</span>; <span class="comment"># also '&AElig;'</span>
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".--."</span> <span class="keywd">then</span>    ch := <span class="stri">'P'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".---"</span> <span class="keywd">then</span>    ch := <span class="stri">'J'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-..."</span> <span class="keywd">then</span>    ch := <span class="stri">'B'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-..-"</span> <span class="keywd">then</span>    ch := <span class="stri">'X'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-.-."</span> <span class="keywd">then</span>    ch := <span class="stri">'C'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-.--"</span> <span class="keywd">then</span>    ch := <span class="stri">'Y'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"--.."</span> <span class="keywd">then</span>    ch := <span class="stri">'Z'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"--.-"</span> <span class="keywd">then</span>    ch := <span class="stri">'Q'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"---."</span> <span class="keywd">then</span>    ch := <span class="stri">'&Ouml;'</span>; <span class="comment"># also '&Oslash;'</span>
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"----"</span> <span class="keywd">then</span>    ch := <span class="stri">' '</span>; <span class="comment"># 'ch'</span>
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"....."</span> <span class="keywd">then</span>   ch := <span class="stri">'5'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"....-"</span> <span class="keywd">then</span>   ch := <span class="stri">'4'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"...-."</span> <span class="keywd">then</span>   ch := <span class="stri">'&#348;'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"...--"</span> <span class="keywd">then</span>   ch := <span class="stri">'3'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"..-.."</span> <span class="keywd">then</span>   ch := <span class="stri">'&Eacute;'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"..-.-"</span> <span class="keywd">then</span>   ch := <span class="stri">' '</span>; <span class="comment"># unused</span>
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"..--."</span> <span class="keywd">then</span>   ch := <span class="stri">'&ETH;'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"..---"</span> <span class="keywd">then</span>   ch := <span class="stri">'2'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".-..."</span> <span class="keywd">then</span>   ch := <span class="stri">' '</span>; <span class="comment"># unused</span>
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".-..-"</span> <span class="keywd">then</span>   ch := <span class="stri">'&Egrave;'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".-.-."</span> <span class="keywd">then</span>   ch := <span class="stri">'+'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".-.--"</span> <span class="keywd">then</span>   ch := <span class="stri">' '</span>; <span class="comment"># unused</span>
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".--.."</span> <span class="keywd">then</span>   ch := <span class="stri">'&THORN;'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".--.-"</span> <span class="keywd">then</span>   ch := <span class="stri">'&Agrave;'</span>; <span class="comment"># also '&Aring;'</span>
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".---."</span> <span class="keywd">then</span>   ch := <span class="stri">'&#308;'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".----"</span> <span class="keywd">then</span>   ch := <span class="stri">'1'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-...."</span> <span class="keywd">then</span>   ch := <span class="stri">'6'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-...-"</span> <span class="keywd">then</span>   ch := <span class="stri">'='</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-..-."</span> <span class="keywd">then</span>   ch := <span class="stri">'/'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-..--"</span> <span class="keywd">then</span>   ch := <span class="stri">' '</span>; <span class="comment"># unused</span>
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-.-.."</span> <span class="keywd">then</span>   ch := <span class="stri">'&Ccedil;'</span>; <span class="comment"># also '&#264;'</span>
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-.-.-"</span> <span class="keywd">then</span>   ch := <span class="stri">' '</span>; <span class="comment"># Start of message</span>
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-.--."</span> <span class="keywd">then</span>   ch := <span class="stri">'('</span>; <span class="comment"># also '&#292;'</span>
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-.---"</span> <span class="keywd">then</span>   ch := <span class="stri">' '</span>; <span class="comment"># unused</span>
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"--..."</span> <span class="keywd">then</span>   ch := <span class="stri">'7'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"--..-"</span> <span class="keywd">then</span>   ch := <span class="stri">' '</span>; <span class="comment"># unused</span>
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"--.-."</span> <span class="keywd">then</span>   ch := <span class="stri">'&#284;'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"--.--"</span> <span class="keywd">then</span>   ch := <span class="stri">'&Ntilde;'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"---.."</span> <span class="keywd">then</span>   ch := <span class="stri">'8'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"---.-"</span> <span class="keywd">then</span>   ch := <span class="stri">' '</span>; <span class="comment"># unused</span>
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"----."</span> <span class="keywd">then</span>   ch := <span class="stri">'9'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-----"</span> <span class="keywd">then</span>   ch := <span class="stri">'0'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"..--.."</span> <span class="keywd">then</span>  ch := <span class="stri">'?'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".-..-."</span> <span class="keywd">then</span>  ch := <span class="stri">'"'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".-.-.-"</span> <span class="keywd">then</span>  ch := <span class="stri">'.'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".--.-."</span> <span class="keywd">then</span>  ch := <span class="stri">'@'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">".----."</span> <span class="keywd">then</span>  ch := <span class="stri">'''</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-....-"</span> <span class="keywd">then</span>  ch := <span class="stri">'-'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-.-.--"</span> <span class="keywd">then</span>  ch := <span class="stri">'!'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-.-.-."</span> <span class="keywd">then</span>  ch := <span class="stri">';'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"-.--.-"</span> <span class="keywd">then</span>  ch := <span class="stri">')'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"--..--"</span> <span class="keywd">then</span>  ch := <span class="stri">','</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"---..."</span> <span class="keywd">then</span>  ch := <span class="stri">':'</span>;
    <span class="keywd">elsif</span> morseLetter = <span class="stri">"...-..-"</span> <span class="keywd">then</span> ch := <span class="stri">'$'</span>;
    else                               ch := <span class="stri">' '</span>;
    end if;
  end func;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#string">string</a>: morseToString (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: morseCode) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#array">array</a> <a class="type" href="../manual/types.htm#string">string</a>: letters <span class="keywd">is</span> 0 <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> <span class="stri">""</span>;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: letter <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    letters := split(replace(morseCode, <span class="stri">"  "</span>, <span class="stri">" "</span>), <span class="stri">' '</span>);
    <span class="keywd">for</span> letter <span class="keywd">range</span> letters <span class="keywd">do</span>
      stri &:= str(morseToChar(letter));
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="wildcard_match"><h3>Wildcard match used in command shells</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#boolean">boolean</a>: wildcard_match (<span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: main_stri, <span class="keywd">in</span> <a class="type" href="../manual/types.htm#string">string</a>: pattern) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#boolean">boolean</a>: doesMatch <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: main_length <span class="keywd">is</span> 0;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: main_index <span class="keywd">is</span> 1;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: pattern_tail <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> pattern = <span class="stri">""</span> <span class="keywd">then</span>
      doesMatch := main_stri = <span class="stri">""</span>;
    <span class="keywd">else</span>
      <span class="keywd">case</span> pattern[1] <span class="keywd">of</span>
        <span class="keywd">when</span> {<span class="stri">'*'</span>}:
          <span class="keywd">if</span> pattern = <span class="stri">"*"</span> <span class="keywd">then</span>
            doesMatch := TRUE;
          <span class="keywd">else</span>
            main_length := length(main_stri);
            pattern_tail := pattern[2 .. ];
            <span class="keywd">while</span> main_index &lt;= main_length <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> <a class="op" href="../libraries/boolean.htm#not(in_boolean)">not</a> doesMatch <span class="keywd">do</span>
              doesMatch := wildcard_match(main_stri[main_index .. ],
                  pattern_tail);
              incr(main_index);
            <span class="keywd">end while</span>;
          <span class="keywd">end if</span>;
        <span class="keywd">when</span> {<span class="stri">'?'</span>}:
          <span class="keywd">if</span> main_stri &lt;> <span class="stri">""</span> <span class="keywd">then</span>
            doesMatch := wildcard_match(main_stri[2 .. ], pattern[2 .. ]);
          <span class="keywd">end if</span>;
        <span class="keywd">otherwise</span>:
          <span class="keywd">if</span> main_stri &lt;> <span class="stri">""</span> <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> main_stri[1] = pattern[1] <span class="keywd">then</span>
            doesMatch := wildcard_match(main_stri[2 .. ], pattern[2 .. ]);
          <span class="keywd">end if</span>;
      <span class="keywd">end case</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre></div>

<div><a name="cmpNumeric"><h3>String compare function where digit sequences are compared numerically</h3></a>
<p>
</p><pre class="indent">
<span class="keywd">include</span> <span class="stri">"<a class="lib" href="../prg/scanstri.htm">scanstri.s7i</a>"</span>;

<span class="keywd">const</span> <a class="type" href="../manual/types.htm#func">func</a> <a class="type" href="../manual/types.htm#integer">integer</a>: cmpNumeric (<span class="keywd">in var</span> <a class="type" href="../manual/types.htm#string">string</a>: stri1, <span class="keywd">in var</span> <a class="type" href="../manual/types.htm#string">string</a>: stri2) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#integer">integer</a>: signumValue <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: part1 <span class="keywd">is</span> <span class="stri">""</span>;
    <span class="keywd">var</span> <a class="type" href="../manual/types.htm#string">string</a>: part2 <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> signumValue = 0 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> (stri1 &lt;> <span class="stri">""</span> <a class="op" href="../libraries/boolean.htm#(in_boolean)or(ref_func_boolean)">or</a> stri2 &lt;> <span class="stri">""</span>) <span class="keywd">do</span>
      part1 := getDigits(stri1);
      part2 := getDigits(stri2);
      <span class="keywd">if</span> part1 &lt;> <span class="stri">""</span> <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> part2 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        signumValue := compare(part1 <a class="op" href="../libraries/string.htm#(in_string)lpad0(in_integer)">lpad0</a> length(part2), part2 <a class="op" href="../libraries/string.htm#(in_string)lpad0(in_integer)">lpad0</a> length(part1));
        <span class="keywd">if</span> signumValue = 0 <span class="keywd">then</span>
          signumValue := compare(length(part1), length(part2));
        <span class="keywd">end if</span>;
      <span class="keywd">elsif</span> part1 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        signumValue := compare(part1, stri2);
      <span class="keywd">elsif</span> part2 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
        signumValue := compare(stri1, part2);
      <span class="keywd">end if</span>;
      <span class="keywd">if</span> signumValue = 0 <span class="keywd">then</span>
        part1 := getNonDigits(stri1);
        part2 := getNonDigits(stri2);
        <span class="keywd">if</span> part1 &lt;> <span class="stri">""</span> <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> part2 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          signumValue := compare(part1, part2);
        <span class="keywd">elsif</span> part1 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          signumValue := compare(part1, stri2);
        <span class="keywd">elsif</span> part2 &lt;> <span class="stri">""</span> <span class="keywd">then</span>
          signumValue := compare(stri1, part2);
        <span class="keywd">end if</span>;
      <span class="keywd">end if</span>;
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre></div>
<table width="100%" cellpadding="0" cellspacing="0">
<tr>
<td align="left" width="60%">
<b><big><hr \></big></b></td>
<td align="right">
<table border="0" cellspacing="1" bgcolor="blue">
<tr bgcolor="gainsboro">
<td>&nbsp;<a class="navigation" href="../algorith/date.htm">previous</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/index.htm">up</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../algorith/float.htm">next</a>&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</div>
  </body>
</html>
