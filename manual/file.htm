<html>
<head>
<meta charset="utf-8" />
<title>
Seed7 Manual: File input and output</title>
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style1.css" type="text/css" />
</head>
<body style="margin:0 0 0 0;">
<div style="background-image: url('../images/header1x.png');" class="top_image">
<img style="overflow:hidden;" src="../images/hearts7m.png" height="68" width="50"
 /><img style="overflow:hidden;" src="../images/header3.png" height="68" width="745" />
</div>
<div style="background-image: url('../images/fillpix.png');" class="space_below_top_image">
</div>
<div class="menu">

<a class="head" href="../index.htm"><big>Seed7</big></a>
<a class="menu" href="../faq.htm">FAQ</a>
<a class="menu" href="../manual/index.htm">Manual</a>
<a class="menu" href="../scrshots/index.htm">Programs</a>
<a class="menu" href="../examples/index.htm">Examples</a>
<a class="menu" href="../libraries/index.htm">Libraries</a>
<a class="menu" href="../algorith/index.htm">Algorithms</a>
<a class="menu" href="../benchmks/index.htm">Benchmarks</a>
<a class="menu" href="../subject_index.htm">Index</a>
<a class="menu" href="http://sourceforge.net/project/showfiles.php?group_id=151126">Download</a>
<a class="menu" href="https://github.com/ThomasMertes/seed7">GitHub</a>
<a class="menu" href="../build.htm">Build Seed7</a>
<a class="menu" href="../links.htm">Links</a>

<br />

<a class="head" href="index.htm"><big>Manual</big></a>
<a class="menu" href="intro.htm">Introduction</a>
<a class="menu" href="tutorial.htm">Tutorial</a>
<a class="menu" href="decls.htm">Declarations</a>
<a class="menu" href="stats.htm">Statements</a>
<a class="menu" href="types.htm">Types</a>
<a class="menu" href="params.htm">Parameters</a>
<a class="menu" href="objects.htm">Objects</a>
<a class="menu" href="file.htm">File I/O</a>
<a class="menu" href="syntax.htm">Syntax</a>
<a class="menu" href="tokens.htm">Tokens</a>
<a class="menu" href="expr.htm">Expressions</a>
<a class="menu" href="os.htm">OS&nbsp;access</a>
<a class="menu" href="database.htm">Database</a>
<a class="menu" href="graphic.htm">Graphic</a>
<a class="menu" href="actions.htm">Actions</a>
<a class="menu" href="ffi.htm">Foreign&nbsp;funcs</a>
<a class="menu" href="errors.htm">Errors</a>

<br />

<a class="head" href="#FILE_INPUT_AND_OUTPUT"><big>File&nbsp;I/O</big></a>
<a class="menu" href="#Conversion_to_strings_and_back">conversion</a>
<a class="menu" href="#Basic_input_and_output_operations">basic&nbsp;I/O</a>
<a class="menu" href="#Input_and_output_with_conversion">I/O&nbsp;+&nbsp;conv</a>
<a class="menu" href="#Simple_read_and_write_statements">read&nbsp;/&nbsp;write</a>
<a class="menu" href="#Standard_input_and_output_files">standard&nbsp;I/O</a>
<a class="menu" href="#Access_to_operating_system_files">OS&nbsp;files</a>
<a class="menu" href="#Keyboard_file">keyboard</a>
<a class="menu" href="#Files_with_line_structure">text&nbsp;files</a>
<a class="menu" href="#Sockets">sockets</a>
<a class="menu" href="#Transport_layer_security">TLS sockets</a>
<a class="menu" href="#User_defined_file_types">file&nbsp;types</a>
<a class="menu" href="#Scanning_a_file">scanning</a>
</div>
<div class="content">
<div style="padding-right:20;">
<table width="100%" cellpadding="0" cellspacing="0">
<tr>
<td align="left" width="80">
<a class="head" href="index.htm"><big>Manual</big></a>
</td>
<td>
<table width="10">
</table>
</td>
<td align="left" width="60%">
<b><big>File I/O</big></b></td>
<td align="right">
<table border="0" cellspacing="1" bgcolor="blue">
<tr bgcolor="gainsboro">
<td>&nbsp;<a class="navigation" href="../manual/objects.htm">previous</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../manual/index.htm">up</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../manual/syntax.htm">next</a>&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
<a name="file_start"></a><p></p>
<a name="FILE_INPUT_AND_OUTPUT"><h2>8. FILE INPUT AND OUTPUT</h2></a>

<p>
    Files are used for communication in various ways. For example:
  To write strings on the screen we use the following statements:
</p><pre class="indent">
<a class="func" href="../libraries/stdio.htm#write(in_string)">write</a>(<span class="stri">"hello world"</span>);
<a class="func" href="../libraries/stdio.htm#writeln">writeln</a>;
</pre><p>
  The procedure <tt><a class="func" href="../libraries/stdio.htm#write(in_string)">write</a></tt> writes a given string and <tt><a class="func" href="../libraries/stdio.htm#writeln">writeln</a></tt> means:
  Write newline. We can also write data of various types with <tt>'write'</tt>:
</p><pre class="indent">
write(<span class="stri">"result = "</span>);
write(number <span class="keywd">div</span> 5);
write(<span class="stri">" "</span>);
writeln(<span class="keywd">not</span> error);
</pre><p>
  The <tt>'writeln'</tt> above writes data and then terminates the line.
  This is equal to a <tt>'write'</tt> followed by a <tt>'writeln'</tt>. Instead of
  multiple write statements the <tt><a class="keywd" href="../libraries/enable_io.htm#(in_string)&lt;&amp;(in_aType)">&lt;&amp;</a></tt> operator can be used to
  concatenate the elements to be written:
</p><pre class="indent">
<a class="func" href="../libraries/stdio.htm#writeln(in_string)">writeln</a>(<span class="stri">"result = "</span> <a class="keywd" href="../libraries/enable_io.htm#(in_string)&lt;&amp;(in_aType)">&lt;&amp;</a> number <span class="keywd">div</span> 5 <a class="keywd" href="../libraries/enable_io.htm#(in_string)&lt;&amp;(in_aType)">&lt;&amp;</a> <span class="stri">" "</span> <a class="keywd" href="../libraries/enable_io.htm#(in_string)&lt;&amp;(in_aType)">&lt;&amp;</a> <span class="keywd">not</span> error);
</pre><p>
  The <tt><a class="keywd" href="../libraries/enable_io.htm#(in_string)&lt;&amp;(in_aType)">&lt;&amp;</a></tt> operator is overloaded for various types and is present
  it three variants:
</p><ul>
    <li><tt><a class="type" href="types.htm#string">string</a> <a class="keywd" href="../libraries/enable_io.htm#(in_string)&lt;&amp;(in_aType)">&lt;&amp;</a> <span class="type">otherType</span></tt>:
      In this case the right operand is converted to a <tt><a class="type" href="types.htm#string">string</a></tt> before
      the concatenation takes place.</li>
    <li><tt><span class="type">otherType</span> <a class="keywd" href="../libraries/enable_io.htm#(in_aType)&lt;&amp;(in_string)">&lt;&amp;</a> <a class="type" href="types.htm#string">string</a></tt>:
      In this case the left operand is converted to a <tt><a class="type" href="types.htm#string">string</a></tt> before
      the concatenation takes place.</li>
    <li><tt><a class="type" href="types.htm#string">string</a> <a class="keywd" href="../libraries/string.htm#(in_string)<&(in_string)">&lt;&amp;</a> <a class="type" href="types.htm#string">string</a></tt>: In this case the two operands are concatenated.</li>
</ul><p>
  This allows chaining concatenations like in:
</p><pre class="indent">
write(next_time <a class="keywd" href="../libraries/enable_io.htm#(in_aType)&lt;&amp;(in_string)">&lt;&amp;</a> <span class="stri">" is "</span> <a class="keywd" href="../libraries/enable_io.htm#(in_string)&lt;&amp;(in_aType)">&lt;&amp;</a> booleanExpression);
</pre><p>
  Several objects can be concatenated in a chain, if the first or the
  second object is a <tt><a class="type" href="types.htm#string">string</a></tt>.
</p><p>
  We can also read data from the keyboard:
</p><pre class="indent">
write(<span class="stri">"Amount? "</span>);
read(amount);
</pre><p>
  The user is allowed to use <span class="box">Backspace</span> and sends the input
  to the program with the <span class="box">Return</span> key. To let the user respond
  with the <span class="box">Return</span> key we can write:
</p><pre class="indent">
writeln(<span class="stri">"Type RETURN"</span>);
readln;
</pre><p>
  To read a line of data we can use <tt>'readln'</tt>:
</p><pre class="indent">
write(<span class="stri">"Your comment? "</span>);
readln(user_comment_string);
</pre><p>
  In the previous examples all <tt>'read'</tt> statements read from the
  file <tt><a class="var" href="../libraries/stdio.htm#IN">IN</a></tt> and all <tt>'write'</tt> statements write to the file <tt><a class="var" href="../libraries/stdio.htm#OUT">OUT</a></tt>. The
  files <tt><a class="var" href="../libraries/stdio.htm#IN">IN</a></tt> and <tt><a class="var" href="../libraries/stdio.htm#OUT">OUT</a></tt> are initialized with <tt><a class="var" href="../libraries/stdio.htm#STD_IN">STD_IN</a></tt> and <tt><a class="var" href="../libraries/stdio.htm#STD_OUT">STD_OUT</a></tt>
  which are the stdin and stdout files of the operating system.
  (Usually the keyboard and the screen). If we want to write
  to other files we use write statements with the file as first
  parameter. To write a line of text to the file <tt><span class="stri">"info.fil"</span></tt> we
  use the following statements:
</p><pre class="indent">
info_file := <a class="func" href="../libraries/external_file.htm#open(in_string,in_string)">open</a>(<span class="stri">"info.fil"</span>, <span class="stri">"w"</span>);
writeln(info_file, <span class="stri">"This is the first line of the info file."</span>);
close(info_file);
</pre><p>
  First the external file is opened for writing and then it is
  used. To read the file back in the string <tt>'stri'</tt> we write:
</p><pre class="indent">
info_file := <a class="func" href="../libraries/external_file.htm#open(in_string,in_string)">open</a>(<span class="stri">"info.fil"</span>, <span class="stri">"r"</span>);
readln(info_file, stri);
close(info_file);
</pre><p>
  It is also possible to write values of other types to
  <tt>'info_file'</tt>:
</p><pre class="indent">
writeln(info_file, number);
</pre><p>
  Here the <tt>'number'</tt> is converted to a string which is written
  to the file. A <tt>'number'</tt> is read back with:
</p><pre class="indent">
readln(info_file, number);
</pre><p>
  For doing I/O to a window on the screen we write:
</p><pre class="indent">
window1 := openWindow(screen, 10, 10, 5, 60);
box(window1);
setPos(window1, 3, 1);
write(window1, <span class="stri">"hello there"</span>);
</pre><p>
  This opens the window <tt>'window1'</tt> on the <tt>'screen'</tt> at the position
  10, 10. This window has 5 lines and 60 columns. A box (of
  characters: - | + ) is written to surround the <tt>'window1'</tt> and
  finally the string <tt><span class="stri">"hello there"</span></tt> is written in the window
  <tt>'window1'</tt> at Position 3, 1. If we want to clear the <tt>'window1'</tt>
  we write:
</p><pre class="indent">
clear(window1);
</pre><p>
  Files can be used for much more things. Here is a list of
  goals for an input/output system:
</p><ul>
    <li>A concept which provides conversions from arbitrary
      types to strings and back.</li>

    <li>Basic input and output operations to process a file
      character wise, word wise or line wise.</li>

    <li>Input and output statements which combine input with
      conversion respectively conversion with output.</li>

    <li>Simple read and write statements for standard
      input and output for arbitrary types.</li>

    <li>Standard input and output files and the possibility
      to route the standard I/O to any file.</li>

    <li>Access to operating system files and devices.</li>

    <li>An interface which allows the user to define
      his own file types.</li>
</ul><p>
  In the following sub-chapters we discuss each of these goals.
</p>

<a name="Conversion_to_strings_and_back"><h3>8.1 Conversion to strings and back</h3></a>
<p>
    We archive the goal of doing I/O for arbitrary types with
  two conversion functions. In order to do I/O with a type
  the <tt><span class="func">str</span></tt> and <tt><span class="op">parse</span></tt> functions must be defined for that
  type. As an example we show the conversion functions for the
  type <tt><a class="type" href="types.htm#boolean">boolean</a></tt>:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func string</span>: str (<span class="keywd">in</span> <span class="type">boolean</span>: aBool) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> aBool <span class="keywd">then</span>
      stri := <span class="stri">"TRUE"</span>;
    <span class="keywd">else</span>
      stri := <span class="stri">"FALSE"</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <span class="type">func boolean</span>: (<span class="keywd">attr</span> <span class="type">boolean</span>) parse (<span class="keywd">in</span> <span class="type">string</span>: stri) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">boolean</span>: aBoolean <span class="keywd">is</span> <a class="var" href="../libraries/boolean.htm#FALSE">FALSE</a>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> stri = <span class="stri">"TRUE"</span> <span class="keywd">then</span>
      aBoolean := <a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a>;
    <span class="keywd">elsif</span> stri = <span class="stri">"FALSE"</span> <span class="keywd">then</span>
      aBoolean := <a class="var" href="../libraries/boolean.htm#FALSE">FALSE</a>;
    <span class="keywd">else</span>
      raise <a class="exception" href="errors.htm#RANGE_ERROR">RANGE_ERROR</a>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  The <tt><a class="func" href="../libraries/boolean.htm#str(in_boolean)">str</a></tt> function must deliver a corresponding string for
  every value of the type. The <tt><a class="keywd" href="../libraries/boolean.htm#(attr_boolean)parse(in_string)">parse</a></tt> operator parses a string
  and delivers the converted value as result. If the conversion
  is not successful the exception <tt><a class="exception" href="errors.htm#RANGE_ERROR">RANGE_ERROR</a></tt> is raised. The
  attribute used with <tt><span class="op">parse</span></tt> allows that it is overloaded for
  different types.
</p><p>
  After defining the <tt><span class="func">str</span></tt> and <tt><span class="op">parse</span></tt> functions for a type the
  <tt><a class="func" href="../libraries/enable_io.htm#enable_io(in_type)">enable_io</a></tt> function can be called for this type as in:
</p><pre class="indent">
enable_io(<span class="type">boolean</span>);
</pre><p>
  The <tt><a class="func" href="../libraries/enable_io.htm#enable_io(in_type)">enable_io</a></tt> template declares various io functions like
  <tt>'read'</tt>, <tt>'write'</tt> and others for the provided type (in this
  example <tt><a class="type" href="types.htm#boolean">boolean</a></tt>). If only output (or only input) is needed
  for a type it is possible to define just <tt><span class="func">str</span></tt> (or <tt><span class="op">parse</span></tt>)
  and activate just <tt><a class="func" href="../libraries/enable_io.htm#enable_output(in_type)">enable_output</a></tt> (or <tt><a class="func" href="../libraries/enable_input.htm#enable_input(in_type)">enable_input</a></tt>).
</p><p>
  There is also a formatting operator called <tt><a class="keywd" href="../libraries/enable_io.htm#(in_aType)lpad(in_integer)">lpad</a></tt> which is based
  on the <tt><span class="func">str</span></tt> function. The statements
</p><pre class="indent">
write(12 <a class="keywd" href="../libraries/enable_io.htm#(in_aType)lpad(in_integer)">lpad</a> 6);
write(3 <a class="keywd" href="../libraries/enable_io.htm#(in_aType)lpad(in_integer)">lpad</a> 6);
writeln(45 <a class="keywd" href="../libraries/enable_io.htm#(in_aType)lpad(in_integer)">lpad</a> 6);
write(678 <a class="keywd" href="../libraries/enable_io.htm#(in_aType)lpad(in_integer)">lpad</a> 6);
write(98765 <a class="keywd" href="../libraries/enable_io.htm#(in_aType)lpad(in_integer)">lpad</a> 6);
writeln(4321 <a class="keywd" href="../libraries/enable_io.htm#(in_aType)lpad(in_integer)">lpad</a> 6);
</pre><p>
  produce the following output:
</p><pre class="indent">
    12     3    45
   678 98765  4321
</pre><p>
  As we see the <tt><a class="keywd" href="../libraries/enable_io.htm#(in_aType)lpad(in_integer)">lpad</a></tt> operator can be used to produce right
  justified output. There is also <tt><a class="keywd" href="../libraries/enable_io.htm#(in_aType)rpad(in_integer)">rpad</a></tt> operator to produce
  left justified output. The basic definitions of the <tt><a class="keywd" href="../libraries/string.htm#(in_string)lpad(in_integer)">lpad</a></tt>
  and <tt><a class="keywd" href="../libraries/string.htm#(in_string)rpad(in_integer)">rpad</a></tt> operators work on strings and are as follows:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func string</span>: (<span class="keywd">ref</span> <span class="type">string</span>: stri) lpad (<span class="keywd">in</span> <span class="type">integer</span>: leng) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: padded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> leng > <a class="func" href="../libraries/string.htm#length(in_string)">length</a>(stri) <span class="keywd">then</span>
      padded := <span class="stri">" "</span> <a class="op" href="../libraries/string.htm#(in_string)mult(in_integer)">mult</a> leng - <a class="func" href="../libraries/string.htm#length(in_string)">length</a>(stri) &amp; stri;
    <span class="keywd">else</span>
      padded := stri;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <span class="type">func string</span>: (<span class="keywd">ref</span> <span class="type">string</span>: stri) rpad (<span class="keywd">in</span> <span class="type">integer</span>: leng) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: padded <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> leng > <a class="func" href="../libraries/string.htm#length(in_string)">length</a>(stri) <span class="keywd">then</span>
      padded := stri &amp; <span class="stri">" "</span> <a class="op" href="../libraries/string.htm#(in_string)mult(in_integer)">mult</a> leng - <a class="func" href="../libraries/string.htm#length(in_string)">length</a>(stri);
    <span class="keywd">else</span>
      padded := stri;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  The <tt><a class="func" href="../libraries/enable_io.htm#enable_io(in_type)">enable_io</a></tt> template contains definitions of <tt><a class="keywd" href="../libraries/enable_io.htm#(in_aType)lpad(in_integer)">lpad</a></tt> and <tt><a class="keywd" href="../libraries/enable_io.htm#(in_aType)rpad(in_integer)">rpad</a></tt>
  to work on the type specified with <tt><a class="func" href="../libraries/enable_io.htm#enable_io(in_type)">enable_io</a></tt>:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func string</span>: (<span class="keywd">in</span> <span class="type">aType</span>: aValue) lpad (<span class="keywd">in</span> <span class="type">integer</span>: leng) <span class="keywd">is</span>
  <span class="keywd">return</span> str(aValue) <a class="op" href="../libraries/string.htm#(in_string)lpad(in_integer)">lpad</a> leng;

<span class="keywd">const</span> <span class="type">func string</span>: (<span class="keywd">in</span> <span class="type">aType</span>: aValue) rpad (<span class="keywd">in</span> <span class="type">integer</span>: leng) <span class="keywd">is</span>
  <span class="keywd">return</span> str(aValue) <a class="op" href="../libraries/string.htm#(in_string)rpad(in_integer)">rpad</a> leng;
</pre><p>
  Values of type <tt><a class="type" href="types.htm#integer">integer</a></tt> and <tt><a class="type" href="types.htm#bigInteger">bigInteger</a></tt> can be written in
  a numeral system with a radix (base) other than 10. The
  operators <tt><a class="keywd" href="../libraries/integer.htm#(in_integer)radix(in_integer)">radix</a></tt> and <tt><a class="keywd" href="../libraries/integer.htm#(in_integer)RADIX(in_integer)">RADIX</a></tt> can be used for this purpose.
  E.g. the statements
</p><pre class="indent">
writeln(48879 <a class="keywd" href="../libraries/integer.htm#(in_integer)radix(in_integer)">radix</a> 16);
writeln(3735928559_ <a class="keywd" href="../libraries/bigint.htm#(in_var_bigInteger)RADIX(in_integer)">RADIX</a> 16);
</pre><p>
  produce the following output:
</p><pre class="indent">
beef
DEADBEEF
</pre><p>
  For <tt><a class="type" href="types.htm#float">float</a></tt> values exist additional ways to convert them to
  strings. The <tt><a class="keywd" href="../libraries/float.htm#(in_float)digits(in_integer)">digits</a></tt> operator allows the specification of a
  precision. E.g. the statements
</p><pre class="indent">
writeln(3.1415 <a class="keywd" href="../libraries/float.htm#(in_float)digits(in_integer)">digits</a> 2);
writeln(4.0 <a class="keywd" href="../libraries/float.htm#(in_float)digits(in_integer)">digits</a> 2);
</pre><p>
  produce the following output:
</p><pre class="indent">
3.14
4.00
</pre><p>
  A combination with the <tt><a class="keywd" href="../libraries/string.htm#(in_string)lpad(in_integer)">lpad</a></tt> operator as in
</p><pre class="indent">
writeln(3.1415 <a class="keywd" href="../libraries/float.htm#(in_float)digits(in_integer)">digits</a> 2 <a class="keywd" href="../libraries/string.htm#(in_string)lpad(in_integer)">lpad</a> 6);
writeln(99.9 <a class="keywd" href="../libraries/float.htm#(in_float)digits(in_integer)">digits</a> 2 <a class="keywd" href="../libraries/string.htm#(in_string)lpad(in_integer)">lpad</a> 6);
</pre><p>
  is also possible and produces the following output:
</p><pre class="indent">
  3.14
 99.90
</pre><p>
  Scientific notation for <tt><a class="type" href="types.htm#float">float</a></tt> is supported with the
  conversion operator <tt><a class="keywd" href="../libraries/float.htm#(in_float)sci(in_integer)">sci</a></tt>. The statements
</p><pre class="indent">
writeln(0.012345 <a class="keywd" href="../libraries/float.htm#(in_float)sci(in_integer)">sci</a> 4);
writeln(1.2468 <a class="keywd" href="../libraries/float.htm#(in_float)sci(in_integer)">sci</a> 2 );
writeln(3.1415 <a class="keywd" href="../libraries/float.htm#(in_float)sci(in_integer)">sci</a> 0);
writeln(0.125 <a class="keywd" href="../libraries/float.htm#(in_float)sci(in_integer)">sci</a> 1);
writeln(0.375 <a class="keywd" href="../libraries/float.htm#(in_float)sci(in_integer)">sci</a> 1);
</pre><p>
  produce the following output:
</p><pre class="indent">
1.2345e-2
1.25e+0
3e+0
1.2e-1
3.8e-1
</pre><p>
  The operator <tt><a class="keywd" href="../libraries/float.htm#(in_string)exp(in_integer)">exp</a></tt> is used to specify the number of exponent digits.  The statements
</p><pre class="indent">
writeln(0.012345 <a class="keywd" href="../libraries/float.htm#(in_float)sci(in_integer)">sci</a> 4 <a class="keywd" href="../libraries/float.htm#(in_string)exp(in_integer)">exp</a> 2);
writeln(1.2468e15 <a class="keywd" href="../libraries/float.htm#(in_float)sci(in_integer)">sci</a> 2 <a class="keywd" href="../libraries/float.htm#(in_string)exp(in_integer)">exp</a> 1);
writeln(3.1415 <a class="keywd" href="../libraries/float.htm#(in_float)sci(in_integer)">sci</a> 0 <a class="keywd" href="../libraries/float.htm#(in_string)exp(in_integer)">exp</a> 3);
writeln(0.125 <a class="keywd" href="../libraries/float.htm#(in_float)sci(in_integer)">sci</a> 1 <a class="keywd" href="../libraries/float.htm#(in_string)exp(in_integer)">exp</a> 2);
writeln(0.375 <a class="keywd" href="../libraries/float.htm#(in_float)sci(in_integer)">sci</a> 1 <a class="keywd" href="../libraries/float.htm#(in_string)exp(in_integer)">exp</a> 2);
</pre><p>
  produce the following output:
</p><pre class="indent">
1.2345e-02
1.25e+15
3e+000
1.2e-01
3.8e-01
</pre><p></p>

<a name="Basic_input_and_output_operations"><h3>8.2 Basic input and output operations</h3></a>
<p>
    To allow arbitrary user defined file-types beside the
  operating system files we chose a model in which the
  I/O methods are assigned to the type of the file-value and
  not to the type of the file-variable. This allows a file
  variable to point to any file-value. The file-variables
  have the type <tt><a class="type" href="types.htm#file">file</a></tt>, which is the interface type for sequential
  files. For the operating system files and for each user
  defined file a file-type must be declared which has the
  I/O methods defined. These file-types are derived (direct
  or indirect) from the type <tt><a class="type" href="../libraries/null_file.htm#null_file">null_file</a></tt> for which all I/O
  methods are defined upon a base of basic string I/O
  methods. So for a new user defined file-type only the
  basic string I/O methods must be defined.
</p><p>
  The two basic I/O methods defined for <tt><a class="type" href="../libraries/null_file.htm#null_file">null_file</a></tt> are
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: write (<span class="keywd">in</span> <a class="type" href="../libraries/null_file.htm#null_file">null_file</a>: aFile, <span class="keywd">in</span> <span class="type">string</span>: stri) <span class="keywd">is</span> noop;

<span class="keywd">const</span> <span class="type">func string</span>: gets (<span class="keywd">in</span> <a class="type" href="../libraries/null_file.htm#null_file">null_file</a>: inFile, <span class="keywd">in</span> <span class="type">integer</span>: maxLength) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: striRead <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> maxLength &lt; 0 <span class="keywd">then</span>
      <span class="keywd">raise</span> <a class="exception" href="errors.htm#RANGE_ERROR">RANGE_ERROR</a>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  A <tt><a class="func" href="../libraries/null_file.htm#write(in_null_file,in_string)">write</a></tt> to <tt><a class="type" href="../libraries/null_file.htm#null_file">null_file</a></tt> with any string has no effect.
  Reading any number of characters with <tt><a class="func" href="../libraries/null_file.htm#gets(in_null_file,in_integer)">gets</a></tt> from
  <tt><a class="type" href="../libraries/null_file.htm#null_file">null_file</a></tt> delivers the empty string. When a user defined
  file type is declared these are the two methods, which must
  be redefined, for the new file-type. Based upon these
  two methods three more methods are defined for
  <tt><a class="type" href="../libraries/null_file.htm#null_file">null_file</a></tt>, named  <tt><a class="func" href="../libraries/null_file.htm#getc(inout_null_file)">getc</a></tt>, <tt><a class="func" href="../libraries/null_file.htm#getwd(inout_null_file)">getwd</a></tt> and <tt><a class="func" href="../libraries/null_file.htm#getln(inout_null_file)">getln</a></tt>.
  These methods get a character, a word and a line
  respectively. A word is terminated by a space, a tab
  or a linefeed. A line is terminated by a linefeed.
  This methods need not to be redefined for a user defined
  file type but for performance reasons they can also be
  redefined. The definitions for <tt><a class="func" href="../libraries/null_file.htm#getc(inout_null_file)">getc</a></tt>, <tt><a class="func" href="../libraries/null_file.htm#getwd(inout_null_file)">getwd</a></tt> and <tt><a class="func" href="../libraries/null_file.htm#getln(inout_null_file)">getln</a></tt> for
  <tt><a class="type" href="../libraries/null_file.htm#null_file">null_file</a></tt> are
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func char</span>: getc (<span class="keywd">inout</span> <a class="type" href="../libraries/null_file.htm#null_file">null_file</a>: aFile) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">char</span>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: buffer <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    buffer := <a class="func" href="../libraries/file.htm#gets(inout_file,in_integer)">gets</a>(aFile, 1);
    <span class="keywd">if</span> buffer = <span class="stri">""</span> <span class="keywd">then</span>
      ch := <a class="var" href="../libraries/char.htm#EOF">EOF</a>;
    <span class="keywd">else</span>
      ch := buffer[1];
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <span class="type">func string</span>: getwd (<span class="keywd">inout</span> <a class="type" href="../libraries/null_file.htm#null_file">null_file</a>: aFile) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: buffer <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      buffer := <a class="func" href="../libraries/file.htm#gets(inout_file,in_integer)">gets</a>(aFile, 1);
    <span class="keywd">until</span> buffer &lt;> <span class="stri">" "</span> <span class="keywd">and</span> buffer &lt;> <span class="stri">"\t"</span>;
    <span class="keywd">while</span> buffer &lt;> <span class="stri">" "</span> <span class="keywd">and</span> buffer &lt;> <span class="stri">"\t"</span> <span class="keywd">and</span>
        buffer &lt;> <span class="stri">"\n"</span> <span class="keywd">and</span> buffer &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      stri &amp;:= buffer;
      buffer := <a class="func" href="../libraries/file.htm#gets(inout_file,in_integer)">gets</a>(aFile, 1);
    <span class="keywd">end while</span>;
    <span class="keywd">if</span> buffer = <span class="stri">""</span> <span class="keywd">then</span>
      aFile.bufferChar := <a class="var" href="../libraries/char.htm#EOF">EOF</a>;
    <span class="keywd">else</span>
      aFile.bufferChar := buffer[1];
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <span class="type">func string</span>: getln (<span class="keywd">inout</span> <a class="type" href="../libraries/null_file.htm#null_file">null_file</a>: aFile) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: buffer <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    buffer := <a class="func" href="../libraries/file.htm#gets(inout_file,in_integer)">gets</a>(aFile, 1);
    <span class="keywd">while</span> buffer &lt;> <span class="stri">"\n"</span> <span class="keywd">and</span> buffer &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      stri &amp;:= buffer;
      buffer := <a class="func" href="../libraries/file.htm#gets(inout_file,in_integer)">gets</a>(aFile, 1);
    <span class="keywd">end while</span>;
    <span class="keywd">if</span> buffer = <span class="stri">""</span> <span class="keywd">then</span>
      aFile.bufferChar := <a class="var" href="../libraries/char.htm#EOF">EOF</a>;
    <span class="keywd">else</span>
      aFile.bufferChar := buffer[1];
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  Note that <tt><a class="func" href="../libraries/null_file.htm#getwd(inout_null_file)">getwd</a></tt> skips leading spaces and tabs while <tt><a class="func" href="../libraries/null_file.htm#getc(inout_null_file)">getc</a></tt> and
  <tt><a class="func" href="../libraries/null_file.htm#getln(inout_null_file)">getln</a></tt> do not.
  If <tt><a class="func" href="../libraries/null_file.htm#getc(inout_null_file)">getc</a></tt>, <tt><a class="func" href="../libraries/null_file.htm#getwd(inout_null_file)">getwd</a></tt> or <tt><a class="func" href="../libraries/null_file.htm#getln(inout_null_file)">getln</a></tt> is not defined for a new user defined
  file type the declarations from the <tt><a class="type" href="../libraries/null_file.htm#null_file">null_file</a></tt> are used instead.
  These declarations are based on the method <tt><a class="func" href="../libraries/file.htm#gets(inout_file,in_integer)">gets</a></tt> which must be
  defined for every new user defined file-type.
</p><p>
  Note that there is an assignment to the variable <tt>'bufferChar'</tt>.
  This variable is an element of <tt><a class="type" href="../libraries/null_file.htm#null_file">null_file</a></tt> and therefore also
  an element of all derived file types. This allows an
  <tt>'eoln'</tt> function to test if the last <tt><a class="func" href="../libraries/file.htm#getwd(inout_file)">getwd</a></tt> or <tt><a class="func" href="../libraries/file.htm#getln(inout_file)">getln</a></tt> reach the end
  of a line. Here is a definition of the <tt>'eoln'</tt> function:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func boolean</span>: eoln (<span class="keywd">in</span> <a class="type" href="../libraries/null_file.htm#null_file">null_file</a>: inFile) <span class="keywd">is</span>
  <span class="keywd">return</span> inFile.bufferChar = '\n';
</pre><p>
  Besides assigning a value to <tt>'bufferChar'</tt> in <tt><a class="func" href="../libraries/file.htm#getwd(inout_file)">getwd</a></tt> and <tt><a class="func" href="../libraries/file.htm#getln(inout_file)">getln</a></tt>
  and using it in <tt>'eoln'</tt> the standard <tt><a class="type" href="types.htm#file">file</a></tt> functions do nothing
  with <tt>'bufferChar'</tt>. The functions of the <span class="stri">"<a class="lib" href="../libraries/scanfile.htm">scanfile.s7i</a>"</span> library
  use the <tt>'bufferChar'</tt> variable as current character in the scan
  process. As such all functions of the <span class="stri">"<a class="lib" href="../libraries/scanfile.htm">scanfile.s7i</a>"</span> library
  assume that the first character to be processed is always in
  <tt>'bufferChar'</tt>. Since the standard <tt><a class="type" href="types.htm#file">file</a></tt> functions do not have
  this behavior, care has to be taken if mixing scanner and
  file functions.
</p><p>
  The type <tt><a class="type" href="../libraries/null_file.htm#null_file">null_file</a></tt> provides default functions to write end-of-line:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: writeln (<span class="keywd">inout</span> <a class="type" href="../libraries/null_file.htm#null_file">null_file</a>: outFile) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    write(outFile, <span class="stri">"\n"</span>);
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: writeln (<span class="keywd">inout</span> <a class="type" href="../libraries/null_file.htm#null_file">null_file</a>: outFile, <span class="keywd">in</span> <span class="type">string</span>: stri) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    write(outFile, stri);
    writeln(outFile);
  <span class="keywd">end func</span>;
</pre><p>
  The next declarations allow various I/O operations for strings:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: read (<span class="keywd">inout</span> <a class="type" href="types.htm#file">file</a>: aFile, <span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    stri := getwd(aFile);
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: readln (<span class="keywd">inout</span> <a class="type" href="types.htm#file">file</a>: aFile, <span class="keywd">inout</span> <span class="type">string</span>: stri) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    stri := getln(aFile);
  <span class="keywd">end func</span>;
</pre><p></p>

<a name="Input_and_output_with_conversion"><h3>8.3 Input and output with conversion</h3></a>
<p>
    Normally we need a combination of an I/O operation with
  a conversion operation. There are several functions which are
  based on the <tt><span class="func">str</span></tt> and <tt><span class="op">parse</span></tt> conversions and on the basic
  I/O-functions. The declaration of this functions is done by
  the templates <tt><a class="func" href="../libraries/enable_io.htm#enable_io(in_type)">enable_io</a></tt>, <tt><a class="func" href="../libraries/enable_input.htm#enable_input(in_type)">enable_input</a></tt> and <tt><a class="func" href="../libraries/enable_io.htm#enable_output(in_type)">enable_output</a></tt>.
  The templates <tt><a class="func" href="../libraries/enable_io.htm#enable_io(in_type)">enable_io</a></tt> and <tt><a class="func" href="../libraries/enable_io.htm#enable_output(in_type)">enable_output</a></tt> define the following
  <tt><a class="func" href="../libraries/enable_io.htm#write(inout_file,in_aType)">write</a></tt> function:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: write (<span class="keywd">in</span> <a class="type" href="types.htm#file">file</a>: aFile, <span class="keywd">in</span> <span class="type">aType</span>: aValue) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    write(aFile, str(aValue));
  <span class="keywd">end func</span>;
</pre><p>
  The templates <tt><a class="func" href="../libraries/enable_io.htm#enable_io(in_type)">enable_io</a></tt> and <tt><a class="func" href="../libraries/enable_input.htm#enable_input(in_type)">enable_input</a></tt> define the following
  <tt><a class="func" href="../libraries/enable_input.htm#read(inout_file,inout_aType)">read</a></tt> and <tt><a class="func" href="../libraries/enable_input.htm#readln(inout_file,inout_aType)">readln</a></tt> functions:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: read (<span class="keywd">inout</span> <a class="type" href="types.htm#file">file</a>: aFile, <span class="keywd">inout</span> <span class="type">aType</span>: aValue) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    aValue := <span class="type">aType</span> <span class="op">parse</span> <a class="func" href="../libraries/file.htm#getwd(inout_file)">getwd</a>(aFile);
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: readln (<span class="keywd">inout</span> <a class="type" href="types.htm#file">file</a>: aFile, <span class="keywd">inout</span> <span class="type">aType</span>: aValue) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    aValue := <span class="type">aType</span> <span class="op">parse</span> trimValue(aType, <a class="func" href="../libraries/file.htm#getln(inout_file)">getln</a>(aFile));
  <span class="keywd">end func</span>;
</pre><p>
  The function <tt><span class="func">trimValue</span></tt> is used to trim the <tt><a class="type" href="types.htm#string">string</a></tt> retrieved by
  <tt><a class="func" href="../libraries/file.htm#getln(inout_file)">getln</a></tt>. This adjusts the <tt><a class="type" href="types.htm#string">string</a></tt> before the <tt><span class="op">parse</span></tt> operator is
  applied. There are 3 cases:
</p><ul>
    <li>Trimming of a <tt><a class="type" href="types.htm#string">string</a></tt> with <tt><a class="func" href="../libraries/string.htm#trimValue(attr_string,in_string)">trimValue</a>(<a class="type" href="types.htm#string">string</a>, aString)</tt>:
      This leaves the string unchanged.</li>
    <li>Trimming of a <tt><a class="type" href="types.htm#char">char</a></tt> with <tt><a class="func" href="../libraries/char.htm#trimValue(attr_char,in_string)">trimValue</a>(<a class="type" href="types.htm#char">char</a>, aString)</tt>:
      For <span class="stri">""</span> it returns <span class="stri">""</span>. In all other cases it returns a trimmed
      string of length 1.</li>
    <li>Trimming of all other types with <tt><a class="func" href="../libraries/string.htm#trimValue(in_type,in_string)">trimValue</a>(<span class="type">aType</span>, aString)</tt>:
      This removes leading and trailing spaces.</li>
</ul><p>
  The next declaration defines <tt>'backSpace'</tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: backSpace (<span class="keywd">ref</span> <span class="type">external_file</span>: aFile) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    write(aFile, <span class="stri">"\b \b"</span>);
  <span class="keywd">end func</span>;
</pre><p></p>

<a name="Simple_read_and_write_statements"><h3>8.4 Simple read and write statements</h3></a>
<p>
    The simple input/output for the standard I/O-files are
  <tt>'read'</tt> and <tt>'write'</tt> which are defined with <tt><a class="func" href="../libraries/enable_io.htm#enable_io(in_type)">enable_io</a></tt>. Simple
  I/O may look like:
</p><pre class="indent">
write(<span class="stri">"Amount? "</span>);
read(amount);
</pre><p>
  <tt>'read'</tt> and <tt>'write'</tt> use the files <tt><a class="var" href="../libraries/stdio.htm#IN">IN</a></tt> and <tt><a class="var" href="../libraries/stdio.htm#OUT">OUT</a></tt>, which are described
  in the next chapter.  Here is the definition of the <tt>'read'</tt> and
  <tt>'write'</tt> procedures done with <tt><a class="func" href="../libraries/enable_io.htm#enable_io(in_type)">enable_io</a></tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: read (<span class="keywd">inout</span> <span class="type">aType</span>: aValue) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    read(<a class="var" href="../libraries/stdio.htm#IN">IN</a>, aValue);
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: readln (<span class="keywd">inout</span> <span class="type">aType</span>: aValue) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    readln(<a class="var" href="../libraries/stdio.htm#IN">IN</a>, aValue);
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: write (<span class="keywd">in</span> <span class="type">aType</span>: aValue) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    write(<a class="var" href="../libraries/stdio.htm#OUT">OUT</a>, aValue);
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: writeln (<span class="keywd">in</span> <span class="type">aType</span>: aValue) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    writeln(<a class="var" href="../libraries/stdio.htm#OUT">OUT</a>, aValue);
  <span class="keywd">end func</span>;
</pre><p>
  Additional procedures defined outside of <tt><a class="func" href="../libraries/enable_io.htm#enable_io(in_type)">enable_io</a></tt> are:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: readln <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    stri := getln(<a class="var" href="../libraries/stdio.htm#IN">IN</a>);
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: writeln <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    writeln(<a class="var" href="../libraries/stdio.htm#OUT">OUT</a>);
  <span class="keywd">end func</span>;
</pre><p>
  As an example, when you call
</p><pre class="indent">
<a class="func" href="../libraries/enable_io.htm#readln(inout_aType)">readln</a>(number);
</pre><p>
  the <tt>readln(number)</tt> function of the type <tt><a class="type" href="types.htm#integer">integer</a></tt> calls
</p><pre class="indent">
<a class="func" href="../libraries/enable_io.htm#readln(inout_file,inout_aType)">readln</a>(<a class="var" href="../libraries/stdio.htm#IN">IN</a>, number);
</pre><p>
  which executes
</p><pre class="indent">
number := <a class="type" href="types.htm#integer">integer</a> <a class="op" href="../libraries/integer.htm#(attr_integer)parse(in_string)">parse</a> <a class="func" href="../libraries/string.htm#trimValue(in_type,in_string)">trimValue</a>(<a class="type" href="types.htm#integer">integer</a>, <a class="func" href="../libraries/file.htm#getln(inout_file)">getln</a>(<a class="var" href="../libraries/stdio.htm#IN">IN</a>));
</pre><p>
  The file <tt><a class="var" href="../libraries/stdio.htm#IN">IN</a></tt> may have its own implementation of <tt><a class="func" href="../libraries/file.htm#getln(inout_file)">getln</a></tt> (e.g. as
  <tt><a class="func" href="../libraries/external_file.htm#getln(inout_external_file)">getln</a></tt> of <tt><a class="type" href="../libraries/external_file.htm#external_file">external_file</a></tt>). The default implementation of <tt><a class="func" href="../libraries/null_file.htm#getln(inout_null_file)">getln</a></tt>
  (in <tt><a class="type" href="../libraries/external_file.htm#null_file">null_file</a></tt>) calls <tt><a class="func" href="../libraries/file.htm#gets(inout_file,in_integer)">gets</a>(<a class="var" href="../libraries/stdio.htm#IN">IN</a>, 1)</tt> in a loop. For the type
  <tt><a class="type" href="types.htm#integer">integer</a></tt> the function <tt><a class="func" href="../libraries/string.htm#trimValue(in_type,in_string)">trimValue</a></tt> removes leading and trailing
  spaces. Finally the <tt><a class="op" href="../libraries/integer.htm#(attr_integer)parse(in_string)">parse</a></tt> operator converts the string read into
  an <tt><a class="type" href="types.htm#integer">integer</a></tt> which is assigned to <tt>'number'</tt>.
</p>

<a name="Standard_input_and_output_files"><h3>8.5 Standard input and output files</h3></a>
<p>
    The standard I/O files are <tt><a class="var" href="../libraries/stdio.htm#IN">IN</a></tt> for input and <tt><a class="var" href="../libraries/stdio.htm#OUT">OUT</a></tt> for output.
  <tt><a class="var" href="../libraries/stdio.htm#IN">IN</a></tt> and <tt><a class="var" href="../libraries/stdio.htm#OUT">OUT</a></tt> are <tt><a class="type" href="types.htm#file">file</a></tt> variables, which are defined as follows:
</p><pre class="indent">
<span class="keywd">var</span> <a class="type" href="types.htm#file">file</a>: <a class="var" href="../libraries/stdio.htm#IN">IN</a> <span class="keywd">is</span> <a class="var" href="../libraries/stdio.htm#STD_IN">STD_IN</a>;
<span class="keywd">var</span> <a class="type" href="types.htm#file">file</a>: <a class="var" href="../libraries/stdio.htm#OUT">OUT</a> <span class="keywd">is</span> <a class="var" href="../libraries/stdio.htm#STD_OUT">STD_OUT</a>;
</pre><p>
  The files <tt><a class="var" href="../libraries/stdio.htm#STD_IN">STD_IN</a></tt> and <tt><a class="var" href="../libraries/stdio.htm#STD_OUT">STD_OUT</a></tt> are the standard input and
  output files of the operating system (Usually the keyboard and
  the screen). Because <tt><a class="var" href="../libraries/stdio.htm#IN">IN</a></tt> and <tt><a class="var" href="../libraries/stdio.htm#OUT">OUT</a></tt> are variables redirection of
  standard input or standard output can be done easily by
  assigning a new value to them:
</p><pre class="indent">
<a class="var" href="../libraries/stdio.htm#IN">IN</a> := OTHER_FILE;
</pre><p>
  After that all <tt>'read'</tt> statements refer to <tt>OTHER_FILE</tt>.
  Most operating systems have also a stderr file which
  can be accessed via the name <tt><a class="var" href="../libraries/stdio.htm#STD_ERR">STD_ERR</a></tt>. If you want to
  write error messages to the screen even if stdout
  is redirected elsewhere you can write:
</p><pre class="indent">
writeln(<a class="var" href="../libraries/stdio.htm#STD_ERR">STD_ERR</a>, <span class="stri">"ERROR MESSAGE"</span>);
</pre><p>
  To redirect the standard output to <tt><a class="var" href="../libraries/stdio.htm#STD_ERR">STD_ERR</a></tt> you can write:
</p><pre class="indent">
<a class="var" href="../libraries/stdio.htm#OUT">OUT</a> := <a class="var" href="../libraries/stdio.htm#STD_ERR">STD_ERR</a>;
</pre><p>
  There is also a file <tt><a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a></tt> defined. Anything written to
  it is ignored. Reading from it does deliver empty strings.
  This file can be used to initialize file variables as in:
</p><pre class="indent">
<span class="keywd">var</span> <a class="type" href="types.htm#file">file</a>: MY_FILE <span class="keywd">is</span> <a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a>;
</pre><p>
  It is also used to represent an illegal file value, if for
  example an attempt to <tt><a class="func" href="../libraries/external_file.htm#open(in_string,in_string)">open</a></tt> a <tt><a class="type" href="types.htm#file">file</a></tt> fails.
</p>

<a name="Access_to_operating_system_files"><h3>8.6 Access to operating system files</h3></a>
<p>
    The interface type <tt><a class="type" href="types.htm#file">file</a></tt> is also used to access
  operating system files. Usually a file variable is defined
</p><pre class="indent">
<span class="keywd">var</span> <a class="type" href="types.htm#file">file</a>: my_out <span class="keywd">is</span> <a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a>;
</pre><p>
  and the result of the <tt><a class="func" href="../libraries/external_file.htm#open(in_string,in_string)">open</a></tt> function is assigned to this file
  variable
</p><pre class="indent">
my_out := open(<span class="stri">"my_file"</span>, <span class="stri">"w"</span>);
</pre><p>
  The first parameter of <tt><a class="func" href="../libraries/external_file.htm#open(in_string,in_string)">open</a></tt> is the path of the file to
  be opened. The path must use the <a class="link" href="os.htm#Standard_path_representation">standard path representation</a>.
  This means that a slash (<tt>'/'</tt>) is used as path delimiter.
  A path with a backslash or a drive letter may raise the
  exception <tt><a class="exception" href="errors.htm#RANGE_ERROR">RANGE_ERROR</a></tt>. The second parameter of <tt><a class="func" href="../libraries/external_file.htm#open(in_string,in_string)">open</a></tt>
  specifies the mode:
</p><dl><dd><dl>
    <dt>Binary mode:</dt><dd><table border="0" cellspacing="0">
      <tr><td><span class="stri">"r"</span></td>   <td>...&nbsp;</td><td>Open file for reading.</td></tr>
      <tr><td><span class="stri">"w"</span></td>   <td>...&nbsp;</td><td>Truncate to zero length or create file for writing.</td></tr>
      <tr><td><span class="stri">"a"</span></td>   <td>...&nbsp;</td><td>Append; open or create file for writing at end-of-file.</td></tr>
      <tr><td><span class="stri">"r+"</span></td>  <td>...&nbsp;</td><td>Open file for update (reading and writing).</td></tr>
      <tr><td><span class="stri">"w+"</span></td>  <td>...&nbsp;</td><td>Truncate to zero length or create file for update.</td></tr>
      <tr><td><span class="stri">"a+"</span></td>  <td>...&nbsp;</td><td>Append; open or create file for update, writing at end-of-file.</td></tr></table>
    <dt>Text mode:</dt><dd><table border="0" cellspacing="0">
      <tr><td><span class="stri">"rt"</span></td>  <td>...&nbsp;</td><td>Open file for reading.</td></tr>
      <tr><td><span class="stri">"wt"</span></td>  <td>...&nbsp;</td><td>Truncate to zero length or create file for writing.</td></tr>
      <tr><td><span class="stri">"at"</span></td>  <td>...&nbsp;</td><td>Append; open or create file for writing at end-of-file.</td></tr>
      <tr><td><span class="stri">"rt+"</span></td> <td>...&nbsp;</td><td>Open file for update (reading and writing).</td></tr>
      <tr><td><span class="stri">"wt+"</span></td> <td>...&nbsp;</td><td>Truncate to zero length or create file for update.</td></tr>
      <tr><td><span class="stri">"at+"</span></td> <td>...&nbsp;</td><td>Append; open or create file for update, writing at end-of-file.</td></tr></table>
</dl></dd></dl><p>
  Note that Seed7 defines the modes <tt><span class="stri">"r"</span></tt>, <tt><span class="stri">"w"</span></tt>, <tt><span class="stri">"a"</span></tt>, <tt><span class="stri">"r+"</span></tt>, <tt><span class="stri">"w+"</span></tt>
  and <tt><span class="stri">"a+"</span></tt> as binary modes. If <tt><a class="func" href="../libraries/external_file.htm#open(in_string,in_string)">open</a></tt> is called, with a mode
  not listed in the table above, the exception <tt><a class="exception" href="errors.htm#RANGE_ERROR">RANGE_ERROR</a></tt>
  is raised. If there is not enough memory to convert <tt>'path'</tt>
  to the system path type the exception <tt><a class="exception" href="errors.htm#MEMORY_ERROR">MEMORY_ERROR</a></tt>
  is raised. If <tt><a class="func" href="../libraries/external_file.htm#open(in_string,in_string)">open</a></tt> fails for other reasons it returns
  <tt><a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a></tt>. E.g.: It is not allowed to <tt><a class="func" href="../libraries/external_file.htm#open(in_string,in_string)">open</a></tt> a directory.
  An attempt to <tt><a class="func" href="../libraries/external_file.htm#open(in_string,in_string)">open</a></tt> a directory returns <tt><a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a></tt>. It is
  recommended to check the file variable after opening a file:
</p><pre class="indent">
<span class="keywd">if</span> my_out &lt;> <a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a> <span class="keywd">then</span>
</pre><p>
  After that output to <tt>'my_out'</tt> is possible with
</p><pre class="indent">
writeln(my_out, <span class="stri">"hi there"</span>);
</pre><p>
  When processing of a file has finished it should be closed
</p><pre class="indent">
close(my_out);
</pre><p>
  Writing to a file after it has been closed results in the
  exception <tt><a class="exception" href="errors.htm#FILE_ERROR">FILE_ERROR</a></tt>. The following program writes
  <tt><span class="stri">"hi there"</span></tt> to the file <tt><span class="stri">"my_file"</span></tt>:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"seed7_05.s7i"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#file">file</a>: my_out <span class="keywd">is</span> <a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a>;
  <span class="keywd">begin</span>
    my_out := <a class="func" href="../libraries/external_file.htm#open(in_string,in_string)">open</a>(<span class="stri">"my_file"</span>, <span class="stri">"w"</span>);
    <span class="keywd">if</span> my_out &lt;> <a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a> <span class="keywd">then</span>
      writeln(my_out, <span class="stri">"hi there"</span>);
      close(my_out);
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  Note that <tt><a class="func" href="../libraries/external_file.htm#open(in_string,in_string)">open</a></tt> opens BYTE files. Writing
  a character with an ordinal >= 256 such as
</p><pre class="indent">
writeln(my_out, <span class="stri">"illegal char: \256;"</span>);
</pre><p>
  results in the exception <tt><a class="exception" href="errors.htm#RANGE_ERROR">RANGE_ERROR</a></tt>. To write Unicode
  characters other file types must be used. The libraries
  <span class="stri">"<a class="lib" href="../libraries/utf8.htm">utf8.s7i</a>"</span> and <span class="stri">"<a class="lib" href="../libraries/utf16.htm">utf16.s7i</a>"</span> provide access to UTF-8 and
  UTF-16 files. The function <tt><a class="func" href="../libraries/utf8.htm#openUtf8(in_string,in_string)">openUtf8</a></tt> can be used the same
  way as <tt><a class="func" href="../libraries/external_file.htm#open(in_string,in_string)">open</a></tt>:
</p><pre class="indent">
my_out := <a class="func" href="../libraries/utf8.htm#openUtf8(in_string,in_string)">openUtf8</a>(<span class="stri">"utf8_file"</span>, <span class="stri">"w"</span>);
</pre><p>
  An UTF-8 file accepts all Unicode characters. That way
</p><pre class="indent">
writeln(my_out, <span class="stri">"Unicode char: \256;"</span>);
</pre><p>
  works without problems. UTF-8 files are byte order independent.
  Therefore they do not need a byte order mark (BOM).
  In case a BOM is required it can be written by the user program:
</p><pre class="indent">
my_out := <a class="func" href="../libraries/utf8.htm#openUtf8(in_string,in_string)">openUtf8</a>(<span class="stri">"utf8_file"</span>, <span class="stri">"w"</span>);
write(<span class="stri">"\16#feff;"</span>);
</pre><p>
  The following example expects a mandatory BOM at the beginning of an UTF-8 file:
</p><pre class="indent">
my_out := <a class="func" href="../libraries/utf8.htm#openUtf8(in_string,in_string)">openUtf8</a>(<span class="stri">"utf8_file"</span>, <span class="stri">"r"</span>);
<span class="keywd">if</span> <a class="func" href="../libraries/utf8.htm#getc(in_utf8File)">getc</a>(my_file) &lt;> <span class="stri">'\16#feff;'</span> <span class="keywd">then</span>
  writeln(<span class="stri">"The BOM is missing"</span>");
<span class="keywd">else</span>
  ...
<span class="keywd">end if</span>;
</pre><p>
  Accepting an optional BOM at the beginning of an UTF-8 file is done with:
</p><pre class="indent">
my_out := <a class="func" href="../libraries/utf8.htm#openUtf8(in_string,in_string)">openUtf8</a>(<span class="stri">"utf8_file"</span>, <span class="stri">"r"</span>);
<span class="keywd">if</span> <a class="func" href="../libraries/utf8.htm#getc(in_utf8File)">getc</a>(my_file) &lt;> <span class="stri">'\16#feff;'</span> <span class="keywd">then</span>
  <span class="comment"># This is a file without BOM (the first character will be read later).</span>
  <a class="func" href="../libraries/utf8.htm#seek(in_utf8File,in_integer)">seek</a>(my_file, 1);
<span class="keywd">end if</span>;
...
</pre><p>
  UTF-16 comes in two flavors UTF-16LE and UTF-16BE. To support
  both flavors the <span class="stri">"<a class="lib" href="../libraries/utf16.htm">utf16.s7i</a>"</span> library defines several functions.
</p><p>
  The function <tt><a class="func" href="../libraries/utf16.htm#openUtf16(in_string,in_string)">openUtf16</a></tt> opens a Unicode file which uses the
  UTF-16LE or UTF-16BE encoding. The function <tt><a class="func" href="../libraries/utf16.htm#openUtf16(in_string,in_string)">openUtf16</a></tt> checks for
  a BOM and depending on that it opens an UTF-16LE or UTF-16BE file.
</p><p>
  The functions <tt><a class="func" href="../libraries/utf16.htm#openUtf16le(in_string,in_string)">openUtf16le</a></tt> and <tt><a class="func" href="../libraries/utf16.htm#openUtf16be(in_string,in_string)">openUtf16be</a></tt> open Unicode files
  with the UTF-16LE and UTF-16BE encoding respectively. If the
  file is opened with one of the modes <tt><span class="stri">"w"</span></tt>, <tt><span class="stri">"w+"</span></tt>, <tt><span class="stri">"wt"</span></tt> or <tt><span class="stri">"wt+"</span></tt> an
  appropriate BOM is created. If the file is opened with any other
  mode the application program is in charge to handle optional BOM
  markers. This way <tt><a class="func" href="../libraries/utf16.htm#openUtf16le(in_string,in_string)">openUtf16le</a></tt> and <tt><a class="func" href="../libraries/utf16.htm#openUtf16be(in_string,in_string)">openUtf16be</a></tt> can be used
  to open existing files without BOM.
</p><p>
  External BYTE files use the implementation type <tt><a class="type" href="../libraries/external_file.htm#external_file">external_file</a></tt>.
  The type <tt><a class="type" href="../libraries/external_file.htm#external_file">external_file</a></tt> is defined as:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">type</span>: external_file <span class="keywd">is sub</span> <a class="type" href="../libraries/null_file.htm#null_file">null_file</a> <span class="keywd">struct</span>
    <span class="keywd">var</span> <span class="type">clib_file</span>: ext_file <span class="keywd">is</span> CLIB_NULL_FILE;
    <span class="keywd">var</span> <span class="type">string</span>: name <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">end struct</span>;
</pre><p>
  This means that every data item of the type <tt><a class="type" href="../libraries/external_file.htm#external_file">external_file</a></tt>
  has the elements from <tt><a class="type" href="../libraries/null_file.htm#null_file">null_file</a></tt> and additionally the
  elements <tt>'ext_file'</tt> and <tt>'name'</tt>. The type <tt><span class="type">clib_file</span></tt>
  points directly to an operating system file. Objects
  of type <tt><span class="type">clib_file</span></tt> can only have operating system
  files as values while objects of type <tt><a class="type" href="types.htm#file">file</a></tt> can also have
  other files as values. To allow the implementation of the
  type <tt><a class="type" href="../libraries/external_file.htm#external_file">external_file</a></tt> several operations for the type
  <tt><span class="type">clib_file</span></tt> are defined. But outside <tt><a class="type" href="../libraries/external_file.htm#external_file">external_file</a></tt> the
  type <tt><span class="type">clib_file</span></tt> and its operations should not be used.
</p><p>
  There are three predefined external files <tt><a class="var" href="../libraries/stdio.htm#STD_IN">STD_IN</a></tt>, <tt><a class="var" href="../libraries/stdio.htm#STD_OUT">STD_OUT</a></tt>
  and <tt><a class="var" href="../libraries/stdio.htm#STD_ERR">STD_ERR</a></tt> which have the following declarations:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func external_file</span>: INIT_STD_FILE (<span class="keywd">ref</span> <span class="type">clib_file</span>: primitive_file,
    <span class="keywd">in</span> <span class="type">string</span>: file_name) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">external_file</span>: standardFile <span class="keywd">is</span> <span class="type">external_file</span>.value;
  <span class="keywd">begin</span>
    standardFile.ext_file := primitive_file;
    standardFile.name := file_name;
  <span class="keywd">end func</span>;

<span class="keywd">var</span> <span class="type">external_file</span>: STD_IN <span class="keywd">is</span>  INIT_STD_FILE(CLIB_INPUT,  <span class="stri">"STD_IN"</span>);
<span class="keywd">var</span> <span class="type">external_file</span>: STD_OUT <span class="keywd">is</span> INIT_STD_FILE(CLIB_OUTPUT, <span class="stri">"STD_OUT"</span>);
<span class="keywd">var</span> <span class="type">external_file</span>: STD_ERR <span class="keywd">is</span> INIT_STD_FILE(CLIB_ERROR,  <span class="stri">"STD_ERR"</span>);
</pre><p>
  It is possible to do I/O directly with them, but it is more wisely
  to use them only to initialize user defined file variables as in:
</p><pre class="indent">
<span class="keywd">var</span> <a class="type" href="types.htm#file">file</a>: err <span class="keywd">is</span> <a class="var" href="../libraries/stdio.htm#STD_ERR">STD_ERR</a>;
</pre><p>
  In the rest of the program references to such a variable can be
  used:
</p><pre class="indent">
writeln(err, <span class="stri">"Some error occurred"</span>);
</pre><p>
  In this case redirection of the file <tt>'err'</tt> can be done very easy.
  Another way to access external files is to use the function
  <tt><a class="func" href="../libraries/external_file.htm#open(in_string,in_string)">open</a></tt>. The modes used by <tt><a class="func" href="../libraries/external_file.htm#open(in_string,in_string)">open</a></tt> differ from those used
  by the <tt>'fopen'</tt> function in the C library.
  The following table compares the file modes of Seed7 and C:
</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
    <tr><td>Seed7 <tt>'open'</tt> mode</td>   <td>C <tt>'fopen'</tt> mode</td></tr>
    <tr><td><span class="stri">"r"</span></td>                 <td><span class="stri">"rb"</span></td></tr>
    <tr><td><span class="stri">"w"</span></td>                 <td><span class="stri">"wb"</span></td></tr>
    <tr><td><span class="stri">"a"</span></td>                 <td><span class="stri">"ab"</span></td></tr>
    <tr><td><span class="stri">"r+"</span></td>                <td><span class="stri">"rb+"</span></td></tr>
    <tr><td><span class="stri">"w+"</span></td>                <td><span class="stri">"wb+"</span></td></tr>
    <tr><td><span class="stri">"a+"</span></td>                <td><span class="stri">"ab+"</span></td></tr>
    <tr><td><span class="stri">"rt"</span></td>                <td><span class="stri">"r"</span></td></tr>
    <tr><td><span class="stri">"wt"</span></td>                <td><span class="stri">"w"</span></td></tr>
    <tr><td><span class="stri">"at"</span></td>                <td><span class="stri">"a"</span></td></tr>
    <tr><td><span class="stri">"rt+"</span></td>               <td><span class="stri">"r+"</span></td></tr>
    <tr><td><span class="stri">"wt+"</span></td>               <td><span class="stri">"w+"</span></td></tr>
    <tr><td><span class="stri">"at+"</span></td>               <td><span class="stri">"a+"</span></td></tr>
</table></dd></dl><p>
  The difference between binary and text mode is as follows:
</p><ul>
    <li>Binary mode provides an implementation independent
      behavior on all operating systems. In binary mode no
      conversion to and from the line end character (<tt><span class="stri">'\n'</span></tt>)
      is done. This has the advantage that an <tt><a class="type" href="../libraries/external_file.htm#external_file">external_file</a></tt>
      written in binary mode is identical on all operating
      systems. Reading files with different line endings
      (<tt><span class="stri">"\n"</span></tt> and <tt><span class="stri">"\r\n"</span></tt>) is supported by every <tt><a class="type" href="../libraries/external_file.htm#external_file">external_file</a></tt>:
      The functions <tt><a class="func" href="../libraries/external_file.htm#getwd(inout_external_file)">getwd</a></tt>, <tt><a class="func" href="../libraries/external_file.htm#getln(inout_external_file)">getln</a></tt>, <tt><span class="func">read</span></tt> and <tt><span class="func">readln</span></tt>, of
      <tt><a class="type" href="../libraries/external_file.htm#external_file">external_file</a></tt> skip a carriage return (<tt><span class="stri">'\r'</span></tt>) if it
      is just before a linefeed (<tt><span class="stri">'\n'</span></tt>). The rest of the
      <tt><a class="type" href="../libraries/external_file.htm#external_file">external_file</a></tt> functions like <tt><a class="func" href="../libraries/external_file.htm#getc(in_external_file)">getc</a></tt> and <tt><a class="func" href="../libraries/external_file.htm#gets(in_external_file,in_integer)">gets</a></tt> deliver
      line endings unchanged.
</li>
    <li>The behavior of an <tt><a class="type" href="../libraries/external_file.htm#external_file">external_file</a></tt> in text mode is
      implementation dependent. Under Unix/Linux/Bsd text and
      binary modes are identical. Other operating systems
      prefer to do some line end conversions in text mode:
      When reading a file all occurrences of <tt><span class="stri">"\r\n"</span></tt> are
      converted to <tt><span class="stri">'\n'</span></tt>. When writing to a file all
      occurrences of <tt><span class="stri">'\n'</span></tt> are converted to <tt><span class="stri">"\r\n"</span></tt>. Note that
      text mode cannot be used to automatically create files
      with <tt><span class="stri">"\r\n"</span></tt> line endings under Unix/Linux/Bsd.</li>
</ul><p>
  The library <span class="stri">"<a class="lib" href="../libraries/utf8.htm">utf8.s7i</a>"</span> defines the
  implementation type <tt><a class="type" href="../libraries/utf8.htm#utf8File">utf8File</a></tt> as
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">type</span>: utf8File <span class="keywd">is sub</span> <span class="type">external_file</span> <span class="keywd">struct</span>
  <span class="keywd">end struct</span>;
</pre><p></p>

<a name="Keyboard_file"><h3>8.7 Keyboard file</h3></a>
<p>
    As stated earlier <tt><a class="var" href="../libraries/stdio.htm#STD_IN">STD_IN</a></tt> provides an interface to the keyboard
  which is line buffered and echoed on <tt><a class="var" href="../libraries/stdio.htm#STD_OUT">STD_OUT</a></tt>. This means that
  you can see everything you typed. Additionally you can correct
  your input with <span class="box">Backspace</span> until you press <span class="box">Return</span>. But sometimes
  an unbuffered and unechoed input is needed. This is provided in
  the library <span class="stri">"<a class="lib" href="../libraries/keybd.htm">keybd.s7i</a>"</span>, which defines the type <tt><a class="type" href="../libraries/keybd.htm#keyboard_file">keyboard_file</a></tt>
  and the file <tt><a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a></tt>. Characters typed at the keyboard are
  queued (first in first out) and can be read directly from
  <tt><a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a></tt> without any possibility to correct. Additionally
  <tt><a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a></tt> does not echo the characters. Reading from <tt><a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a></tt>
  delivers normal Unicode characters or special codes (which may be
  or may not be Unicode characters) for function and cursor keys.
  Unicode characters and special codes both are <tt><a class="type" href="types.htm#char">char</a></tt> values. The
  library <span class="stri">"<a class="lib" href="../libraries/keybd.htm">keybd.s7i</a>"</span> defines <tt><a class="type" href="types.htm#char">char</a></tt> constants for various keys:
</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
    <tr><td>Key character constant</td>     <td>Description</td></tr>
    <tr><td><tt><a name="KEY_CTL_A_TO_Z">KEY_CTL_A</a></tt> to <tt>KEY_CTL_Z</tt></td>     <td>The control keys ctrl-a to ctrl-z</td></tr>
    <tr><td><tt>KEY_ALT_A</tt> to <tt>KEY_ALT_Z</tt></td>     <td>The alternate keys alt-a to alt-z</td></tr>
    <tr><td><tt>KEY_CTL_0</tt> to <tt>KEY_CTL_9</tt></td>     <td>The control keys ctrl-0 to ctrl-9</td></tr>
    <tr><td><tt>KEY_ALT_0</tt> to <tt>KEY_ALT_9</tt></td>     <td>The alternate keys alt-0 to alt-9</td></tr>
    <tr><td><tt>KEY_F1</tt> to <tt>KEY_F10</tt></td>          <td>Function keys F1 to F10</td></tr>
    <tr><td><tt>KEY_SFT_F1</tt> to <tt>KEY_SFT_F10</tt></td>  <td>Shifted function keys F1 to F10</td></tr>
    <tr><td><tt>KEY_CTL_F1</tt> to <tt>KEY_CTL_F10</tt></td>  <td>Control function keys F1 to F10</td></tr>
    <tr><td><tt>KEY_ALT_F1</tt> to <tt>KEY_ALT_F10</tt></td>  <td>Alternate function keys F1 to F10</td></tr>
    <tr><td><tt><a name="KEY_LEFT">KEY_LEFT</a></tt></td>                   <td>Cursor left</td></tr>
    <tr><td><tt><a name="KEY_RIGHT">KEY_RIGHT</a></tt></td>                  <td>Cursor right</td></tr>
    <tr><td><tt><a name="KEY_UP">KEY_UP</a></tt></td>                     <td>Cursor up</td></tr>
    <tr><td><tt><a name="KEY_DOWN">KEY_DOWN</a></tt></td>                   <td>Cursor down</td></tr>
    <tr><td><tt><a name="KEY_HOME">KEY_HOME</a></tt></td>                   <td>Home key</td></tr>
    <tr><td><tt><a name="KEY_END">KEY_END</a></tt></td>                    <td>End key</td></tr>
    <tr><td><tt><a name="KEY_PGUP">KEY_PGUP</a></tt></td>                   <td>Page up</td></tr>
    <tr><td><tt><a name="KEY_PGDN">KEY_PGDN</a></tt></td>                   <td>Page down</td></tr>
    <tr><td><tt><a name="KEY_INS">KEY_INS</a></tt></td>                    <td>Insert key</td></tr>
    <tr><td><tt><a name="KEY_DEL">KEY_DEL</a></tt></td>                    <td>Delete key</td></tr>
    <tr><td><tt>KEY_PAD_CENTER</tt></td>             <td>Numeric keypad center key</td></tr>
    <tr><td><tt>KEY_SFT_LEFT</tt></td>               <td>Shifted cursor left</td></tr>
    <tr><td><tt>KEY_SFT_RIGHT</tt></td>              <td>Shifted cursor right</td></tr>
    <tr><td><tt>KEY_SFT_UP</tt></td>                 <td>Shifted cursor up</td></tr>
    <tr><td><tt>KEY_SFT_DOWN</tt></td>               <td>Shifted cursor down</td></tr>
    <tr><td><tt>KEY_SFT_HOME</tt></td>               <td>Shifted home key</td></tr>
    <tr><td><tt>KEY_SFT_END</tt></td>                <td>Shifted end key</td></tr>
    <tr><td><tt>KEY_SFT_PGUP</tt></td>               <td>Shifted page up</td></tr>
    <tr><td><tt>KEY_SFT_PGDN</tt></td>               <td>Shifted page down</td></tr>
    <tr><td><tt>KEY_SFT_INS</tt></td>                <td>Shifted insert key</td></tr>
    <tr><td><tt>KEY_SFT_DEL</tt></td>                <td>Shifted delete key</td></tr>
    <tr><td><tt>KEY_SFT_PAD_CENTER</tt></td>         <td>Shifted numeric keypad center key</td></tr>
    <tr><td><tt>KEY_CTL_LEFT</tt></td>               <td>Control cursor left</td></tr>
    <tr><td><tt>KEY_CTL_RIGHT</tt></td>              <td>Control cursor right</td></tr>
    <tr><td><tt>KEY_CTL_UP</tt></td>                 <td>Control cursor up</td></tr>
    <tr><td><tt>KEY_CTL_DOWN</tt></td>               <td>Control cursor down</td></tr>
    <tr><td><tt>KEY_CTL_HOME</tt></td>               <td>Control home key</td></tr>
    <tr><td><tt>KEY_CTL_END</tt></td>                <td>Control end key</td></tr>
    <tr><td><tt>KEY_CTL_PGUP</tt></td>               <td>Control page up</td></tr>
    <tr><td><tt>KEY_CTL_PGDN</tt></td>               <td>Control page down</td></tr>
    <tr><td><tt>KEY_CTL_INS</tt></td>                <td>Control insert key</td></tr>
    <tr><td><tt>KEY_CTL_DEL</tt></td>                <td>Control delete key</td></tr>
    <tr><td><tt>KEY_CTL_PAD_CENTER</tt></td>         <td>Control numeric keypad center key</td></tr>
    <tr><td><tt>KEY_ALT_LEFT</tt></td>               <td>Alt cursor left</td></tr>
    <tr><td><tt>KEY_ALT_RIGHT</tt></td>              <td>Alt cursor right</td></tr>
    <tr><td><tt>KEY_ALT_UP</tt></td>                 <td>Alt cursor up</td></tr>
    <tr><td><tt>KEY_ALT_DOWN</tt></td>               <td>Alt cursor down</td></tr>
    <tr><td><tt>KEY_ALT_HOME</tt></td>               <td>Alt home key</td></tr>
    <tr><td><tt>KEY_ALT_END</tt></td>                <td>Alt end key</td></tr>
    <tr><td><tt>KEY_ALT_PGUP</tt></td>               <td>Alt page up</td></tr>
    <tr><td><tt>KEY_ALT_PGDN</tt></td>               <td>Alt page down</td></tr>
    <tr><td><tt>KEY_ALT_INS</tt></td>                <td>Alt insert key</td></tr>
    <tr><td><tt>KEY_ALT_DEL</tt></td>                <td>Alt delete key</td></tr>
    <tr><td><tt>KEY_ALT_PAD_CENTER</tt></td>         <td>Alt numeric keypad center key</td></tr>
    <tr><td><tt><a name="KEY_NL">KEY_NL</a></tt></td>                     <td>Newline/enter/return key (equal to KEY_CTL_J)</td></tr>
    <tr><td><tt><a name="KEY_BS">KEY_BS</a></tt></td>                     <td>Backspace (equal to KEY_CTL_H)</td></tr>
    <tr><td><tt><a name="KEY_TAB">KEY_TAB</a></tt></td>                    <td>Horizontal tab (equal to KEY_CTL_H)</td></tr>
    <tr><td><tt><a name="KEY_CR">KEY_CR</a></tt></td>                     <td>Carriage return (equal to KEY_CTL_M)</td></tr>
    <tr><td><tt><a name="KEY_ESC">KEY_ESC</a></tt></td>                    <td>Escape key</td></tr>
    <tr><td><tt>KEY_MENU</tt></td>                   <td>Menu key</td></tr>
    <tr><td><tt>KEY_PRINT</tt></td>                  <td>Print key</td></tr>
    <tr><td><tt>KEY_PAUSE</tt></td>                  <td>Pause key</td></tr>
    <tr><td><tt>KEY_SFT_NL</tt></td>                 <td>Shift newline/enter/return key</td></tr>
    <tr><td><tt>KEY_SFT_BS</tt></td>                 <td>Shift backspace</td></tr>
    <tr><td><tt>KEY_SFT_TAB</tt></td>                <td>Shift tab (same as <tt>KEY_BACKTAB</tt>)</td></tr>
    <tr><td><tt><a name="KEY_BACKTAB">KEY_BACKTAB</a></tt></td>                <td>Shift tab (same as <tt>KEY_SFT_TAB</tt>)</td></tr>
    <tr><td><tt>KEY_SFT_ESC</tt></td>                <td>Shift escape</td></tr>
    <tr><td><tt>KEY_SFT_MENU</tt></td>               <td>Shift menu</td></tr>
    <tr><td><tt>KEY_SFT_PRINT</tt></td>              <td>Shift print</td></tr>
    <tr><td><tt>KEY_SFT_PAUSE</tt></td>              <td>Shift pause</td></tr>
    <tr><td><tt>KEY_CTL_NL</tt></td>                 <td>Control newline/enter/return key</td></tr>
    <tr><td><tt>KEY_CTL_BS</tt></td>                 <td>Control backspace</td></tr>
    <tr><td><tt>KEY_CTL_TAB</tt></td>                <td>Control tab</td></tr>
    <tr><td><tt>KEY_CTL_ESC</tt></td>                <td>Control escape</td></tr>
    <tr><td><tt>KEY_CTL_MENU</tt></td>               <td>Control menu</td></tr>
    <tr><td><tt>KEY_CTL_PRINT</tt></td>              <td>Control print</td></tr>
    <tr><td><tt>KEY_CTL_PAUSE</tt></td>              <td>Control pause</td></tr>
    <tr><td><tt>KEY_ALT_NL</tt></td>                 <td>Alt newline/enter/return key</td></tr>
    <tr><td><tt>KEY_ALT_BS</tt></td>                 <td>Alt backspace</td></tr>
    <tr><td><tt>KEY_ALT_TAB</tt></td>                <td>Alt tab</td></tr>
    <tr><td><tt>KEY_ALT_ESC</tt></td>                <td>Alt escape</td></tr>
    <tr><td><tt>KEY_ALT_MENU</tt></td>               <td>Alt menu</td></tr>
    <tr><td><tt>KEY_ALT_PRINT</tt></td>              <td>Alt print</td></tr>
    <tr><td><tt>KEY_ALT_PAUSE</tt></td>              <td>Alt pause</td></tr>
    <tr><td><tt>KEY_SCRLUP</tt></td>                 <td>Scroll up key</td></tr>
    <tr><td><tt>KEY_SCRLDN</tt></td>                 <td>Scroll down key</td></tr>
    <tr><td><tt>KEY_INSLN</tt></td>                  <td>Insert line key</td></tr>
    <tr><td><tt>KEY_DELLN</tt></td>                  <td>Delete line key</td></tr>
    <tr><td><tt>KEY_ERASE</tt></td>                  <td>Erase key</td></tr>
    <tr><td><tt><a name="KEY_NULCHAR">KEY_NULCHAR</a></tt></td>                <td>Nul character key</td></tr>
    <tr><td><tt>KEY_NULLCMD</tt></td>                <td>Null command of window manager</td></tr>
    <tr><td><tt>KEY_REDRAW</tt></td>                 <td>Redraw command of window manager</td></tr>
    <tr><td><tt><a name="KEY_MOUSE1">KEY_MOUSE1</a></tt></td>                 <td>Mouse button 1 (counted from left)</td></tr>
    <tr><td><tt><a name="KEY_MOUSE2">KEY_MOUSE2</a></tt></td>                 <td>Mouse button 2 (counted from left)</td></tr>
    <tr><td><tt><a name="KEY_MOUSE3">KEY_MOUSE3</a></tt></td>                 <td>Mouse button 3 (counted from left)</td></tr>
    <tr><td><tt>KEY_MOUSE4</tt></td>                 <td>Mouse wheel scroll up</td></tr>
    <tr><td><tt>KEY_MOUSE5</tt></td>                 <td>Mouse wheel scroll down</td></tr>
    <tr><td><tt><a name="KEY_MOUSE_FWD">KEY_MOUSE_FWD</a></tt></td>              <td>Mouse forward button</td></tr>
    <tr><td><tt><a name="KEY_MOUSE_BACK">KEY_MOUSE_BACK</a></tt></td>             <td>Mouse back button</td></tr>
    <tr><td><tt>KEY_SFT_MOUSE1</tt></td>             <td>Shift mouse button 1 (counted from left)</td></tr>
    <tr><td><tt>KEY_SFT_MOUSE2</tt></td>             <td>Shift mouse button 2 (counted from left)</td></tr>
    <tr><td><tt>KEY_SFT_MOUSE3</tt></td>             <td>Shift mouse button 3 (counted from left)</td></tr>
    <tr><td><tt>KEY_SFT_MOUSE4</tt></td>             <td>Shift mouse wheel scroll up</td></tr>
    <tr><td><tt>KEY_SFT_MOUSE5</tt></td>             <td>Shift mouse wheel scroll down</td></tr>
    <tr><td><tt>KEY_SFT_MOUSE_FWD</tt></td>          <td>Shift mouse forward button</td></tr>
    <tr><td><tt>KEY_SFT_MOUSE_BACK</tt></td>         <td>Shift mouse back button</td></tr>
    <tr><td><tt>KEY_CTL_MOUSE1</tt></td>             <td>Control mouse button 1 (counted from left)</td></tr>
    <tr><td><tt>KEY_CTL_MOUSE2</tt></td>             <td>Control mouse button 2 (counted from left)</td></tr>
    <tr><td><tt>KEY_CTL_MOUSE3</tt></td>             <td>Control mouse button 3 (counted from left)</td></tr>
    <tr><td><tt>KEY_CTL_MOUSE4</tt></td>             <td>Control mouse wheel scroll up</td></tr>
    <tr><td><tt>KEY_CTL_MOUSE5</tt></td>             <td>Control mouse wheel scroll down</td></tr>
    <tr><td><tt>KEY_CTL_MOUSE_FWD</tt></td>          <td>Control mouse forward button</td></tr>
    <tr><td><tt>KEY_CTL_MOUSE_BACK</tt></td>         <td>Control mouse back button</td></tr>
    <tr><td><tt>KEY_ALT_MOUSE1</tt></td>             <td>Alt mouse button 1 (counted from left)</td></tr>
    <tr><td><tt>KEY_ALT_MOUSE2</tt></td>             <td>Alt mouse button 2 (counted from left)</td></tr>
    <tr><td><tt>KEY_ALT_MOUSE3</tt></td>             <td>Alt mouse button 3 (counted from left)</td></tr>
    <tr><td><tt>KEY_ALT_MOUSE4</tt></td>             <td>Alt mouse wheel scroll up</td></tr>
    <tr><td><tt>KEY_ALT_MOUSE5</tt></td>             <td>Alt mouse wheel scroll down</td></tr>
    <tr><td><tt>KEY_ALT_MOUSE_FWD</tt></td>          <td>Alt mouse forward button</td></tr>
    <tr><td><tt>KEY_ALT_MOUSE_BACK</tt></td>         <td>Alt mouse back button</td></tr>
    <tr><td><tt><a name="KEY_CLOSE">KEY_CLOSE</a></tt></td>                  <td>The close button of the window has been pressed</td></tr>
    <tr><td><tt><a name="KEY_RESIZE">KEY_RESIZE</a></tt></td>                 <td>The window has been resized</td></tr>
    <tr><td><tt>KEY_UNDEF</tt></td>                  <td>Undefined key</td></tr>
    <tr><td><tt><a name="KEY_NONE">KEY_NONE</a></tt></td>                   <td>No key pressed (returned by <tt><a class="func" href="../libraries/keybd.htm#getc(inout_file,NO_WAIT)">getc</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>, <a class="var" href="../libraries/keybd.htm#getc(inout_file,NO_WAIT)">NO_WAIT</a>)</tt>)</td></tr>
</table></dd></dl><p>
  The following example uses the <tt><a class="type" href="types.htm#char">char</a></tt> constant <tt><a class="var" href="#KEY_UP">KEY_UP</a></tt>:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"seed7_05.s7i"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/keybd.htm">keybd.s7i</a>"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    writeln(<span class="stri">"Please press cursor up"</span>);
    <span class="keywd">while</span> <a class="func" href="../libraries/keybd.htm#getc(in_console_keybd_file)">getc</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>) &lt;> <tt><a class="var" href="#KEY_UP">KEY_UP</a></tt> <span class="keywd">do</span>
      writeln(<span class="stri">"This was not cursor up"</span>);
    <span class="keywd">end while</span>;
    writeln(<span class="stri">"Cursor up was pressed"</span>);
  <span class="keywd">end func</span>;
</pre><p>
  Programs should use the <tt><a class="type" href="types.htm#char">char</a></tt> constants defined in <span class="stri">"<a class="lib" href="../libraries/keybd.htm">keybd.s7i</a>"</span>
  to deal with function and cursor keys, since the special key
  codes may change in future versions of Seed7.
</p><p>
  Note that <tt><a class="func" href="../libraries/keybd.htm#getc(in_console_keybd_file)">getc</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>)</tt> works synchronous. This means that it
  might wait (block) until a key has been pressed. Blocking can be
  avoided with the following functions:
</p><ul>
    <li><tt><a class="func" href="../libraries/file.htm#inputReady(in_file)">inputReady</a></tt>, which returns <tt><a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a></tt> if a character can be read
      without blocking and <tt><a class="var" href="../libraries/boolean.htm#FALSE">FALSE</a></tt> otherwise.</li>
    <li><tt><a class="func" href="../libraries/keybd.htm#getc(inout_file,NO_WAIT)">getc</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>, <a class="var" href="../libraries/keybd.htm#getc(inout_file,NO_WAIT)">NO_WAIT</a>)</tt>, which delivers the next character
      from the keyboard or <tt><a class="var" href="#KEY_NONE">KEY_NONE</a></tt> if no key has been pressed.</li>
</ul><p>
  Note that <tt><a class="func" href="../libraries/file.htm#inputReady(in_file)">inputReady</a></tt> does not actually read a character. Reading
  must be done with with a different function (e.g. <tt><a class="func" href="../libraries/keybd.htm#getc(in_console_keybd_file)">getc</a></tt>) after
  <tt><a class="func" href="../libraries/file.htm#inputReady(in_file)">inputReady</a></tt> returns <tt><a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a></tt>. The program below writes a sequence of
  <tt>#</tt> characters. If any key is pressed it starts a new line.
  Pressing <span class="box">Return</span> (or <span class="box">Enter</span>) terminates the program:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"seed7_05.s7i"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/keybd.htm">keybd.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/duration.htm">duration.s7i</a>"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      <span class="keywd">while</span> not <a class="func" href="../libraries/file.htm#inputReady(in_file)">inputReady</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>) <span class="keywd">do</span>
        write(<span class="stri">"#"</span>);
        <a class="func" href="../libraries/file.htm#flush(inout_file)">flush</a>(<a class="var" href="../libraries/stdio.htm#OUT">OUT</a>);
        <a class="func" href="../libraries/duration.htm#wait(in_duration)">wait</a>(30000 . MICRO_SECONDS);
      <span class="keywd">end while</span>;
      writeln;
    <span class="keywd">until</span> getc(KEYBOARD) = KEY_NL;
  <span class="keywd">end func</span>;
</pre><p>
  Both functions (<tt><a class="func" href="../libraries/keybd.htm#getc(inout_file,NO_WAIT)">getc</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>, <a class="var" href="../libraries/keybd.htm#getc(inout_file,NO_WAIT)">NO_WAIT</a>)</tt> and <tt><a class="func" href="../libraries/file.htm#inputReady(in_file)">inputReady</a></tt>)
  are useful when user input is allowed while some processing takes
  place. The following program uses <tt><a class="func" href="../libraries/keybd.htm#getc(inout_file,NO_WAIT)">getc</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>, <a class="var" href="../libraries/keybd.htm#getc(inout_file,NO_WAIT)">NO_WAIT</a>)</tt> to
  display the time until a key is pressed:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"seed7_05.s7i"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/time.htm">time.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/keybd.htm">keybd.s7i</a>"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    writeln;
    <span class="keywd">while</span> <a class="func" href="../libraries/keybd.htm#getc(inout_file,NO_WAIT)">getc</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>, <a class="var" href="../libraries/keybd.htm#getc(inout_file,NO_WAIT)">NO_WAIT</a>) = <a class="var" href="#KEY_NONE">KEY_NONE</a> <span class="keywd">do</span>
      write(time(NOW) &lt;&amp; <span class="stri">"\r"</span>);
      <a class="func" href="../libraries/file.htm#flush(inout_file)">flush</a>(<a class="var" href="../libraries/stdio.htm#OUT">OUT</a>);
    <span class="keywd">end while</span>;
    writeln;
    writeln;
  <span class="keywd">end func</span>;
</pre><p>
  Seed7 programs can run in two modes:
</p><ul>
    <li>Console mode, where the program runs in a console/terminal
      window (the default).</li>
    <li>Graphics mode, where the program has its own graphic window.</li>
</ul><p>
  These two modes are supported with two basic keyboard files:
</p><ul>
    <li><tt><a class="var" href="../libraries/keybd.htm#CONSOLE_KEYBOARD">CONSOLE_KEYBOARD</a></tt>, which uses a terminfo or console driver.</li>
    <li><tt><a class="var" href="../libraries/keybd.htm#GRAPH_KEYBOARD">GRAPH_KEYBOARD</a></tt>, which uses a X11 or GDI driver.</li>
</ul><p>
  The file <tt><a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a></tt> is actually a variable which refers to one
  of the two basic keyboard files.  The declaration of the type
  <tt><a class="type" href="../libraries/keybd.htm#keyboard_file">keyboard_file</a></tt> and the file <tt><a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a></tt> in <span class="stri">"<a class="lib" href="../libraries/keybd.htm">keybd.s7i</a>"</span> is:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">type</span>: keyboard_file <span class="keywd">is</span> <span class="type">subtype file</span>;

<span class="keywd">var</span> <span class="type">keyboard_file</span>: KEYBOARD <span class="keywd">is</span> CONSOLE_KEYBOARD;
</pre><p>
  Graphic programs switch to to the <tt><a class="var" href="../libraries/keybd.htm#GRAPH_KEYBOARD">GRAPH_KEYBOARD</a></tt> driver with:
</p><pre class="indent">
<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a> := <a class="var" href="../libraries/keybd.htm#GRAPH_KEYBOARD">GRAPH_KEYBOARD</a>;
</pre><p>
  A <tt><a class="var" href="../libraries/keybd.htm#GRAPH_KEYBOARD">GRAPH_KEYBOARD</a></tt> additionally provides the following functions:
</p><ul>
    <li><tt><a class="func" href="../libraries/keybd.htm#buttonPressed(in_graph_keybd_file,in_char)">buttonPressed</a></tt>, which determines if a given button is
      currently pressed.</li>
    <li><tt><a class="func" href="../libraries/keybd.htm#clickedXPos(in_graph_keybd_file)">clickedXPos</a></tt>, which returns the X position of the mouse cursor
      when a button was pressed.</li>
    <li><tt><a class="func" href="../libraries/keybd.htm#clickedYPos(in_graph_keybd_file)">clickedYPos</a></tt>, which returns the Y position of the mouse cursor
      when a button was pressed.</li>
</ul><p>
  Modifier keys such as <span class="box">shift</span>, <span class="box">control</span>, <span class="box">super</span> and <span class="box">alt</span> do not send
  key/button down or up events. The function <tt><a class="func" href="../libraries/keybd.htm#buttonPressed(in_graph_keybd_file,in_char)">buttonPressed</a></tt>
  can be used to determine if a modifier has been pressed. The
  program below displays blue and red squares depending on the
  state of the left and right <span class="box">shift</span> keys. The program is
  terminated by pressing any non-modifier key:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"seed7_05.s7i"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/keybd.htm">keybd.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/draw.htm">draw.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/duration.htm">duration.s7i</a>"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    screen(640, 480);
    <a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a> := <a class="var" href="../libraries/keybd.htm#GRAPH_KEYBOARD">GRAPH_KEYBOARD</a>;
    <span class="keywd">repeat</span>
      rect(  85, 190, 100, 100, <a class="func" href="../libraries/keybd.htm#buttonPressed(in_graph_keybd_file,in_char)">buttonPressed</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>, <a class="var" href="#KEY_LEFT_SHIFT">KEY_LEFT_SHIFT</a>)  ? light_blue : light_red);
      rect( 270, 190, 100, 100, <a class="func" href="../libraries/keybd.htm#buttonPressed(in_graph_keybd_file,in_char)">buttonPressed</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>, <a class="var" href="#KEY_SHIFT">KEY_SHIFT</a>)       ? light_blue : light_red);
      rect( 455, 190, 100, 100, <a class="func" href="../libraries/keybd.htm#buttonPressed(in_graph_keybd_file,in_char)">buttonPressed</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>, <a class="var" href="#KEY_RIGHT_SHIFT">KEY_RIGHT_SHIFT</a>) ? light_blue : light_red);
      <a class="func" href="../libraries/graph.htm#flushGraphic">flushGraphic</a>;
      <a class="func" href="../libraries/duration.htm#wait(in_duration)">wait</a>(30000 . MICRO_SECONDS);
    <span class="keywd">until</span> <a class="func" href="../libraries/file.htm#inputReady(in_file)">inputReady</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>);
  <span class="keywd">end func</span>;
</pre><p>
  Note that <tt><a class="func" href="../libraries/keybd.htm#buttonPressed(in_graph_keybd_file,in_char)">buttonPressed</a></tt> does not process key/button events.
  This must be done with <tt><a class="func" href="../libraries/file.htm#inputReady(in_file)">inputReady</a></tt> or <tt><a class="func" href="../libraries/keybd.htm#getc(in_console_keybd_file)">getc</a></tt>.
</p><p>
  The library <span class="stri">"<a class="lib" href="../libraries/keybd.htm">keybd.s7i</a>"</span> provides definitions for modifier keys:
</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
    <tr><td>Key character constant</td>     <td>Description</td></tr>
    <tr><td><tt><a name="KEY_SHIFT">KEY_SHIFT</a></tt></td>                  <td>Left or right shift is pressed</td></tr>
    <tr><td><tt><a name="KEY_LEFT_SHIFT">KEY_LEFT_SHIFT</a></tt></td>             <td>Left shift is pressed</td></tr>
    <tr><td><tt><a name="KEY_RIGHT_SHIFT">KEY_RIGHT_SHIFT</a></tt></td>            <td>Right shift is pressed</td></tr>
    <tr><td><tt><a name="KEY_CONTROL">KEY_CONTROL</a></tt></td>                <td>Left or right control is pressed</td></tr>
    <tr><td><tt><a name="KEY_LEFT_CONTROL">KEY_LEFT_CONTROL</a></tt></td>           <td>Left control is pressed</td></tr>
    <tr><td><tt><a name="KEY_RIGHT_CONTROL">KEY_RIGHT_CONTROL</a></tt></td>          <td>Right control is pressed</td></tr>
    <tr><td><tt><a name="KEY_ALT">KEY_ALT</a></tt></td>                    <td>Left or right alt is pressed</td></tr>
    <tr><td><tt><a name="KEY_LEFT_ALT">KEY_LEFT_ALT</a></tt></td>               <td>Left alt is pressed</td></tr>
    <tr><td><tt><a name="KEY_RIGHT_ALT">KEY_RIGHT_ALT</a></tt></td>              <td>Right alt is pressed</td></tr>
    <tr><td><tt><a name="KEY_SUPER">KEY_SUPER</a></tt></td>                  <td>Left or right super is pressed</td></tr>
    <tr><td><tt><a name="KEY_LEFT_SUPER">KEY_LEFT_SUPER</a></tt></td>             <td>Left super is pressed</td></tr>
    <tr><td><tt><a name="KEY_RIGHT_SUPER">KEY_RIGHT_SUPER</a></tt></td>            <td>Right super is pressed</td></tr>
    <tr><td><tt><a name="KEY_SHIFT_LOCK">KEY_SHIFT_LOCK</a></tt></td>             <td>Shift lock is pressed</td></tr>
    <tr><td><tt><a name="KEY_SHIFT_LOCK_ON">KEY_SHIFT_LOCK_ON</a></tt></td>          <td>Shift lock is currently on</td></tr>
    <tr><td><tt><a name="KEY_NUM_LOCK">KEY_NUM_LOCK</a></tt></td>               <td>Num lock is pressed</td></tr>
    <tr><td><tt><a name="KEY_NUM_LOCK_ON">KEY_NUM_LOCK_ON</a></tt></td>            <td>Num lock is currently on</td></tr>
    <tr><td><tt><a name="KEY_SCROLL_LOCK">KEY_SCROLL_LOCK</a></tt></td>            <td>Scroll lock is pressed</td></tr>
    <tr><td><tt><a name="KEY_SCROLL_LOCK_ON">KEY_SCROLL_LOCK_ON</a></tt></td>         <td>Scroll lock is currently on</td></tr>
</table></dd></dl><p>
  The functions <tt><a class="func" href="../libraries/keybd.htm#clickedXPos(in_graph_keybd_file)">clickedXPos</a></tt> and <tt><a class="func" href="../libraries/keybd.htm#clickedYPos(in_graph_keybd_file)">clickedYPos</a></tt> can be used to determine
  which position was "clicked". The program below uses <tt><a class="func" href="../libraries/keybd.htm#clickedXPos(in_graph_keybd_file)">clickedXPos</a></tt>
  and <tt><a class="func" href="../libraries/keybd.htm#clickedYPos(in_graph_keybd_file)">clickedYPos</a></tt> to produce a dot for each keypress.
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"seed7_05.s7i"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/keybd.htm">keybd.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/draw.htm">draw.s7i</a>"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#char">char</a>: command <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    screen(640, 480);
    <a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a> := <a class="var" href="../libraries/keybd.htm#GRAPH_KEYBOARD">GRAPH_KEYBOARD</a>;
    command := <a class="func" href="../libraries/keybd.htm#getc(in_graph_keybd_file)">getc</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>);
    <span class="keywd">while</span> command = <a class="var" href="#KEY_MOUSE1">KEY_MOUSE1</a> <span class="keywd">do</span>
      fcircle(<a class="func" href="../libraries/keybd.htm#clickedXPos(in_graph_keybd_file)">clickedXPos</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>), <a class="func" href="../libraries/keybd.htm#clickedYPos(in_graph_keybd_file)">clickedYPos</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>), 4, light_red);
      command := <a class="func" href="../libraries/keybd.htm#getc(in_graph_keybd_file)">getc</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>);
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre><p>
  The current position of the mouse cursor, which is independent
  from key presses can be retrieved with the following functions:
</p><ul>
    <li><tt><a class="func" href="../libraries/graph.htm#pointerXPos(in_PRIMITIVE_WINDOW)">pointerXPos</a></tt>, which returns the actual X position of the
      mouse pointer.</li>
    <li><tt><a class="func" href="../libraries/graph.htm#pointerYPos(in_PRIMITIVE_WINDOW)">pointerYPos</a></tt>, which returns the actual Y position of the
      mouse pointer.</li>
</ul><p>
  The functions <tt><a class="func" href="../libraries/graph.htm#pointerXPos(in_PRIMITIVE_WINDOW)">pointerXPos</a></tt> and <tt><a class="func" href="../libraries/graph.htm#pointerYPos(in_PRIMITIVE_WINDOW)">pointerYPos</a></tt> can be used to move
  something with the cursor (e.g.: drag and drop). The program below
  uses <tt><a class="func" href="../libraries/keybd.htm#buttonPressed(in_graph_keybd_file,in_char)">buttonPressed</a></tt> to determine how long the mouse button is
  pressed. This is used together with <tt><a class="func" href="../libraries/graph.htm#pointerXPos(in_PRIMITIVE_WINDOW)">pointerXPos</a></tt> and <tt><a class="func" href="../libraries/graph.htm#pointerYPos(in_PRIMITIVE_WINDOW)">pointerYPos</a></tt>
  to draw along the mouse cursor while the mouse button is pressed:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"seed7_05.s7i"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/keybd.htm">keybd.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/draw.htm">draw.s7i</a>"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#char">char</a>: command <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    screen(640, 480);
    <a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a> := <a class="var" href="../libraries/keybd.htm#GRAPH_KEYBOARD">GRAPH_KEYBOARD</a>;
    command := <a class="func" href="../libraries/keybd.htm#getc(in_graph_keybd_file)">getc</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>);
    <span class="keywd">while</span> command = <a class="var" href="#KEY_MOUSE1">KEY_MOUSE1</a> <span class="keywd">do</span>
      <span class="keywd">while</span> <a class="func" href="../libraries/keybd.htm#buttonPressed(in_graph_keybd_file,in_char)">buttonPressed</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>, <a class="var" href="#KEY_MOUSE1">KEY_MOUSE1</a>) <span class="keywd">do</span>
        fcircle(<a class="func" href="../libraries/graph.htm#pointerXPos(in_PRIMITIVE_WINDOW)">pointerXPos</a>(curr_win), <a class="func" href="../libraries/graph.htm#pointerYPos(in_PRIMITIVE_WINDOW)">pointerYPos</a>(curr_win), 4, light_red);
      <span class="keywd">end while</span>;
      command := <a class="func" href="../libraries/keybd.htm#getc(in_graph_keybd_file)">getc</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>);
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre><p>
Some keys are not delivered to the program by default. By default
the close button of the window (often marked with <tt><span class="box">X</span></tt>)
just exits the program. By default resizing a window is also not
communicated to the program. These two events can be activated
with <tt><a class="func" href="../libraries/graph.htm#selectInput(in_PRIMITIVE_WINDOW,in_char,in_boolean)">selectInput</a></tt>.
This way a program can also receive <tt><a class="var" href="../manual/file.htm#KEY_CLOSE">KEY_CLOSE</a></tt> and <tt><a class="var" href="../manual/file.htm#KEY_RESIZE">KEY_RESIZE</a></tt>:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"seed7_05.s7i"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/keybd.htm">keybd.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/draw.htm">draw.s7i</a>"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#char">char</a>: command <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    screen(640, 480);
    <a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a> := <a class="var" href="../libraries/keybd.htm#GRAPH_KEYBOARD">GRAPH_KEYBOARD</a>;
    <a class="func" href="../libraries/graph.htm#selectInput(in_PRIMITIVE_WINDOW,in_char,in_boolean)">selectInput</a>(curr_win, <a class="var" href="../manual/file.htm#KEY_CLOSE">KEY_CLOSE</a>, <a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a>);  <span class="comment"># Enable the program to get KEY_CLOSE without closing the window.</span>
    <a class="func" href="../libraries/graph.htm#selectInput(in_PRIMITIVE_WINDOW,in_char,in_boolean)">selectInput</a>(curr_win, <a class="var" href="../manual/file.htm#KEY_RESIZE">KEY_RESIZE</a>, <a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a>); <span class="comment"># Enable the program to get KEY_RESIZE.</span>
    command := <a class="func" href="../libraries/keybd.htm#getc(in_graph_keybd_file)">getc</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>);
    <span class="keywd">while</span> command <> <a class="var" href="#KEY_CLOSE">KEY_CLOSE</a> <span class="keywd">do</span>
      <span class="keywd">if</span> command = <a class="var" href="#KEY_RESIZE">KEY_RESIZE</a> <span class="keywd">then</span>
        <a class="func" href="../libraries/draw.htm#lineTo(in_integer,in_integer,in_integer,in_integer,in_color)">lineTo</a>(0, 0, <a class="func" href="../libraries/graph.htm#width(in_PRIMITIVE_WINDOW)">width</a>(curr_win), <a class="func" href="../libraries/graph.htm#height(in_PRIMITIVE_WINDOW)">height</a>(curr_win), white);
      <span class="keywd">end if</span>;
      command := <a class="func" href="../libraries/keybd.htm#getc(in_graph_keybd_file)">getc</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>);
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre><p>
  Some file types are defined to support the <tt><a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a></tt>. One such
  file type is <tt><a class="type" href="../libraries/echo.htm#echoFile">echoFile</a></tt>, which is defined in the library <span class="stri">"<a class="lib" href="../libraries/echo.htm">echo.s7i</a>"</span>.
  An <tt><a class="type" href="../libraries/echo.htm#echoFile">echoFile</a></tt> file can be used to write input characters to
  an output file. This is useful since <tt><a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a></tt> does not echo its
  input, but <tt><a class="type" href="../libraries/echo.htm#echoFile">echoFile</a></tt> is not restricted to support <tt><a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a></tt>.
  The following program writes echoes of the keys typed and exits as
  soon as a <tt><span class="stri">'!'</span></tt> is encountered:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"seed7_05.s7i"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/keybd.htm">keybd.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/echo.htm">echo.s7i</a>"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#char">char</a>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <a class="var" href="../libraries/stdio.htm#IN">IN</a> := <a class="func" href="../libraries/echo.htm#openEcho(in_file,in_file)">openEcho</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>, <a class="var" href="../libraries/stdio.htm#OUT">OUT</a>);
    <span class="keywd">repeat</span>
      ch := getc(<a class="var" href="../libraries/stdio.htm#IN">IN</a>);
    <span class="keywd">until</span> ch = <span class="stri">'!'</span>;
    writeln;
  <span class="keywd">end func</span>;
</pre><p>
  An <tt><a class="type" href="../libraries/echo.htm#echoFile">echoFile</a></tt> checks also for <span class="box">control-C</span> (<tt><a class="var" href="#KEY_CTL_A_TO_Z">KEY_CTL_C</a></tt>). If
  <span class="box">control-C</span> is typed an <tt><a class="type" href="../libraries/echo.htm#echoFile">echoFile</a></tt> asks if the program should be
  terminated:
</p><pre class="indent">
terminate (y/n)?
</pre><p>
  Answering <tt>'y'</tt> or <tt>'Y'</tt> is interpreted as <tt>'yes'</tt> and the program
  is terminated with the following message:
</p><pre class="indent">
*** PROGRAM TERMINATED BY USER
</pre><p>
  Any other input removes the question and the program continues
  to read input.
</p><p>
  Another helpful file type is <tt><a class="type" href="../libraries/line.htm#lineFile">lineFile</a></tt>, which is defined in the
  library <span class="stri">"<a class="lib" href="../libraries/line.htm">line.s7i</a>"</span>. A <tt><a class="type" href="../libraries/line.htm#lineFile">lineFile</a></tt> allows to correct the input with
  <span class="box">Backspace</span> until a <span class="box">Return</span> (represented with <tt><span class="stri">'\n'</span></tt>) is encountered.
  In contrast to this editing feature the possibility to edit a line
  of <tt><a class="var" href="../libraries/stdio.htm#STD_IN">STD_IN</a></tt> is provided by the operating system. The following
  program uses <tt><a class="type" href="../libraries/echo.htm#echoFile">echoFile</a></tt> and <tt><a class="type" href="../libraries/line.htm#lineFile">lineFile</a></tt> to simulate input line
  editing:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"seed7_05.s7i"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/keybd.htm">keybd.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/echo.htm">echo.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/line.htm">line.s7i</a>"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#char">char</a>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <a class="var" href="../libraries/stdio.htm#IN">IN</a> := <a class="func" href="../libraries/echo.htm#openEcho(in_file,in_file)">openEcho</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>, <a class="var" href="../libraries/stdio.htm#OUT">OUT</a>);
    <a class="var" href="../libraries/stdio.htm#IN">IN</a> := <a class="func" href="../libraries/line.htm#openLine(in_file)">openLine</a>(<a class="var" href="../libraries/stdio.htm#IN">IN</a>);
    <span class="keywd">repeat</span>
      ch := getc(<a class="var" href="../libraries/stdio.htm#IN">IN</a>);
      write(ch);
    <span class="keywd">until</span> ch = <span class="stri">'!'</span>;
  <span class="keywd">end func</span>;
</pre><p>
  This program terminates if a line containing <tt><span class="stri">'!'</span></tt> is confirmed
  with <span class="box">Return</span>.
</p><p>
  There is also the <tt><a class="type" href="../libraries/editline.htm#editLineFile">editLineFile</a></tt>, which is defined in the library
  <span class="stri">"<a class="lib" href="../libraries/editline.htm">editline.s7i</a>"</span>. An <tt><a class="type" href="../libraries/editline.htm#editLineFile">editLineFile</a></tt> provides more than a combination
  of an <tt><a class="type" href="../libraries/echo.htm#echoFile">echoFile</a></tt> with a <tt><a class="type" href="../libraries/line.htm#lineFile">lineFile</a></tt>. An <tt><a class="type" href="../libraries/editline.htm#editLineFile">editLineFile</a></tt> allows
  editing with <span class="box">Backspace</span>, <span class="box">Delete</span>, <span class="box">&larr;</span>, <span class="box">&rarr;</span>, <span class="box">Home</span> and <span class="box">End</span>. The vertical
  curser keys can be used to get previous input lines. Like an
  <tt><a class="type" href="../libraries/echo.htm#echoFile">echoFile</a></tt> it checks also for <span class="box">control-C</span> (<tt><a class="var" href="#KEY_CTL_A_TO_Z">KEY_CTL_C</a></tt>).
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"seed7_05.s7i"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/keybd.htm">keybd.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/console.htm">console.s7i</a>"</span>;
  <span class="keywd">include</span> <span class="lib">"<a class="lib" href="../libraries/editline.htm">editline.s7i</a>"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#string">string</a>: command <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    <a class="var" href="../libraries/stdio.htm#OUT">OUT</a> := <a class="var" href="../libraries/console.htm#STD_CONSOLE">STD_CONSOLE</a>;
    <a class="var" href="../libraries/stdio.htm#IN">IN</a> := <a class="func" href="../libraries/editline.htm#openEditLine(in_file,in_file)">openEditLine</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>, <a class="var" href="../libraries/stdio.htm#OUT">OUT</a>);
    writeln(<span class="stri">"Use the command quit to exit the program."</span>);
    <span class="keywd">repeat</span>
      write("command> ");
      readln(command);
    <span class="keywd">until</span> command = <span class="stri">"quit"</span>;
  <span class="keywd">end func</span>;
</pre>

<a name="Files_with_line_structure"><h3>8.8 Files with line structure</h3></a>
<p>
  The library <span class="stri">"<a class="lib" href="../libraries/text.htm">text.s7i</a>"</span> defines the type <tt><a class="type" href="types.htm#text">text</a></tt>, which is a
  subtype of <tt><a class="type" href="types.htm#file">file</a></tt>. The type <tt><a class="type" href="types.htm#text">text</a></tt> adds a line structure and
  other features such as scrolling and color to <tt><a class="type" href="types.htm#file">file</a></tt>. The
  lines and columns of a <tt><a class="type" href="types.htm#text">text</a></tt> start with 1 in the upper left
  corner and increase downward and rightward. The function
  <tt><a class="func" href="../libraries/text.htm#setPos(inout_text,in_integer,in_integer)">setPos</a></tt> sets the current line and column of a <tt><a class="type" href="types.htm#text">text</a></tt>:
</p><pre class="indent">
setPos(aText, 10, 20);
</pre><p>
  The functions <tt><a class="func" href="../libraries/text.htm#setLine(in_text,in_integer)">setLine</a></tt> and <tt><a class="func" href="../libraries/text.htm#setColumn(in_text,in_integer)">setColumn</a></tt> set just the
  line and column respectively:
</p><pre class="indent">
setLine(aText, 2);
setColumn(aText, 72);
</pre><p>
  The current line and column of a <tt><a class="type" href="types.htm#text">text</a></tt> file can be retrieved
  with <tt><a class="func" href="../libraries/text.htm#line(in_text)">line</a></tt> and <tt><a class="func" href="../libraries/text.htm#column(in_text)">column</a></tt>:
</p><pre class="indent">
writeln(<span class="stri">"The current line is: "</span> &lt;& line(aText));
writeln(<span class="stri">"The current column is: "</span> &lt;& column(aText));
</pre><p>
  The current height and width of a <tt><a class="type" href="types.htm#text">text</a></tt> file can be retrieved
  with <tt><a class="func" href="../libraries/text.htm#height(in_text)">height</a></tt> and <tt><a class="func" href="../libraries/text.htm#width(in_text)">width</a></tt>:
</p><pre class="indent">
writeln(<span class="stri">"The height is: "</span> &lt;& height(aText));
writeln(<span class="stri">"The width is: "</span> &lt;& width(aText));
</pre><p>
  To allow random access output to a text console (or text window)
  the library <span class="stri">"<a class="lib" href="../libraries/console.htm">console.s7i</a>"</span> defines the type <tt><a class="type" href="../libraries/console.htm#console_file">console_file</a></tt>. The function
</p><pre class="indent">
open(CONSOLE)
</pre><p>
  returns a <tt><a class="type" href="../libraries/console.htm#console_file">console_file</a></tt>.
</p>

<a name="Sockets"><h3>8.9 Sockets</h3></a>
<p>
    The library <span class="stri">"<a class="lib" href="../libraries/socket.htm">socket.s7i</a>"</span> defines types and functions to
  access sockets. The implementation type for sockets is
  <tt><a class="type" href="../libraries/socket.htm#socket">socket</a></tt>. As interface type <tt><a class="type" href="types.htm#file">file</a></tt> is used:
</p><pre class="indent">
<span class="keywd">var</span> <a class="type" href="types.htm#file">file</a>: clientSocket <span class="keywd">is</span> <a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a>;
</pre><p>
  With <tt><a class="func" href="../libraries/socket.htm#openInetSocket(in_string,in_integer)">openInetSocket</a></tt> an Internet client socket can be opened:
</p><pre class="indent">
clientSocket := <a class="func" href="../libraries/socket.htm#openInetSocket(in_string,in_integer)">openInetSocket</a>(<span class="stri">"www.google.com"</span>, 80);
</pre><p>
  The function <tt><a class="func" href="../libraries/socket.htm#openInetSocket(in_string,in_integer)">openInetSocket</a></tt> creates and connects a socket.
  Opening an Internet socket at the local host is also done with
  a variant of <tt><a class="func" href="../libraries/socket.htm#openInetSocket(in_integer)">openInetSocket</a></tt>:
</p><pre class="indent">
clientSocket := <a class="func" href="../libraries/socket.htm#openInetSocket(in_integer)">openInetSocket</a>(1080);
</pre><p>
  Since sockets use the <tt><a class="type" href="types.htm#file">file</a></tt> interface functions like <tt><a class="func" href="../libraries/file.htm#writeln(inout_file,in_string)">writeln</a></tt>
  and <tt><a class="func" href="../libraries/file.htm#getln(inout_file)">getln</a></tt> can be used:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"seed7_05.s7i"</span>;
  <span class="keywd">include</span> <span class="stri">"socket.s7i"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">const</span> <a class="type" href="types.htm#string">string</a>: serverName <span class="keywd">is</span> <span class="stri">"www.google.com"</span>;
    <span class="keywd">var</span> <a class="type" href="types.htm#file">file</a>: aSocket <span class="keywd">is</span> <a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a>;
  <span class="keywd">begin</span>
    aSocket := <a class="func" href="../libraries/socket.htm#openInetSocket(in_string,in_integer)">openInetSocket</a>(serverName, 80);
    <span class="keywd">if</span> aSocket &lt;> <a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a> <span class="keywd">then</span>
      <a class="func" href="../libraries/socket.htm#writeln(in_socket,in_string)">writeln</a>(aSocket, <span class="stri">"GET / HTTP/1.1"</span>);
      <a class="func" href="../libraries/socket.htm#writeln(in_socket,in_string)">writeln</a>(aSocket, <span class="stri">"Host: "</span> &lt;&amp; serverName);
      <a class="func" href="../libraries/socket.htm#writeln(in_socket,in_string)">writeln</a>(aSocket, <span class="stri">"User-Agent: BlackHole"</span>);
      <a class="func" href="../libraries/null_file.htm#writeln(inout_null_file)">writeln</a>(aSocket);
      writeln(<a class="func" href="../libraries/socket.htm#getln(inout_socket)">getln</a>(aSocket));
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  The example above sends a HTTP request to a server and gets
  the status code from the response. The example above consists
  of code from the library <span class="stri">"<a class="lib" href="../libraries/gethttp.htm">gethttp.s7i</a>"</span>.
</p><p>
  Server sockets are supported with the type <tt><a class="type" href="../libraries/socket.htm#listener">listener</a></tt>.
  A listener is defined with:
</p><pre class="indent">
<span class="keywd">var</span> <a class="type" href="../libraries/socket.htm#listener">listener</a>: myListener <span class="keywd">is</span> <a class="type" href="../libraries/socket.htm#listener">listener</a>.value;
</pre><p>
  The library <span class="stri">"<a class="lib" href="../libraries/listener.htm">listener.s7i</a>"</span> defines the function <tt><a class="func" href="../libraries/listener.htm#openInetListener(in_integer)">openInetListener</a></tt>,
  which opens a <tt><a class="type" href="../libraries/socket.htm#listener">listener</a></tt>:
</p><pre class="indent">
aListener := <a class="func" href="../libraries/listener.htm#openInetListener(in_integer)">openInetListener</a>(1080);
</pre><p>
  The function <tt><a class="func" href="../libraries/listener.htm#listen(in_inetListener,in_integer)">listen</a></tt> is used to listen for incoming socket
  connections of a <tt><a class="type" href="../libraries/socket.htm#listener">listener</a></tt>, and to
  limit the incoming queue:
</p><pre class="indent">
<a class="func" href="../libraries/listener.htm#listen(in_inetListener,in_integer)">listen</a>(aListener, 10);
</pre><p>
  The function <tt><a class="func" href="../libraries/listener.htm#accept(inout_inetListener)">accept</a></tt> returns the first connected socked
  of the <tt><a class="type" href="../libraries/socket.htm#listener">listener</a></tt>:
</p><pre class="indent">
serverSocket := <a class="func" href="../libraries/listener.htm#accept(inout_inetListener)">accept</a>(aListener);
</pre><p>
  Together the functions above can be use to process requests without sessions:
</p><pre class="indent">
aListener := <a class="func" href="../libraries/listener.htm#openInetListener(in_integer)">openInetListener</a>(1080);
<a class="func" href="../libraries/listener.htm#listen(in_inetListener,in_integer)">listen</a>(aListener, 10);
<span class="keywd">while</span> <a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a> <span class="keywd">do</span>
  sock := <a class="func" href="../libraries/listener.htm#accept(inout_inetListener)">accept</a>(aListener);
  <span class="comment"># Read and process the request from sock.</span>
  close(sock);
<span class="keywd">end while</span>;
</pre><p>
  A similar loop is used in the <a class="link" href="../prg/comanche.htm">Comanche</a> web server (see main function).
  The function <tt><a class="func" href="../libraries/listener.htm#waitForRequest(inout_listener,__inout_file,inout_file)">waitForRequest</a></tt> can be used to process requests with session:
</p><pre class="indent">
aListener := <a class="func" href="../libraries/listener.htm#openInetListener(in_integer)">openInetListener</a>(2021);
listen(aListener, 10);
<span class="keywd">while</span> <a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a> <span class="keywd">do</span>
  <a class="func" href="../libraries/listener.htm#waitForRequest(inout_listener,__inout_file,inout_file)">waitForRequest</a>(aListener, existingConnection, newConnection);
  <span class="keywd">if</span> existingConnection &lt;> <a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a> <span class="keywd">then</span>
    <span class="comment"># Read and process the request from existingConnection.</span>
  <span class="keywd">end if</span>;
  <span class="keywd">if</span> newConnection &lt;> <a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a> <span class="keywd">then</span>
    <span class="comment"># Send welcome message to newConnection.</span>
  <span class="keywd">end if</span>;
<span class="keywd">end while</span>;
</pre><p>
  Similar code is used in the program <span class="stri">"ftpserv.sd7"</span>.
  The implementation of <tt><a class="func" href="../libraries/listener.htm#waitForRequest(inout_listener,__inout_file,inout_file)">waitForRequest</a></tt> is based on <tt><a class="type" href="../libraries/poll.htm#pollData">pollData</a></tt>,
  which is defined in <span class="stri">"<a class="lib" href="../libraries/poll.htm">poll.s7i</a>"</span>.
</p>

<a name="Transport_layer_security"><h3>8.10 Transport Layer Security</h3></a>
<p>
    Transport Layer Security (TLS) is the successor of the Secure
  Sockets Layer (SSL). It provides secure communication over a
  computer network. The library <span class="stri">"<a class="lib" href="../libraries/tls.htm">tls.s7i</a>"</span> defines types and functions
  for TLS sockets. The implementation type for sockets is <tt><a class="type" href="../libraries/tls.htm#tlsFile">tlsFile</a></tt>.
  As interface type <tt><a class="type" href="types.htm#file">file</a></tt> is used:
</p><pre class="indent">
<span class="keywd">var</span> <a class="type" href="types.htm#file">file</a>: aTlsSocket <span class="keywd">is</span> <a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a>;
</pre><p>
  With <tt><a class="func" href="../libraries/tls.htm#openTlsSocket(in_string,in_integer)">openTlsSocket</a></tt> a TLS socket can be opened:
</p><pre class="indent">
aTlsSocket := <a class="func" href="../libraries/tls.htm#openTlsSocket(in_string,in_integer)">openTlsSocket</a>(<span class="stri">"www.google.com"</span>, 443);
</pre><p>
  The function <tt><a class="func" href="../libraries/tls.htm#openTlsSocket(in_string,in_integer)">openTlsSocket</a></tt> opens a TLS socket. Since TLS sockets
  use the <tt><a class="type" href="types.htm#file">file</a></tt> interface functions like <tt><a class="func" href="../libraries/file.htm#writeln(inout_file,in_string)">writeln</a></tt> and <tt><a class="func" href="../libraries/file.htm#getln(inout_file)">getln</a></tt> can
  be used:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"seed7_05.s7i"</span>;
  <span class="keywd">include</span> <span class="stri">"tls.s7i"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">const</span> <a class="type" href="types.htm#string">string</a>: serverName <span class="keywd">is</span> <span class="stri">"www.google.com"</span>;
    <span class="keywd">var</span> <a class="type" href="types.htm#file">file</a>: aTlsSocket <span class="keywd">is</span> <a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a>;
  <span class="keywd">begin</span>
    aTlsSocket := <a class="func" href="../libraries/tls.htm#openTlsSocket(in_string,in_integer)">openTlsSocket</a>(serverName, 443);
    <span class="keywd">if</span> aTlsSocket &lt;> <a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a> <span class="keywd">then</span>
      <a class="func" href="../libraries/tls.htm#writeln(inout_tlsFile,in_string)">writeln</a>(aTlsSocket, <span class="stri">"GET / HTTP/1.1"</span>);
      <a class="func" href="../libraries/tls.htm#writeln(inout_tlsFile,in_string)">writeln</a>(aTlsSocket, <span class="stri">"Host: "</span> &lt;&amp; serverName);
      <a class="func" href="../libraries/tls.htm#writeln(inout_tlsFile,in_string)">writeln</a>(aTlsSocket, <span class="stri">"User-Agent: BlackHole"</span>);
      <a class="func" href="../libraries/null_file.htm#writeln(inout_null_file)">writeln</a>(aTlsSocket);
      writeln(<a class="func" href="../libraries/tls.htm#getln(inout_tlsFile)">getln</a>(aTlsSocket));
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  The example above sends a HTTPS request to a server and gets
  the status code from the response. The example above consists
  of code from the library <span class="stri">"<a class="lib" href="../libraries/gethttps.htm">gethttps.s7i</a>"</span>.
</p><p>
  The function <tt><a class="func" href="../libraries/tls.htm#openServerTls(inout_file,in_certAndKey)">openServerTls</a></tt> can be used to open a TLS socket
  at the server side. The library <span class="stri">"<a class="lib" href="../libraries/x509cert.htm">x509cert.s7i</a>"</span> defines the
  self signed certificate <tt><a class="var" href="../libraries/x509cert.htm#stdCertificate">stdCertificate</a></tt>. This certificate
  can be used to open a TLS server socket:
</p><pre class="indent">
$ <span class="keywd">include</span> <span class="stri">"seed7_05.s7i"</span>;
  <span class="keywd">include</span> <span class="stri">"socket.s7i"</span>;
  <span class="keywd">include</span> <span class="stri">"listener.s7i"</span>;
  <span class="keywd">include</span> <span class="stri">"tls.s7i"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: main <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="../libraries/socket.htm#listener">listener</a>: aListener <span class="keywd">is</span> <a class="type" href="../libraries/socket.htm#listener">listener</a>.value;
    <span class="keywd">var</span> <a class="type" href="types.htm#file">file</a>: sock <span class="keywd">is</span> <a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a>;
    <span class="keywd">var</span> <a class="type" href="types.htm#file">file</a>: tlsSock <span class="keywd">is</span> <a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a>;
    <span class="keywd">var</span> <a class="type" href="types.htm#string">string</a>: line <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    aListener := <a class="func" href="../libraries/listener.htm#openInetListener(in_integer)">openInetListener</a>(11111);
    <a class="func" href="../libraries/listener.htm#listen(in_inetListener,in_integer)">listen</a>(aListener, 10);
    <span class="keywd">while</span> <a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a> <span class="keywd">do</span>
      sock := <a class="func" href="../libraries/listener.htm#accept(inout_inetListener)">accept</a>(aListener);
      tlsSock := <a class="func" href="../libraries/tls.htm#openServerTls(inout_file,in_certAndKey)">openServerTls</a>(sock, <a class="var" href="../libraries/x509cert.htm#stdCertificate">stdCertificate</a>);
      <span class="keywd">if</span> tlsSock <> <a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a> <span class="keywd">then</span>
        <a class="func" href="../libraries/stdio.htm#writeln(in_string)">writeln</a>(<span class="stri">"Success"</span>);
        <span class="keywd">repeat</span>
          line := <a class="func" href="../libraries/tls.htm#getln(inout_tlsFile)">getln</a>(tlsSock);
          <a class="func" href="../libraries/stdio.htm#writeln(in_string)">writeln</a>(line <& <span class="stri">" received"</span>);
        <span class="keywd">until</span> line = <span class="stri">""</span>;
        <a class="func" href="../libraries/tls.htm#close(inout_tlsFile)">close</a>(tlsSock);
      <span class="keywd">else</span>
        <a class="func" href="../libraries/stdio.htm#writeln(in_string)">writeln</a>(<span class="stri">" *** Cannot open TLS connection."</span>);
      <span class="keywd">end if</span>;
    <span class="keywd">end while</span>;
  <span class="keywd">end func;
</pre>

<a name="User_defined_file_types"><h3>8.11 User defined file types</h3></a>
<p>
    In addition to the predefined file types it is often
  necessary to define a new type of file. Such a new file
  has several possibilities:
</p><ul>
    <li>It could store its contents in a string (not only to be
      faster but also to provide additional file operations)</li>

    <li>The information can be processed (e.g. to upper case)
      and sent to another file.</li>

    <li>It could work just like an Unix utility (Think of
      more, sort, tee, uniq ...)</li>

    <li>It could provide a file-like interface for something
      with an other interface. (e.g. The contents of a
      directory, or random access I/O to the screen)</li>
</ul><p>
  With the following declaration we define a new file type:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">type</span>: my_file_type <span class="keywd">is sub</span> <a class="type" href="../libraries/null_file.htm#null_file">null_file</a> <span class="keywd">struct</span>
    ...
    <span class="comment">(* Local data *)</span>
    ...
  <span class="keywd">end struct</span>;
</pre><p>
  It is not necessary to derive the type <tt><span class="type">my_file_type</span></tt> directly from
  <tt><a class="type" href="../libraries/null_file.htm#null_file">null_file</a></tt>. The type <tt><span class="type">my_file_type</span></tt> may also be an indirect descendant
  of <tt><a class="type" href="../libraries/null_file.htm#null_file">null_file</a></tt>. So it is possible to create file type hierarchies.
  The interface implemented by the new file needs also to be specified:
</p><pre class="indent">
type_implements_interface(<span class="type">my_file_type</span>, <a class="type" href="types.htm#file">file</a>);
</pre><p>
  The type <tt><a class="type" href="types.htm#file">file</a></tt> is not the only interface
  type which can be used. There is also the type <tt><a class="type" href="types.htm#text">text</a></tt> which
  is derived from <tt><a class="type" href="types.htm#file">file</a></tt>. The type <tt><a class="type" href="types.htm#text">text</a></tt>
  describes a line oriented file which allows <tt><a class="func" href="../libraries/text.htm#setPos(inout_text,in_integer,in_integer)">setPos</a></tt> (which moves the
  current position to the line and column specified) and other functions.
  It is also possible to define new interface types which derive
  from <tt><a class="type" href="types.htm#file">file</a></tt> or <tt><a class="type" href="types.htm#text">text</a></tt>.
</p><p>
  As next an open function is needed to open a <tt><span class="type">my_file_type</span></tt> file:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func file</span>: open_my_file (  <span class="comment">(* Parameters *)</span> ) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#file">file</a>: newFile <span class="keywd">is</span> <a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">my_file_type</span>: new_file <span class="keywd">is</span> <span class="type">my_file_type</span>.value;
  <span class="keywd">begin</span>
    ...
    <span class="comment">(* Initialization of the data elements of new_file *)</span>
    newFile := toInterface(new_file);
    ...
  <span class="keywd">end func</span>;
</pre><p>
  Note that the function <tt>'toInterface'</tt> is used to generate a new <tt><a class="type" href="types.htm#file">file</a></tt>
  object. Now only the two basic I/O operations must be defined:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: write (<span class="keywd">inout</span> <span class="type">my_file_type</span>: new_fil, <span class="keywd">in</span> <span class="type">string</span>: stri) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    ...
    <span class="comment">(* Statements that do the output *)</span>
    ...
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: gets (<span class="keywd">inout</span> <span class="type">my_file_type</span>: new_fil, <span class="keywd">in</span> <span class="type">integer</span>: leng) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: stri <span class="keywd">is</span> "";
  <span class="keywd">begin</span>
    ...
    <span class="comment">(* Statements that do the input *)</span>
    ...
  <span class="keywd">end func</span>;
</pre><p></p>

<a name="Scanning_a_file"><h3>8.12 Scanning a file</h3></a>
<p>
    The I/O concept introduced in the previous chapters separates
  the input of data from its conversion. The <tt><a class="func" href="../libraries/file.htm#read(inout_file,inout_string)">read</a></tt>, <tt><a class="func" href="../libraries/file.htm#readln(inout_file,inout_string)">readln</a></tt>,
  <tt><a class="func" href="../libraries/file.htm#getwd(inout_file)">getwd</a></tt> and <tt><a class="func" href="../libraries/file.htm#getln(inout_file)">getln</a></tt> functions are designed to read whitespace
  separated data elements. If the data elements are not separated
  by whitespace characters this I/O concept is not possible.
  Instead the functions which read from the file need some
  knowledge about the type which they intend to read. Fortunately
  this is a well researched area. The lexical scanners used by
  compilers solve exactly this problem.
</p><p>
  Lexical scanners read symbols from a file and use the concept of
  a current character. A symbol can be a name, a number, a string,
  an operator, a parenthesis or something else. The current
  character is the first character to be processed when scanning a
  symbol. After a scanner has read a symbol the current character
  contains the character just after the symbol. This character
  could be the first character of the next symbol or some
  whitespace character. If the set of symbols is chosen wisely all
  decisions about the type of the symbol and when to stop reading
  characters for a symbol can be done based on the current
  character.
</p><p>
  Every <tt><a class="type" href="types.htm#file">file</a></tt> contains a <tt>'bufferChar'</tt> variable which is used as
  current character by the scanner functions defined in the
  <span class="stri">"<a class="lib" href="../libraries/scanfile.htm">scanfile.s7i</a>"</span> library. The <span class="stri">"<a class="lib" href="../libraries/scanfile.htm">scanfile.s7i</a>"</span> library contains
  skip... and get... functions. The skip... procedures return void
  and are used to skip input while the get... functions return the
  string of characters they have read. The following basic scanner
  functions are defined in the <span class="stri">"<a class="lib" href="../libraries/scanfile.htm">scanfile.s7i</a>"</span> library:
</p><dl>
    <dt><a class="func" href="../libraries/scanfile.htm#skipComment(inout_file)">skipComment</a></dt>
      <dd>Skips a possibly nested <a class="link" href="tokens.htm#Comments">Seed7 comment</a> from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getComment(inout_file)">getComment</a></dt>
      <dd>Reads a possibly nested <a class="link" href="tokens.htm#Comments">Seed7 comment</a> from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#skipClassicComment(inout_file)">skipClassicComment</a></dt>
      <dd>Skips a classic C comment from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#skipLineComment(inout_file)">skipLineComment</a></dt>
      <dd>Skips a <a class="link" href="tokens.htm#Line_comments">line comment</a> from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getLine(inout_file)">getLineComment</a></dt>
      <dd>Reads a <a class="link" href="tokens.htm#Line_comments">line comment</a> from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getDigits(inout_file)">getDigits</a></dt>
      <dd>Reads a sequence of digits from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getInteger(inout_file)">getInteger</a></dt>
      <dd>Reads a decimal integer with optional sign from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getNumber(inout_file)">getNumber</a></dt>
      <dd>Reads a numeric literal (<a class="link" href="tokens.htm#Integer_literals">integer</a>, <a class="link" href="tokens.htm#BigInteger_literals">bigInteger</a> or <a class="link" href="tokens.htm#Float_literals">float</a> literal) from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getNonDigits(inout_file)">getNonDigits</a></dt>
      <dd>Reads a sequence of non digits from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getQuotedText(inout_file)">getQuotedText</a></dt>
      <dd>Reads a text quoted with " or ' from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getSimpleStringLiteral(inout_file)">getSimpleStringLiteral</a></dt>
      <dd>Read a simple string literal from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getCharLiteral(inout_file)">getCharLiteral</a></dt>
      <dd>Reads a <a class="link" href="tokens.htm#Character_literals">character literal</a> from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getStringLiteral(inout_file)">getStringLiteral</a></dt>
      <dd>Reads a <a class="link" href="tokens.htm#String_literals">string literal</a> from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getName(inout_file)">getName</a></dt>
      <dd>Reads an alphanumeric name from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
</dl><p>
  Contrary to <tt><a class="func" href="../libraries/file.htm#read(inout_file,inout_string)">read</a></tt> and <tt><a class="func" href="../libraries/file.htm#getwd(inout_file)">getwd</a></tt> basic scanner functions
  do not skip leading whitespace characters. To skip whitespace
  characters one of the following functions can be used:
</p><dl>
    <dt><a class="func" href="../libraries/scanfile.htm#skipSpace(inout_file)">skipSpace</a></dt>
      <dd>Skips space characters from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#skipSpaceOrTab(inout_file)">skipSpaceOrTab</a></dt>
      <dd>Skips space and tab characters from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#skipWhiteSpace(inout_file)">skipWhiteSpace</a></dt>
      <dd>Skips whitespace characters from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getWhiteSpace(inout_file)">getWhiteSpace</a></dt>
      <dd>Reads whitespace characters from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getWord(inout_file)">getWord</a></dt>
      <dd>Reads a white space delimited word from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#skipLine(inout_file)">skipLine</a></dt>
      <dd>Skips a line from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getLine(inout_file)">getLine</a></dt>
      <dd>Reads a line from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
</dl><p>
  The advanced scanner functions do skip whitespace characters
  before reading a symbol:
</p><dl>
    <dt><a class="func" href="../libraries/scanfile.htm#getSymbolOrComment(inout_file)">getSymbolOrComment</a></dt>
      <dd>Reads a symbol or a comment from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getSymbol(inout_file)">getSymbol</a></dt>
      <dd>Reads a symbol from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getSymbolWithHtmlEntities(inout_file)">getSymbolWithHtmlEntities</a></dt>
      <dd>Reads a symbol, where html entities are allowed, from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getHtmlTagSymbolOrComment(inout_file)">getHtmlTagSymbolOrComment</a></dt>
      <dd>Reads a HTML tag, a symbol or a comment from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#skipXmlComment(inout_file)">skipXmlComment</a></dt>
      <dd>Skips a XML comment from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getXmlTagOrContent(inout_file)">getXmlTagOrContent</a></dt>
      <dd>Reads a XML/HTML tag or the XML/HTML content text from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getXmlCharacterReference(inout_file)">getXmlCharacterReference</a></dt>
      <dd>Reads a predefined XML entity from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getXmlCdataContent(inout_file)">getXmlCdataContent</a></dt>
      <dd>Read the content text of a CDATA section from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getXmlTagHeadOrContent(inout_file)">getXmlTagHeadOrContent</a></dt>
      <dd>Reads a XML/HTML tag head or a XML/HTML content from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getSymbolInXmlTag(inout_file)">getSymbolInXmlTag</a></dt>
      <dd>Reads a symbol which can appear inside a XML/HTML tag from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#skipXmlTag(inout_file)">skipXmlTag</a></dt>
      <dd>Skips beyond an XML Tag in a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getNextXmlAttribute(inout_file,inout_string,inout_string)">getNextXmlAttribute</a></dt>
      <dd>Reads name and value of an attribute inside a XML tag from <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getHtmlAttributeValue(inout_file)">getHtmlAttributeValue</a></dt>
      <dd>Reads a HTML tag attribute value from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getNextHtmlAttribute(inout_file,inout_string,inout_string)">getNextHtmlAttribute</a></dt>
      <dd>Reads name and value of an attribute inside a HTML tag from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
    <dt><a class="func" href="../libraries/scanfile.htm#getSimpleSymbol(inout_file)">getSimpleSymbol</a></dt>
      <dd>Reads a simple symbol from a <tt><a class="type" href="types.htm#file">file</a></tt>.</dd>
</dl><p>
  All scanner functions assume that the first character to be
  processed is in <tt>'bufferChar'</tt> and after they are finished the next
  character which should be processed is also in <tt>'bufferChar'</tt>.
  To use scanner functions for a new opened file it is necessary to
  assign the first character to the <tt>'bufferChar'</tt> with:
</p><pre class="indent">
myFile.bufferChar := getc(myFile);
</pre><p>
  In most cases whole files are either processed with normal I/O
  functions or with scanner functions. If normal I/O functions
  need to be combined with scanner functions care has to be taken:
</p><ul>
    <li>If the last function which read from a file was
      one of <tt><a class="func" href="../libraries/file.htm#read(inout_file,inout_string)">read</a></tt>, <tt><a class="func" href="../libraries/file.htm#readln(inout_file,inout_string)">readln</a></tt>, <tt><a class="func" href="../libraries/file.htm#getwd(inout_file)">getwd</a></tt> or <tt><a class="func" href="../libraries/file.htm#getln(inout_file)">getln</a></tt>
      the <tt>'bufferChar'</tt> already contains the character which
      should be processed next and therefore subsequent scanner
      functions can be used.</li>

    <li>Other I/O functions like <tt><a class="func" href="../libraries/file.htm#getc(inout_file)">getc</a></tt> and <tt><a class="func" href="../libraries/file.htm#gets(inout_file,in_integer)">gets</a></tt>
      do not assign something to <tt>'bufferChar'</tt>. In this
      case something should be assigned to <tt>'bufferChar'</tt>.</li>

    <li>Switching back from scanner functions to
      normal I/O functions is best done when the content of
      <tt>'bufferChar'</tt> is known. For example at the end
      of the line.</li>
</ul><p>
  Scanner functions are helpful if it is necessary to read
  numeric input without failing if no digits are present:
</p><pre class="indent">
skipWhiteSpace(<a class="var" href="../libraries/stdio.htm#IN">IN</a>);
<span class="keywd">if</span> eoln(<a class="var" href="../libraries/stdio.htm#IN">IN</a>) <span class="keywd">then</span>
  writeln("empty input");
<span class="keywd">elsif</span> <a class="var" href="../libraries/stdio.htm#IN">IN</a>.bufferChar <span class="keywd">in</span> {'0' .. '9'} <span class="keywd">then</span>
  number := <span class="type">integer</span> <span class="op">parse</span> getDigits(<a class="var" href="../libraries/stdio.htm#IN">IN</a>);
  skipLine(<a class="var" href="../libraries/stdio.htm#IN">IN</a>);
  writeln("number " &lt;&amp; number);
<span class="keywd">else</span>
  stri := getLine(<a class="var" href="../libraries/stdio.htm#IN">IN</a>);
  writeln("command " &lt;&amp; literal(stri));
<span class="keywd">end if</span>;
</pre><p>
  The function <tt><a class="func" href="../libraries/scanfile.htm#getSymbol(inout_file)">getSymbol</a></tt> is designed to read Seed7 symbols. When
  the end of the file is reached it returns <tt><span class="stri">""</span></tt>.
  With <tt><a class="func" href="../libraries/scanfile.htm#getSymbol(inout_file)">getSymbol</a></tt> name-value pairs can be read:
</p><pre class="indent">
name := getSymbol(inFile);
<span class="keywd">while</span> name &lt;> <span class="stri">""</span> <span class="keywd">do</span>
  <span class="keywd">if</span> name &lt;> <span class="stri">"#"</span> <span class="keywd">and</span> getSymbol(inFile) = <span class="stri">"="</span> <span class="keywd">then</span>
    aValue = getSymbol(inFile);
    <span class="keywd">if</span> aValue &lt;> <span class="stri">""</span> <span class="keywd">then</span>
      <span class="keywd">if</span> aValue[1] = <span class="stri">'"'</span> <span class="keywd">then</span>
        keyValueHash @:= [name] aValue[2 ..];
      <span class="keywd">elsif</span> aValue[1] <span class="keywd">in</span> {<span class="stri">'0'</span> .. <span class="stri">'9'</span>} <span class="keywd">then</span>
        keyValueHash @:= [name] aValue;
      <span class="keywd">end if</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end if</span>;
<span class="keywd">end while</span>;
</pre><p>
  The following loop can be used to process the symbols of a Seed7 program:
</p><pre class="indent">
inFile.bufferChar := getc(inFile);
currSymbol := getSymbol(inFile);
<span class="keywd">while</span> currSymbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
  ... process currSymbol ...
  currSymbol := getSymbol(inFile);
<span class="keywd">end while</span>;
</pre><p>
  Whitespace and comments are automatically skipped with the
  function <tt><a class="func" href="../libraries/scanfile.htm#getSymbol(inout_file)">getSymbol</a></tt>. If comments should also be returned the
  function <tt><a class="func" href="../libraries/scanfile.htm#getSymbolOrComment(inout_file)">getSymbolOrComment</a></tt> can be used. Together with the
  function <tt><a class="func" href="../libraries/scanfile.htm#getWhiteSpace(inout_file)">getWhiteSpace</a></tt> it is even possible to get the
  whitespace between the symbols:
</p><pre class="indent">
<span class="keywd">const</span> <span class="type">func string</span>: processFile (<span class="keywd">in</span> <span class="type">string</span>: fileName) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <span class="type">string</span>: processed <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#file">file</a>: inFile <span class="keywd">is</span> <a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a>;
    <span class="keywd">var</span> <span class="type">string</span>: currSymbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    inFile := open(fileName, <span class="stri">"r"</span>);
    <span class="keywd">if</span> inFile &lt;> <a class="var" href="../libraries/null_file.htm#STD_NULL">STD_NULL</a> <span class="keywd">then</span>
      inFile.bufferChar := getc(inFile);
      processed := getWhiteSpace(inFile);
      currSymbol := getSymbolOrComment(inFile);
      <span class="keywd">while</span> currSymbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
        processed &amp;:= currSymbol;
        processed &amp;:= getWhiteSpace(inFile);
        currSymbol := getSymbolOrComment(inFile);
      <span class="keywd">end while</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  In the example above the function <tt>'processFile'</tt> gathers all
  symbols, whitespace and comments in the string it returns. The
  string returned by <tt>'processFile'</tt> is equivalent to the one
  returned by the function <tt>'getf'</tt>. That way it is easy to test
  the scanner functionality.
</p><p>
  The logic with <tt><a class="func" href="../libraries/scanfile.htm#getWhiteSpace(inout_file)">getWhiteSpace</a></tt> and <tt><a class="func" href="../libraries/scanfile.htm#getSymbolOrComment(inout_file)">getSymbolOrComment</a></tt> can be used
  to add HTML tags to comments and literals. The following function
  colors comments with green, string and char literals with maroon and
  numeric literals with purple:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: sourceToHtml (<span class="keywd">inout</span> <a class="type" href="types.htm#file">file</a>: inFile, <span class="keywd">inout</span> <a class="type" href="types.htm#file">file</a>: outFile) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">string</span>: currSymbol <span class="keywd">is</span> <span class="stri">""</span>;
  <span class="keywd">begin</span>
    inFile.bufferChar := getc(inFile);
    write(outFile, <span class="stri">"&lt;pre>\n"</span>);
    write(outFile, getWhiteSpace(inFile));
    currSymbol := getSymbolOrComment(inFile);
    <span class="keywd">while</span> currSymbol &lt;> <span class="stri">""</span> <span class="keywd">do</span>
      currSymbol := replace(currSymbol, <span class="stri">"&amp;"</span>, <span class="stri">"&amp;amp;"</span>);
      currSymbol := replace(currSymbol, <span class="stri">"&lt;"</span>, <span class="stri">"&amp;lt;"</span>);
      <span class="keywd">if</span> currSymbol[1] <span class="keywd">in</span> {<span class="stri">'"'</span>, <span class="stri">'''</span>} <span class="keywd">then</span>
        write(outFile, <span class="stri">"&lt;font color=\"maroon\">"</span>);
        write(outFile, currSymbol);
        write(outFile, <span class="stri">"&lt;/font>"</span>);
      <span class="keywd">elsif</span> currSymbol[1] = <span class="stri">'#'</span> <span class="keywd">or</span> startsWith(currSymbol, <span class="stri">"(*"</span>) <span class="keywd">then</span>
        write(outFile, <span class="stri">"&lt;font color=\"green\">"</span>);
        write(outFile, currSymbol);
        write(outFile, <span class="stri">"&lt;/font>"</span>);
      <span class="keywd">elsif</span> currSymbol[1] <span class="keywd">in</span> digit_char <span class="keywd">then</span>
        write(outFile, <span class="stri">"&lt;font color=\"purple\">"</span>);
        write(outFile, currSymbol);
        write(outFile, <span class="stri">"&lt;/font>"</span>);
      <span class="keywd">else</span>
        write(outFile, currSymbol);
      <span class="keywd">end if</span>;
      write(outFile, getWhiteSpace(inFile));
      currSymbol := getSymbolOrComment(inFile);
    <span class="keywd">end while</span>;
    write(outFile, <span class="stri">"&lt;/pre>\n"</span>);
  <span class="keywd">end func</span>;
</pre><p>
  The functions <tt><a class="func" href="../libraries/scanfile.htm#skipSpace(inout_file)">skipSpace</a></tt> and <tt><a class="func" href="../libraries/scanfile.htm#skipWhiteSpace(inout_file)">skipWhiteSpace</a></tt> are defined in
  the <span class="stri">"<a class="lib" href="../libraries/scanfile.htm">scanfile.s7i</a>"</span> library as follows:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: skipSpace (<span class="keywd">inout</span> <a class="type" href="types.htm#file">file</a>: inFile) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#char">char</a>: ch <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    ch := inFile.bufferChar;
    <span class="keywd">while</span> ch = ' ' <span class="keywd">do</span>
      ch := getc(inFile);
    <span class="keywd">end while</span>;
    inFile.bufferChar := ch;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: skipWhiteSpace (<span class="keywd">inout</span> <a class="type" href="types.htm#file">file</a>: inFile) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">while</span> inFile.bufferChar <span class="keywd">in</span> white_space_char <span class="keywd">do</span>
      inFile.bufferChar := getc(inFile);
    <span class="keywd">end while</span>;
  <span class="keywd">end func</span>;
</pre><p>
  The functions <tt><a class="func" href="../libraries/scanfile.htm#skipComment(inout_file)">skipComment</a></tt> and <tt><a class="func" href="../libraries/scanfile.htm#skipLineComment(inout_file)">skipLineComment</a></tt>, which can be
  used to skip Seed7 comments, are defined as follows:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: skipComment (<span class="keywd">inout</span> <a class="type" href="types.htm#file">file</a>: inFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: character <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    character := getc(inFile);
    <span class="keywd">repeat</span>
      <span class="keywd">repeat</span>
        <span class="keywd">while</span> character <span class="keywd">not</span> <span class="keywd">in</span> special_comment_char <span class="keywd">do</span>
          character := getc(inFile);
        <span class="keywd">end</span> <span class="keywd">while</span>;
        <span class="keywd">if</span> character = <span class="stri">'('</span> <span class="keywd">then</span>
          character := getc(inFile);
          <span class="keywd">if</span> character = <span class="stri">'*'</span> <span class="keywd">then</span>
            skipComment(inFile);
            character := getc(inFile);
          <span class="keywd">end</span> <span class="keywd">if</span>;
        <span class="keywd">end</span> <span class="keywd">if</span>;
      <span class="keywd">until</span> character = <span class="stri">'*'</span> <span class="keywd">or</span> character = <a class="var" href="../libraries/char.htm#EOF">EOF</a>;
      <span class="keywd">if</span> character &lt;> <a class="var" href="../libraries/char.htm#EOF">EOF</a> <span class="keywd">then</span>
        character := getc(inFile);
      <span class="keywd">end</span> <span class="keywd">if</span>;
    <span class="keywd">until</span> character = <span class="stri">')'</span> <span class="keywd">or</span> character = <a class="var" href="../libraries/char.htm#EOF">EOF</a>;
    <span class="keywd">if</span> character = <a class="var" href="../libraries/char.htm#EOF">EOF</a> <span class="keywd">then</span>
      inFile.bufferChar := <a class="var" href="../libraries/char.htm#EOF">EOF</a>;
    <span class="keywd">else</span>
      inFile.bufferChar := getc(inFile);
    <span class="keywd">end</span> <span class="keywd">if</span>;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># skipComment</span>

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: skipLineComment (<span class="keywd">inout</span> <a class="type" href="types.htm#file">file</a>: inFile) <span class="keywd">is</span> <span class="keywd">func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">char</span>: character <span class="keywd">is</span> <span class="stri">' '</span>;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      character := getc(inFile);
    <span class="keywd">until</span> character = <span class="stri">'\n'</span> <span class="keywd">or</span> character = <a class="var" href="../libraries/char.htm#EOF">EOF</a>;
    inFile.bufferChar := character;
  <span class="keywd">end</span> <span class="keywd">func</span>; <span class="comment"># skipLineComment</span>
</pre><p></p>
<table width="100%" cellpadding="0" cellspacing="0">
<tr>
<td align="left" width="60%">
<b><big><hr \></big></b></td>
<td align="right">
<table border="0" cellspacing="1" bgcolor="blue">
<tr bgcolor="gainsboro">
<td>&nbsp;<a class="navigation" href="../manual/objects.htm">previous</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../manual/index.htm">up</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../manual/syntax.htm">next</a>&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</div>
  </body>
</html>
