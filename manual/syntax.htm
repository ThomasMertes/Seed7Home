<html>
<head>
<meta charset="utf-8" />
<title>
Seed7 Manual: Structured syntax definition</title>
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body style="margin:0 0 0 0;">
<div style="background-image: url('../images/header1x.png');" class="top_image">
<img style="overflow:hidden;" src="../images/hearts7m.png" height="68" width="50"
 /><img style="overflow:hidden;" src="../images/header3.png" height="68" width="745" />
</div>
<div style="background-image: url('../images/fillpix.png');" class="space_below_top_image">
</div>
<div class="menu">

<a class="head" href="../index.htm"><big>Seed7</big></a>
<a class="menu" href="../faq.htm">FAQ</a>
<a class="menu" href="../manual/index.htm">Manual</a>
<a class="menu" href="../scrshots/index.htm">Programs</a>
<a class="menu" href="../examples/index.htm">Examples</a>
<a class="menu" href="../libraries/index.htm">Libraries</a>
<a class="menu" href="../algorith/index.htm">Algorithms</a>
<a class="menu" href="../benchmks/index.htm">Benchmarks</a>
<a class="menu" href="../subject_index.htm">Index</a>
<a class="menu" href="http://sourceforge.net/project/showfiles.php?group_id=151126">Download</a>
<a class="menu" href="https://github.com/ThomasMertes/seed7">GitHub</a>
<a class="menu" href="../build.htm">Build Seed7</a>
<a class="menu" href="../links.htm">Links</a>

<br />

<a class="head" href="index.htm"><big>Manual</big></a>
<a class="menu" href="intro.htm">Introduction</a>
<a class="menu" href="tutorial.htm">Tutorial</a>
<a class="menu" href="decls.htm">Declarations</a>
<a class="menu" href="stats.htm">Statements</a>
<a class="menu" href="types.htm">Types</a>
<a class="menu" href="params.htm">Parameters</a>
<a class="menu" href="objects.htm">Objects</a>
<a class="menu" href="file.htm">File I/O</a>
<a class="menu" href="syntax.htm">Syntax</a>
<a class="menu" href="tokens.htm">Tokens</a>
<a class="menu" href="expr.htm">Expressions</a>
<a class="menu" href="os.htm">OS&nbsp;access</a>
<a class="menu" href="database.htm">Database</a>
<a class="menu" href="graphic.htm">Graphic</a>
<a class="menu" href="actions.htm">Actions</a>
<a class="menu" href="ffi.htm">Foreign&nbsp;funcs</a>
<a class="menu" href="errors.htm">Errors</a>

<br />

<a class="head" href="#STRUCTURED_SYNTAX_DEFINITION"><big>Syntax</big></a>
<a class="menu" href="#The_Extended_Backus-Naur_Form">EBNF</a>
<a class="menu" href="syntax.htm#The_Seed7_Structured_Syntax_Description">S7SSD</a>
<a class="menu" href="#The_syntax_of_a_statement">Statement</a>
<a class="menu" href="#Priority_and_associativity">Priority</a>
<a class="menu" href="#The_syntax_of_operators">Operators</a>
<a class="menu" href="#Syntax_of_predefined_statements">predefined</a>
<a class="menu" href="#Advanced_syntax_definitions">advanced</a>
<a class="menu" href="#Comparison_of_EBNF_and_S7SSD">Comparison</a>
</div>
<div class="content">
<div style="padding-right:20;">
<table width="100%" cellpadding="0" cellspacing="0">
<tr>
<td align="left" width="80">
<a class="head" href="index.htm"><big>Manual</big></a>
</td>
<td>
<table width="10">
</table>
</td>
<td align="left" width="60%">
<b><big>Syntax</big></b></td>
<td align="right">
<table border="0" cellspacing="1" bgcolor="blue">
<tr bgcolor="gainsboro">
<td>&nbsp;<a class="navigation" href="../manual/file.htm">previous</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../manual/index.htm">up</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../manual/tokens.htm">next</a>&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
<a name="file_start"></a><p></p>
<a name="STRUCTURED_SYNTAX_DEFINITION"><h2>9. STRUCTURED SYNTAX DEFINITION</h2></a>

<p>
    Most programming languages have only predefined constructs like
  statements and operators. Seed7, on the other hand, additionally
  allows user defined constructs. This chapter introduces the Seed7
  Structured Syntax Description (S7SSD) which is used to define the
  syntax of new constructs. The syntax of predefined constructs is
  also defined with S7SSD.
</p><p>
    The syntax descriptions used in manuals of conventional
  programming languages have no relationship to the approach used by
  the syntax analysis of the corresponding interpreters/compilers.
  S7SSD is a simple syntax description that can be used by humans
  and compilers/interpreters. Although compiler-compilers follow the
  path of machine readable syntax descriptions, they use much more
  complicated syntax and semantic descriptions and do not allow
  users of the language to define new constructs.
</p><p>
    There are different existing notations to specify the syntax of
  programming languages. Backus-Naur Form (BNF) and its variants
  like Extended Backus-Naur Form (EBNF) are examples of such syntax
  specifications. Since it is easier to understand new concepts if
  they are compared to well known concepts, EBNF will be used as a
  base to explain S7SSD.
</p>

<a name="The_Extended_Backus-Naur_Form"><h3>9.1 The Extended Backus-Naur Form</h3></a>
<p>
    As the name says the Extended Backus-Naur Form is an extension
  of BNF. The extension allows the definition of repetitions and
  optional parts without the use of recursion. EBNF has the
  following elements:
</p><ul>
    <li>Nonterminal symbols are described with identifiers. An
      identifier consist of lower case letters and underline
      characters.</li>

    <li>Terminal symbols are quoted strings or names in upper case
      characters, which describe unprintable characters (control
      characters).</li>

    <li>The concatenation of nonterminal and/or terminal symbols is
      described by writing them in sequence.</li>

    <li>With | two alternatives can be separated.</li>

    <li>Expressions of the extended Backus-Naur form can be put within
      parentheses ( ... ) .</li>

    <li>If an expression is optional it is enclosed in square
      brackets [ ... ] .</li>

    <li>If an expression may be omitted or repeated it is
      enclosed in curly braces { ... } .</li>
</ul><p>
  The syntax of the extended Backus-Naur form can be described in
  extended Backus-Naur form:
</p><dl><dd><tt><dl>
    <dt>syntax_description ::=</dt><dd>
      { <a class="ebnf" href="#ebnf_ebnf_statement">ebnf_statement</a> } .</dd>
<dt><br /></dt>
    <dt><a name="ebnf_ebnf_statement">ebnf_statement</a> ::=</dt><dd>
      identifier '::=' <a class="ebnf" href="#ebnf_ebnf_expression">ebnf_expression</a> '.' .</dd>
<dt><br /></dt>
    <dt><a name="ebnf_ebnf_expression">ebnf_expression</a> ::=</dt><dd>
      <a class="ebnf" href="#ebnf_ebnf_term">term</a> { '|' <a class="ebnf" href="#ebnf_ebnf_term">term</a> } .</dd>
<dt><br /></dt>
    <dt><a name="ebnf_ebnf_term">term</a> ::=</dt><dd>
      <a class="ebnf" href="#ebnf_ebnf_factor">factor</a> { <a class="ebnf" href="#ebnf_ebnf_factor">factor</a> } .</dd>
<dt><br /></dt>
    <dt><a name="ebnf_ebnf_factor">factor</a> ::=</dt><dd>
      identifier | string | control_character_description |<br />
      '(' <a class="ebnf" href="#ebnf_ebnf_expression">ebnf_expression</a> ')' | '[' <a class="ebnf" href="#ebnf_ebnf_expression">ebnf_expression</a> ']' |<br />
      '{' <a class="ebnf" href="#ebnf_ebnf_expression">ebnf_expression</a> '}' .</dd>
</dl></tt></dd></dl><p></p>

<a name="The_Seed7_Structured_Syntax_Description"><h3>9.2 The Seed7 Structured Syntax Description</h3></a>
<p>
    The Seed7 Structured Syntax Description is abbreviated with S7SSD.
  The S7SSD can describe most but not all of the syntax of a
  programming language. The syntax of identifiers, literals and
  comments is not described with S7SSD. S7SSD views a program as
  a big typeless expression. The syntax of this expression is
  described with prefix, infix and postfix operators. The operators
  have a priority and an associativity. Operators can have one or
  more operator symbols. The operator symbols of an operator can be
  adjacent or they can have parameters in between. The S7SSD of
  an infix <tt>+</tt> is:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .(). + .()   <span class="keywd">is</span> <a class="op_no_ul" href="#left_associative">-></a> 7;
</pre><p>
  This defines the <tt>+</tt> as <a class="link" href="#left_associative">left associative</a> infix operator with
  priority 7. The actual syntax is described with:
</p><pre class="indent">
. () . + . ()
</pre><p>
  The dots are used to create a list of elements. For the purpose of
  the syntax description we can just remove the dots, which gives:
</p><pre class="indent">
() + ()
</pre><p>
  The place of the parameters is specified with <tt>()</tt>. The <tt>+</tt> operator
  is an infix operator, because the <tt>+</tt> is preceded and succeeded by
  a <tt>()</tt>. Any expression can be used as <tt>()</tt> parameter. The type of the
  <tt>()</tt> parameters and the type of the result of <tt>+</tt> is not specified by
  the S7SSD. Checks for the correct type are not done at the syntactic
  level. This way S7SSD allows syntax that would not be allowed in a
  corresponding EBNF description. S7SSD considers just operator
  symbols and their priority and associativity.
</p>

<a name="The_syntax_of_a_statement"><h3>9.3 The syntax of a statement</h3></a>
<p>
    To explain the Seed7 Structured Syntax Description we design a
  new statement, the <a class="link" href="#The_syntax_of_a_statement">loop-statement</a>. The <a class="link" href="#The_syntax_of_a_statement">loop-statement</a> should
  be similar to <a class="link" href="stats.htm#while-statement">while-</a> and <a class="link" href="stats.htm#repeat-statement">repeat-loops</a> but instead of having
  the conditional exit at the beginning or at the end, it should
  have a conditional exit in the middle of the loop. This middle
  conditional exit should be part of the <a class="link" href="#The_syntax_of_a_statement">loop-statement</a>. Note that
  the break-statement, which exists in some programming languages,
  is a statement on its own and is not part of the loop which it
  leaves. Therefore the middle conditional exit should not be
  confused with a break-statement. An example of the new <a class="link" href="#The_syntax_of_a_statement">loop-statement</a>
  is:
<p><pre class="indent">
<span class="keywd">loop</span>
  ch <a class="op_no_ul" href="stats.htm#Assignment">:=</a> <a class="func_no_ul" href="../libraries/file.htm#getc(inout_file)">getc</a>(inFile);
<span class="keywd">until</span> ch <a class="op_no_ul" href="../libraries/char.htm#(in_char)=(in_char)">=</a> <span class="stri">'\n'</span> <span class="keywd">do</span>
  stri <a class="op_no_ul" href="../libraries/string.htm#(inout_string)&:=(in_char)">&amp;:=</a> ch;
<span class="keywd">end loop</span>;
</pre><p>
  The <tt>'<span class="keywd">loop</span>'</tt> example above reads characters from a file and
  concatenates them to a string until the character <tt><span class="stri">'\n'</span></tt> is read.
  The <tt><span class="stri">'\n'</span></tt> ends the loop. Hence it is not added to the string.
  An equivalent solution without the usage of the <a class="link" href="#The_syntax_of_a_statement">loop-statement</a>
  would be:
<p><pre class="indent">
<span class="keywd">repeat</span>
  ch <a class="op_no_ul" href="stats.htm#Assignment">:=</a> <a class="func_no_ul" href="../libraries/file.htm#getc(inout_file)">getc</a>(inFile);
  <span class="keywd">if</span> ch <a class="op_no_ul" href="../libraries/char.htm#(in_char)<>(in_char)">&lt;></a> <span class="stri">'\n'</span> <span class="keywd">then</span>
    stri <a class="op_no_ul" href="../libraries/string.htm#(inout_string)&:=(in_char)">&amp;:=</a> ch;
  <span class="keywd">end if</span>;
<span class="keywd">until</span> ch <a class="op_no_ul" href="../libraries/char.htm#(in_char)=(in_char)">=</a> <span class="stri">'\n'</span>;
</pre><p>
  The S7SSD of the <a class="link" href="#The_syntax_of_a_statement">loop-statement</a> is:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .loop.().until.().do.().end.loop   <span class="keywd">is</span> <a class="op_no_ul" href="#left_associative">-></a> 25;
</pre><p>
  The details of the S7SSD <tt>'<span class="keywd">syntax</span>'</tt> definition will be explained
  later. For now we concentrate at the heart of the S7SSD, the
  expression:
</p><pre class="indent">
.loop.().until.().do.().end.loop
</pre><p>
  For the purpose of the syntax description we can just remove the
  dots, which gives:
</p><pre class="indent">
 loop () until () do () end loop
</pre><p>
  This are the keywords used in a <a class="link" href="#The_syntax_of_a_statement">loop-statement</a>. The symbol <tt>()</tt>
  acts as placeholder for an expression.
  With EBNF the <a class="link" href="#The_syntax_of_a_statement">loop-statement</a> can be described as:
</p><dl><dd><tt><dl>
    <dt>loop_statement ::=</dt><dd>
      '<span class="keywd">loop</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="stats.htm#ebnf_statement">statement</a><br />
      '<span class="keywd">until</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> '<span class="keywd">do</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="stats.htm#ebnf_statement">statement</a><br />
      '<span class="keywd">end</span>' '<span class="keywd">loop</span>' .</dd>
</dl></tt></dd></dl><p>
  An EBNF description may use many nonterminal symbols such as
  <tt>'<a class="ebnf" href="stats.htm#ebnf_statement">statement</a>'</tt> or <tt>'<a class="ebnf" href="expr.htm#ebnf_expression">expression</a>'</tt>. S7SSD does not distinguish
  between different nonterminal symbols. Instead S7SSD only
  knows one nonterminal symbol: <tt>()</tt>
</p><p>
  Therefore S7SSD cannot distinguish between <tt>'<a class="ebnf" href="stats.htm#ebnf_statement">statement</a>'</tt>,
  <tt>'<a class="ebnf" href="expr.htm#ebnf_expression">expression</a>'</tt> or something else. At the syntax level any kind of
  expression can by substituted for a S7SSD nonterminal symbol <tt>()</tt>.
  With EBNF it is possible to describe constraints such as the type
  of an expression. S7SSD relies on semantic checks to verify
  such constraints. Given the S7SSD of the <a class="link" href="#The_syntax_of_a_statement">loop-statement</a> an
  expression like
</p><pre class="indent">
<span class="keywd">loop</span>
  <span class="stri">"X"</span>
<span class="keywd">until</span> 1+2 <span class="keywd">do</span>
  <a class="type" href="types.htm#integer">integer</a>
<span class="keywd">end loop</span>
</pre><p>
  would be legal as it contains the required keywords
</p><pre class="indent">
<span class="keywd">loop</span>  <span class="keywd">until</span>  <span class="keywd">do</span>  <span class="keywd">end</span>  <span class="keywd">loop</span>
</pre><p>
  and the expressions
</p><pre class="indent">
<span class="stri">"X"</span>  1+2  <a class="type" href="types.htm#integer">integer</a>
</pre><p>
  at the places of the <tt>()</tt> symbols. This is exactly what the syntax
  definition specifies, but it would be not be considered correct
  given the description of the <a class="link" href="#The_syntax_of_a_statement">loop-statement</a> at the beginning of
  the chapter. To determine which types of expressions are allowed
  at the places of the <tt>()</tt> symbol, a semantic definition of the
  <a class="link" href="#The_syntax_of_a_statement">loop-statement</a> is necessary. A semantic definition is just a
  function definition which uses the keywords and parameters from
  the syntax definition. The definition of the <tt>'<span class="keywd">loop</span>'</tt> function
  (semantic definition of the <a class="link" href="#The_syntax_of_a_statement">loop-statement</a>) is:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: loop
              (<span class="keywd">in</span> <a class="type" href="types.htm#proc">proc</a>: statements1)
            until (<span class="keywd">in</span> <a class="type" href="types.htm#func">func</a> <a class="type" href="types.htm#boolean">boolean</a>: condition) do
              (<span class="keywd">in</span> <a class="type" href="types.htm#proc">proc</a>: statements2)
            end loop <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#boolean">boolean</a>: exitLoop <span class="keywd">is</span> FALSE;
  <span class="keywd">begin</span>
    <span class="keywd">repeat</span>
      statements1;
      <span class="keywd">if</span> <span class="op">not</span> condition <span class="keywd">then</span>
        statements2;
      <span class="keywd">else</span>
        exitLoop := TRUE;
      <span class="keywd">end if</span>;
    <span class="keywd">until</span> exitLoop;
  <span class="keywd">end func</span>;
</pre><p>
  This definition determines the types of the expressions accepted
  between the keywords. Besides that the semantic definition of the
  <a class="link" href="#The_syntax_of_a_statement">loop-statement</a> is just a normal function definition. Note that
  the sequence of keywords and parameters in the header of this
  function definition is determined by the corresponding syntax
  definition.
</p><p>
  The parameters <tt>'statements1'</tt>, <tt>'condition'</tt> and <tt>'statements2'</tt> are
  call-by-name parameters. A call-by-name parameter is a function
  without parameters. Function types such as <tt><a class="type" href="types.htm#proc">proc</a></tt> or <tt><a class="type" href="types.htm#func">func</a> <a class="type" href="types.htm#boolean">boolean</a></tt>
  are used as type of formal call-by-name parameters. An expression
  with the correct type is allowed as actual call-by-name parameter.
  This actual parameter expression is not evaluated when the
  function is called. Instead the expression is evaluated every time
  the formal call-by-name parameter is used. This way <tt>'statements1'</tt>,
  <tt>'condition'</tt> and <tt>'statements2'</tt> are not executed when the <tt>'<span class="keywd">loop</span>'</tt>
  function is called. Inside the body of the <tt>'<span class="keywd">loop</span>'</tt> function the
  call-by-name parameters are executed at some places.
</p><p>
  The <tt>'<span class="keywd">loop</span>'</tt> function uses a <a class="link" href="stats.htm#repeat-statement">repeat-</a> and an <a class="link" href="stats.htm#if-statement">if-statement</a> to
  implement the desired behavior. If necessary the call-by-name
  parameters are executed several times.
</p><p>
  For the <tt>'<span class="keywd">loop</span>'</tt> example with the semantic errors (see above) we
  would get an error message like:
</p><pre class="indent">
*** chkloop.sd7(35):51: <a class="link" href="errors.htm#NO_MATCH">Match for {loop "X" until {1 + 2 } do integer end loop } failed</a>
</pre><p></p>

<a name="Priority_and_associativity"><h3>9.4 Priority and associativity</h3></a>
<p>
    If a syntax construct has parameters before the first symbol or
  after the last symbol the priority and the associativity of the
  construct are significant. Constructs with stronger priority bind
  their parameters earlier than constructs with weaker priority. The
  priority is described by a natural number (inclusive 0). The
  strongest priority is 0. Weaker priorities are described by larger
  numbers. What bind means is can be explained with an example:
</p><pre class="box">
                                      =
    A = B + C * D                    / \
                                    A   +
    * priority  6                      / \
    + priority  7                     B   *
    = priority 12                        / \
                                        C   D
</pre><p>
  The * operator has the strongest priority (6) of all operators
  involved. Therefore the <tt><span class="op">*</span></tt> takes its parameters first. Then
  the <tt><span class="op">+</span></tt> (with priority 7) and at last the <tt><span class="op">=</span></tt> (with priority 12)
  follows. This leads to the following interpretation of
  the expression:
</p><pre class="indent">
A = (B + (C * D))
</pre><p>
  The associativity describes, in which order constructs with equal
  priority bind their parameters. For example
</p><pre class="indent">
A - B - C
</pre><p>
  can be interpreted in two ways:
</p><pre class="indent">
(A - B) - C    or   A - (B - C)
</pre><p>
  The first interpretation is usually preferred by mathematicians
  and is described with the associativity <tt><a class="op_no_ul" href="#left_associative">-></a></tt> . Generally four
  associativities are possible:
</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
    
    <tr><th align="left"> Associativity                             </th><th> Symbol </th></tr>
    
    <tr><td> <a name="left_associative">Binding from left to right</a>                </td><td align="center">   <tt><span class="op">-></span></tt>   </td></tr>
    
    <tr><td> <a name="right_associative">Binding from right to left</a>                </td><td align="center">   <tt><span class="op">&lt;-</span></tt>   </td></tr>
    
    <tr><td> Neither the left nor the right parameter          
     are allowed to have the same priority     </td><td align="center">   <tt><span class="op">&lt;-></span></tt>  </td></tr>
    
    <tr><td> At the left side there is a binding from          
     left to right and at the right side there         
     is a binding from right to left           </td><td align="center">  <tt><span class="op">->&lt;-</span></tt>  </td></tr>
    
</table></dd></dl><p>
  The last two possibilities give no legal interpretation in the
  subtraction example. The third kind of associativity ( <tt><span class="op">&lt;-></span></tt> ) is
  used by the equal operator ( <tt><span class="op">=</span></tt> ) of Pascal because there an
  expression like
</p><pre class="indent">
A = B = C
</pre><p>
  is not legal.
</p><p>
  There is a second way to describe the associativity. The
  associativity describes, if an operand must have a stronger
  priority than the priority of the operator. For example:
</p><pre class="box">
                             -                     7
    A - B - C              /   \                 /   \
                          /     \           &lt;=7 /     \ &lt;7
    - priority 7 <a class="op_no_ul" href="#left_associative">-></a>      /       \             /       \
                        -         C           7         0
                      /   \                 /   \
                     /     \           &lt;=7 /     \ &lt;7
                    /       \             /       \
                   A         B           0         0
</pre><p>
  The numbers in the nodes of the right tree show the priority of
  each sub expression (sub tree). With <tt><span class="op">&lt;</span></tt> and <tt><span class="op">&lt;=</span></tt> the required
  condition for the priority of an operand is described. An
  interpretation is legal if all this conditions are met. If there
  are more than one legal interpretations or no legal
  interpretation the expression is illegal.
</p><p>
  Table for the possibilities of associativity:
</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
    
    <tr><th rowspan="2"> associativity </th><th align="center" colspan="2">             The priority of the              </th></tr>
    
    <tr><th align="center"> left operand must be </th><th align="center"> right operand must be </th></tr>
    
    <tr><td align="center">      <tt><a class="op_no_ul" href="#left_associative">-></a></tt>       </td><td align="center">          <tt><span class="op">&lt;=</span></tt>          </td><td align="center">          <tt><span class="op">&lt;</span></tt>            </td></tr>
    <tr><td align="center">      <tt><a class="op_no_ul" href="#right_associative">&lt;-</a></tt>       </td><td align="center">          <tt><span class="op">&lt;</span></tt>           </td><td align="center">          <tt><span class="op">&lt;=</span></tt>           </td></tr>
    <tr><td align="center">      <tt><span class="op">&lt;-></span></tt>      </td><td align="center">          <tt><span class="op">&lt;</span></tt>           </td><td align="center">          <tt><span class="op">&lt;</span></tt>            </td></tr>
    <tr><td align="center">     <tt><span class="op">->&lt;-</span></tt>      </td><td align="center">          <tt><span class="op">&lt;=</span></tt>          </td><td align="center">          <tt><span class="op">&lt;=</span></tt>           </td></tr>
    
    <tr><td>&nbsp;              </td><td align="center" colspan="2">          than that of the operator           </td></tr>
    
</table></dd></dl><p>
  The parameter before the operator symbol is called left operand.
  The parameter after the last symbol of a construct is called
  right operand. In case of normal operators the last symbol of a
  construct and the operator symbol are identical. If this is not
  the case there is a third kind of operand. Between the operator
  symbol and the last symbol of a construct are the middle operands.
  Middle operands can have any priority.
</p>

<a name="The_syntax_of_operators"><h3>9.5 The syntax of operators</h3></a>
<p>
    A syntax definition specifies the way a usage of a statement
  or operator must be written. For example a call of the
  <tt><a class="keywd" href="../libraries/boolean.htm#not(in_boolean)">not</a></tt> operator looks like:
</p><pre class="indent">
<span class="op">not</span> okay
</pre><p>
  To describe the syntax of the <tt><a class="keywd" href="../libraries/boolean.htm#not(in_boolean)">not</a></tt> operator we write:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .not.() <span class="keywd">is</span> <a class="op_no_ul" href="#right_associative">&lt;-</a> 13;
</pre><p>
  This means that a <tt><a class="keywd" href="../libraries/boolean.htm#not(in_boolean)">not</a></tt> expression is constructed with the
  symbol <tt><a class="keywd" href="../libraries/boolean.htm#not(in_boolean)">not</a></tt> followed by a parameter. The place of the
  parameter is marked with the () sign. The syntax description
  contains no information about the types of the parameters. At
  the syntax level a parameter may be anything. With <tt><a class="op_no_ul" href="#right_associative">&lt;-</a></tt> the
  associativity of the <tt><a class="keywd" href="../libraries/boolean.htm#not(in_boolean)">not</a></tt> operator is specified as right
  associative. This means that the right operand is allowed to
  have the same priority as the operator symbol. So the
  expression
</p><pre class="indent">
<span class="op">not</span> <span class="op">not</span> okay
</pre><p>
  is legal and means
</p><pre class="indent">
<span class="op">not</span> (<span class="op">not</span> okay)
</pre><p>
  If the associativity of the <tt><a class="keywd" href="../libraries/boolean.htm#not(in_boolean)">not</a></tt> operator is specified with
  <tt><a class="op_no_ul" href="#left_associative">-></a></tt> instead of <tt><a class="op_no_ul" href="#right_associative">&lt;-</a></tt> the <tt>'<span class="op">not</span> <span class="op">not</span>'</tt> expression above is not legal.
  With 13 the priority of the whole <tt><a class="keywd" href="../libraries/boolean.htm#not(in_boolean)">not</a></tt> operator is determined.
  As convention priorities from 1 to 20 are used by operators
  and priority 25 is used by statements. Arithmetic operators
  have priorities from 1 to 11 and comparisons have priority 12.
</p><p>
  To define the <tt><a class="keywd" href="../libraries/boolean.htm#not(in_boolean)">not</a></tt> operator completely there must be also
  a semantic definition which is as follows:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#func">func</a> <a class="type" href="types.htm#boolean">boolean</a>: not (<span class="keywd">in</span> <a class="type" href="types.htm#boolean">boolean</a>: aBool) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#boolean">boolean</a>: negation <span class="keywd">is</span> TRUE;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> aBool <span class="keywd">then</span>
      negation := FALSE;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  In the declaration the <tt><a class="keywd" href="../libraries/boolean.htm#not(in_boolean)">not</a></tt> operator is written exactly
  in the same way it is written when it is called. The syntax
  definition is used at both places: declaration and call.
  The syntax and semantic declarations define precisely how
  the <tt><a class="keywd" href="../libraries/boolean.htm#not(in_boolean)">not</a></tt> operator works.
</p><p>
    As next example we try an infix operator like the <tt><a class="keywd" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a></tt> operator.
  A call of the <tt><a class="keywd" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a></tt> operator may look like:
</p><pre class="indent">
okay <span class="op">and</span> <span class="op">not</span> error
</pre><p>
  To describe the syntax of the <tt><a class="keywd" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a></tt> operator we write:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .().and.() <span class="keywd">is</span>    -> 14;
</pre><p>
  This means that an <tt><a class="keywd" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a></tt> expression is constructed with the
  symbol <tt><a class="keywd" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a></tt> surrounded by parameters. The <tt><span class="op">-></span></tt> defines the
  <tt><a class="keywd" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a></tt> operator as left associative. This means that an expression
  like
</p><pre class="indent">
A <span class="op">and</span> B <span class="op">and</span> C
</pre><p>
  is interpreted as
</p><pre class="indent">
(A <span class="op">and</span> B) <span class="op">and</span> C
</pre><p>
  With 14 the priority of the whole <tt><a class="keywd" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a></tt> operator is determined.
  Since priority 14 is weaker than the priority of the <tt><a class="keywd" href="../libraries/boolean.htm#not(in_boolean)">not</a></tt> operator
  which is 13 the example expression is evaluated as:
</p><pre class="indent">
okay <span class="op">and</span> (<span class="op">not</span> error)
</pre><p>
  Note that the expression
</p><pre class="indent">
okay <span class="op">and</span> <span class="op">not</span> error
</pre><p>
  makes no sense if the <tt><a class="keywd" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a></tt> operator has priority 12 instead of 14.
</p><p>
  S7SSD treats everything as operator description. Operators
  have priority and associativity. The priority and associativity
  determine in which succession S7SSD syntax rules get applied.
  To explain priority and associativity we use the basic arithmetic
  operations (+,-,*,/). To describe them with EBNF we can write:
</p><dl><dt></dt><dd><tt><dl>
    <dt>factor ::=</dt><dd>
      number | name .</dd>

    <dt>expression_5 ::=</dt><dd>
      factor |
      ( '+' expression_5 ) |<br />
      ( '-' expression_5 ) .</dd>

    <dt>expression_6 ::=</dt><dd>
      expression_5 |<br />
      ( expression_6 '*' expression_7 ) |<br />
      ( expression_6 '/' expression_7 ) .</dd>

    <dt>expression_7 ::=</dt><dd>
      expression_6 |<br />
      ( expression_7 '+' expression_6 ) |<br />
      ( expression_7 '-' expression_6 ) .</dd>
</dl></tt></dd></dl><p>
  This describes the following things:
</p><ul>
    <li>The operators have different priorities:<ul>
      <li>Plus and minus signs are executed first</li>
      <li>Multiplication and division are executed second.</li>
      <li>Addition and subtraction are executed last.</li></ul></li>

    <li>These priorities are exactly what we expect from an
      arithmetic expression.</li>

    <li>Additionally we see that ++2 is allowed and interpreted as
      +(+(2)) which means that the plus sign is a right-associative
      operator.</li>

    <li>We can also see that a*b*c is allowed and interpreted as
      (a*b)*c which means that the multiplication is a
      left-associative operator.</li>
</ul><p>
  All this things can also be described with S7SSD:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: . + .()      is <a class="op_no_ul" href="#right_associative">&lt;-</a>  5;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: . - .()      is <a class="op_no_ul" href="#right_associative">&lt;-</a>  5;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .(). * .()   is  <a class="op_no_ul" href="#left_associative">-></a> 6;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .(). / .()   is  <a class="op_no_ul" href="#left_associative">-></a> 6;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .(). + .()   is  <a class="op_no_ul" href="#left_associative">-></a> 7;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .(). - .()   is  <a class="op_no_ul" href="#left_associative">-></a> 7;
</pre><p>
  As we can see S7SSD is shorter as the description with EBNF.
  A syntax statement is explained as follows:
</p><ul>
    <li>The $ is used to introduce all hard coded statements.</li>

    <li>The keyword <tt>'<span class="keywd">syntax</span>'</tt> introduces a structured syntax
      description.</li>

    <li>The result of the recognized expression will have
      the type <tt><a class="type" href="types.htm#expr">expr</a></tt>. The type <tt><a class="type" href="types.htm#expr">expr</a></tt> is used between the syntax
      and the semantic analysis. The type <tt><a class="type" href="types.htm#expr">expr</a></tt> describes
      expressions which are syntactically analyzed but not
      semantically analyzed. After the semantic analysis (and
      during the runtime) the type <tt><a class="type" href="types.htm#expr">expr</a></tt> is not used.</li>

    <li>The colon ':' is used as separator between type and syntax
      description.</li>

    <li>A dot expression like <tt>'.(). * .()'</tt> is introduced (as can
      probably be guessed by the name) with a dot. For the purpose
      of the syntax description we can just remove the dots in
      our mind: <tt>'() * ()'</tt></li>

    <li>The symbol <tt>'<span class="keywd">is</span>'</tt> is used in all Seed7 declarations as
      separator between the name and the value.</li>

    <li>The associativity is described with one of the symbols
      <tt>-></tt> (left-associative), <tt>&lt;-</tt> (right-associative),
      <tt>&lt;-></tt> (not associative) and <tt>->&lt;-</tt> (both associativities).
      If there are no left or right operands, as it is the case
      for the <a class="link" href="#The_syntax_of_a_statement">loop-statement</a>, the associativity is irrelevant.</li>

    <li>Finally the priority of the syntax construct is defined with
      a integer literal like <tt>'6'</tt>. The priority <tt>'6'</tt> is used for the
      operators <tt><a class="keywd" href="../libraries/integer.htm#(in_integer)*(in_integer)">*</a></tt>, <tt><a class="keywd" href="../libraries/float.htm#(in_float)/(in_float)">/</a></tt>, <tt><a class="keywd" href="../libraries/integer.htm#(in_integer)div(in_integer)">div</a></tt>, <tt><a class="keywd" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a></tt>, <tt><a class="keywd" href="../libraries/integer.htm#(in_integer)mdiv(in_integer)">mdiv</a></tt> and <tt><a class="keywd" href="../libraries/integer.htm#(in_integer)mod(in_integer)">mod</a></tt>.</li>
</ul><p></p>

<a name="Syntax_of_predefined_statements"><h3>9.6 Syntax of predefined statements</h3></a>
<p>
    Predefined statements can also be defined with S7SSD.
  E.g.: The <a class="link" href="stats.htm#while-statement">while-statement</a>. A use of the <a class="link" href="stats.htm#while-statement">while-statement</a> is:
</p><pre class="indent">
<span class="keywd">while</span> element_index > 0 <span class="op">and</span> okay <span class="keywd">do</span>
  processElement;
  write(<span class="stri">"."</span>);
<span class="keywd">end while</span>;
</pre><p>
  To describe the syntax of the <a class="link" href="stats.htm#while-statement">while-statement</a> we write:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .while.().do.().end.while <span class="keywd">is</span> <a class="op_no_ul" href="#left_associative">-></a> 25;
</pre><p>
  This means that the <a class="link" href="stats.htm#while-statement">while-statement</a> is an expression with the
  symbols <tt>'<span class="keywd">while</span>'</tt>, <tt>'<span class="keywd">do</span>'</tt>, <tt>'<span class="keywd">end</span>'</tt> and <tt>'<span class="keywd">while</span>'</tt>. With <tt><span class="op">-></span></tt> the
  associativity of the <a class="link" href="stats.htm#while-statement">while-statement</a> is specified as left
  associative. The associativity has no meaning for the
  <a class="link" href="stats.htm#while-statement">while-statement</a> since there is no parameter before the first
  symbol or after the last symbol. The priority of the whole
  <a class="link" href="stats.htm#while-statement">while-statement</a> is 25.
</p><p>
  The semantic definition of the <a class="link" href="stats.htm#while-statement">while-statement</a> is as follows:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: while (<span class="keywd">in</span> func <a class="type" href="types.htm#boolean">boolean</a>: condition) do
    (<span class="keywd">in</span> <a class="type" href="types.htm#proc">proc</a>: statement) end while <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> condition <span class="keywd">then</span>
      statement;
      <span class="keywd">while</span> condition <span class="keywd">do</span>
        statement;
      <span class="keywd">end while</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  The syntax definition is used for the declaration and for the call.
  This declaration defines precisely how the <a class="link" href="stats.htm#while-statement">while-statement</a>
  works. It is based on the <a class="link" href="stats.htm#if-statement">if-statement</a> and uses recursion
  to emulate the repetition of the loop body.
  Another example for a syntax description is the
  <a class="link" href="stats.htm#repeat-statement">repeat-statement</a>
</p><pre class="indent">
<span class="keywd">repeat</span>
  processElement;
  write(<span class="stri">"."</span>);
<span class="keywd">until</span> element_index = 0 <span class="op">or</span> <span class="op">not</span> okay;
</pre><p>
  which has the following syntax description:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .repeat.().until.() <span class="keywd">is</span> <a class="op_no_ul" href="#left_associative">-></a> 25;
</pre><p>
  This means that the <a class="link" href="stats.htm#repeat-statement">repeat-statement</a> is an expression with
  the symbols <tt>'<span class="keywd">repeat</span>'</tt> and <tt>'<span class="keywd">until</span>'</tt> and a parameter between
  <tt>'<span class="keywd">repeat</span>'</tt> and <tt>'<span class="keywd">until</span>'</tt> and after <tt>'<span class="keywd">until</span>'</tt>. With 25 the priority
  of the whole <a class="link" href="stats.htm#repeat-statement">repeat-statement</a> is determined. With <tt><span class="op">-></span></tt> the
  associativity of the <a class="link" href="stats.htm#repeat-statement">repeat-statement</a> is specified as left
  associative. This allows priorities from 0 to 24 for the
  parameter after <tt>'<span class="keywd">until</span>'</tt>. Since statements have priority 25
  it is not possible to write a statement direct behind <tt>'<span class="keywd">until</span>'</tt>.
</p><p>
  A simple <a class="link" href="stats.htm#if-statement">if-statement</a>, without
  <tt>'<span class="keywd">elsif</span>'</tt> part, is the next example.
  A usage of this <a class="link" href="stats.htm#if-statement">if-statement</a> might be:
</p><pre class="indent">
<span class="keywd">if</span> okay <span class="keywd">then</span>
  writeln(<span class="stri">"okay"</span>);
<span class="keywd">else</span>
  writeln(<span class="stri">"not okay"</span>);
<span class="keywd">end if</span>;
</pre><p>
  As syntax description we use
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .if.().then.().end.if <span class="keywd">is</span>            <a class="op_no_ul" href="#left_associative">-></a> 25;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .if.().then.().else.().end.if <span class="keywd">is</span>    <a class="op_no_ul" href="#left_associative">-></a> 25;
</pre><p>
  Note that this description allows <a class="link" href="stats.htm#if-statement">if-statements</a> with and
  without <tt>'<span class="keywd">else</span>'</tt> parts. As semantic description we use
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: if (<span class="keywd">in</span> <a class="type" href="types.htm#boolean">boolean</a>: condition) then
              (<span class="keywd">in</span> <a class="type" href="types.htm#proc">proc</a>: statement)
            end if <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">case</span> condition <span class="keywd">of</span>
      <span class="keywd">when</span> {TRUE}: statement;
    <span class="keywd">end case</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> proc: if (<span class="keywd">in</span> <a class="type" href="types.htm#boolean">boolean</a>: condition) then
              (<span class="keywd">in</span> <a class="type" href="types.htm#proc">proc</a>: statement1)
            else
              (<span class="keywd">in</span> <a class="type" href="types.htm#proc">proc</a>: statement2)
            end if <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">case</span> condition of
      <span class="keywd">when</span> {TRUE}:  statement1;
      <span class="keywd">when</span> {FALSE}: statement2;
    <span class="keywd">end case</span>;
  <span class="keywd">end func</span>;
</pre><p>
  The two forms of the <a class="link" href="stats.htm#if-statement">if-statement</a> are based on the
  <a class="link" href="stats.htm#case-statement">case-statement</a>. A more complex <a class="link" href="stats.htm#if-statement">if-statement</a> with <tt>'<span class="keywd">elsif</span>'</tt>
  parts can be:
</p><pre class="indent">
<span class="keywd">if</span> number &lt; 0 <span class="keywd">then</span>
  write(<span class="stri">"less"</span>);
<span class="keywd">elsif</span> number = 0 <span class="keywd">then</span>
  write(<span class="stri">"equal"</span>);
<span class="keywd">else</span>
  write(<span class="stri">"greater"</span>);
<span class="keywd">end if</span>;
</pre><p>
  How to define the syntax and the semantic for this statement
  is described in the next chapter.
</p>

<a name="Advanced_syntax_definitions"><h3>9.7 Advanced syntax definitions</h3></a>
<p>
  If we want to use some special syntax which should be only
  allowed at some place we do the following:
</p><ul>
    <li>Define the special syntax with S7SSD in a way that does not
      contradict with the rest of the syntax definitions.</li>

    <li>Use semantic definitions to make sure that this syntax
      construct can only be used at the place desired.</li>
</ul><p>
  The EBNF of the <a class="link" href="stats.htm#if-statement">if-statement</a> with <tt>'<span class="keywd">elsif</span>'</tt> parts is:
</p><dl><dd><tt><dl>
    <dt>if_statement ::=</dt><dd>
      '<span class="keywd">if</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> '<span class="keywd">then</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="stats.htm#ebnf_statement">statement</a><br />
      { '<span class="keywd">elsif</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> '<span class="keywd">then</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="stats.htm#ebnf_statement">statement</a> }<br />
      [ '<span class="keywd">else</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="stats.htm#ebnf_statement">statement</a> ]<br />
      '<span class="keywd">end</span>' '<span class="keywd">if</span>' .</dd>
</dl></tt></dd></dl><p>
  The S7SSD of this <a class="link" href="stats.htm#if-statement">if-statement</a> is:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a> : .if.().then.().end.if           <span class="keywd">is</span> <a class="op_no_ul" href="#left_associative">-></a> 25;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a> : .if.().then.().().end.if        <span class="keywd">is</span> <a class="op_no_ul" href="#left_associative">-></a> 25;

$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a> : .elsif.().then.()               <span class="keywd">is</span> <a class="op_no_ul" href="#right_associative">&lt;-</a> 60;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a> : .elsif.().then.().()            <span class="keywd">is</span> <a class="op_no_ul" href="#right_associative">&lt;-</a> 60;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a> : .else.()                        <span class="keywd">is</span> <a class="op_no_ul" href="#right_associative">&lt;-</a> 60;
</pre><p>
  Instead of one rule (as EBNF does) the rule is broken into several
  S7SSD rules. This is necessary because S7SSD does not support the
  [ ] and { } notations. They are not supported for good reasons:
  They complicate the parameter lists and they are also not so easy
  to implement. On the other hand, the BNF like rules of S7SSD
  lead to semantic constructs which are easy to parse and easy to
  compile. The broken down S7SSD rules of the <a class="link" href="stats.htm#if-statement">if-statement</a>
  corresponds to the following EBNF description:
</p><dl><dd><tt><dl>
    <dt>if_statement ::=</dt><dd>
      '<span class="keywd">if</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> '<span class="keywd">then</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="stats.htm#ebnf_statement">statement</a><br />
      '<span class="keywd">end</span>' '<span class="keywd">if</span>' .</dd>
<dt><br /></dt>
    <dt>if_statement ::=</dt><dd>
      '<span class="keywd">if</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> '<span class="keywd">then</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="stats.htm#ebnf_statement">statement</a><br />
      &nbsp;&nbsp;elseif_or_else_part<br />
      '<span class="keywd">end</span>' '<span class="keywd">if</span>' .</dd>
<dt><br /></dt>
    <dt>elseif_or_else_part ::=</dt><dd>
      '<span class="keywd">elsif</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> '<span class="keywd">then</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="stats.htm#ebnf_statement">statement</a> .</dd>
<dt><br /></dt>
    <dt>elseif_or_else_part ::=</dt><dd>
      '<span class="keywd">elsif</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> '<span class="keywd">then</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="stats.htm#ebnf_statement">statement</a><br />
      &nbsp;&nbsp;elseif_or_else_part .</dd>
<dt><br /></dt>
    <dt>elseif_or_else_part ::=</dt><dd>
      '<span class="keywd">else</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="stats.htm#ebnf_statement">statement</a> .</dd>
</dl></tt></dd></dl><p>
  Since S7SSD uses only one nonterminal symbol <tt>'()'</tt> it is the job
  of the semantic level to make sure that only the right nonterminal
  symbol can be used. This is done by introducing the type
  <tt><span class="type">ELSIF_PROC</span></tt> (which corresponds to the nonterminal symbol
  <tt>'elseif_or_else_part'</tt> of the EBNF) and the type
  <tt><span class="type">ELSIF_RESULT</span></tt> (which is the result
  of the <tt><span class="type">ELSIF_PROC</span></tt>).
</p><p>
  Normally a syntax declaration can be used in many semantic
  declarations. E.g.: The syntax of the <tt>'+'</tt> operator is defined
  once and the semantic of the <tt>'+'</tt> operator is defined for the types
  <tt><a class="type" href="types.htm#integer">integer</a></tt>, <tt><a class="type" href="types.htm#bigInteger">bigInteger</a></tt>, <tt><a class="type" href="types.htm#float">float</a></tt>, <tt><a class="type" href="types.htm#integer">complex</a></tt>, ... This possibility
  is not needed for the <a class="link" href="stats.htm#if-statement">if-statement</a>. For each of the five
  S7SSD syntax rules of the <a class="link" href="stats.htm#if-statement">if-statement</a> just one
  corresponding semantic declaration is done:
</p><pre class="indent">
<span class="comment"># Semantic for the syntax: .if.().then.().end.if</span>
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: if (<span class="keywd">in</span> <a class="type" href="types.htm#boolean">boolean</a>: condition) then
              (<span class="keywd">in</span> <a class="type" href="types.htm#proc">proc</a>: statements)
            end if                                    <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">case</span> condition <span class="keywd">of</span>
      <span class="keywd">when</span> {TRUE}: statements;
    <span class="keywd">end case</span>;
  <span class="keywd">end func</span>;

<span class="comment"># Semantic for the syntax: .if.().then.().().end.if</span>
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: if (<span class="keywd">in</span> <a class="type" href="types.htm#boolean">boolean</a>: condition) then
              (<span class="keywd">in</span> <a class="type" href="types.htm#proc">proc</a>: statements)
            (<span class="keywd">in</span> <span class="type">ELSIF_PROC</span>: elsifPart)
            end if                                    <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">case</span> condition <span class="keywd">of</span>
      <span class="keywd">when</span> {TRUE}: statements;
      <span class="keywd">when</span> {FALSE}: elsifPart;
    <span class="keywd">end case</span>;
  <span class="keywd">end func</span>;

<span class="comment"># Semantic for the syntax: .elsif.().then.()</span>
<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: elsif (<span class="keywd">in</span> <a class="type" href="types.htm#boolean">boolean</a>: condition) then
                    (<span class="keywd">in</span> <a class="type" href="types.htm#proc">proc</a>: statements)             <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">case</span> condition <span class="keywd">of</span>
      <span class="keywd">when</span> {TRUE}: statements;
    <span class="keywd">end case</span>;
  <span class="keywd">end func</span>;

<span class="comment"># Semantic for the syntax: .elsif.().then.().()</span>
<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: elsif (<span class="keywd">in</span> <a class="type" href="types.htm#boolean">boolean</a>: condition) then
                    (<span class="keywd">in</span> <a class="type" href="types.htm#proc">proc</a>: statements)
                  (<span class="keywd">in</span> <span class="type">ELSIF_PROC</span>: elsifPart)          <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">case</span> condition <span class="keywd">of</span>
      <span class="keywd">when</span> {TRUE}: statements;
      <span class="keywd">when</span> {FALSE}: elsifPart;
    <span class="keywd">end case</span>;
  <span class="keywd">end func</span>;

<span class="comment"># Semantic for the syntax: .else.()</span>
<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: else
                    (<span class="keywd">ref</span> <a class="type" href="types.htm#void">void</a>: voidValue)        <span class="keywd">is</span> ELSIF_EMPTY;
</pre><p>
  Since no other functions of type <tt>'<span class="type">ELSIF_PROC</span>'</tt> are defined only
  legal <a class="link" href="stats.htm#if-statement">if-statements</a> can be written.
</p>

<a name="Comparison_of_EBNF_and_S7SSD"><h3>9.8 Comparison of EBNF and S7SSD</h3></a>
<p>
  In the S7SSD of the <a class="link" href="#The_syntax_of_a_statement">loop-statement</a>
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .loop.().until.().do.().end.loop <span class="keywd">is</span> -> 25;
</pre><p>
  are no nonterminal expressions <tt>'()'</tt> before the first keyword or
  after the last keyword. Therefore the associativity does not play
  any role. The nonterminal expressions <tt>'()'</tt> of the <a class="link" href="#The_syntax_of_a_statement">loop-statement</a>
  are all surrounded by keywords and therefore they can have any
  priority. As priority of the <tt>'<span class="keywd">loop</span>'</tt> 25 is chosen just because
  most other statements have also priority 25. The assignments
  (:= +:= *:= ...) have priority 20 and all operators used in
  arithmetic, boolean and string expressions have priorities less
  than 20. BTW: The semicolon operator (;) is defined with the
  priority 50. Operators with a priority of 0 get their parameters
  before operators with priority 1 and so on.
</p><p>
  The corresponding EBNF description of the <a class="link" href="#The_syntax_of_a_statement">loop-statement</a> would
  be:
</p><dl><dd><tt><dl>
    <dt>expression_25 ::=</dt><dd>
      '<span class="keywd">loop</span>'<br />
      &nbsp;&nbsp;expression_127<br />
      '<span class="keywd">until</span>' expression_127 '<span class="keywd">do</span>'<br />
      &nbsp;&nbsp;expression_127<br />
      '<span class="keywd">end</span>' '<span class="keywd">loop</span>' .</dd>
</dl></tt></dd></dl><p>
  We must keep in mind that alternative rules for expression_25 are
  also possible and that for every priority level a rule like
</p><dl><dd><tt><dl>
    <dt>expression_127 ::=</dt><dd>
      expression_126 .</dd>
</dl></tt></dd></dl><p>
  is defined. Additionally the following rules are defined:
</p><dl><dd><tt><dl>
    <dt>expression_0 ::=</dt><dd>
      token | parentheses_expression |<br />
      call_expression | dot_expression .</dd>
<dt><br /></dt>
    <dt>token ::=</dt><dd>
      identifier | literal .</dd>
<dt><br /></dt>
    <dt>parentheses_expression ::=</dt><dd>
      '(' expression_127 ')' .</dd>
<dt><br /></dt>
    <dt>call_expression ::=</dt><dd>
      expression_127 [ '('<br />
      [ expression_127 { ',' expression_127 } ]<br />
      ')' ] .</dd>
<dt><br /></dt>
    <dt>dot_expression ::=</dt><dd>
      [ '.' ] call_expression { '.' call_expression } .</dd>
</dl></tt></dd></dl><p>
  The EBNF description can become long if many priority levels
  exist, as it is the case in Seed7.
</p><p>
  There are some things which are out of the scope of S7SSD.
  The syntax of <a class="link" href="tokens.htm#Comments">comments</a>, tokens (<a class="link" href="tokens.htm#Identifiers">identifiers</a> and <a class="link" href="tokens.htm#Literals">literals</a>) and
  expressions (parentheses, function calls and dot expressions)
  is hard coded. The hard coded constructs are described in
  <a class="link" href="tokens.htm">chapter 10 (Tokens)</a> and <a class="link" href="expr.htm">chapter 11 (Expressions)</a>.
</p><p>
  For the reasons mentioned above it is not possible to transform
  every EBNF syntax description into S7SSD. Transforming S7SSD
  descriptions to EBNF is always possible.
</p><p>
  The advantage of S7SSD lies in its simplicity and that a fast
  automated syntax recognition algorithm can be easily implemented.
  It is exactly the combination of hard coded syntax recognition and
  flexible syntax rules that make it successful.
</p>
<table width="100%" cellpadding="0" cellspacing="0">
<tr>
<td align="left" width="60%">
<b><big><hr \></big></b></td>
<td align="right">
<table border="0" cellspacing="1" bgcolor="blue">
<tr bgcolor="gainsboro">
<td>&nbsp;<a class="navigation" href="../manual/file.htm">previous</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../manual/index.htm">up</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../manual/tokens.htm">next</a>&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</div>
  </body>
</html>
