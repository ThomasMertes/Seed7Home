<html>
<head>
<meta charset="utf-8" />
<title>
Seed7 Manual: Predefined statements</title>
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style2.css" type="text/css" />
</head>
<body style="margin:0 0 0 0;">
<div style="background-image: url('../images/header1x.png');" class="top_image">
<img style="overflow:hidden;" src="../images/hearts7m.png" height="68" width="50"
 /><img style="overflow:hidden;" src="../images/header3.png" height="68" width="745" />
</div>
<div style="background-image: url('../images/fillpix.png');" class="space_below_top_image">
</div>
<div class="menu">

<a class="head" href="../index.htm"><big>Seed7</big></a>
<a class="menu" href="../faq.htm">FAQ</a>
<a class="menu" href="../manual/index.htm">Manual</a>
<a class="menu" href="../scrshots/index.htm">Programs</a>
<a class="menu" href="../examples/index.htm">Examples</a>
<a class="menu" href="../libraries/index.htm">Libraries</a>
<a class="menu" href="../algorith/index.htm">Algorithms</a>
<a class="menu" href="../benchmks/index.htm">Benchmarks</a>
<a class="menu" href="../subject_index.htm">Index</a>
<a class="menu" href="http://sourceforge.net/project/showfiles.php?group_id=151126">Download</a>
<a class="menu" href="https://github.com/ThomasMertes/seed7">GitHub</a>
<a class="menu" href="../build.htm">Build Seed7</a>
<a class="menu" href="../links.htm">Links</a>

<br />

<a class="head" href="index.htm"><big>Manual</big></a>
<a class="menu" href="intro.htm">Introduction</a>
<a class="menu" href="tutorial.htm">Tutorial</a>
<a class="menu" href="decls.htm">Declarations</a>
<a class="menu" href="stats.htm">Statements</a>
<a class="menu" href="types.htm">Types</a>
<a class="menu" href="params.htm">Parameters</a>
<a class="menu" href="objects.htm">Objects</a>
<a class="menu" href="file.htm">File I/O</a>
<a class="menu" href="syntax.htm">Syntax</a>
<a class="menu" href="tokens.htm">Tokens</a>
<a class="menu" href="expr.htm">Expressions</a>
<a class="menu" href="os.htm">OS&nbsp;access</a>
<a class="menu" href="database.htm">Database</a>
<a class="menu" href="graphic.htm">Graphic</a>
<a class="menu" href="actions.htm">Actions</a>
<a class="menu" href="ffi.htm">Foreign&nbsp;funcs</a>
<a class="menu" href="errors.htm">Errors</a>

<br />

<a class="head" href="#PREDEFINED_STATEMENTS"><big>Statements</big></a>
<a class="menu" href="#Assignment">Assignment</a>
<a class="menu" href="#Ignoring_values">ignore</a>
<a class="menu" href="#while-statement">while</a>
<a class="menu" href="#repeat-statement">repeat</a>
<a class="menu" href="#for-statement">for</a>
<a class="menu" href="#for-until-statement">for-until</a>
<a class="menu" href="#for-step-statement">for-step</a>
<a class="menu" href="#for-each-statement">for-each</a>
<a class="menu" href="#for-each-key-statement">for-each-key</a>
<a class="menu" href="#for-key-statement">for-key</a>
<a class="menu" href="#if-statement">if</a>
<a class="menu" href="#case-statement">case</a>
</div>
<div class="content">
<div style="padding-right:20;">
<table width="100%" cellpadding="0" cellspacing="0">
<tr>
<td align="left" width="80">
<a class="head" href="index.htm"><big>Manual</big></a>
</td>
<td>
<table width="10">
</table>
</td>
<td align="left" width="60%">
<b><big>Statements</big></b></td>
<td align="right">
<table border="0" cellspacing="1" bgcolor="blue">
<tr bgcolor="gainsboro">
<td>&nbsp;<a class="navigation" href="../manual/decls.htm">previous</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../manual/index.htm">up</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../manual/types.htm">next</a>&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
<a name="file_start"></a><p></p>
<a name="PREDEFINED_STATEMENTS"><h2>4. PREDEFINED STATEMENTS</h2></a>

<p>
    The library contains several predefined statements:
  <a class="link" href="#Assignment">assignment</a>, <a class="link" href="#while-statement">while-statement</a>, <a class="link" href="#repeat-statement">repeat-statement</a>, <a class="link" href="#for-statement">for-statement</a>,
  <a class="link" href="#if-statement">if-statement</a>, <a class="link" href="#case-statement">case-statement</a> and procedure call.
</p>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="ebnf_statement">statement</a> ::=</dt><dd>
      <a class="ebnf" href="#ebnf_single_statement">single_statement</a> [ ';' [ <a class="ebnf" href="#ebnf_statement">statement</a> ] ] .</dd>
<dt><br /></dt>
    <dt><a name="ebnf_single_statement">single_statement</a> ::=</dt><dd>
      <a class="ebnf" href="#ebnf_assignment_statement">assignment_statement</a> | <a class="ebnf" href="#ebnf_while_statement">while_statement</a> | <a class="ebnf" href="#ebnf_repeat_statement">repeat_statement</a> |<br />
      <a class="ebnf" href="#ebnf_for_statement">for_statement</a> | <a class="ebnf" href="#ebnf_for_step_statement">for_step_statement</a> | <a class="ebnf" href="#ebnf_for_each_statement">for_each_statement</a> |<br />
      <a class="ebnf" href="#ebnf_for_each_key_statement">for_each_key_statement</a> | <a class="ebnf" href="#ebnf_for_key_statement">for_key_statement</a> | <a class="ebnf" href="#ebnf_if_statement">if_statement</a> |<br />
      <a class="ebnf" href="#ebnf_case_statement">case_statement</a> | procedure_call | <a class="ebnf" href="#ebnf_empty_statement">empty_statement</a> .</dd>
<dt><br /></dt>
    <dt><a name="ebnf_empty_statement">empty_statement</a> ::=</dt><dd>
      'noop' .</dd>
</dl></tt></dd></dl><p>
  The execution of a <tt><span class="keywd">noop</span></tt> statement (short for NO OPeration) has
  no effect. Some places in a program require a statement. If
  nothing needs to be done in such a place a <tt><span class="keywd">noop</span></tt> can be used.
</p><p>
  Everywhere where one statement can be written a sequence of
  statements can also be used. The semicolon-operator concatenates
  two statements giving a new statement. The semicolon operator
  can also be used behind the last statement of a statement
  sequence. In this case the semicolon is just ignored.

</p><p>
  <a name="semicolon_operator_declaration">Declaration</a>:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .(). ; .()   <span class="keywd">is</span> &lt;- 50;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .(). ;       <span class="keywd">is</span> &lt;- 50 [1];

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<span class="keywd">ref</span> <a class="type" href="types.htm#void">void</a>: statement1) ; (<span class="keywd">ref</span> <a class="type" href="types.htm#void">void</a>: statement2) <span class="keywd">is</span> noop;
</pre><p></p>

<a name="Assignment"><h3>4.1 Assignment</h3></a>
<p>
  For example:
</p><pre class="indent">
minimum := maximum <span class="op">div</span> 2;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    The expression at the right side of the assignment symbol is
    evaluated and assigned to the variable at the left side.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="ebnf_assignment_statement">assignment_statement</a> ::=</dt><dd>
      designator ':=' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> .</dd>
</dl></tt></dd></dl><p>
  The assignment statement is defined for every standard type.
</p><p>
  If an assignment for a new user defined type is needed it
  must be defined additionally.

</p><p>
  <a name="assignment_statement_declaration">Declaration</a>:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .(). := .()   <span class="keywd">is</span> &lt;-> 20;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#type">type</a>: dest) := (<span class="keywd">ref</span> <a class="type" href="types.htm#type">type</a>: source)                   <span class="keywd">is action</span> <span class="stri">"TYP_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#proc">proc</a>: dest) := (<span class="keywd">ref</span> <a class="type" href="types.htm#proc">proc</a>: source)                   <span class="keywd">is action</span> <span class="stri">"PRC_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#func">func</a> <span class="type">aType</span>: dest) := (<span class="keywd">ref</span> <a class="type" href="types.htm#func">func</a> <span class="type">aType</span>: source)       <span class="keywd">is action</span> <span class="stri">"PRC_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#varfunc">varfunc</a> <span class="type">aType</span>: dest) := (<span class="keywd">ref</span> <a class="type" href="types.htm#varfunc">varfunc</a> <span class="type">aType</span>: source) <span class="keywd">is action</span> <span class="stri">"PRC_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">ACTION</span>: dest) := (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">ACTION</span>: source)                <span class="keywd">is action</span> <span class="stri">"ACT_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#boolean">boolean</a>: dest) <a name="(inout_boolean):=(in_boolean)">:=</a> (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#boolean">boolean</a>: source)              <span class="keywd">is action</span> <span class="stri">"BLN_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#integer">integer</a>: dest) <a name="(inout_integer):=(in_integer)">:=</a> (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#integer">integer</a>: source)              <span class="keywd">is action</span> <span class="stri">"INT_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#bigInteger">bigInteger</a>: dest) := (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#bigInteger">bigInteger</a>: source)        <span class="keywd">is action</span> <span class="stri">"BIG_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#char">char</a>: dest) <a name="(inout_char):=(in_char)">:=</a> (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#char">char</a>: source)                    <span class="keywd">is action</span> <span class="stri">"CHR_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#string">string</a>: dest) <a name="(inout_string):=(in_string)">:=</a> (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#string">string</a>: source)                <span class="keywd">is action</span> <span class="stri">"STR_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#bin64">bin64</a>: dest) := (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#bin64">bin64</a>: source)                  <span class="keywd">is action</span> <span class="stri">"INT_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#bin32">bin32</a>: dest) := (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#bin32">bin32</a>: source)                  <span class="keywd">is action</span> <span class="stri">"INT_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#bstring">bstring</a>: dest) := (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#bstring">bstring</a>: source)              <span class="keywd">is action</span> <span class="stri">"BST_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#reference">reference</a>: dest) := (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#reference">reference</a>: source)          <span class="keywd">is action</span> <span class="stri">"REF_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#ref_list">ref_list</a>: dest) := (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#ref_list">ref_list</a>: source)            <span class="keywd">is action</span> <span class="stri">"RFL_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">ptrType</span>: dest) := (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">ptrType</span>: source)              <span class="keywd">is action</span> <span class="stri">"REF_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">varptrType</span>: dest) := (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">varptrType</span>: source)        <span class="keywd">is action</span> <span class="stri">"REF_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">arrayType</span>: dest) := (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">arrayType</span>: source)          <span class="keywd">is action</span> <span class="stri">"ARR_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#set">bitset</a>: dest) := (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#set">bitset</a>: source)                <span class="keywd">is action</span> <span class="stri">"SET_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">structType</span>: dest) := (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">structType</span>: source)        <span class="keywd">is action</span> <span class="stri">"SCT_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">enumType</span>: dest) := (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">enumType</span>: source)            <span class="keywd">is action</span> <span class="stri">"ENU_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">clib_file</span>: dest) := (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">clib_file</span>: source)          <span class="keywd">is action</span> <span class="stri">"FIL_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#process">process</a>: dest) := (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#process">process</a>: source)              <span class="keywd">is action</span> <span class="stri">"PCS_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">interfaceType</span>: dest) := (<span class="keywd">ref</span> <span class="type">interfaceType</span>: source) <span class="keywd">is action</span> <span class="stri">"ITF_CPY"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">interfaceType</span>: dest) := (<span class="keywd">ref</span> <span class="type">aType</span>: source)         <span class="keywd">is action</span> <span class="stri">"ITF_CPY2"</span>;
</pre><p></p>

<a name="Ignoring_values"><h3>4.2 Ignoring values</h3></a>
<p>
  Unused expression results are not implicitely discarded. Writing:
</p><pre class="indent">
  <span class="keywd">begin</span>
    1 + 1;
    writeln;
  <span class="keywd">end func</span>;
</pre><p>
  results in a <a class="link" href="errors.htm#Parsing_errors">parsing error</a>:
</p><pre class="indent">
*** tst316.sd7(5):52: <a class="link" href="errors.htm#NO_MATCH">Match for {INT_ADD({1 + 1 }) ; writeln } failed</a>
    1 + 1;
</pre><p>
  An unused expression result must be explicitly ignored. E.g.:
</p><pre class="indent">
<span class="keywd">ignore</span>(<a class="func" href="../libraries/keybd.htm#getc(in_console_keybd_file)">getc</a>(<a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a>));
</pre><p>
  This example waits for a character pressed on the <tt><a class="var" href="../libraries/keybd.htm#KEYBOARD">KEYBOARD</a></tt> and
  then ignores that character. So all of the side effects of the
  expressions take place. It is just the result of the expression
  that is ignored.
</p><p>
  The need to explicitly ignore unused expression results
  removes another possible source of errors.
</p>

<a name="while-statement"><h3>4.3 while-statement</h3></a>
<p>
  For example:
</p><pre class="indent">
<span class="keywd">while</span> maximum > minimum <span class="keywd">do</span>
  minimum <a class="op_no_ul" href="#Assignment">:=</a> 2 * minimum + stepValue;
  decr(stepValue);
<span class="keywd">end while</span>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    First the condition between <tt><span class="keywd">while</span></tt> and <tt><span class="keywd">do</span></tt> is evaluated.
    When this evaluation yields <tt><a class="var" href="../libraries/boolean.htm#FALSE">FALSE</a></tt>, the while-statement is
    finished. When the evaluation yields <tt><a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a></tt>, the statement
    between <tt><span class="keywd">do</span></tt> and <tt><span class="keywd">end</span></tt> is executed and the whole while-statement
    is executed again.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="ebnf_while_statement">while_statement</a> ::=</dt><dd>
      '<span class="keywd">while</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> '<span class="keywd">do</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#ebnf_statement">statement</a><br />
      '<span class="keywd">end</span>' '<span class="keywd">while</span>' .</dd>
</dl></tt></dd></dl><p>
  The expression must be of type <tt><a class="type" href="types.htm#boolean">boolean</a></tt>.

</p><p>
  <a name="while_statement_declaration">Declaration</a>:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .while.().do.().end.while   <span class="keywd">is</span> -> 25;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: while (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#func">func</a> <a class="type" href="types.htm#boolean">boolean</a>: condition) do (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statement) end while <span class="keywd">is action</span> <span class="stri">"PRC_WHILE"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: while (<a class="keywd_no_ul" href="params.htm#ref_parameter">ref</a> <a class="type" href="types.htm#boolean">boolean</a>: condition) do (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statement) end while     <span class="keywd">is action</span> <span class="stri">"PRC_WHILE"</span>;
</pre><p>
  Alternate declaration:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: while (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#func">func</a> <a class="type" href="types.htm#boolean">boolean</a>: condition) do (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statement) end while <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> condition <span class="keywd">then</span>
      statement;
      <span class="keywd">while</span> condition <span class="keywd">do</span>
        statement;
      <span class="keywd">end while</span>;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p></p>

<a name="repeat-statement"><h3>4.4 repeat-statement</h3></a>
<p>
  For example:
</p><pre class="indent">
<span class="keywd">repeat</span>
  incr(minimum);
  maximum <a class="op_no_ul" href="#Assignment">:=</a> maximum - stepValue;
<span class="keywd">until</span> 2 * minimum > maximum;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    The statement between <tt><span class="keywd">repeat</span></tt> and <tt><span class="keywd">until</span></tt> is executed.
    Then the condition after <tt><span class="keywd">until</span></tt> is evaluated. When this
    evaluation yields <tt><a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a></tt>, the repeat-statement is finished.
    When the evaluation yields <tt><a class="var" href="../libraries/boolean.htm#FALSE">FALSE</a></tt> the repeat-statement is
    executed again.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="ebnf_repeat_statement">repeat_statement</a> ::=</dt><dd>
      '<span class="keywd">repeat</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#ebnf_statement">statement</a><br />
      '<span class="keywd">until</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> .</dd>
</dl></tt></dd></dl><p>
  The expression must be of type <tt><a class="type" href="types.htm#boolean">boolean</a></tt>.

</p><p>
  <a name="repeat_statement_declaration">Declaration</a>:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .repeat.().until.()   <span class="keywd">is</span> -> 25;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: repeat (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statement) until (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#func">func</a> <a class="type" href="types.htm#boolean">boolean</a>: condition) <span class="keywd">is action</span> <span class="stri">"PRC_REPEAT"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: repeat (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statement) until (<a class="keywd_no_ul" href="params.htm#ref_parameter">ref</a> <a class="type" href="types.htm#boolean">boolean</a>: condition)     <span class="keywd">is action</span> <span class="stri">"PRC_REPEAT"</span>;
</pre><p>
  Alternate declaration:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: repeat (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statement) until (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#func">func</a> <a class="type" href="types.htm#boolean">boolean</a>: condition) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    statement;
    <span class="keywd">if</span> <span class="keywd">not</span> condition <span class="keywd">then</span>
      <span class="keywd">repeat</span>
        statement;
      <span class="keywd">until</span> condition;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p></p>

<a name="for-statement"><h3>4.5 for-statement</h3></a>
<p>
  For example:
</p><pre class="indent">
<span class="keywd">for</span> index <span class="keywd">range</span> min_index <span class="keywd">to</span> max_index <span class="keywd">do</span>
  sumValue +:= field[index];
<span class="keywd">end for</span>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd><dl><dt>
    When the <tt><span class="keywd">to</span></tt> symbol is used the for-statement is defined as
    follows:</dt><dd>
      First the lower limit and the upper limit which stand behind
      <tt><span class="keywd">range</span></tt> and <tt><span class="keywd">to</span></tt> are evaluated. Then the lower limit is assigned
      to the control variable which stands behind <tt><span class="keywd">for</span></tt>. If the value
      of the control variable is less than or equal the upper limit
      the statements behind <tt><span class="keywd">do</span></tt> are executed. After that the control
      variable is incremented and compared with the upper limit
      again. This compare - execute - increment cycle is repeated
      until the control variable is greater than the upper limit.</dd><dt>
    When the <tt><span class="keywd">downto</span></tt> symbol is used the for-statement is defined as
    follows:</dt><dd>
      First the upper limit and the lower limit which stand behind
      <tt><span class="keywd">range</span></tt> and <tt><span class="keywd">downto</span></tt> are evaluated. Then the upper limit is
      assigned to the control variable which stands behind <tt><span class="keywd">for</span></tt>. If
      the value of the control variable is greater than or equal the
      lower limit the statements behind <tt><span class="keywd">do</span></tt> are executed. After that
      the control variable is decremented and compared with the lower
      limit again. This compare - execute - increment cycle is
      repeated until the control variable is less than the lower limit.</dd></dl>
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="ebnf_for_statement">for_statement</a> ::=</dt><dd>
      '<span class="keywd">for</span>' <a class="ebnf" href="tokens.htm#ebnf_identifier">identifier</a> '<span class="keywd">range</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> [ '<span class="keywd">to</span>' | '<span class="keywd">downto</span>' ] <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> '<span class="keywd">do</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#ebnf_statement">statement</a><br />
      '<span class="keywd">end</span>' '<span class="keywd">for</span>' .</dd>
</dl></tt></dd></dl><p>

  <a name="for_statement_declaration">Declaration</a>:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .for.().range.().to.().do.().end.for       <span class="keywd">is</span> -> 25;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .for.().range.().downto.().do.().end.for   <span class="keywd">is</span> -> 25;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#integer">integer</a>: aVar) range (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#integer">integer</a>: lowerLimit) to (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#integer">integer</a>: upperLimit) do
              (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statements)
            end for                                                      <span class="keywd">is action</span> <span class="stri">"PRC_FOR_TO"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#integer">integer</a>: aVar) range (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#integer">integer</a>: upperLimit) downto (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#integer">integer</a>: lowerLimit) do
              (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statements)
            end for                                                      <span class="keywd">is action</span> <span class="stri">"PRC_FOR_DOWNTO"</span>;
</pre><p>
  Declaration for non-integer types:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: FOR_DECLS (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#type">type</a>: aType) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">aType</span>: variable) range
        (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">aType</span>: lowerLimit) to (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">aType</span>: upperLimit) do
        (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statements) end for <span class="keywd">is func</span>
      <span class="keywd">local</span>
        <span class="keywd">var</span> <a class="type" href="types.htm#boolean">boolean</a>: continue <span class="keywd">is</span> <a class="var" href="../libraries/boolean.htm#FALSE">FALSE</a>;
      <span class="keywd">begin</span>
        variable <a class="op_no_ul" href="#Assignment">:=</a> lowerLimit;
        continue <a class="op_no_ul" href="#Assignment">:=</a> variable &lt;= upperLimit;
        <span class="keywd">while</span> continue <span class="keywd">do</span>
          statements;
          <span class="keywd">if</span> variable &lt; upperLimit <span class="keywd">then</span>
            incr(variable);
          <span class="keywd">else</span>
            continue <a class="op_no_ul" href="#Assignment">:=</a> <a class="var" href="../libraries/boolean.htm#FALSE">FALSE</a>;
          <span class="keywd">end if</span>;
        <span class="keywd">end while</span>;
      <span class="keywd">end func</span>;

    <span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">aType</span>: variable) range
        (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">aType</span>: upperLimit) downto (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">aType</span>: lowerLimit) do
        (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statements) end for <span class="keywd">is func</span>
      <span class="keywd">local</span>
        <span class="keywd">var</span> <a class="type" href="types.htm#boolean">boolean</a>: continue <span class="keywd">is</span> <a class="var" href="../libraries/boolean.htm#FALSE">FALSE</a>;
      <span class="keywd">begin</span>
        variable <a class="op_no_ul" href="#Assignment">:=</a> upperLimit;
        continue <a class="op_no_ul" href="#Assignment">:=</a> variable >= lowerLimit;
        <span class="keywd">while</span> continue <span class="keywd">do</span>
          statements;
          <span class="keywd">if</span> variable > lowerLimit <span class="keywd">then</span>
            decr(variable);
          <span class="keywd">else</span>
            continue <a class="op_no_ul" href="#Assignment">:=</a> <a class="var" href="../libraries/boolean.htm#FALSE">FALSE</a>;
          <span class="keywd">end if</span>;
        <span class="keywd">end while</span>;
      <span class="keywd">end func</span>;

  <span class="keywd">end func</span>;

FOR_DECLS(<a class="type" href="types.htm#char">char</a>);
FOR_DECLS(<a class="type" href="types.htm#boolean">boolean</a>);
FOR_DECLS(<a class="type" href="types.htm#bigInteger">bigInteger</a>);
</pre><p></p>

<a name="for-until-statement"><h3>4.6 for-until-statement</h3></a>
<p>
  For example:
</p><pre class="indent">
<span class="keywd">for</span> column <span class="keywd">range</span> 1 <span class="keywd">to</span> length(maxRow) <span class="keywd">until</span> selectedColumn &lt;> 0 <span class="keywd">do</span>
  <span class="keywd"></span>if maxRow[column] &lt;> 0 <span class="keywd">then</span>
    incr(numColumns);
  <span class="keywd">end if</span>;
  <span class="keywd">if</span> numColumns = selectedNum <span class="keywd">then</span>
    selectedColumn <a class="op_no_ul" href="#Assignment">:=</a> column;
  <span class="keywd">end if</span>;
<span class="keywd">end for</span>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd><dl><dt>
    When the <tt><span class="keywd">to</span></tt> symbol is used the for-until-statement is defined as
    follows:</dt><dd>
      First the lower limit and the upper limit which stand behind
      <tt><span class="keywd">range</span></tt> and <tt><span class="keywd">to</span></tt> are evaluated. Then the lower limit is assigned
      to the control variable which stands behind <tt><span class="keywd">for</span></tt>. If the value
      of the control variable is less than or equal the upper limit
      the condition behind <tt><span class="keywd">until</span></tt> is checked. If the condition is
      <tt><a class="var" href="../libraries/boolean.htm#FALSE">FALSE</a></tt> the statements behind <tt><span class="keywd">do</span></tt> are executed. After that the
      control variable is incremented and compared with the upper limit
      again. This compare - check condition - execute - increment cycle
      is repeated until the control variable would become greater than
      the upper limit or the condition is <tt><a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a></tt>.</dd><dt>
    When the <tt><span class="keywd">downto</span></tt> symbol is used the for-until-statement is defined as
    follows:</dt><dd>
      First the upper limit and the lower limit which stand behind
      <tt><span class="keywd">range</span></tt> and <tt><span class="keywd">downto</span></tt> are evaluated. Then the upper limit is
      assigned to the control variable which stands behind <tt><span class="keywd">for</span></tt>. If the
      value of the control variable is greater than or equal the lower
      limit the condition behind <tt><span class="keywd">until</span></tt> is checked. If the condition is
      <tt><a class="var" href="../libraries/boolean.htm#FALSE">FALSE</a></tt> the statements behind <tt><span class="keywd">do</span></tt> are executed. After that the
      control variable is decremented and compared with the lower limit
      again. This compare - check condition - execute - increment cycle
      is repeated until the control variable would become less than the
      lower limit or the condition is <tt><a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a></tt>.</dd></dl>
    In all cases the control variable never gets a value outside of the
    range lower limit .. upper limit.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="ebnf_for_until_statement">for_until_statement</a> ::=</dt><dd>
      '<span class="keywd">for</span>' <a class="ebnf" href="tokens.htm#ebnf_identifier">identifier</a> '<span class="keywd">range</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> [ '<span class="keywd">to</span>' | '<span class="keywd">downto</span>' ] <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> '<span class="keywd">until</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> '<span class="keywd">do</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#ebnf_statement">statement</a><br />
      '<span class="keywd">end</span>' '<span class="keywd">for</span>' .</dd>
</dl></tt></dd></dl><p>

  <a name="for_until_statement_declaration">Declaration</a>:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .for.().range.().to.().until.().do.().end.for       <span class="keywd">is</span> -> 25;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .for.().range.().downto.().until.().do.().end.for   <span class="keywd">is</span> -> 25;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: FOR_UNTIL_DECLS (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#type">type</a>: aType) <span class="keywd">is func</span>
  <span class="keywd">begin</span>

    <span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">aType</span>: variable) range (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">aType</span>: lowerLimit) to (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">aType</span>: upperLimit)
        until (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#func">func</a> <a class="type" href="types.htm#boolean">boolean</a>: condition) do
        (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statements) end for <span class="keywd">is func</span>
      <span class="keywd">local</span>
        <span class="keywd">var</span> <a class="type" href="types.htm#boolean">boolean</a>: continue <span class="keywd">is</span> <a class="var" href="../libraries/boolean.htm#FALSE">FALSE</a>;
      <span class="keywd">begin</span>
        variable <a class="op_no_ul" href="#Assignment">:=</a> lowerLimit;
        continue <a class="op_no_ul" href="#Assignment">:=</a> variable &lt;= upperLimit;
        <span class="keywd">while</span> continue <span class="op">and not</span> condition <span class="keywd">do</span>
          statements;
          <span class="keywd">if</span> variable &lt; upperLimit <span class="keywd">then</span>
            incr(variable);
          <span class="keywd">else</span>
            continue <a class="op_no_ul" href="#Assignment">:=</a> <a class="var" href="../libraries/boolean.htm#FALSE">FALSE</a>;
          <span class="keywd">end if</span>;
        <span class="keywd">end while</span>;
      <span class="keywd">end func</span>;

    <span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">aType</span>: variable) range (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">aType</span>: lowerLimit) downto (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">aType</span>: upperLimit)
        until (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#func">func</a> <a class="type" href="types.htm#boolean">boolean</a>: condition) do
        (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statements) end for <span class="keywd">is func</span>
      <span class="keywd">local</span>
        <span class="keywd">var</span> <a class="type" href="types.htm#boolean">boolean</a>: continue <span class="keywd">is</span> <a class="var" href="../libraries/boolean.htm#FALSE">FALSE</a>;
      <span class="keywd">begin</span>
        variable <a class="op_no_ul" href="#Assignment">:=</a> upperLimit;
        continue <a class="op_no_ul" href="#Assignment">:=</a> variable >= lowerLimit;
        <span class="keywd">while</span> continue <span class="op">and not</span> condition <span class="keywd">do</span>
          statements;
          <span class="keywd">if</span> variable > lowerLimit <span class="keywd">then</span>
            decr(variable);
          <span class="keywd">else</span>
            continue <a class="op_no_ul" href="#Assignment">:=</a> <a class="var" href="../libraries/boolean.htm#FALSE">FALSE</a>;
          <span class="keywd">end if</span>;
        <span class="keywd">end while</span>;
      <span class="keywd">end func</span>;

  <span class="keywd">end func</span>;

FOR_UNTIL_DECLS(<a class="type" href="types.htm#integer">integer</a>);
FOR_UNTIL_DECLS(<a class="type" href="types.htm#char">char</a>);
FOR_UNTIL_DECLS(<a class="type" href="types.htm#boolean">boolean</a>);
FOR_UNTIL_DECLS(<a class="type" href="types.htm#bigInteger">bigInteger</a>);
</pre><p></p>

<a name="for-step-statement"><h3>4.7 for-step-statement</h3></a>
<p>
  For example:
</p><pre class="indent">
<span class="keywd">for</span> evenNumber <span class="keywd">range</span> 0 <span class="keywd">to</span> 10 <span class="keywd">step</span> 2 <span class="keywd">do</span>
  write(evenNumber);
<span class="keywd">end for</span>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd><dl><dt>
    When the <tt><span class="keywd">to</span></tt> symbol is used the for-statement is defined as
    follows:</dt><dd>
      First the lower limit and the upper limit which stand behind
      <tt><span class="keywd">range</span></tt> and <tt><span class="keywd">to</span></tt> are evaluated. Then the lower limit is assigned
      to the control variable which stands behind <tt><span class="keywd">for</span></tt>. If the value
      of the control variable is less than or equal the upper limit
      the statements behind <tt><span class="keywd">do</span></tt> are executed. After that the control
      variable is incremented by the value behind <tt><span class="keywd">step</span></tt>. Then
      the control variable is compared with the upper limit again.
      This compare - execute - increment cycle is repeated until
      the control variable is greater than the upper limit.</dd><dt>
    When the <tt><span class="keywd">downto</span></tt> symbol is used the for-statement is defined as
    follows:</dt><dd>
      First the upper limit and the lower limit which stand behind
      <tt><span class="keywd">range</span></tt> and <tt><span class="keywd">downto</span></tt> are evaluated. Then the upper limit is
      assigned to the control variable which stands behind <tt><span class="keywd">for</span></tt>. If
      the value of the control variable is greater than or equal the
      lower limit the statements behind <tt><span class="keywd">do</span></tt> are executed. After that
      the control variable is decremented by the value behind <tt><span class="keywd">step</span></tt>.
      Then the control variable is compared with the lower limit
      again. This compare - execute - increment cycle is repeated
      until the control variable is less than the lower limit.</dd></dl>
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="ebnf_for_step_statement">for_step_statement</a> ::=</dt><dd>
      '<span class="keywd">for</span>' <a class="ebnf" href="tokens.htm#ebnf_identifier">identifier</a> '<span class="keywd">range</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> [ '<span class="keywd">to</span>' | '<span class="keywd">downto</span>' ] <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> '<span class="keywd">step</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> '<span class="keywd">do</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#ebnf_statement">statement</a><br />
      '<span class="keywd">end</span>' '<span class="keywd">for</span>' .</dd>
</dl></tt></dd></dl><p>

  <a name="for_step_statement_declaration">Declaration</a>:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .for.().range.().to.().step.().do.().end.for       <span class="keywd">is</span> -> 25;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .for.().range.().downto.().step.().do.().end.for   <span class="keywd">is</span> -> 25;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: FOR_STEP_DECLS (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#type">type</a>: aType) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">if</span> getobj((<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">aType</span>: variable) +:= (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#integer">integer</a>: delta)) &lt;> NIL <span class="keywd">then</span>

      <span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">aType</span>: variable) range (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">aType</span>: lowerLimit) to (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">aType</span>: upperLimit)
          step (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#integer">integer</a>: incr_step) do
          (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statements) end for <span class="keywd">is func</span>
        <span class="keywd">begin</span>
          variable <a class="op_no_ul" href="#Assignment">:=</a> lowerLimit;
          <span class="keywd">while</span> variable &lt;= upperLimit <span class="keywd">do</span>
            statements;
            variable +:= incr_step;
          <span class="keywd">end while</span>;
        <span class="keywd">end func</span>;

    <span class="keywd">end if</span>;
    <span class="keywd">if</span> getobj((<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">aType</span>: variable) -:= (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#integer">integer</a>: delta)) &lt;> NIL <span class="keywd">then</span>

      <span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">aType</span>: variable) range (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">aType</span>: upperLimit) downto (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">aType</span>: lowerLimit)
          step (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#integer">integer</a>: decr_step) do
          (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statements) end for <span class="keywd">is func</span>
        <span class="keywd">begin</span>
          variable <a class="op_no_ul" href="#Assignment">:=</a> upperLimit;
          <span class="keywd">while</span> variable >= lowerLimit <span class="keywd">do</span>
            statements;
            variable -:= decr_step;
          <span class="keywd">end while</span>;
        <span class="keywd">end func</span>;

    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;

FOR_STEP_DECLS(<a class="type" href="types.htm#integer">integer</a>);
FOR_STEP_DECLS(<a class="type" href="types.htm#bigInteger">bigInteger</a>);
</pre><p></p>

<a name="for-each-statement"><h3>4.8 for-each-statement</h3></a>
<p>
  A for-each-statement loops over the elements of a container
  (<tt><a class="type" href="types.htm#array">array</a></tt>, <tt><a class="type" href="types.htm#hash">hash</a></tt>, <tt><a class="type" href="types.htm#set">set</a></tt>, <tt><a class="type" href="types.htm#string">string</a></tt>, <tt><a class="type" href="types.htm#bstring">bstring</a></tt>, <tt><a class="type" href="types.htm#ref_list">ref_list</a></tt>). For example:
</p><pre class="indent">
<a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)range(in_arrayType)do(in_proc)end_for">for</a> currObject <a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)range(in_arrayType)do(in_proc)end_for">range</a> element_list <a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)range(in_arrayType)do(in_proc)end_for">do</a>
  <a class="func_no_ul" href="../libraries/stdio.htm#writeln(in_string)">writeln</a>(<a class="stri" href="tokens.htm#String_literals">"element: "</a> <a class="op_no_ul" href="../libraries/enable_io.htm#(in_string)<&(in_aType)">&lt;&amp;</a> currObject);
<a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)range(in_arrayType)do(in_proc)end_for">end for</a>;
</pre><p>
  A for-each-statement can be combined with an <tt><span class="keywd">until</span></tt> condition:
</p><pre class="indent">
<a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)range(in_arrayType)until(ref_func_boolean)do(in_proc)end_for">for</a> currObject <a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)range(in_arrayType)until(ref_func_boolean)do(in_proc)end_for">range</a> element_list <a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)range(in_arrayType)until(ref_func_boolean)do(in_proc)end_for">until</a> found <a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)range(in_arrayType)until(ref_func_boolean)do(in_proc)end_for">do</a>
  <a class="keywd_no_ul", href="#if-statement">if</a> currObject <span class="op">=</a> searched <a class="keywd_no_ul", href="#if-statement">then</a>
    <a class="func_no_ul" href="../libraries/stdio.htm#writeln(in_string)">writeln</a>(<a class="stri" href="tokens.htm#String_literals">"found: "</a> <a class="op_no_ul" href="../libraries/enable_io.htm#(in_string)<&(in_aType)">&lt;&amp;</a> currObject);
    found <a class="op_no_ul" href="#Assignment">:=</a> <a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a>;
  <a class="keywd_no_ul", href="#if-statement">end if</a>;
<a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)range(in_arrayType)until(ref_func_boolean)do(in_proc)end_for">end for</a>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    First the element list which stands behind <tt><span class="keywd">range</span></tt> is evaluated.
    If the element list is empty the for-each-statement is finished.
    Otherwise the first element of the element list is assigned
    to the control variable which stands behind <tt><span class="keywd">for</span></tt>. If there is
    an <tt><span class="keywd">until</span></tt> part the condition behind <tt><span class="keywd">until</span></tt> is checked and if it
    evaluates to <tt><a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a></tt> the for-each-statement is finished. If the
    for-each-statement is not finished the statements behind <tt><span class="keywd">do</span></tt>
    (loop body) are executed. If there is no next element in the
    element list the for-each-statement is finished. Otherwise the
    next element of the element list is assigned to the control
    variable. This check for next element - assign element -
    check possible until condition - execute loop body - cycle is
    repeated until there is no next element in the element list.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="ebnf_for_each_statement">for_each_statement</a> ::=</dt><dd>
      '<span class="keywd">for</span>' <a class="ebnf" href="tokens.htm#ebnf_identifier">identifier</a> '<span class="keywd">range</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> [ '<span class="keywd">until</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> ] '<span class="keywd">do</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#ebnf_statement">statement</a><br />
      '<span class="keywd">end</span>' '<span class="keywd">for</span>' .</dd>
</dl></tt></dd></dl><p>

  <a name="for_each_statement_declaration">Declaration</a>:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .for.().range.().do.().end.for   <span class="keywd">is</span> -> 25;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#char">char</a>: forVar) range (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#string">string</a>: stri) do
              (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statement)
            end for <span class="keywd">is action</span> <span class="stri">"STR_FOR"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#reference">reference</a>: variable) range (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#ref_list">ref_list</a>: aRefList) do
              (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statement)
            end for <span class="keywd">is action</span> <span class="stri">"RFL_FOR"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">baseType</span>: variable) range (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">arrayType</span>: arr_obj) do
              (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statements)
            end for <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#integer">integer</a>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> number <span class="keywd">range</span> minIdx(arr_obj) <span class="keywd">to</span> maxIdx(arr_obj) <span class="keywd">do</span>
      variable <a class="op_no_ul" href="#Assignment">:=</a> arr_obj[number];
      statements;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">baseType</span>: forVar) range (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">hashType</span>: aHashMap) do
              (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statements)
            end for <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    FOR_DATA(forVar, aHashMap, statements, hashType.dataCopy);
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">baseType</span>: variable) range (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">setType</span>: aSet) do
              (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statements)
            end for <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <span class="type">baseType</span>: upperBound <span class="keywd">is</span> <span class="type">baseType</span>.value;
    <span class="keywd">var</span> <a class="type" href="types.htm#boolean">boolean</a>: leave <span class="keywd">is</span> <a class="var" href="../libraries/boolean.htm#FALSE">FALSE</a>;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> aSet <> setType.EMPTY_SET <span class="keywd">then</span>
      variable <a class="op_no_ul" href="#Assignment">:=</a> <a class="func_no_ul" href="../libraries/bitsetof.htm#min(in_setType)">min</a>(aSet);
      upperBound <a class="op_no_ul" href="#Assignment">:=</a> <a class="func_no_ul" href="../libraries/bitsetof.htm#max(in_setType)">max</a>(aSet);
      <span class="keywd">repeat</span>
        statements;
        <span class="keywd">if</span> variable = upperBound <span class="keywd">then</span>
          leave <a class="op_no_ul" href="#Assignment">:=</a> <a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a>;
        <span class="keywd">else</span>
          variable <a class="op_no_ul" href="#Assignment">:=</a> <a class="func_no_ul" href="../libraries/bitsetof.htm#next(in_setType,in_baseType)">next</a>(aSet, variable);
        <span class="keywd">end if</span>;
       <span class="keywd">until</span> leave;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#char">char</a>: forVar) range (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#bstring">bstring</a>: bstri) do
              (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statements)
            end for <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#integer">integer</a>: number <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> number <span class="keywd">range</span> 1 <span class="keywd">to</span> length(bstri) <span class="keywd">do</span>
      forVar <a class="op_no_ul" href="#Assignment">:=</a> bstri[number];
      statements;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre><p></p>

<a name="for-each-key-statement"><h3>4.9 for-each-key-statement</h3></a>
<p>
  A for-each-key-statement loops over the elements and keys (indices)
  of a container (<tt><a class="type" href="types.htm#array">array</a></tt>, <tt><a class="type" href="types.htm#hash">hash</a></tt>, <tt><a class="type" href="types.htm#string">string</a></tt>). For example:
</p><pre class="indent">
<a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)key(inout_integer)range(in_arrayType)do(in_proc)end_for">for</a> currObject <a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)key(inout_integer)range(in_arrayType)do(in_proc)end_for">key</a> currIndex <a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)key(inout_integer)range(in_arrayType)do(in_proc)end_for">range</a> element_list <a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)key(inout_integer)range(in_arrayType)do(in_proc)end_for">do</a>
  <a class="func_no_ul" href="../libraries/stdio.htm#writeln(in_string)">writeln</a>(<a class="stri" href="tokens.htm#String_literals">"key: "</a> <a class="op_no_ul" href="../libraries/enable_io.htm#(in_string)<&(in_aType)">&lt;&amp;</a> currIndex <a class="op_no_ul" href="../libraries/enable_io.htm#(in_string)<&(in_aType)">&lt;&amp;</a> <a class="stri" href="tokens.htm#String_literals">", element: "</a> <a class="op_no_ul" href="../libraries/enable_io.htm#(in_string)<&(in_aType)">&lt;&amp;</a> currObject);
<a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)key(inout_integer)range(in_arrayType)do(in_proc)end_for">end for</a>;
</pre><p>
  A for-each-key-statement can be combined with an <tt><span class="keywd">until</span></tt> condition:
</p><pre class="indent">
<a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)key(inout_integer)range(in_arrayType)until(ref_func_boolean)do(in_proc)end_for">for</a> currObject <a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)key(inout_integer)range(in_arrayType)until(ref_func_boolean)do(in_proc)end_for">key</a> currIndex <a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)key(inout_integer)range(in_arrayType)until(ref_func_boolean)do(in_proc)end_for">range</a> element_list <a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)key(inout_integer)range(in_arrayType)until(ref_func_boolean)do(in_proc)end_for">until</a> found <a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)key(inout_integer)range(in_arrayType)until(ref_func_boolean)do(in_proc)end_for">do</a>
  <a class="keywd_no_ul", href="#if-statement">if</a> currObject <span class="op">=</a> searched <a class="keywd_no_ul", href="#if-statement">then</a>
    <a class="func_no_ul" href="../libraries/stdio.htm#writeln(in_string)">writeln</a>(<a class="stri" href="tokens.htm#String_literals">"found key: "</a> <a class="op_no_ul" href="../libraries/enable_io.htm#(in_string)<&(in_aType)">&lt;&amp;</a> currIndex <a class="op_no_ul" href="../libraries/enable_io.htm#(in_string)<&(in_aType)">&lt;&amp;</a> <a class="stri" href="tokens.htm#String_literals">", element: "</a> <a class="op_no_ul" href="../libraries/enable_io.htm#(in_string)<&(in_aType)">&lt;&amp;</a> currObject);
    found <a class="op_no_ul" href="#Assignment">:=</a> <a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a>;
  <a class="keywd_no_ul", href="#if-statement">end if</a>;
<a class="keywd_no_ul" href="../libraries/array.htm#for(inout_baseType)key(inout_integer)range(in_arrayType)until(ref_func_boolean)do(in_proc)end_for">end for</a>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    First the element list which stands behind <tt><span class="keywd">range</span></tt> is evaluated.
    If the element list is empty the for-each-key-statement is
    finished. Otherwise the first element of the element list is
    assigned to the control variable which stands behind <tt><span class="keywd">for</span></tt> and
    the index (key) of the first element is assigned to the key
    control variable which stands behind the keyword <tt><span class="keywd">key</span></tt>. If there
    is an <tt><span class="keywd">until</span></tt> part the condition behind <tt><span class="keywd">until</span></tt> is checked and
    if it evaluates to <tt><a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a></tt> the for-each-statement is finished.
    If the for-each-statement is not finished the statements behind
    <tt><span class="keywd">do</span></tt> (loop body) are executed. If there is no next element
    in the element list the for-each-key-statement is finished.
    Otherwise the next element of the element list is assigned to the
    control variable and the index of the next element is assigned
    to the key control variable. This check for next element -
    assign index and element - check possible until condition -
    execute loop body - cycle is repeated until there is no next
    element in the element list.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="ebnf_for_each_key_statement">for_each_key_statement</a> ::=</dt><dd>
      '<span class="keywd">for</span>' <a class="ebnf" href="tokens.htm#ebnf_identifier">identifier</a> '<span class="keywd">key</span>' <a class="ebnf" href="tokens.htm#ebnf_identifier">identifier</a> '<span class="keywd">range</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> [ '<span class="keywd">until</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> ] '<span class="keywd">do</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#ebnf_statement">statement</a><br />
      '<span class="keywd">end</span>' '<span class="keywd">for</span>' .</dd>
</dl></tt></dd></dl><p>

  <a name="for_each_key_statement_declaration">Declaration</a>:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .for.().key.().range.().do.().end.for   <span class="keywd">is</span> -> 25;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#char">char</a>: forVar) key (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#integer">integer</a>: keyVar) range (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#string">string</a>: stri) do
              (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statement)
            end for <span class="keywd">is action</span> <span class="stri">"STR_FOR_VAR_KEY"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">baseType</span>: forVar) key (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#integer">integer</a>: keyVar) range (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> arrayType: arr) do
              (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statement)
            end for <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">for</span> keyVar <span class="keywd">range</span> minIdx(arr) <span class="keywd">to</span> maxIdx(arr) <span class="keywd">do</span>
      forVar <a class="op_no_ul" href="#Assignment">:=</a> arr[keyVar];
      statements;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">baseType</span>: forVar) key (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">keyType</span>: keyVar) range (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">hashType</span>: aHashMap) do
              (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statements)
            end for <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    FOR_DATA_KEY(forVar, keyVar, aHashMap, statements, hashType.dataCopy, hashType.keyCopy);
  <span class="keywd">end func</span>;
</pre><p></p>

<a name="for-key-statement"><h3>4.10 for-key-statement</h3></a>
<p>
  A for-key-statement loops over the keys (indices) of a container
  (<tt><a class="type" href="types.htm#array">array</a></tt>, <tt><a class="type" href="types.htm#hash">hash</a></tt>, <tt><a class="type" href="types.htm#string">string</a></tt>). For example:
</p><pre class="indent">
<a class="keywd_no_ul" href="../libraries/array.htm#for_key(inout_integer)range(in_arrayType)do(in_proc)end_for">for</a> <a class="keywd_no_ul" href="../libraries/array.htm#for_key(inout_integer)range(in_arrayType)do(in_proc)end_for">key</a> currIndex <a class="keywd_no_ul" href="../libraries/array.htm#for_key(inout_integer)range(in_arrayType)do(in_proc)end_for">range</a> element_list <a class="keywd_no_ul" href="../libraries/array.htm#for_key(inout_integer)range(in_arrayType)do(in_proc)end_for">do</a>
  <a class="func_no_ul" href="../libraries/stdio.htm#writeln(in_string)">writeln</a>(<a class="stri" href="tokens.htm#String_literals">"key: "</a> <a class="op_no_ul" href="../libraries/enable_io.htm#(in_string)<&(in_aType)">&lt;&amp;</a> currIndex);
<a class="keywd_no_ul" href="../libraries/array.htm#for_key(inout_integer)range(in_arrayType)do(in_proc)end_for">end for</a>;
</pre><p>
  A for-key-statement can be combined with an <tt><span class="keywd">until</span></tt> condition:
</p><pre class="indent">
<a class="keywd_no_ul" href="../libraries/array.htm#for_key(inout_integer)range(in_arrayType)until(ref_func_boolean)do(in_proc)end_for">for</a> <a class="keywd_no_ul" href="../libraries/array.htm#for_key(inout_integer)range(in_arrayType)until(ref_func_boolean)do(in_proc)end_for">key</a> currIndex <a class="keywd_no_ul" href="../libraries/array.htm#for_key(inout_integer)range(in_arrayType)until(ref_func_boolean)do(in_proc)end_for">range</a> element_list <a class="keywd_no_ul" href="../libraries/array.htm#for_key(inout_integer)range(in_arrayType)until(ref_func_boolean)do(in_proc)end_for">until</a> found <a class="keywd_no_ul" href="../libraries/array.htm#for_key(inout_integer)range(in_arrayType)until(ref_func_boolean)do(in_proc)end_for">do</a>
  <a class="keywd_no_ul", href="#if-statement">if</a> element_list[currIndex] <span class="op">=</a> searched <a class="keywd_no_ul", href="#if-statement">then</a>
    <a class="func_no_ul" href="../libraries/stdio.htm#writeln(in_string)">writeln</a>(<a class="stri" href="tokens.htm#String_literals">"found key: "</a> <a class="op_no_ul" href="../libraries/enable_io.htm#(in_string)<&(in_aType)">&lt;&amp;</a> currIndex);
    found <a class="op_no_ul" href="#Assignment">:=</a> <a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a>;
  <a class="keywd_no_ul", href="#if-statement">end if</a>;
<a class="keywd_no_ul" href="../libraries/array.htm#for_key(inout_integer)range(in_arrayType)until(ref_func_boolean)do(in_proc)end_for">end for</a>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    First the element list which stands behind <tt><span class="keywd">range</span></tt> is evaluated.
    If the element list is empty the for-key-statement is finished.
    Otherwise the index (key) of the first element is assigned to
    the key control variable which stands behind the keyword <tt><span class="keywd">key</span></tt>.
    If there is an <tt><span class="keywd">until</span></tt> part the condition behind <tt><span class="keywd">until</span></tt> is
    checked and if it evaluates to <tt><a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a></tt> the for-each-statement
    is finished. If the for-each-statement is not finished the
    statements behind <tt><span class="keywd">do</span></tt> (loop body) are executed. If there is
    no next element in the element list the for-key-statement is
    finished. Otherwise the index of the next element is assigned
    to the key control variable. This check for next element -
    assign index - check possible until condition -
    execute loop body - cycle is repeated until there is no next
    element in the element list.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="ebnf_for_key_statement">for_key_statement</a> ::=</dt><dd>
      '<span class="keywd">for</span>' '<span class="keywd">key</span>' <a class="ebnf" href="tokens.htm#ebnf_identifier">identifier</a> '<span class="keywd">range</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> [ '<span class="keywd">until</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> ] '<span class="keywd">do</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#ebnf_statement">statement</a><br />
      '<span class="keywd">end</span>' '<span class="keywd">for</span>' .</dd>
</dl></tt></dd></dl><p>

  <a name="for_key_statement_declaration">Declaration</a>:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .for.key.().range.().do.().end.for   <span class="keywd">is</span> -> 25;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for key (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#integer">integer</a>: keyVar) range (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#string">string</a>: stri) do
              (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statement)
            end for <span class="keywd">is action</span> <span class="stri">"STR_FOR_KEY"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for key (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <a class="type" href="types.htm#integer">integer</a>: keyVar) range (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> arrayType: arr) do
              (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statement)
            end for <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <span class="keywd">for</span> keyVar <span class="keywd">range</span> minIdx(arr) <span class="keywd">to</span> maxIdx(arr) <span class="keywd">do</span>
      statements;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: for key (<a class="keywd_no_ul" href="params.htm#inout_parameter">inout</a> <span class="type">keyType</span>: keyVar) range (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">hashType</span>: aHashMap) do
              (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statements)
            end for <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    FOR_KEY(keyVar, aHashMap, statements, hashType.keyCopy);
  <span class="keywd">end func</span>;
</pre><p></p>

<a name="if-statement"><h3>4.11 if-statement</h3></a>
<p>
  For example:
</p><pre class="indent">
<span class="keywd">if</span> sumValue &lt; minimum <span class="keywd">then</span>
  factor <a class="op_no_ul" href="#Assignment">:=</a> sumValue;
  sumValue <a class="op_no_ul" href="#Assignment">:=</a> minimum;
<span class="keywd">elsif</span> sumValue > maximum <span class="keywd">then</span>
  factor <a class="op_no_ul" href="#Assignment">:=</a> -sumValue;
  sumValue <a class="op_no_ul" href="#Assignment">:=</a> maximum;
<span class="keywd">else</span>
  factor <a class="op_no_ul" href="#Assignment">:=</a> 0;
<span class="keywd">end if</span>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    The expressions before <tt><span class="keywd">then</span></tt> are evaluated in row.
    When such an expression evaluates to <tt><a class="var" href="../libraries/boolean.htm#TRUE">TRUE</a></tt> the statements
    behind <tt><span class="keywd">then</span></tt> are executed and the if-statement is finished.
    If all expressions before <tt><span class="keywd">then</span></tt> evaluate to <tt><a class="var" href="../libraries/boolean.htm#FALSE">FALSE</a></tt> and an
    else-part is present the statements behind <tt><span class="keywd">else</span></tt> are executed
    and the if-statement is finished.
    If all expressions before <tt><span class="keywd">then</span></tt> evaluate to <tt><a class="var" href="../libraries/boolean.htm#FALSE">FALSE</a></tt> and no
    else-part is present the if-statement is finished.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="ebnf_if_statement">if_statement</a> ::=</dt><dd>
      '<span class="keywd">if</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> '<span class="keywd">then</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#ebnf_statement">statement</a><br />
      { '<span class="keywd">elsif</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> '<span class="keywd">then</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#ebnf_statement">statement</a> }<br />
      [ '<span class="keywd">else</span>'<br />
      &nbsp;&nbsp;<a class="ebnf" href="#ebnf_statement">statement</a> ]<br />
      '<span class="keywd">end</span>' '<span class="keywd">if</span>' .</dd>
</dl></tt></dd></dl><p>
  The expression must be of type <tt><a class="type" href="types.htm#boolean">boolean</a></tt>.

</p><p>
  <a name="if_statement_declaration">Declaration</a>:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .if.().then.().end.if      <span class="keywd">is</span> -> 25;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .if.().then.().().end.if   <span class="keywd">is</span> -> 25;

$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .elsif.().then.()          <span class="keywd">is</span> &lt;- 60;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .elsif.().then.().()       <span class="keywd">is</span> &lt;- 60;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .else.()                   <span class="keywd">is</span> &lt;- 60;

<span class="keywd">const</span> <a class="type" href="types.htm#type">type</a>: ELSIF_RESULT <span class="keywd">is</span> newtype;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<span class="keywd">ref</span> <span class="type">ELSIF_RESULT</span>: dest) ::= enumlit       <span class="keywd">is action</span> <span class="stri">"ENU_GENLIT"</span>;
<span class="keywd">const</span> <span class="type">ELSIF_RESULT</span>: ELSIF_EMPTY <span class="keywd">is</span> enumlit;
<span class="keywd">const</span> <a class="type" href="types.htm#type">type</a>: ELSIF_PROC                                 <span class="keywd">is</span> func <span class="type">ELSIF_RESULT</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<span class="keywd">ref</span> <span class="type">ELSIF_PROC</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">ELSIF_RESULT</span>: source) <span class="keywd">is action</span> <span class="stri">"ENU_CREATE"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>:       if (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#boolean">boolean</a>: condition) then
                    (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statements)
                  end if                               <span class="keywd">is action</span> <span class="stri">"PRC_IF"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>:       if (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#boolean">boolean</a>: condition) then
                    (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statements)
                  (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">ELSIF_PROC</span>: elsifPart)
                  end if                               <span class="keywd">is action</span> <span class="stri">"PRC_IF_ELSIF"</span>;

<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: elsif (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#boolean">boolean</a>: condition) then
                    (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statements)              <span class="keywd">is action</span> <span class="stri">"PRC_IF"</span>;

<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: elsif (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#boolean">boolean</a>: condition) then
                    (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#proc">proc</a>: statements)
                  (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <span class="type">ELSIF_PROC</span>: elsifPart)           <span class="keywd">is action</span> <span class="stri">"PRC_IF_ELSIF"</span>;

<span class="keywd">const</span> <span class="type">ELSIF_PROC</span>: else
                    (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#void">void</a>: elsePart)                <span class="keywd">is</span> ELSIF_EMPTY;
</pre><p></p>

<a name="case-statement"><h3>4.12 case-statement</h3></a>
<p>
  For example:
</p><pre class="indent">
<span class="keywd">case</span> currChar <span class="keywd">of</span>
  <span class="keywd">when</span> {<span class="stri">'A'</span> .. <span class="stri">'Z'</span>} | {<span class="stri">'a'</span> .. <span class="stri">'z'</span>}:
    characterClass <a class="op_no_ul" href="#Assignment">:=</a> LETTER;
  <span class="keywd">when</span> {<span class="stri">'0'</span> .. <span class="stri">'9'</span>}:
    characterClass <a class="op_no_ul" href="#Assignment">:=</a> DIGIT;
  <span class="keywd">when</span> {<span class="stri">'!'</span>, <span class="stri">'$'</span>, <span class="stri">'%'</span>, <span class="stri">'&'</span>, <span class="stri">'*'</span>, <span class="stri">'+'</span>, <span class="stri">','</span>, <span class="stri">'-'</span>, <span class="stri">'.'</span>, <span class="stri">'/',
      ':'</span>, <span class="stri">';'</span>, <span class="stri">'&lt;'</span>, <span class="stri">'='</span>, <span class="stri">'>'</span>, <span class="stri">'?'</span>, <span class="stri">'@'</span>, <span class="stri">'\'</span>, <span class="stri">'^'</span>, <span class="stri">'`',
      '|'</span>, <span class="stri">'~'</span>}:
    characterClass <a class="op_no_ul" href="#Assignment">:=</a> SPECIAL;
  <span class="keywd">when</span> {<span class="stri">'('</span>, <span class="stri">')'</span>, <span class="stri">'['</span>, <span class="stri">']'</span>, <span class="stri">'{'</span>, <span class="stri">'}'</span>}:
    characterClass <a class="op_no_ul" href="#Assignment">:=</a> PAREN;
  <span class="keywd">when</span> {<span class="stri">'"'</span>}:  <span class="comment"># Also possible '\"'</span>
    characterClass <a class="op_no_ul" href="#Assignment">:=</a> APPOSTROPHE;
  <span class="keywd">when</span> {<span class="stri">'''</span>}:  <span class="comment"># Also possible '\''</span>
    characterClass <a class="op_no_ul" href="#Assignment">:=</a> QUOTE;
  <span class="keywd">otherwise</span>:
    characterClass <a class="op_no_ul" href="#Assignment">:=</a> ILLEGAL;
<span class="keywd">end case</span>;
</pre><p>
  Case statements work also for strings:
</p><pre class="indent">
<span class="keywd">case</span> elementName <span class="keywd">of</span>
  <span class="keywd">when</span> {<span class="stri">"li"</span>}:       alternateEndTags <a class="op_no_ul" href="#Assignment">:=</a> {<span class="stri">"&lt;li"</span>};
  <span class="keywd">when</span> {<span class="stri">"dt"</span>, <span class="stri">"dd"</span>}: alternateEndTags <a class="op_no_ul" href="#Assignment">:=</a> {<span class="stri">"&lt;dt"</span>, <span class="stri">"&lt;dd"</span>};
  <span class="keywd">when</span> {<span class="stri">"td"</span>, <span class="stri">"th"</span>}: alternateEndTags <a class="op_no_ul" href="#Assignment">:=</a> {<span class="stri">"&lt;td"</span>, <span class="stri">"&lt;th"</span>, <span class="stri">"&lt;tr"</span>, <span class="stri">"&lt;thead"</span>, <span class="stri">"&lt;tbody"</span>, <span class="stri">"&lt;tfoot"</span>};
  <span class="keywd">when</span> {<span class="stri">"tr"</span>}:       alternateEndTags <a class="op_no_ul" href="#Assignment">:=</a> {<span class="stri">"&lt;tr"</span>, <span class="stri">"&lt;thead"</span>, <span class="stri">"&lt;tbody"</span>, <span class="stri">"&lt;tfoot"</span>};
  <span class="keywd">when</span> {<span class="stri">"thead"</span>, <span class="stri">"tbody"</span>, <span class="stri">"tfoot"</span>}:
                     alternateEndTags <a class="op_no_ul" href="#Assignment">:=</a> {<span class="stri">"&lt;thead"</span>, <span class="stri">"&lt;tbody"</span>, <span class="stri">"&lt;tfoot"</span>};
<span class="keywd">end case</span>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    The expression between <tt><span class="keywd">case</span></tt> and <tt><span class="keywd">of</span></tt> is evaluated. When the
    resulting value is element of a set behind a <tt><span class="keywd">when</span></tt> the
    statements behind the corresponding colon are executed and
    the case-statement is finished. If the value is not element of
    a set behind a <tt><span class="keywd">when</span></tt> and an <tt><span class="keywd">otherwise</span></tt> part is present the
    statements behind the colon of the <tt><span class="keywd">otherwise</span></tt> are executed
    and the case-statement is finished. If the value is not element
    of a set behind a <tt><span class="keywd">when</span></tt> and no <tt><span class="keywd">otherwise</span></tt> part is present
    the case-statement is finished.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt><a name="ebnf_case_statement">case_statement</a> ::=</dt><dd>
      '<span class="keywd">case</span>' <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> '<span class="keywd">of</span>'<br />
      &nbsp;&nbsp;{ '<span class="keywd">when</span>' <a class="ebnf" href="#ebnf_set_expression">set_expression</a> ':'<br />
      &nbsp;&nbsp;&nbsp;&nbsp;<a class="ebnf" href="#ebnf_statement">statement</a> }<br />
      &nbsp;&nbsp;[ '<span class="keywd">otherwise</span>' ':'<br />
      &nbsp;&nbsp;&nbsp;&nbsp;<a class="ebnf" href="#ebnf_statement">statement</a> ]<br />
      '<span class="keywd">end</span>' '<span class="keywd">case</span>' .</dd>
<dt><br /></dt>
    <dt><a name="ebnf_set_expression">set_expression</a> ::=</dt><dd>
      <a class="ebnf" href="expr.htm#ebnf_expression">expression</a> .</dd>
</dl></tt></dd></dl><p>

  <a name="case_statement_declaration">Declaration</a>:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .case.().of.().end.case                    <span class="keywd">is</span> -> 25;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .case.().of.().otherwise. : .().end.case   <span class="keywd">is</span> -> 25;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .case.().of.otherwise. : .().end.case      <span class="keywd">is</span> -> 25;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .case.().of.end.case                       <span class="keywd">is</span> -> 25;

$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .when.(). : .().()   <span class="keywd">is</span> &lt;- 60;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .when.(). : .()      <span class="keywd">is</span> &lt;- 60;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: CASE_DECLS (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type" href="types.htm#type">type</a>: aType) <span class="keywd">is func</span>
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#type">type</a>: WHEN_RESULT <span class="keywd">is</span> <a class="type" href="types.htm#void">void</a>;
    <span class="keywd">var</span> <a class="type" href="types.htm#type">type</a>: WHEN_PROC <span class="keywd">is</span> <a class="type" href="types.htm#void">void</a>;
    <span class="keywd">var</span> <a class="type" href="types.htm#type">type</a>: SELECTOR_TYPE <span class="keywd">is</span> <a class="type" href="types.htm#void">void</a>;
  <span class="keywd">begin</span>
    <span class="type">WHEN_RESULT</span> <a class="op_no_ul" href="#Assignment">:=</a> newtype;
    <span class="type">WHEN_PROC</span> <a class="op_no_ul" href="#Assignment">:=</a> (<a class="type" href="types.htm#func">func</a> <span class="type">WHEN_RESULT</span>);
    <span class="type">SELECTOR_TYPE</span> <a class="op_no_ul" href="#Assignment">:=</a> <a class="type" href="types.htm#set">set</a> <a class="type" href="types.htm#set">of</a> <span class="type">aType</span>;
    <span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: case (<span class="keywd">ref</span> <span class="type">aType</span>: decisionValue) of end case                     <span class="keywd">is</span> noop;
    <span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: case (<span class="keywd">ref</span> <span class="type">aType</span>: decisionValue) of
                    otherwise : (<span class="keywd">ref</span> <a class="type" href="types.htm#proc">proc</a>: statements)
                  end case                                                      <span class="keywd">is func</span>
      <span class="keywd">begin</span>
        statements;
      <span class="keywd">end func</span>;
    <span class="keywd">if</span> getobj(ord(<span class="keywd">ref</span> <span class="type">aType</span>: decisionValue)) <> NIL <span class="op">and</span>
        getobj(ord(<span class="keywd">ref</span> <span class="type">aType</span>: decisionValue, mayRaiseRangeError)) = NIL <span class="keywd">then</span>
      <span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: case (<span class="keywd">ref</span> <span class="type">aType</span>: decisionValue) of
                    (<span class="keywd">ref</span> <span class="type">WHEN_PROC</span>: whenPart)
                  end case                                                      <span class="keywd">is action</span> <span class="stri">"PRC_CASE"</span>;
      <span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: case (<span class="keywd">ref</span> <span class="type">aType</span>: decisionValue) of
                    (<span class="keywd">ref</span> <span class="type">WHEN_PROC</span>: whenPart)
                    otherwise : (<span class="keywd">ref</span> <a class="type" href="types.htm#proc">proc</a>: statements)
                  end case                                                      <span class="keywd">is action</span> <span class="stri">"PRC_CASE_DEF"</span>;
    <span class="keywd">else</span>
      <span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: case (<span class="keywd">ref</span> <span class="type">aType</span>: decisionValue) of
                    (<span class="keywd">ref</span> <span class="type">WHEN_PROC</span>: whenPart)
                  end case                                                      <span class="keywd">is action</span> <span class="stri">"PRC_CASE_HASHSET"</span>;
      <span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: case (<span class="keywd">ref</span> <span class="type">aType</span>: decisionValue) of
                    (<span class="keywd">ref</span> <span class="type">WHEN_PROC</span>: whenPart)
                    otherwise : (<span class="keywd">ref</span> <a class="type" href="types.htm#proc">proc</a>: statements)
                  end case                                                      <span class="keywd">is action</span> <span class="stri">"PRC_CASE_HASHSET_DEF"</span>;
    <span class="keywd">end if</span>;
    <span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<span class="keywd">ref</span> <span class="type">WHEN_RESULT</span>: dest) ::= enumlit                             <span class="keywd">is action</span> <span class="stri">"ENU_GENLIT"</span>;
    <span class="keywd">const</span> <span class="type">WHEN_RESULT</span>: WHEN_EMPTY (<span class="keywd">attr</span> <span class="type">aType</span>) is enumlit;
    <span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<span class="keywd">ref</span> <span class="type">WHEN_PROC</span>: dest) ::= (<span class="keywd">ref</span> <span class="type">WHEN_RESULT</span>: source)             <span class="keywd">is action</span> <span class="stri">"ENU_CREATE"</span>;
    <span class="keywd">const</span> <span class="type">WHEN_PROC</span>: when (<span class="keywd">ref</span> <span class="type">SELECTOR_TYPE</span>: whenSet) : (<span class="keywd">ref</span> <a class="type" href="types.htm#proc">proc</a>: statement)  <span class="keywd">is</span> WHEN_EMPTY(<span class="type">aType</span>);
    <span class="keywd">const</span> <span class="type">WHEN_PROC</span>: when (<span class="keywd">ref</span> <span class="type">SELECTOR_TYPE</span>: whenSet) : (<span class="keywd">ref</span> <a class="type" href="types.htm#proc">proc</a>: statement)
                       (<span class="keywd">ref</span> <span class="type">WHEN_PROC</span>: whenPart)                                <span class="keywd">is</span> WHEN_EMPTY(<span class="type">aType</span>);
  <span class="keywd">end func</span>;

CASE_DECLS(<a class="type" href="types.htm#integer">integer</a>);
CASE_DECLS(<a class="type" href="types.htm#char">char</a>);
CASE_DECLS(<a class="type" href="types.htm#boolean">boolean</a>);
CASE_DECLS(<a class="type" href="types.htm#string">string</a>);
CASE_DECLS(<a class="type" href="types.htm#bigInteger">bigInteger</a>);
</pre><p></p>
<table width="100%" cellpadding="0" cellspacing="0">
<tr>
<td align="left" width="60%">
<b><big><hr \></big></b></td>
<td align="right">
<table border="0" cellspacing="1" bgcolor="blue">
<tr bgcolor="gainsboro">
<td>&nbsp;<a class="navigation" href="../manual/decls.htm">previous</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../manual/index.htm">up</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../manual/types.htm">next</a>&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</div>
  </body>
</html>
