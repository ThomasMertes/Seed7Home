<html>
<head>
<meta charset="utf-8" />
<title>
Seed7 Manual: Parameters</title>
<meta name="author" content="Thomas Mertes" />
<meta name="copyright" content="Thomas Mertes" />
<meta name="keywords" content="Seed7, SeedSeven, Seed, Seven, 7, programming, language, extensible, extendable" />
<meta name="description" content="Seed7 - The extensible programming language" />
<meta name="page-topic" content="programming language, computer, software, downloads" />
<meta name="audience" content="all" />
<meta name="content-language" content="en" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="../style3.css" type="text/css" />
</head>
<body style="margin:0 0 0 0;">
<div style="background-image: url('../images/header1x.png');" class="top_image">
<img style="overflow:hidden;" src="../images/hearts7m.png" height="68" width="50"
 /><img style="overflow:hidden;" src="../images/header3.png" height="68" width="745" />
</div>
<div style="background-image: url('../images/fillpix.png');" class="space_below_top_image">
</div>
<div class="menu">

<a class="head" href="../index.htm"><big>Seed7</big></a>
<a class="menu" href="../faq.htm">FAQ</a>
<a class="menu" href="../manual/index.htm">Manual</a>
<a class="menu" href="../scrshots/index.htm">Programs</a>
<a class="menu" href="../examples/index.htm">Examples</a>
<a class="menu" href="../libraries/index.htm">Libraries</a>
<a class="menu" href="../algorith/index.htm">Algorithms</a>
<a class="menu" href="../benchmks/index.htm">Benchmarks</a>
<a class="menu" href="../subject_index.htm">Index</a>
<a class="menu" href="http://sourceforge.net/project/showfiles.php?group_id=151126">Download</a>
<a class="menu" href="https://github.com/ThomasMertes/seed7">GitHub</a>
<a class="menu" href="../build.htm">Build Seed7</a>
<a class="menu" href="../links.htm">Links</a>

<br />

<a class="head" href="index.htm"><big>Manual</big></a>
<a class="menu" href="intro.htm">Introduction</a>
<a class="menu" href="tutorial.htm">Tutorial</a>
<a class="menu" href="decls.htm">Declarations</a>
<a class="menu" href="stats.htm">Statements</a>
<a class="menu" href="types.htm">Types</a>
<a class="menu" href="params.htm">Parameters</a>
<a class="menu" href="objects.htm">Objects</a>
<a class="menu" href="file.htm">File I/O</a>
<a class="menu" href="syntax.htm">Syntax</a>
<a class="menu" href="tokens.htm">Tokens</a>
<a class="menu" href="expr.htm">Expressions</a>
<a class="menu" href="os.htm">OS&nbsp;access</a>
<a class="menu" href="database.htm">Database</a>
<a class="menu" href="graphic.htm">Graphic</a>
<a class="menu" href="actions.htm">Actions</a>
<a class="menu" href="ffi.htm">Foreign&nbsp;funcs</a>
<a class="menu" href="errors.htm">Errors</a>

<br />

<a class="head" href="#PARAMETERS"><big>Parameters</big></a>
<a class="menu" href="#val_parameter">val</a>
<a class="menu" href="#ref_parameter">ref</a>
<a class="menu" href="#in_parameter">in</a>
<a class="menu" href="#in_var_parameter">in var</a>
<a class="menu" href="#inout_parameter">inout</a>
<a class="menu" href="#Symbol_parameter">Symbol</a>
<a class="menu" href="#attr_parameter">attr</a>
</div>
<div class="content">
<div style="padding-right:20;">
<table width="100%" cellpadding="0" cellspacing="0">
<tr>
<td align="left" width="80">
<a class="head" href="index.htm"><big>Manual</big></a>
</td>
<td>
<table width="10">
</table>
</td>
<td align="left" width="60%">
<b><big>Parameters</big></b></td>
<td align="right">
<table border="0" cellspacing="1" bgcolor="blue">
<tr bgcolor="gainsboro">
<td>&nbsp;<a class="navigation" href="../manual/types.htm">previous</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../manual/index.htm">up</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../manual/objects.htm">next</a>&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
<a name="file_start"></a><p></p>
<a name="PARAMETERS"><h2>6. PARAMETERS</h2></a>

<p>
    The following sub-chapters introduce the parameter types of
  Seed7.
</p>

<a name="val_parameter"><h3>6.1 'val' parameter</h3></a>
<p>
  Value parameters are introduced with the keyword <tt>'<span class="keywd">val</span>'</tt>
  (e.g.: <tt><span class="keywd">val</span> <a class="type" href="types.htm#string">string</a>: stri</tt>). A value parameter copies the value
  of the actual parameter. The formal <tt>'<span class="keywd">val</span>'</tt> parameter cannot be
  changed inside the function. Value parameters are used, when
  copying is cheap or when copying  is necessary for the
  correct behavior. The function below appends a comma and a
  string to the variable <tt>'globalStri'</tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: appendStri (<span class="keywd">val</span> <a class="type" href="types.htm#string">string</a>: stri) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    globalStri &amp;:= <span class="stri">","</span>;
    globalStri &amp;:= stri;
  <span class="keywd">end func</span>;
</pre><p>
  After doing
</p><pre class="indent">
globalStri &amp;:= <span class="stri">"a"</span>;
appendStri(globalStri);
</pre><p>
  the variable globalStri contains the value <tt><span class="stri">"a,a"</span></tt>. If the function
  header would be
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: appendStri (<span class="keywd">in</span> <a class="type" href="types.htm#string">string</a>: stri) <span class="keywd">is func</span>
</pre><p>
  the variable globalStri would contain the value <tt><span class="stri">"a,a,"</span></tt>. This
  difference is because of the following reasons:
</p><p>
  For arrays <tt>'<span class="keywd">in</span>'</tt> parameters are equal to <tt>'<span class="keywd">ref</span>'</tt> parameters.
  When appendStri is called with globalStri as parameter an unwanted
  side effect takes place: Every change of globalStri changes also
  the <tt>'<span class="keywd">ref</span>'</tt> parameter stri. Changes to the <tt>'<span class="keywd">ref</span>'</tt> parameter would
  also change the global variable. Such unwanted side effects can
  also take place between parameters (when at least one parameter
  is an <tt>'<span class="keywd">inout</span>'</tt> parameter).
</p><p>
  In most cases such unwanted side effects are impossible or can
  be avoided easily. An <tt>'<span class="keywd">in</span>'</tt> parameter should be preferred
  over an <tt>'<span class="keywd">val</span>'</tt> parameter, when possible.
</p><dl><dt>
  Semantics:</dt><dd>
    When calling a function a formal <tt>'<span class="keywd">val</span>'</tt> parameter gets its
    value from the corresponding actual parameter. This is done
    with a create procedure ( ::= ). Inside the function it is only
    possible to read a formal <tt>'<span class="keywd">val</span>'</tt> parameter. Changing a formal
    <tt>'<span class="keywd">val</span>'</tt> parameter is not possible. When a function is left a
    <tt>'destr'</tt> procedure is called for every <tt>'<span class="keywd">val</span>'</tt> parameter. Formal
    <tt>'<span class="keywd">val</span>'</tt> parameters have the access right <tt>'<span class="keywd">const</span>'</tt>.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt>val_parameter ::=</dt><dd>
      '<span class="keywd">val</span>' type_expression ':' identifier_declaration |<br />
      '<span class="keywd">val</span>' type_expression '<span class="keywd">param</span>' .</dd>
</dl></tt></dd></dl><p>

  Declaration:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .val.().param       <span class="keywd">is</span> -> 40;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .val.(). : .(<a class="type" href="types.htm#expr">expr</a>)  <span class="keywd">is</span> -> 40;

<span class="keywd">const</span> <a class="type" href="types.htm#func">func</a> <span class="type">f_param</span>: val (<span class="keywd">ref</span> <a class="type" href="types.htm#type">type</a> <span class="keywd">param</span>) param               <span class="keywd">is action</span> <span class="stri">"DCL_VAL1"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#func">func</a> <span class="type">f_param</span>: val (<span class="keywd">ref</span> <a class="type" href="types.htm#type">type</a> <span class="keywd">param</span>) : (<span class="keywd">ref</span> <a class="type" href="types.htm#expr">expr</a> <span class="keywd">param</span>)  <span class="keywd">is action</span> <span class="stri">"DCL_VAL2"</span>;
</pre><p></p>

<a name="ref_parameter"><h3>6.2 'ref' parameter</h3></a>
<p>
  Reference parameters are introduced with the keyword <tt>'<span class="keywd">ref</span>'</tt>
  (e.g.: <tt><span class="keywd">ref</span> <a class="type" href="types.htm#array">array</a> <a class="type" href="types.htm#string">string</a>: arr</tt>). A reference parameter refers to
  the value of the actual parameter. The formal <tt>'<span class="keywd">ref</span>'</tt> parameter
  cannot be changed inside the function. Reference parameters are
  used, when copying is expensive and referring to the value does
  not change the correct behavior. The function below defines the
  primitive action for the semicolon operator:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: (<span class="keywd">ref</span> <a class="type" href="types.htm#void">void</a>: statement1) ; (<span class="keywd">ref</span> <a class="type" href="types.htm#void">void</a>: statement2) <span class="keywd">is</span> noop;
</pre><p>
  In this definition and other definitions of primitive actions
  <tt>'<span class="keywd">ref</span>'</tt> parameters are used. For normal functions usually
  <tt>'<span class="keywd">in</span>'</tt> parameters are used instead of <tt>'<span class="keywd">ref</span>'</tt> parameters:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#func">func</a> <a class="type" href="types.htm#integer">integer</a>: total_length (<span class="keywd">in</span> <a class="type" href="types.htm#array">array</a> <a class="type" href="types.htm#string">string</a>: arr) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#integer">integer</a>: lengthSum <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#integer">integer</a>: index <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">for</span> index <span class="keywd">range</span> 1 <span class="keywd">to</span> length(arr) <span class="keywd">do</span>
      lengthSum +:= length(arr[index]);
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre><p>
  Above function could also be defined with the following
  function head:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#func">func</a> <a class="type" href="types.htm#integer">integer</a>: total_length (<span class="keywd">ref</span> <a class="type" href="types.htm#array">array</a> <a class="type" href="types.htm#string">string</a>: arr) <span class="keywd">is func</span>
</pre><p>
  Since for array types (and also for struct types) <tt>'<span class="keywd">in</span>'</tt>
  parameters are defined to act as <tt>'<span class="keywd">ref</span>'</tt> parameters both
  definitions are equal. An <tt>'<span class="keywd">in</span>'</tt> parameter should be
  preferred over an <tt>'<span class="keywd">ref</span>'</tt> parameter, when possible.
</p><dl><dt>
  Semantics:</dt><dd>
    When calling a function a formal <tt>'<span class="keywd">ref</span>'</tt> parameter is set to
    refer to the corresponding actual parameter. Inside the function
    it is only possible to read a formal <tt>'<span class="keywd">ref</span>'</tt> parameter.
    Changing a formal <tt>'<span class="keywd">ref</span>'</tt> parameter is not possible. Formal
    <tt>'<span class="keywd">ref</span>'</tt> parameters have the access right <tt>'<span class="keywd">const</span>'</tt>.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt>ref_parameter ::=</dt><dd>
      '<span class="keywd">ref</span>' type_expression ':' identifier_declaration |<br />
      '<span class="keywd">ref</span>' type_expression '<span class="keywd">param</span>' .</dd>
</dl></tt></dd></dl><p>

  Declaration:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .ref.().param       <span class="keywd">is</span> -> 40;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .ref.(). : .(<a class="type" href="types.htm#expr">expr</a>)  <span class="keywd">is</span> -> 40;

<span class="keywd">const</span> <a class="type" href="types.htm#func">func</a> <span class="type">f_param</span>: ref (<span class="keywd">ref</span> <a class="type" href="types.htm#type">type</a> <span class="keywd">param</span>) param               <span class="keywd">is action</span> <span class="stri">"DCL_REF1"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#func">func</a> <span class="type">f_param</span>: ref (<span class="keywd">ref</span> <a class="type" href="types.htm#type">type</a> <span class="keywd">param</span>) : (<span class="keywd">ref</span> <a class="type" href="types.htm#expr">expr</a> <span class="keywd">param</span>)  <span class="keywd">is action</span> <span class="stri">"DCL_REF2"</span>;
</pre><p></p>

<a name="in_parameter"><h3>6.3 'in' parameter</h3></a>
<p>
  Input parameters are introduced with the keyword <tt>'<span class="keywd">in</span>'</tt>
  (e.g.: <tt><span class="keywd">in</span> <a class="type" href="types.htm#integer">integer</a>: number</tt>). Depending on the type an input
  parameter is either a value or a reference parameter. The
  formal <tt>'<span class="keywd">in</span>'</tt> parameter cannot be changed inside the function.
  The function below checks if a given number is a prime number:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#func">func</a> <a class="type" href="types.htm#boolean">boolean</a>: is_prime (<span class="keywd">in</span> <a class="type" href="types.htm#integer">integer</a>: number) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#boolean">boolean</a>: prime <span class="keywd">is</span> FALSE;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#integer">integer</a>: count <span class="keywd">is</span> 2;
  <span class="keywd">begin</span>
    <span class="keywd">if</span> number = 2 <span class="keywd">then</span>
      prime := TRUE;
    <span class="keywd">elsif</span> number >= 3 <span class="keywd">then</span>
      <span class="keywd">while</span> number <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> count &lt;> 0 <a class="op" href="../libraries/boolean.htm#(in_boolean)and(ref_func_boolean)">and</a> count * count &lt;= number <span class="keywd">do</span>
        incr(count);
      <span class="keywd">end while</span>;
      prime := number <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> count &lt;> 0;
    <span class="keywd">end if</span>;
  <span class="keywd">end func</span>;
</pre><p>
  The following function defines the ex (outer) product:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#func">func</a> <a class="type" href="types.htm#array">array</a> <a class="type" href="types.htm#array">array</a> <a class="type" href="types.htm#integer">integer</a>:
    (<span class="keywd">in</span> <a class="type" href="types.htm#array">array</a> <a class="type" href="types.htm#integer">integer</a>: a) ex (<span class="keywd">in</span> <a class="type" href="types.htm#array">array</a> <a class="type" href="types.htm#integer">integer</a>: b) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#array">array</a> <a class="type" href="types.htm#array">array</a> <a class="type" href="types.htm#integer">integer</a>: product <span class="keywd">is</span> 0 <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> 0 <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#integer">integer</a>: index1 <span class="keywd">is</span> 1;
  <span class="keywd">begin</span>
    product := length(a) <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> length(b) <a class="op" href="../libraries/array.htm#(in_integer)times(in_baseType)">times</a> 0;
    <span class="keywd">for</span> index1 <span class="keywd">range</span> 1 <span class="keywd">to</span> length(a) <span class="keywd">do</span>
      <span class="keywd">for</span> index2 <span class="keywd">range</span> 1 <span class="keywd">to</span> length(b) <span class="keywd">do</span>
        product[index1][index2] := a[index1] * b[index2];
      <span class="keywd">end for</span>;
    <span class="keywd">end for</span>;
  <span class="keywd">end func</span>;
</pre><p>
  Although both examples use <tt>'<span class="keywd">in</span>'</tt> parameters the parameter in the
  first example is actually a <tt>'<span class="keywd">val</span>'</tt> parameter while the parameters
  in the second example are actually <tt>'<span class="keywd">ref</span>'</tt> parameters. When a new
  type is created with the <tt>'newtype'</tt> function it is necessary to
  specify the meaning of the <tt>'<span class="keywd">in</span>'</tt> parameter. This is done with a
  call of the IN_PARAM_IS_VALUE or the IN_PARAM_IS_REFERENCE function
  with the new generated type as parameter. If a new type is created
  with the <tt>'subtype'</tt> function this specification is optional since
  the base type has already a specification of the <tt>'<span class="keywd">in</span>'</tt> parameter.
</p><dl><dt>
  Semantics:</dt><dd>
    Depending on the type an <tt>'<span class="keywd">in</span>'</tt> parameter is equivalent to an
    <tt>'<span class="keywd">val</span>'</tt> (call by value) parameter or to an <tt>'<span class="keywd">ref</span>'</tt> (call by reference)
    parameter. Formal <tt>'<span class="keywd">in</span>'</tt> parameters have the access right <tt>'<span class="keywd">const</span>'</tt>.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt>in_parameter ::=</dt><dd>
      '<span class="keywd">in</span>' type_expression ':' identifier_declaration .</dd>
</dl></tt></dd></dl><p>

  Declaration:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .in.().param       <span class="keywd">is</span> -> 40;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .in.(). : .(<a class="type" href="types.htm#expr">expr</a>)  <span class="keywd">is</span> -> 40;

<span class="keywd">const</span> <a class="type" href="types.htm#func">func</a> <span class="type">f_param</span>: in (<span class="keywd">ref</span> <a class="type" href="types.htm#type">type</a> <span class="keywd">param</span>) <span class="keywd">param</span>               <span class="keywd">is action</span> <span class="stri">"DCL_IN1"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#func">func</a> <span class="type">f_param</span>: in (<span class="keywd">ref</span> <a class="type" href="types.htm#type">type</a> <span class="keywd">param</span>) : (<span class="keywd">ref</span> <a class="type" href="types.htm#expr">expr</a> <span class="keywd">param</span>)  <span class="keywd">is action</span> <span class="stri">"DCL_IN2"</span>;

<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: IN_PARAM_IS_VALUE (<span class="keywd">ref</span> <a class="type" href="types.htm#type">type</a>: aType)             <span class="keywd">is action</span> <span class="stri">"TYP_SET_IN_PARAM_VALUE"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: IN_PARAM_IS_REFERENCE (<span class="keywd">ref</span> <a class="type" href="types.htm#type">type</a>: aType)         <span class="keywd">is action</span> <span class="stri">"TYP_SET_IN_PARAM_REF"</span>;
</pre><p></p>

<a name="in_var_parameter"><h3>6.4 'in var' parameter</h3></a>
<p>
  Value parameters that can be changed inside the function are
  introduced with the keywords <tt>'<span class="keywd">in var</span>'</tt> (e.g.: <tt><span class="keywd">in var</span> <a class="type" href="types.htm#integer">integer</a>: a</tt>).
  The value of the actual parameter is copied. Changes to the
  formal <tt>'<span class="keywd">in var</span>'</tt> parameter have no effect outside the function.
  The function below computes the greatest common divisor:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#func">func</a> <a class="type" href="types.htm#integer">integer</a>: gcd (<span class="keywd">in var</span> <a class="type" href="types.htm#integer">integer</a>: a, <span class="keywd">in var</span> <a class="type" href="types.htm#integer">integer</a>: b) <span class="keywd">is func</span>
  <span class="keywd">result</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#integer">integer</a>: gcd <span class="keywd">is</span> 0;
  <span class="keywd">local</span>
    <span class="keywd">var</span> <a class="type" href="types.htm#integer">integer</a>: help <span class="keywd">is</span> 0;
  <span class="keywd">begin</span>
    <span class="keywd">while</span> a &lt;> 0 <span class="keywd">do</span>
      help := b <a class="op" href="../libraries/integer.htm#(in_integer)rem(in_integer)">rem</a> a;
      b := a;
      a := help;
    <span class="keywd">end while</span>;
    gcd := b;
  <span class="keywd">end func</span>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    When calling a function a formal <tt><span class="keywd">in var</span></tt> parameter gets its
    value from the corresponding actual parameter. This is done
    with a create procedure ( ::= ). Inside the function it is
    possible to read and change a formal <tt><span class="keywd">in var</span></tt> parameter.
    Changing a formal <tt><span class="keywd">in var</span></tt> parameter has no effect on the
    actual parameter. When a function is left a <tt>'destr'</tt> procedure
    is called for every <tt><span class="keywd">in var</span></tt> parameter. Formal <tt><span class="keywd">in var</span></tt>
    parameters have the access right <tt><span class="keywd">var</span></tt>.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt>in_var_parameter ::=</dt><dd>
      '<span class="keywd">in var</span>' type-expression ':' identifier_declaration .</dd>
</dl></tt></dd></dl><p>

  Declaration:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .in.var.().param       <span class="keywd">is</span> -> 40;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .in.var.(). : .(<a class="type" href="types.htm#expr">expr</a>)  <span class="keywd">is</span> -> 40;

<span class="keywd">const</span> <a class="type" href="types.htm#func">func</a> <span class="type">f_param</span>: in var (<span class="keywd">ref</span> <a class="type" href="types.htm#type">type</a> <span class="keywd">param</span>) <span class="keywd">param</span>               <span class="keywd">is action</span> <span class="stri">"DCL_IN1VAR"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#func">func</a> <span class="type">f_param</span>: in var (<span class="keywd">ref</span> <a class="type" href="types.htm#type">type</a> <span class="keywd">param</span>) : (<span class="keywd">ref</span> <a class="type" href="types.htm#expr">expr</a> <span class="keywd">param</span>)  <span class="keywd">is action</span> <span class="stri">"DCL_IN2VAR"</span>;
</pre><p></p>

<a name="inout_parameter"><h3>6.5 'inout' parameter</h3></a>
<p>
  Reference parameters, that can be changed inside the function, are
  introduced with the keyword <tt>'<span class="keywd">inout</span>'</tt> (e.g.: <tt><span class="keywd">inout</span> <a class="type" href="types.htm#integer">integer</a>: number</tt>).
  A reference parameter refers to the value of the actual parameter.
  Changes to the formal <tt>'<span class="keywd">inout</span>'</tt> parameter effect also the actual
  parameter. The procedure below doubles the given parameter
  'number':
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: double (<span class="keywd">inout</span> <a class="type" href="types.htm#integer">integer</a>: number) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    number := 2 * number;
  <span class="keywd">end func</span>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    When calling a function a formal <tt>'<span class="keywd">inout</span>'</tt> parameter is set to
    refer to the corresponding actual parameter. Inside the function
    it is possible to read and change a formal <tt>'<span class="keywd">inout</span>'</tt> parameter.
    Changing a formal <tt>'<span class="keywd">inout</span>'</tt> parameter changes the actual
    parameter as well. Formal <tt>'<span class="keywd">inout</span>'</tt> parameters have the
    access right <tt>'<span class="keywd">var</span>'</tt>.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt>inout_parameter ::=</dt><dd>
      '<span class="keywd">inout</span>' type_expression ':' identifier_declaration .</dd>
</dl></tt></dd></dl><p>

  Declaration:
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .inout.().param       <span class="keywd">is</span> -> 40;
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .inout.(). : .(expr)  <span class="keywd">is</span> -> 40;

<span class="keywd">const</span> <a class="type" href="types.htm#func">func</a> <span class="type">f_param</span>: inout (<span class="keywd">ref</span> <a class="type" href="types.htm#type">type</a> <span class="keywd">param</span>) param               <span class="keywd">is action</span> <span class="stri">"DCL_INOUT1"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#func">func</a> <span class="type">f_param</span>: inout (<span class="keywd">ref</span> <a class="type" href="types.htm#type">type</a> <span class="keywd">param</span>) : (<span class="keywd">ref</span> <a class="type" href="types.htm#expr">expr</a> <span class="keywd">param</span>)  <span class="keywd">is action</span> <span class="stri">"DCL_INOUT2"</span>;
</pre><p></p>

<a name="call_by_name_parameter"><h3>6.6 Call-by-name parameter</h3></a>
<p>
  Call-by-name is an evaluation strategy for parameters.
  Call-by-name parameters are not introduced with a keyword.
  All parameters with a function type like <tt><a class="type_no_ul" href="types.htm#func">func</a> <a class="type_no_ul" href="types.htm#boolean">boolean</a></tt> or <tt><a class="type_no_ul" href="types.htm#proc">proc</a></tt>
  are a call-by-name parameters. The actual call-by-name parameter
  is not evaluated before the function is called. When the
  function is executed the call-by-name parameter might be executed
  once, many times or not at all. 
</p><p>
  For normal (not call-by-name) parameters the following holds:
  When the function is called the actual parameter expressions
  are evaluated and the results of the evaluation are forwarded
  to the function. Assume <tt>number</tt> has the value <tt>12</tt> and the
  following statement is executed:
</p><pre class="indent">
<a class="func_no_ul" href="../libraries/file.htm#seek(inout_file,in_integer)">seek</a>(aFile, number <a class="op_no_ul" href="../libraries/integer.htm#(in_integer)+(in_integer)">+</a> 5);
</pre><p>
  The expression <tt>number <a class="op_no_ul" href="../libraries/integer.htm#(in_integer)+(in_integer)">+</a> 5</tt> is evaluated to <tt>17</tt> before <tt><a class="func_no_ul" href="../libraries/file.htm#seek(inout_file,in_integer)">seek</a></tt> is
  called. The statement actually executed is:
</p><pre class="indent">
<a class="func_no_ul" href="../libraries/file.htm#seek(inout_file,in_integer)">seek</a>(aFile, 17);
</pre><p>
  The definition of <tt><a class="func_no_ul" href="../libraries/file.htm#seek(inout_file,in_integer)">seek</a></tt> requests that its 2nd parameter must
  be an <tt><a class="type" href="types.htm#integer">integer</a></tt> and not an integer expression:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type_no_ul" href="types.htm#proc">proc</a>: seek (<a class="keywd_no_ul" href="#inout_parameter">inout</a> <a class="type_no_ul" href="types.htm#file">file</a>: aFile, <a class="keywd_no_ul" href="#in_parameter">in</a> <a class="type_no_ul" href="types.htm#integer">integer</a>: position) <span class="keywd">is</span> ...
</pre><p>
  This triggers the evaluation of <tt>number <a class="op_no_ul" href="../libraries/integer.htm#(in_integer)+(in_integer)">+</a> 5</tt>. Compare this to:
</p><pre class="indent">
<a class="keywd_no_ul" href="stats.htm#while-statement">while</a> number <a class="op_no_ul" href="../libraries/integer.htm#(in_integer)>(in_integer)">&gt;</a> 0 <a class="keywd_no_ul" href="stats.htm#while-statement">do</a>
  number <a class="op_no_ul" href="../libraries/integer.htm#(inout_integer)-:=(in_integer)">-:=</a> 5;
<a class="keywd_no_ul" href="stats.htm#while-statement">end</a> <a class="keywd_no_ul" href="stats.htm#while-statement">while</a>;
</pre><p>
  The <a class="link" href="stats.htm#while-statement">while-statement</a> is not called with the result of <tt>number <a class="op_no_ul" href="../libraries/integer.htm#(in_integer)>(in_integer)">&gt;</a> 0</tt>.
  This would not work for the loop condition. The <a class="link" href="stats.htm#while-statement">while-statement</a>
  receives the expression <tt>number <a class="op_no_ul" href="../libraries/integer.htm#(in_integer)>(in_integer)">&gt;</a> 0</tt> instead. This way the
  <a class="link" href="stats.htm#while-statement">while-statement</a> can decide how often <tt>number <a class="op_no_ul" href="../libraries/integer.htm#(in_integer)>(in_integer)">&gt;</a> 0</tt> is evaluated.
  This contradicts the claim from above that actual parameter
  expressions are evaluated before the function is called.
  Obviously the condition parameter behaves different. This
  behavior is triggered by the declaration of the <a class="link" href="stats.htm#while-statement">while-statement</a>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type_no_ul" href="types.htm#proc">proc</a>: while (<a class="keywd_no_ul" href="#in_parameter">in</a> <a class="type_no_ul" href="types.htm#func">func</a> <a class="type_no_ul" href="types.htm#boolean">boolean</a>: condition) do (<a class="keywd_no_ul" href="#in_parameter">in</a> <a class="type_no_ul" href="types.htm#proc">proc</a>: statement) end while <span class="keywd">is</span> ...
</pre><p>
  The parameter <tt>condition</tt> has the type <tt><a class="type" href="types.htm#func">func</a> <a class="type" href="types.htm#boolean">boolean</a></tt> which
  is exactly the type of the expression <tt>number <a class="op_no_ul" href="../libraries/integer.htm#(in_integer)>(in_integer)">&gt;</a> 0</tt>. For this
  reason <tt>number <a class="op_no_ul" href="../libraries/integer.htm#(in_integer)>(in_integer)">&gt;</a> 0</tt> is forwarded to the <a class="link" href="stats.htm#while-statement">while-statement</a> without
  evaluating it. All parameters with a <tt><a class="type" href="types.htm#func">func</a></tt> type have this
  behavior. The common name for all of them is call-by-name
  parameter. All call-by-name parameters are not evaluated before
  the function is called.
</p><p>
  Examples of normal and call-by-name parameters:
</p><dl><dd><table border="1" cellspacing="0" cellpadding="5">
  
  <tr><th> Normal parameter </th><th> Call-by-name parameter </th></tr>
  
  <tr><td> <tt><a class="keywd_no_ul" href="#in_parameter">in</a> <a class="type_no_ul" href="types.htm#boolean">boolean</a>: name</tt> </td><td> <tt><a class="keywd_no_ul" href="#in_parameter">in</a> <a class="type_no_ul" href="types.htm#func">func</a> <a class="type_no_ul" href="types.htm#boolean">boolean</a>: name</tt>  </td></tr>
  <tr><td> <tt><a class="keywd_no_ul" href="#in_parameter">in</a> <a class="type_no_ul" href="types.htm#integer">integer</a>: name</tt> </td><td> <tt><a class="keywd_no_ul" href="#in_parameter">in</a> <a class="type_no_ul" href="types.htm#func">func</a> <a class="type_no_ul" href="types.htm#integer">integer</a>: name</tt>  </td></tr>
  <tr><td> <tt><a class="keywd_no_ul" href="#in_parameter">in</a> <a class="type_no_ul" href="types.htm#string">string</a>: name</tt>  </td><td> <tt><a class="keywd_no_ul" href="#in_parameter">in</a> <a class="type_no_ul" href="types.htm#func">func</a> <a class="type_no_ul" href="types.htm#string">string</a>: name</tt>   </td></tr>
  
</table></dd></dl><p>
  The type <tt><a class="type_no_ul" href="types.htm#proc">proc</a></tt> can also be used to define a call-by-name
  parameter:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type_no_ul" href="types.htm#proc">proc</a>: possiblyDo (<a class="keywd_no_ul" href="params.htm#in_parameter">in</a> <a class="type_no_ul" href="types.htm#proc">proc</a>: statement) <span class="keywd">is func</span>
  <span class="keywd">begin</span>
    <a class="keywd_no_ul" href="stats.htm#if-statement">if</a> flipCoin <a class="keywd_no_ul" href="stats.htm#if-statement">then</a>
      statement;
    <a class="keywd_no_ul" href="stats.htm#if-statement">end if</a>;
  <span class="keywd">end func</span>;
</pre><p>
  The function <tt>possiblyDo</tt> can be called with any statement
  (procedure):
</p><pre class="indent">
possiblyDo(<a class="func_no_ul" href="../libraries/stdio.htm#writeln(in_string)">writeln</a>(<a class="stri" href="tokens.htm#String_literals">"hello world"</a>));
</pre></p>

<a name="Symbol_parameter"><h3>6.7 Symbol parameter</h3></a>
<p>
  Some functions need symbols at fixed places in the parameter
  list. The following IF-statement requests the keywords <tt>'<span class="keywd">THEN</span>'</tt>,
  <tt>'<span class="keywd">END</span>'</tt> and <tt>'<span class="keywd">IF</span>'</tt> at specific places:
</p><pre class="indent">
<span class="keywd">IF</span> condition <span class="keywd">THEN</span>
  statement
<span class="keywd">END IF</span>;
</pre><p>
  After defining the syntax of this IF-statement with
</p><pre class="indent">
$ <span class="keywd">syntax</span> <a class="type" href="types.htm#expr">expr</a>: .IF.().THEN.().END.IF  <span class="keywd">is</span> -> 25;
</pre><p>
  the semantic can be defined with:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#proc">proc</a>: IF (<span class="keywd">in</span> <a class="type" href="types.htm#boolean">boolean</a>: condition) THEN
              (<span class="keywd">in</span> <a class="type" href="types.htm#proc">proc</a>: statement)
            END IF <span class="keywd">is func</span>

              <span class="keywd">begin</span>
                <span class="keywd">case</span> condition <span class="keywd">of</span>
                  <span class="keywd">when</span> {TRUE}: statement;
                <span class="keywd">end case</span>;
              <span class="keywd">end func</span>;
</pre><p>
  The symbol parameters are just written outside the parentheses.
  A call of this statement could be:
</p><pre class="indent">
<span class="keywd">IF</span> value &lt; maximum <span class="keywd">THEN</span>
  write(value)
<span class="keywd">END IF</span>;
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    Symbol parameters must be defined in a syntax definition and in
    a corresponding semantic definition. In the semantic definition
    symbol parameters are written outside of the parentheses.
    In the actual parameter list the corresponding symbol of the
    formal parameter list must be written.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt>symbol_parameter ::=</dt><dd>
      name_identifier | special_identifier .</dd>
</dl></tt></dd></dl><p></p>

<a name="attr_parameter"><h3>6.8 'attr' parameter</h3></a>
<p>
  This declaration associates a name to the type <tt>'<a class="type" href="types.htm#char">char</a>'</tt>:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#string">string</a>: name (<span class="keywd">attr</span> <a class="type" href="types.htm#char">char</a>) <span class="keywd">is</span> <span class="stri">"char"</span>;
</pre><p>
  This <tt>'name'</tt> can be used as follows:
</p><pre class="indent">
writeln(name(<a class="type" href="types.htm#char">char</a>));
</pre><p>
  It is possible to overload such declarations:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#string">string</a>: name (<span class="keywd">attr</span> <a class="type" href="types.htm#boolean">boolean</a>)  <span class="keywd">is</span> <span class="stri">"boolean"</span>;
<span class="keywd">const</span> <a class="type" href="types.htm#string">string</a>: name (<span class="keywd">attr</span> <a class="type" href="types.htm#float">float</a>)    <span class="keywd">is</span> <span class="stri">"float"</span>;
</pre><p>
  An <tt>'<span class="keywd">attr</span>'</tt> parameter can be used in a function also:
</p><pre class="indent">
<span class="keywd">const</span> <a class="type" href="types.htm#func">func</a> <a class="type" href="types.htm#char">char</a>: (<span class="keywd">attr</span> <a class="type" href="types.htm#char">char</a>) parse (<span class="keywd">in</span> <a class="type" href="types.htm#string">string</a>: stri) <span class="keywd">is</span>
  <span class="keywd">return</span> stri[1];
</pre><p></p><dl><dt>
  Semantics:</dt><dd>
    The actual parameter which corresponds to an <tt>'<span class="keywd">attr</span>'</tt> parameter
    must be the type mentioned in the declaration of the <tt>'<span class="keywd">attr</span>'</tt> parameter.
    An <tt>'<span class="keywd">attr</span>'</tt> parameter does not declare a formal parameter
    variable which could be used inside a function.
</dd></dl>
<dl><dt>
  Syntax:
</dt><dd><tt><dl>
    <dt>attr_parameter ::=</dt><dd>
      '<span class="keywd">attr</span>' type_expression .</dd>
</dl></tt></dd></dl><p></p>
<table width="100%" cellpadding="0" cellspacing="0">
<tr>
<td align="left" width="60%">
<b><big><hr \></big></b></td>
<td align="right">
<table border="0" cellspacing="1" bgcolor="blue">
<tr bgcolor="gainsboro">
<td>&nbsp;<a class="navigation" href="../manual/types.htm">previous</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../manual/index.htm">up</a>&nbsp;</td>
<td>&nbsp;<a class="navigation" href="../manual/objects.htm">next</a>&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</div>
  </body>
</html>
